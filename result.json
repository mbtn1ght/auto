[
  {
    "id": 7,
    "name": "Золото племени АББА",
    "description": "Главный вождь племени Абба не умеет считать. В обмен на одну из его земель вождь другого племени предложил ему выбрать одну из трех куч с золотыми монетами. Но вождю племени Абба хочется получить наибольшее количество золотых монет. Помогите вождю сделать правильный выбор!\nOUTPUT.TXT72987531 234 863649875319875314958439238923098349024[Лучшие попытки]\nВходные данные3189285 283 49584392389230983490244958439238923098349024\nВ первой строке входного файла INPUT.TXT записаны три натуральных числа через пробел. Каждое из чисел не превышает 10100. Числа записаны без ведущих нулей.\nВыходные данные\nВ выходной файл OUTPUT.TXT нужно вывести одно целое число — максимальное количество монет, которые может взять вождь.",
    "complexity": 30,
    "memory": 16000,
    "time": 1000,
    "examples": [
      {
        "input": "5 7 3",
        "output": "7"
      },
      {
        "input": "987531 234 86364",
        "output": "987531"
      },
      {
        "input": "189285 283 4958439238923098349024",
        "output": "4958439238923098349024"
      }
    ]
  },
  {
    "id": 2,
    "name": "Сумма",
    "description": "Требуется посчитать сумму целых чисел, расположенных между числами 1 и N включительно.\nOUTPUT.TXT15[Лучшие попытки]\nВходные данные[Решение]\nВ единственной строке входного файла INPUT.TXT записано единственное целое число N, не превышающее по абсолютной величине 104.\nВыходные данные\nВ единственную строку выходного файла OUTPUT.TXT нужно вывести одно целое число — сумму чисел, расположенных между 1 и N включительно.",
    "complexity": 19,
    "memory": 16000,
    "time": 1000,
    "examples": [
      {
        "input": "5",
        "output": "15"
      }
    ]
  },
  {
    "id": 8,
    "name": "Арифметика",
    "description": "В прошлом году Вася пошел в школу и научился считать. В этом году он изучил таблицу умножения и теперь умеет перемножать любые числа от 1 до 10 без ошибок. Друг Петя рассказал ему про системы счисления, отличные от десятичной. В частности, про двоичную, восьмеричную и даже шестнадцатеричную. Теперь Вася без труда (но уже с помощью листка и ручки) может перемножать числа от 1 до 10 и в этих системах, используя перевод из нестандартной системы в десятичную и обратно из десятичной. Например, если Васе нужно перемножить числа 101 и 1001 в двоичной системе, то он сначала эти числа переводит в десятичное представление следующим образом:\n122OUTPUT.TXTYES216 19 777NONO[Лучшие попытки]\n(101)2=1*22+0*21+1*20=4+0+1=501[Решение]\n(1001)2=1*23+0*22+0*21+1*20=8+0+0+1=90\nПосле чего перемножение чисел 5 и 9 Вася с легкостью производит в десятичной системе счисления в уме и получает число 45. Далее производится перевод из десятичной системы счисления в двоичную. Для этого Вася делит число 45 на 2 (порядок системы счисления), запоминая остатки от деления, до тех пор пока в результате не останется число 0:\nОтвет составляется из полученных остатков от деления путем их записи в обратном порядке. Таким образом Вася получает результат: (101)2 * (1001)2 = (101101)2. Но теперь Вася изучает таблицу умножения чисел от 1 до 100 в десятичной системе счисления, а поскольку запомнить такую таблицу очень сложно, то Васе придется очень долго ее зубрить. Составьте для Васи программу, которая поможет ему проверять свои знания.\nВходные данные\nВо входном файле INPUT.TXT записаны три натуральных числа A, B и C через пробел. Числа A и B ≤ 102, а C ≤ 106.\nВыходные данные\nВ выходной файл нужно вывести YES в том случае, если A*B=C и вывести NO в противном случае.",
    "complexity": 5,
    "memory": 16000,
    "time": 1000,
    "examples": [
      {
        "input": "8 54 432",
        "output": "YES"
      },
      {
        "input": "16 19 777",
        "output": "NO"
      }
    ]
  },
  {
    "id": 5,
    "name": "Статистика",
    "description": "Вася не любит английский язык, но каждый раз старается получить хотя бы четверку за четверть, чтобы оставаться ударником. В текущей четверти Вася заметил следующую закономерность: по нечетным дням месяца он получал тройки, а по четным – четверки. Так же он помнит, в какие дни он получал эти оценки. Поэтому он выписал на бумажке все эти дни для того, чтобы оценить, сколько у него троек и сколько четверок. Помогите Васе это сделать, расположив четные и нечетные числа в разных строчках. Вася может рассчитывать на оценку 4, если четверок не меньше, чем троек.\nOUTPUT.TXT19 314 16 2YES2829 4 7 12 15 17 24 129 7 15 17 14 12 24NO29 7 15 17 14 12 24NO[Лучшие попытки]\nВходные данные\nВ первой строке входного файла INPUT.TXT записано единственное число N – количество элементов целочисленного массива (1 ≤ N ≤ 100). Вторая строка содержит N чисел, представляющих заданный массив. Каждый элемент массива – натуральное число от 1 до 31. Все элементы массива разделены пробелом.\nВыходные данные\nВ первую строку выходного файла OUTPUT.TXT нужно вывести числа, которые соответствуют дням месяцев, в которые Вася получил тройки, а во второй строке соответственно расположить числа месяца, в которые Вася получил четверки. В третьей строке нужно вывести «YES», если Вася может рассчитывать на четверку и «NO» в противном случае. В каждой строчке числа следует выводить в том же порядке, в котором они идут во входных данных. При выводе числа отделяются пробелом.",
    "complexity": 15,
    "memory": 16000,
    "time": 1000,
    "examples": [
      {
        "input": "5\n4 16 19 31 2",
        "output": "19 31\n4 16 2\nYES"
      },
      {
        "input": "8\n29 4 7 12 15 17 24 1",
        "output": "29 7 15 17 1\n4 12 24\nNO"
      }
    ]
  },
  {
    "id": 6,
    "name": "Шахматы",
    "description": "Совсем недавно Вася занялся программированием и решил реализовать собственную программу для игры в шахматы. Но у него возникла проблема определения правильности хода конем, который делает пользователь. Т.е. если пользователь вводит значение «C7-D5», то программа должна определить это как правильный ход, если же введено «E2-E4», то ход неверный. Также нужно проверить корректность записи ввода: если например, введено «D9-N5», то программа должна определить данную запись как ошибочную. Помогите ему осуществить эту проверку!OUTPUT.TXTYES2E2-E4NONOERROR[Лучшие попытки]\n3BSNERROR\nВходные данные\nВ единственной строке входного файла INPUT.TXT записан текст хода (непустая строка), который указал пользователь. Пользователь не может ввести строку, длиннее 5 символов.\nВыходные данные\nВ выходной файл OUTPUT.TXT нужно вывести «YES», если указанный ход конем верный, если же запись корректна (в смысле правильности записи координат), но ход невозможен, то нужно вывести «NO». Если же координаты не определены или заданы некорректно, то вывести сообщение «ERROR».",
    "complexity": 23,
    "memory": 16000,
    "time": 1000,
    "examples": [
      {
        "input": "C7-D5",
        "output": "YES"
      },
      {
        "input": "E2-E4",
        "output": "NO"
      },
      {
        "input": "BSN",
        "output": "ERROR"
      }
    ]
  },
  {
    "id": 10,
    "name": "Уравнение",
    "description": "Вася в школе изучил квадратные уравнения и понял, как они легко решаются путем вычисления дискриминанта. Но Петя поведал ему о методе решения кубических уравнений вида A*X3 + B*X2 + C*X + D = 0. На факультативе по математике Васе задали решить около ста уравнений как раз такого вида. Но, к сожалению, Вася забыл формулы, о которых рассказывал ему Петя. Но Васе было известно, что все корни уравнений – целые числа и находятся на отрезке [-100, 100]. Поэтому у Васи есть шанс найти их методом перебора, но для этого ему придется затратить уйму времени, т.к. возможно необходимо будет осуществить перебор нескольких тысяч значений. Помогите Васе написать программу, которая поможет ему найти корни кубических уравнений!\nOUTPUT.TXT0 323 -15 18 00 2 30 2 3-5 3 9[Лучшие попытки]\nВходные данные31 -7 -33 135-5 3 9\nВ единственной строке входного файла INPUT.TXT записаны 4 числа: A, B, C и D – целые коэффициенты кубического уравнения. Каждый коэффициент по модулю меньше 32768, A ≠ 0.\nВыходные данные\nВ единственную строку выходного файла OUTPUT.TXT нужно вывести через пробел в порядке возрастания все корни заданного кубического уравнения. Кратные корни следует выводить только один раз.",
    "complexity": 17,
    "memory": 16000,
    "time": 1000,
    "examples": [
      {
        "input": "1 -3 0 0",
        "output": "0 3"
      },
      {
        "input": "3 -15 18 0",
        "output": "0 2 3"
      },
      {
        "input": "1 -7 -33 135",
        "output": "-5 3 9"
      }
    ]
  },
  {
    "id": 9,
    "name": "Домашнее задание",
    "description": "Петя успевает по математике лучше всех в классе, поэтому учитель задал ему сложное домашнее задание, в котором нужно в заданном наборе целых чисел найти сумму всех положительных элементов, затем найти где в заданной последовательности находятся максимальный и минимальный элемент и вычислить произведение чисел, расположенных в этой последовательности между ними. Так же известно, что минимальный и максимальный элемент встречаются в заданном множестве чисел только один раз и не являются соседними. Поскольку задач такого рода учитель дал Пете около ста, то Петя как сильный программист смог написать программу, которая по заданному набору чисел самостоятельно находит решение. А Вам слабо?\nOUTPUT.TXT17 -15283 14 -9 4 -5 1 -12 426 18026 18036 5040[Лучшие попытки]\nВходные данные310-5 1 2 3 4 5 6 7 8 -336 5040\nВ первой строке входного файла INPUT.TXT записано единственное число N – количество элементов массива. Вторая строка содержит N целых чисел, представляющих заданный массив. Все элементы массива разделены пробелом. Каждое из чисел во входном файле, в том числе и N, не превышает 102 по абсолютной величине.\nВыходные данные\nВ единственную строку выходного файла OUTPUT.TXT нужно вывести два числа, разделенных пробелом: сумму положительных элементов и произведение чисел, расположенных между минимальным и максимальным элементами. Значения суммы и произведения не превышают по модулю 3*104.",
    "complexity": 27,
    "memory": 16000,
    "time": 1000,
    "examples": [
      {
        "input": "5\n-7 5 -1 3 9",
        "output": "17 -15"
      },
      {
        "input": "8\n3 14 -9 4 -5 1 -12 4",
        "output": "26 180"
      },
      {
        "input": "10\n-5 1 2 3 4 5 6 7 8 -3",
        "output": "36 5040"
      }
    ]
  },
  {
    "id": 12,
    "name": "Дачники",
    "description": "Всем известно, что дачники – народ странный, почти такой же, как и программисты. Строят они свои дачи непонятно где, да и выращивают там непонятно что и непонятно зачем. А уж как они туда добираются, это другая история: кто на автобусе, кто на электричке, кто на автомобиле, ну а кто-то вовсе пешком ходит от дома и до самого участка. Так что не стоит удивляться, если вдруг Вы узнаете, что некое садоводческое товарищество располагается на острове, а дачники добираются до него самолетом. Да еще и на этом острове может не быть посадочной полосы, так что высадиться на остров можно, только прыгая с парашютом (мы уж не рассматриваем то, как они возвращаются с дач домой). Рассмотрим этот уникальный случай. Пилот всегда старается осуществить высадку парашютистов таким образом, чтобы дачники приземлялись как можно ближе к своим прямоугольным участкам. Пилоту интересно знать: сколько дачников приземлится на свои участки? \nПомогите ему решить эту задачу!\nOUTPUT.TXT2[Лучшие попытки]\nВходные данные\nВ первой строке входного файла INPUT.TXT записано натуральное число N (1 ≤ N ≤ 1000) – количество дачников, далее идут N строк, в каждой из которых описаны координаты каждого дачника и его участка:\nX Y X1 Y1 X2 Y2 X3 Y3 X4 Y4\nгде\n(X,Y) – координаты приземления парашютиста\n(X1, Y1, X2, Y2, X3, Y3, X4,Y4) – координаты прямоугольного участка на плоскости, указанные последовательно.\nВсе координаты – целые числа, не превышающие 50000 по абсолютной величине\nВыходные данные\nВ выходной файл OUTPUT.TXT нужно вывести количество дачников, приземлившихся на свой участок. Попадание на границу участка считается попаданием на участок.",
    "complexity": 45,
    "memory": 16000,
    "time": 1000,
    "examples": [
      {
        "input": "3\n\n6 6 3 6 6 9 8 7 5 4\n\n13 5 9 2 9 8 12 8 12 2\n\n3 2 2 1 2 3 6 3 6 1",
        "output": "2"
      }
    ]
  },
  {
    "id": 41,
    "name": "Сортировка подсчетом",
    "description": "На планете «Аурон» атмосфера практически отсутствует, поэтому она известна своими перепадами температур в различных точках. Известно, что эти перепады колеблются от -100 до 100 градусов. Нашим специалистам удалось выяснить значения температур в N точках этой планеты. К сожалению, эти значения вычислены с большими погрешностями, поэтому их решили округлить до целых чисел. Хотелось бы наглядно видеть участки с повышенной и пониженной температурой. Вам требуется помочь. Вы должны упорядочить температуры участков по неубыванию.\nOUTPUT.TXT-20 9 1421012 7 92 5 18 4 32 48 11 744 5 7 11 12 18 32 48 74 924 5 7 11 12 18 32 48 74 92[Лучшие попытки]\nВходные данные[Решение]\nВ первой строке входного файла INPUT.TXT задано натуральное число N - количество участков (N ≤ 106). Во второй строке через пробел записаны целые значения температур этих участков, не превосходящие 100 по абсолютной величине.\nВыходные данные\nВ единственную строку выходного файла OUTPUT.TXT нужно вывести разделенные пробелом значения температур всех известных участков, которые должны следовать друг за другом в порядке неубывания.",
    "complexity": 29,
    "memory": 128000,
    "time": 1000,
    "examples": [
      {
        "input": "3\n9 -20 14",
        "output": "-20 9 14"
      },
      {
        "input": "10\n12 7 92 5 18 4 32 48 11 74",
        "output": "4 5 7 11 12 18 32 48 74 92"
      }
    ]
  },
  {
    "id": 4,
    "name": "Игра",
    "description": "В свободное время одноклассники Вася и Петя любят играть в различные логические игры: морской бой, крестики-нолики, шахматы, шашки и многое другое. Ребята уже испробовали и поиграли во всевозможные классические игры подобного рода, включая компьютерные. Однажды им захотелось сыграть во что-нибудь новое, но ничего подходящего найти не удалось. Тогда Петя придумал следующую игру «Угадайка»:\nИграют двое участников. Первый загадывает любое трехзначное число, такое что первая и последняя цифры отличаются друг от друга более чем на единицу. Далее загадавший число игрок переворачивает загаданное число, меняя первую и последнюю цифры местами, таким образом  получая еще одно число. Затем из максимального из полученных двух чисел вычитается минимальное. Задача второго игрока – угадать по первой цифре полученного в результате вычитания числа само это число.\nНапример, если Вася загадал число 487, то перестановкой первой и последней цифры он получит число 784. После чего ему придется вычесть из 784 число 487, в результате чего получится число 297, которое и должен отгадать Петя по указанной первой цифре «2», взятой из этого числа.\nПетя успевает лучше Васи по математике, поэтому практически всегда выигрывает в играх такого типа. Но в данном случае Петя схитрил и специально придумал такую игру, в которой он не проиграет Васе в любом случае. Дело в том, что придуманная Петей игра имеет выигрышную стратегию, которая заключается в следующем: искомое число всегда является трехзначным и вторая его цифра всегда равна девяти, а для получения значения последней достаточно отнять от девяти первую, т.е. в рассмотренном выше случае последняя цифра равна 9-2=7.\nПомогите Пете еще упростить процесс отгадывания числа по заданной его первой цифре, написав соответствующую программу.\nOUTPUT.TXT59422297297792[Лучшие попытки]\nВходные данные37792[Решение]\nВ единственной строке входного файла INPUT.TXT задана единственная цифра К, соответствующая первой цифре полученного Васей в результате вычитания наименьшего загаданного Васей значения из наибольшего.\nВыходные данные\nВ выходной файл OUTPUT.TXT нужно вывести значение полученной Васей разности.",
    "complexity": 4,
    "memory": 16000,
    "time": 1000,
    "examples": [
      {
        "input": "5",
        "output": "594"
      },
      {
        "input": "2",
        "output": "297"
      },
      {
        "input": "7",
        "output": "792"
      }
    ]
  },
  {
    "id": 14,
    "name": "НОК",
    "description": "Требуется написать программу, определяющую наименьшее общее кратное (НОК) чисел a и b.\nOUTPUT.TXT108239 65195195[Лучшие попытки]\nВходные данные[Решение]\nВ единственной строке входного файла INPUT.TXT записаны два натуральных числа А и В через пробел, не превышающих 46340.\nВыходные данные\nВ единственную строку выходного файла OUTPUT.TXT нужно вывести одно целое число — НОК чисел А и В.",
    "complexity": 19,
    "memory": 16000,
    "time": 1000,
    "examples": [
      {
        "input": "36 27",
        "output": "108"
      },
      {
        "input": "39 65",
        "output": "195"
      }
    ]
  },
  {
    "id": 13,
    "name": "Быки и коровы",
    "description": "Петя и Вася часто играют в различные логические игры. Недавно Петя поведал Васе о новой игре «Быки и коровы» и теперь они играют в эту игру сутками. Суть игры очень проста: Петя загадывает четырехзначное число, состоящее из различных цифр. Вася отгадывает задуманное Петей число, перебирая возможные варианты. Каждый раз Вася предлагает вариант своего четырёхзначного числа, состоящего из различных цифр, а Петя делает Васе подсказку: сообщает количество быков и коров, после чего Вася с учетом подсказки продолжает отгадывание числа до тех пор, пока не отгадает. Быки – это количество цифр в предложенном Васей числе, совпадающих по значению и стоящих в правильной позиции в задуманном Петей числе. Коровы – количество цифр, совпадающих по значению, но находящихся в неверной позиции. Например, если Петя задумал число 5671, а Вася предложил вариант 7251, то число быков равно 1 (только цифра 1 на своем месте), а число коров равно 2 (только цифры 7 и 5 не на своих местах). Петя силен в математике, но даже он может ошибаться. Помогите Пете написать программу, которая бы по загаданному Петей и предложенному Васей числам сообщала количество быков и коров.\nOUTPUT.TXT1 221234 12344 04 02 1[Лучшие попытки]\nВходные данные32034 62342 1\nВ единственной строке входного файла INPUT.TXT записано два четырехзначных натуральных числа A и B через пробел, где А – загаданное Петей число, а В – предложенный Васей вариант.\nВыходные данные\nВ выходной файл OUTPUT.TXT нужно вывести два целых числа через пробел — количество быков и коров.",
    "complexity": 20,
    "memory": 16000,
    "time": 1000,
    "examples": [
      {
        "input": "5671 7251",
        "output": "1 2"
      },
      {
        "input": "1234 1234",
        "output": "4 0"
      },
      {
        "input": "2034 6234",
        "output": "2 1"
      }
    ]
  },
  {
    "id": 11,
    "name": "Зайчик",
    "description": "В нашем зоопарке появился заяц. Его поместили в клетку, и чтобы ему не было скучно, директор зоопарка распорядился поставить в его клетке лесенку. Теперь наш зайчик может прыгать по лесенке вверх, перепрыгивая через ступеньки. Лестница имеет определенное количество ступенек N. Заяц может одним прыжком преодолеть не более К ступенек. Для разнообразия зайчик пытается каждый раз найти новый путь к вершине лестницы. Директору любопытно, сколько различных способов есть у зайца добраться до вершины лестницы при заданных значениях K и N. Помогите директору написать программу, которая поможет вычислить это количество.\nНапример, если K=3 и N=4, то существуют следующие маршруты: 1+1+1+1, 1+1+2, 1+2+1, 2+1+1, 2+2, 1+3, 3+1. Т.е. при данных значениях у зайца всего 7 различных маршрутов добраться до вершины лестницы.\n\n\n\n\n\nOUTPUT.TXT122 72121274[Лучшие попытки]\nВходные данные33 10274[Решение]\nВ единственной строке входного файла INPUT.TXT записаны два натуральных числа K и N (1 ≤ K ≤ N ≤ 300). К - максимальное количество ступенек, которое может преодолеть заяц одним прыжком, N – общее число ступенек лестницы.\nВыходные данные\nВ единственную строку выходного файла OUTPUT.TXT нужно вывести количество возможных вариантов различных маршрутов зайца на верхнюю ступеньку лестницы без ведущих нулей.",
    "complexity": 55,
    "memory": 16000,
    "time": 1000,
    "examples": [
      {
        "input": "1 3",
        "output": "1"
      },
      {
        "input": "2 7",
        "output": "21"
      },
      {
        "input": "3 10",
        "output": "274"
      }
    ]
  },
  {
    "id": 15,
    "name": "Дороги",
    "description": "В галактике «Milky Way» на планете «Snowflake» есть N городов, некоторые из которых соединены дорогами. Император галактики «Milky Way» решил провести инвентаризацию дорог на планете «Snowflake». Но, как оказалось, он не силен в математике, поэтому он просит вас сосчитать количество дорог.\nТребуется написать программу, помогающую императору сосчитать количество дорог на планете «Snowflake».\nOUTPUT.TXT3[Лучшие попытки]\nВходные данные\nВ первой строке входного файла INPUT.TXT записано число N (0 ≤ N ≤ 100). В следующих N строках записано по N чисел, каждое из которых является единичкой или ноликом. Причем, если в позиции (i, j) квадратной матрицы стоит единичка, то i-ый и j-ый города соединены дорогами, а если нолик, то не соединены. Гарантируется, что все дороги соединяют различные города.\nВыходные данные\nВ выходной файл OUTPUT.TXT необходимо вывести число, определяющее количество дорог на планете «Snowflake».",
    "complexity": 18,
    "memory": 16000,
    "time": 1000,
    "examples": [
      {
        "input": "5\n\n0 1 0 0 0\n\n1 0 1 1 0\n\n0 1 0 0 0\n\n0 1 0 0 0\n\n0 0 0 0 0",
        "output": "3"
      }
    ]
  },
  {
    "id": 20,
    "name": "Пилообразная последовательность",
    "description": "Последовательность a1, a2, a3, … , an-1, an называется пилообразной, если она удовлетворяет одному из следующих условий:\n33iOUTPUT.TXT2212\n5 7 6 3 4 2 7 1 8 9 4 5\n775[Лучшие попытки]\nn-1\n1) a1 \u003c a2 \u003e a3 \u003c … \u003e an-1 \u003c an\n2) a1 \u003c a2 \u003e a3 \u003c … \u003c an-1 \u003e an\n3) a1 \u003e a2 \u003c a3 \u003e … \u003c an-1 \u003e an\n4) a1 \u003e a2 \u003c a3 \u003e … \u003e an-1 \u003c an\nn-135\n1 -2 3 -4 5\n5\nnn\nДана числовая последовательность. Требуется определить длину самой длинной ее пилообразной непрерывной подпоследовательности.\nВходные данные\n1\nВ первой строке входного файла INPUT.TXT записано натуральное число N – количество элементов последовательности. Во второй строке файла через пробел записаны N элементов целочисленной последовательности {ai}. Ограничения: N\u003c106, |ai| \u003c 32000.\n2Выходные данные\n3\nВ единственную строку выходного файла OUTPUT.TXT нужно вывести одно целое число – длину самой длинной непрерывной пилообразной подпоследовательности.\nn-1Пример\nn\n№INPUT.TXTOUTPUT.TXT\n13\n1 2 3\n2\n212\n5 7 6 3 4 2 7 1 8 9 4 5\n7\n35\n1 -2 3 -4 5\n5\n1Для отправки решения задачи необходимо зарегистрироваться и авторизоваться!\n2\n\n  [Обсуждение]\n\n  [Все попытки]\n\n  [Лучшие попытки]\n3\nn-1\n\n\n\nwindow.yaContextCb.push(()=\u003e{\n  Ya.Context.AdvManager.render({\n    renderTo: 'yandex_rtb_R-A-122393-3',\n    blockId: 'R-A-122393-3'\n  })\n})\nn\n1\n2\n3\nn-1\nn",
    "complexity": 38,
    "memory": 128000,
    "time": 1000,
    "examples": [
      {
        "input": "3\n\n1 2 3",
        "output": "2"
      },
      {
        "input": "12\n\n5 7 6 3 4 2 7 1 8 9 4 5",
        "output": "7"
      },
      {
        "input": "5\n\n1 -2 3 -4 5",
        "output": "5"
      }
    ]
  },
  {
    "id": 19,
    "name": "Ферзь, ладья и конь",
    "description": "На шахматной доске 8х8 расположены три фигуры: ферзь, ладья и конь. Требуется определить количество пустых полей доски, которые находятся под боем. Для простоты будем полагать, что фигуры могут «бить» через другие фигуры. Например, в рассмотренной справа ситуации будем считать, что ферзь бьет D5 через ладью.\nOUTPUT.TXT29[Лучшие попытки]\nВходные данные[Решение]\nВ единственной строке входного файла INPUT.TXT записаны через пробел координаты расположения трех фигур: ферзя, ладьи и коня соответственно. Каждая координата состоит из одного английского символа (от A до H) и одной цифры (от 1 до 8).\nВыходные данные\nВ выходной файл OUTPUT.TXT нужно вывести количество пустых полей, которые бьют указанные во входных данных фигуры.",
    "complexity": 29,
    "memory": 16000,
    "time": 1000,
    "examples": [
      {
        "input": "D1 D3 E5",
        "output": "29"
      }
    ]
  },
  {
    "id": 16,
    "name": "Лесенка",
    "description": "Лесенкой называется набор кубиков, в котором каждый более верхний слой содержит кубиков меньше, чем предыдущий. Требуется написать программу, вычисляющую число лесенок, которое можно построить из N кубиков.\nOUTPUT.TXT22644[Лучшие попытки]\nВходные данные\nВо входном файле INPUT.TXT записано натуральное число N (1 ≤ N ≤ 100) – количество кубиков в лесенке.\nВыходные данные\nВ выходной файл OUTPUT.TXT необходимо вывести число лесенок, которые можно построить из N кубиков.",
    "complexity": 45,
    "memory": 16000,
    "time": 1000,
    "examples": [
      {
        "input": "3",
        "output": "2"
      },
      {
        "input": "6",
        "output": "4"
      }
    ]
  },
  {
    "id": 17,
    "name": "Поле чудес",
    "description": "Для игры в «Поле чудес» используется круглый барабан, разделенный на сектора, и стрелка. В каждом секторе записано некоторое число. В различных секторах может быть записано одно и то же число.\nОднажды ведущий игры решил изменить правила. Он сам стал вращать барабан и называть игроку (который барабана не видел) все числа подряд в том порядке, в котором на них указывала стрелка в процессе вращения барабана. Получилось так, что барабан сделал целое число оборотов, то есть последний сектор совпал с первым.\nПосле этого, ведущий задал участнику вопрос: какое наименьшее число секторов может быть на барабане? \nТребуется написать программу, отвечающую на этот вопрос ведущего.\nOUTPUT.TXT624\n1 1 1 1\n113[Лучшие попытки]\nВходные данные34\n1 2 3 1\n3\nВ первой строке входного файла INPUT.TXT записано число N – количество чисел, которое назвал ведущий (2 ≤ N ≤ 30000). Во второй строке записано N чисел, на которые указывала стрелка в процессе вращения барабана. Первое число всегда совпадает с последним (в конце стрелка указывает на тот же сектор, что и в начале). Числа, записанные в секторах барабана – натуральные, не превышающие 32000.\nВыходные данные\nВ выходной файл OUTPUT.TXT необходимо вывести одно число –  минимальное число секторов, которое может быть на барабане.",
    "complexity": 31,
    "memory": 16000,
    "time": 1000,
    "examples": [
      {
        "input": "13\n\n5 3 1 3 5 2 5 3 1 3 5 2 5",
        "output": "6"
      },
      {
        "input": "4\n\n1 1 1 1",
        "output": "1"
      },
      {
        "input": "4\n\n1 2 3 1",
        "output": "3"
      }
    ]
  },
  {
    "id": 21,
    "name": "Зарплата",
    "description": "В отделе работают 3 сотрудника, которые получают заработную плату в рублях. Требуется определить: на сколько зарплата самого высокооплачиваемого из них отличается от самого низкооплачиваемого.\nOUTPUT.TXT900236 11 202525[Лучшие попытки]\nВходные данные[Решение]\nВ единственной строке входного файла INPUT.TXT записаны размеры зарплат всех сотрудников через пробел. Каждая заработная плата – это натуральное число, не превышающее 105.\nВыходные данные\nВ выходной файл OUTPUT.TXT необходимо вывести одно целое число — разницу между максимальной и минимальной зарплатой.",
    "complexity": 4,
    "memory": 16000,
    "time": 1000,
    "examples": [
      {
        "input": "100 500 1000",
        "output": "900"
      },
      {
        "input": "36 11 20",
        "output": "25"
      }
    ]
  },
  {
    "id": 22,
    "name": "Единицы",
    "description": "На уроках информатики вас, наверное, учили переводить числа из одних систем счисления в другие и выполнять другие подобные операции. Пришло время продемонстрировать эти знания. Найдите количество единиц в двоичной записи заданного числа.\nOUTPUT.TXT22733[Лучшие попытки]\nВходные данные[Решение]\nВо входном файле INPUT.TXT записано целое число n (0 ≤ n ≤ 2×109).\nВыходные данные\nВ единственную строку выходного файла OUTPUT.TXT нужно вывести одно целое число — количество двоичных единиц в записи числа n.",
    "complexity": 16,
    "memory": 16000,
    "time": 1000,
    "examples": [
      {
        "input": "5",
        "output": "2"
      },
      {
        "input": "7",
        "output": "3"
      }
    ]
  },
  {
    "id": 18,
    "name": "Факториал",
    "description": "Требуется вычислить факториал целого числа N. Факториал обозначают как N! и вычисляют по формуле: \nOUTPUT.TXT12366120[Лучшие попытки]\nN! = 1 * 2 * 3 * … * (N-1) * N, причем 0! = 1.\n35120\nТак же допустимо рекуррентное соотношение: N! = (N-1)! * N\nВходные данные\nВ единственной строке входного файла INPUT.TXT записано одно целое неотрицательное число N (N \u003c 1000).\nВыходные данные\nВ выходной файл OUTPUT.TXT нужно вывести одно целое число — значение N!.",
    "complexity": 42,
    "memory": 16000,
    "time": 1000,
    "examples": [
      {
        "input": "1",
        "output": "1"
      },
      {
        "input": "3",
        "output": "6"
      },
      {
        "input": "5",
        "output": "120"
      }
    ]
  },
  {
    "id": 67,
    "name": "Маска подсетей",
    "description": "Рассмотрим компьютерную сеть с настроенной TCP/IP маршрутизацией. Будем рассматривать некоторую ее модификацию. А именно в этой сети находить N подсетей. Каждая подсеть характеризуется своей маской. Маска подсети представляет собой 4 однобайтных числа, разделенных точкой. Причем для масок выполнено следующее свойство: если представить маску в двоичном виде, то сначала она будет содержать k единиц, а потом q нулей, причем k + q = 32. Например, 255.255.255.0 — маска подсети, а 192.168.0.1 — нет.\n1OUTPUT.TXT1\n1\n0\n[Лучшие попытки]\nПоясним, как получается двоичное представление IP-адреса. Для этого числа, составляющие IP-адрес, представляются в двоичной системе счисления (при этом каждое из них дополняется ведущими нулями до длины в 8 цифр), после чего удаляются точки. Получившееся 32-битное число и есть двоичное представление IP-адреса. Например, для адреса 192.168.0.1 этот процесс выглядит так: 192.168.0.1 → 11000000.10101000.00000000.00000001 → 11000000101010000000000000000001. Таким образом, двоичным представлением IP-адреса 192.168.0.1 является 11000000101010000000000000000001.\n2\nБудем говорить, что два компьютера с IP1 и IP2 лежат в подсети, если IP1 /\\ Mask = \nIP2 /\\ Mask, где Mask — маска этой подсети, а /\\ — операция побитового логического «и». IP компьютера представляет собой так же 4 однобайтных числа, разделенных точкой.\nВам даны M пар IP адресов компьютеров. Для каждой из них Вам надо определить, в скольких подсетях из заданных они лежат.\nВходные данные\nВ первой строке входного файла INPUT.TXT записано число N — количество подсетей. В следующих N строках перечислены маски этих подсетей. В N + 2 строке находится число M (0 ≤ M ≤ 10000). В следующих M строках записаны пары IP адресов, разделенных пробелом.\nВыходные данные\nДля каждой пары IP адресов в отдельной строке выходного файла OUTPUT.TXT выведите количество подсетей, в которых лежат оба компьютера.",
    "complexity": 33,
    "memory": 16000,
    "time": 1000,
    "examples": [
      {
        "input": "2\n\n255.255.255.255\n\n255.255.255.0\n\n3\n\n192.168.31.1 192.168.31.2\n\n192.168.31.3 192.168.31.4\n\n192.168.31.1 192.167.31.2",
        "output": "1\n\n1\n\n0"
      }
    ]
  },
  {
    "id": 23,
    "name": "Гадание",
    "description": "Как и многие другие девочки, Маша любит разные гадания. Некоторое время назад Маша узнала новый способ гадать на числах – для какого-нибудь интересующего ее натурального числа n надо посчитать сумму всех чисел, на которые n делится без остатка. Маша не очень любит арифметику, и попросила вас написать программу, которая автоматизирует процесс гадания.\nOUTPUT.TXT122101818[Лучшие попытки]\nВходные данные[Решение]\nВ единственной строке входного файла INPUT.TXT записано натуральное число n (n ≤ 1000), которое Маша была вынуждена сообщить.\nВыходные данные\nВ выходной файл OUTPUT.TXT выведите сумму всех натуральных делителей числа n.",
    "complexity": 13,
    "memory": 16000,
    "time": 1000,
    "examples": [
      {
        "input": "6",
        "output": "12"
      },
      {
        "input": "10",
        "output": "18"
      }
    ]
  },
  {
    "id": 26,
    "name": "Две окружности",
    "description": "На плоскости даны две окружности. Требуется проверить, имеют ли они хотя бы одну общую точку.\n\nOUTPUT.TXTYES21 1 14 4 1NONO[Лучшие попытки]\nВходные данные[Решение]\nВходной файл INPUT.TXT состоит из двух строк. На каждой строке записана информация об одной окружности – координаты ее центра x и y (целые числа, по модулю не превосходящие 5000) и радиус (целое число 1 ≤ r ≤ 1000).\nВыходные данные\nВ выходной файл OUTPUT.TXT выведите «YES», если окружности имеют хотя бы одну общую точку, и «NO» в противном случае.",
    "complexity": 17,
    "memory": 16000,
    "time": 1000,
    "examples": [
      {
        "input": "0 0 2\n0 3 2",
        "output": "YES"
      },
      {
        "input": "1 1 1\n4 4 1",
        "output": "NO"
      }
    ]
  },
  {
    "id": 24,
    "name": "Вырубка деревьев",
    "description": "Король Флатландии решил вырубить некоторые деревья, растущие перед его дворцом. Деревья перед дворцом короля посажены в ряд, всего там растет n деревьев, расстояния между соседними деревьями одинаковы.\nOUTPUT.TXT4[Лучшие попытки]\nПосле вырубки перед дворцом должно остаться m деревьев, и расстояния между соседними деревьями должны быть одинаковыми. Помогите королю выяснить, сколько существует способов вырубки деревьев.\nТребуется написать программу, которая по заданным числам n и m определит, сколько существует способов вырубки некоторых из n деревьев так, чтобы после вырубки осталось m деревьев и соседние деревья находились на равном расстоянии друг от друга.\nВходные данные\nВходной файл INPUT.TXT содержит два целых числа n и m (0 ≤ m , n ≤ 1000).\nВыходные данные\nВ единственную строку выходного файла OUTPUT.TXT нужно вывести одно целое число — искомое число способов.",
    "complexity": 46,
    "memory": 16000,
    "time": 1000,
    "examples": [
      {
        "input": "5 3",
        "output": "4"
      }
    ]
  },
  {
    "id": 25,
    "name": "Больше-меньше",
    "description": "Одна из основных операций с числами – их сравнение. Мы подозреваем, что вы в совершенстве владеете этой операцией и можете сравнивать любые числа, в том числе и целые. В данной задаче необходимо сравнить два целых числа. \nOUTPUT.TXT\u003c2-7-12\u003e\u003e=[Лучшие попытки]\nВходные данные31313=[Решение]\nВ двух строчках входного файла INPUT.TXT записаны числа A и B, не превосходящие по абсолютной величине 2×109.\nВыходные данные\nЗапишите в выходной файл OUTPUT.TXT один символ \"\u003c\", если A\u003cB, \"\u003e\", если A\u003eB и \"=\", если A=B.",
    "complexity": 3,
    "memory": 16000,
    "time": 1000,
    "examples": [
      {
        "input": "5\n7",
        "output": "\u0026lt;"
      },
      {
        "input": "-7\n-12",
        "output": "\u0026gt;"
      },
      {
        "input": "13\n13",
        "output": "="
      }
    ]
  },
  {
    "id": 42,
    "name": "Драконы",
    "description": "Известно, что у дракона может быть несколько голов и его сила определяется числом голов. Но как определить силу драконьей стаи, в которой несколько драконов и у каждого из них определенное число голов? Вероятно, вы считаете, что это значение вычисляется как сумма всех голов? Это далеко не так, иначе было бы слишком просто вычислить силу драконьей стаи. Оказывается, что искомое значение равно произведению значений числа голов каждого из драконов. Например, если в стае 3 дракона, у которых 3, 4 и 5 голов соответственно, то сила равна 3*4*5 = 60. Предположим, что нам известно суммарное количество голов драконьей стаи, как нам вычислить максимально возможное значение силы этого логова драконов? Именно эту задачу Вам и предстоит решить.\nOUTPUT.TXT9281818108[Лучшие попытки]\nВходные данные313108\nВ единственной строке входного файла INPUT.TXT записано натуральное число N (0 \u003c N \u003c 100) – количество голов драконьей стаи.\nВыходные данные\nВ единственную строку выходного файла OUTPUT.TXT нужно вывести максимально возможное значение силы, которая может быть у стаи драконов из N голов.",
    "complexity": 40,
    "memory": 16000,
    "time": 1000,
    "examples": [
      {
        "input": "6",
        "output": "9"
      },
      {
        "input": "8",
        "output": "18"
      },
      {
        "input": "13",
        "output": "108"
      }
    ]
  },
  {
    "id": 43,
    "name": "Нули",
    "description": "Требуется найти самую длинную непрерывную цепочку нулей в последовательности нулей и единиц.\nOUTPUT.TXT4[Лучшие попытки]\nВходные данные[Решение]\nВ единственной строке входного файла INPUT.TXT записана последовательность нулей и единиц (без пробелов). Суммарное количество цифр от 1 до 100.\nВыходные данные\nВ единственную строку выходного файла OUTPUT.TXT нужно вывести искомую длину цепочки нулей.",
    "complexity": 16,
    "memory": 16000,
    "time": 1000,
    "examples": [
      {
        "input": "00101110000110",
        "output": "4"
      }
    ]
  },
  {
    "id": 27,
    "name": "Художник",
    "description": "Известный художник решил написать новый шедевр. После многих дней усердной работы он захотел исследовать свое творение. Художник вспомнил, что картина писалась следующим образом: сначала был взят белый холст, имеющий форму прямоугольника шириной w и высотой h. Затем художник нарисовал на этом холсте n прямоугольников со сторонами, параллельными сторонам холста и вершинами, расположенными в целочисленных координатах.\nПомогите художнику определить площадь незакрашенной части холста.\n2OUTPUT.TXT1826 7\n3\n0 0 5 5\n1 1 4 4\n2 2 3 3\n17171[Лучшие попытки]\nВходные данные232 111 0 2 11[Решение]\nПервая строка входного файла INPUT.TXT содержит два натуральных числа w и h (1 ≤ w, h ≤ 100). Во второй строке записано целое число n (0 ≤ n ≤ 5000) – количество прямоугольников. Следующие n строк содержат информацию о всех прямоугольниках. Каждая строка описывает один прямоугольник в виде четырех чисел x1, y1, x2, y2 , где (x1, y1) и (x2, y2) – координаты левого верхнего и правого нижнего угла прямоугольника соответственно (0 ≤ x1 \u003c x2 ≤ w, 0 ≤ y1 \u003c y2 ≤ h).\n1\n1Выходные данные\n2\nВыведите в выходной файл OUTPUT.TXT одно целое число – площадь незакрашенной части холста.\n2Примеры\n1\n№INPUT.TXTOUTPUT.TXT\n15 5\n2\n1 1 3 3\n2 2 4 4\n18\n26 7\n3\n0 0 5 5\n1 1 4 4\n2 2 3 3\n17\n32 111 0 2 11\n2Пояснение к первому примеру\n1\n2\nДля отправки решения задачи необходимо зарегистрироваться и авторизоваться!\n[Обсуждение]\n\n  [Все попытки]\n\n  [Лучшие попытки]\n\n  [Решение]\nwindow.yaContextCb.push(()=\u003e{\n  Ya.Context.AdvManager.render({\n    renderTo: 'yandex_rtb_R-A-122393-3',\n    blockId: 'R-A-122393-3'\n  })\n})",
    "complexity": 26,
    "memory": 16000,
    "time": 1000,
    "examples": [
      {
        "input": "5 5\n\n2\n\n1 1 3 3\n\n2 2 4 4",
        "output": "18"
      },
      {
        "input": "6 7\n\n3\n\n0 0 5 5\n\n1 1 4 4\n\n2 2 3 3",
        "output": "17"
      },
      {
        "input": "2 1\n1\n1 0 2 1",
        "output": "1"
      }
    ]
  },
  {
    "id": 44,
    "name": "Стрелки",
    "description": "Задана последовательность, состоящая только из символов ‘\u003e’, ‘\u003c’ и ‘-‘. Требуется найти количество стрел, которые спрятаны в этой последовательности. Стрелы – это подстроки вида ‘\u003e\u003e--\u003e’ и ‘\u003c--\u003c\u003c’.\nOUTPUT.TXT4[Лучшие попытки]\nВходные данные\nВ первой строке входного файла INPUT.TXT записана строка, состоящая из символов ‘\u003e’, ‘\u003c’ и ‘-‘  (без пробелов). Строка состоит не более, чем из 250 символов.\nВыходные данные\nВ единственную строку выходного файла OUTPUT.TXT нужно вывести искомое количество стрелок.",
    "complexity": 20,
    "memory": 16000,
    "time": 1000,
    "examples": [
      {
        "input": "\u0026lt;\u0026lt;\u0026lt;\u0026lt;\u0026gt;\u0026gt;--\u0026gt;\u0026lt;--\u0026lt;\u0026lt;--\u0026lt;\u0026lt;\u0026gt;\u0026gt;\u0026gt;--\u0026gt;\u0026lt;\u0026lt;\u0026lt;\u0026lt;\u0026lt;",
        "output": "4"
      }
    ]
  },
  {
    "id": 28,
    "name": "Симметрия",
    "description": "Многие из вас, вероятно, знакомы с понятием симметрии относительно прямой. Пусть на плоскости расположена прямая L и точка A. Точка B называется симметричной точке A относительно прямой L, если отрезок АВ перпендикулярен прямой L и делится пополам точкой пересечения с ней. В частности, если точка А лежит на прямой L, то точка B совпадает с точкой А.\n2OUTPUT.TXT-10 1020 0 1 0\n10 10\n10 -1010 -10[Лучшие попытки]\nЗадана прямая L, параллельная одной из осей координат, и точка А. Найдите точку В, симметричную А относительно L.\n2\nВходные данныеA\nПервая строка входного файла INPUT.TXT содержит 4 числа: x1, y1, x2, y2 – координаты двух различных точек, через которые проходит прямая L. Вторая строка входного файла содержит 2 числа xA и yA – координаты точки А.\nВсе числа во входном файле целые и не превосходят 108 по модулю.\n\nA\n8Выходные данные\nВ выходной файл OUTPUT.TXT выведите числа xB и yB – координаты точки B.",
    "complexity": 19,
    "memory": 16000,
    "time": 1000,
    "examples": [
      {
        "input": "0 0 0 1\n\n10 10",
        "output": "-10 10"
      },
      {
        "input": "0 0 1 0\n\n10 10",
        "output": "10 -10"
      }
    ]
  },
  {
    "id": 29,
    "name": "Компьютерная игра",
    "description": "Вы можете вспомнить хоть одного своего знакомого до двадцатилетнего возраста, который в детстве не играл в компьютерные игры? Если да, то может быть вы и сами не знакомы с этим развлечением? Впрочем, трудностей при решении этой задачи это создать не должно.\nOUTPUT.TXT9231 5 233[Лучшие попытки]\nВо многих старых играх с двумерной графикой можно столкнуться с подобной ситуацией. Какой-нибудь герой прыгает по платформам (или островкам), которые висят в воздухе. Он должен перебраться от одного края экрана до другого. При этом при прыжке с одной платформы на соседнюю, у героя уходит |y2-y1| единиц энергии, где y1 и y2 – высоты, на которых расположены эти платформы. Кроме того, у героя есть суперприем, который позволяет перескочить через платформу, но на это затрачивается 3*|y3-y1| единиц энергии. Конечно же, энергию следует расходовать максимально экономно.\nПредположим, что вам известны координаты всех платформ в порядке от левого края до правого. Сможете ли вы найти, какое минимальное количество энергии потребуется герою, чтобы добраться с первой платформы до последней?\nВходные данные\nВ первой строке входного файла INPUT.TXT записано количество платформ n (1 ≤ n ≤ 30000). Вторая строка содержит n натуральных чисел, не превосходящих 30000 – высоты, на которых располагаются платформы.\nВыходные данные\nВ выходной файл OUTPUT.TXT запишите единственное число – минимальное количество энергии, которую должен потратить игрок на преодоление платформ (конечно же в предположении, что cheat-коды использовать нельзя).",
    "complexity": 38,
    "memory": 16000,
    "time": 1000,
    "examples": [
      {
        "input": "3\n1 5 10",
        "output": "9"
      },
      {
        "input": "3\n1 5 2",
        "output": "3"
      }
    ]
  },
  {
    "id": 31,
    "name": "Неподвижные точки",
    "description": "Перестановкой P[1..n] размера n называется набор чисел от 1 до n, расположенных в определенном порядке. При этом в нем должно присутствовать ровно один раз каждое из этих чисел. Примером перестановок являются 1,3,4,5,2 (для n=5) и 3,2,1 (для n=3), а, например, 1,2,3,4,5,1 перестановкой не является, так как число 1 встречается два раза.\nOUTPUT.TXT2029 61681680133496[Лучшие попытки]\nЧисло i называется неподвижной точкой для перестановки P, если P[i] = i. Например, в перестановке 1,3,4,2,5 ровно две неподвижных точки: 1 и 5, а перестановка 4,3,2,1 не имеет неподвижных точек.\n32 10\nДаны два числа: n и k. Найдите количество перестановок размера n с ровно k неподвижными точками.\n49 0133496\nВходные данные\nВходной файл INPUT.TXT содержит два целых числа n (1 ≤ n ≤ 9) и k (0 ≤ k ≤ n).\nВыходные данные\nВ выходной файл OUTPUT.TXT выведите ответ на задачу.",
    "complexity": 47,
    "memory": 16000,
    "time": 1000,
    "examples": [
      {
        "input": "5 2",
        "output": "20"
      },
      {
        "input": "9 6",
        "output": "168"
      },
      {
        "input": "2 1",
        "output": "0"
      },
      {
        "input": "9 0",
        "output": "133496"
      }
    ]
  },
  {
    "id": 32,
    "name": "Годовой баланс",
    "description": "В конторе «Рога и Копыта» подходит время подведения годового баланса. В бухгалтерию поступили сведения о том, что, согласно документам, суммарный расход составил а рублей, a суммарный приход – b рублей. Поскольку с реальным положением дел эти цифры все равно не имеют ничего общего, бухгалтер решил реализовать следующую свою идею. Как известно, при наборе чисел на компьютере люди часто вводят цифры в неправильном порядке. Поэтому бухгалтер хочет найти такой способ переставить цифры в числах a и b, чтобы в результате разность a-b (и, соответственно, количество денег, которые он положит к себе в карман), была максимальна, а в случае можно будет сослаться на ошибку секретаря. При этом нельзя забывать о знаке чисел и о том, что ноль не может быть первой цифрой числа, отличного от ноля. Напишите программу, которая поможет бухгалтеру.\nOUTPUT.TXT7121-233333[Лучшие попытки]\nВходные данные[Решение]\nВходной файл INPUT.TXT содержит два целых числа a и b (-109 \u003c a,b \u003c 109).\nВыходные данные\nВ выходной файл OUTPUT.TXT выведите одно целое число – наибольшую разность чисел, первое из которых может быть получено перестановкой цифр a, а второе – перестановкой цифр b.",
    "complexity": 35,
    "memory": 16000,
    "time": 1000,
    "examples": [
      {
        "input": "18\n10",
        "output": "71"
      },
      {
        "input": "1\n-23",
        "output": "33"
      }
    ]
  },
  {
    "id": 33,
    "name": "Два бандита",
    "description": "Бандиты Гарри и Ларри отдыхали на природе. Решив пострелять, они выставили на бревно несколько банок из-под кока-колы (не больше 10). Гарри начал простреливать банки по порядку, начиная с самой левой, Ларри — с самой правой. В какой-то момент получилось так, что они одновременно прострелили одну и ту же последнюю банку. \nOUTPUT.TXT6 3[Лучшие попытки]\nГарри возмутился и сказал, что Ларри должен ему кучу денег за то, что тот лишил его удовольствия прострелить несколько банок. В ответ Ларри сказал, что Гарри должен ему еще больше денег по тем же причинам. Они стали спорить кто кому сколько должен, но никто из них не помнил сколько банок было в начале, а искать простреленные банки по всей округе было неохота. Каждый из них помнил только, сколько банок прострелил он сам. \n[Решение]\nОпределите по этим данным, сколько банок не прострелил Гарри и сколько банок не прострелил Ларри.\nВходные данные\nВ единственной строке входного файла INPUT.TXT записано 2 числа — количество банок, простреленных Гарри и Ларри соответственно.\nВыходные данные\nВ файл OUTPUT.TXT выведите 2 числа — количество банок, не простреленных Гарри и Ларри соответственно.",
    "complexity": 4,
    "memory": 16000,
    "time": 1000,
    "examples": [
      {
        "input": "4 7",
        "output": "6 3"
      }
    ]
  },
  {
    "id": 45,
    "name": "Произведение цифр",
    "description": "Требуется найти наименьшее натуральное число Q такое, что произведение его цифр равно заданному числу N.\nOUTPUT.TXT25213-1-18259[Лучшие попытки]\nВходные данные388\nВ единственной строке входного файла INPUT.TXT записано одно целое число N (0 ≤ N ≤ 109). \n490259\nВыходные данные\nВ выходной файл OUTPUT.TXT нужно вывести искомое число Q. В том случае, если такого числа не существует, следует вывести -1.",
    "complexity": 42,
    "memory": 16000,
    "time": 1000,
    "examples": [
      {
        "input": "10",
        "output": "25"
      },
      {
        "input": "13",
        "output": "-1"
      },
      {
        "input": "8",
        "output": "8"
      },
      {
        "input": "90",
        "output": "259"
      }
    ]
  },
  {
    "id": 30,
    "name": "Часы",
    "description": "Петя очень любит наблюдать за электронными часами. Он целыми днями смотрел на часы и считал, сколько раз встречается каждая цифра. Через несколько месяцев он научился по любому промежутку времени говорить, сколько раз на часах за это время встретится каждая цифра, и очень гордился этим.\nOUTPUT.TXT0022040013213:24:0913:24:405454545363333454545453633334[Лучшие попытки]\nВася решил проверить Петю, но он не знает, как это сделать. Вася попросил Вас помочь ему. Напишите программу, решающую эту задачу.\nВходные данные\nПервая и вторая строки входного файла INPUT.TXT содержат начало и конец промежутка времени соответственно. Начальное время не превосходит конечное. Время задается в формате hh:mm:ss (0 ≤ hh \u003c 24, 0 ≤ mm \u003c 60, 0 ≤ ss \u003c 60). hh, mm, ss дополнены ведущими нулями до двух символов. Эти нули также учитываются при подсчете числа цифр.\nВыходные данные\nВыходной файл OUTPUT.TXT должен содержать 10 строк. В i-ой строке должно быть написано, сколько раз встречается цифра i-1.",
    "complexity": 30,
    "memory": 16000,
    "time": 1000,
    "examples": [
      {
        "input": "23:59:58\n23:59:59",
        "output": "0\n0\n2\n2\n0\n4\n0\n0\n1\n3"
      },
      {
        "input": "13:24:09\n13:24:40",
        "output": "5\n45\n45\n45\n36\n3\n3\n3\n3\n4"
      }
    ]
  },
  {
    "id": 34,
    "name": "Секретное сообщение",
    "description": "На секретную базу в Арктике поступила шифровка – последовательность из n десятичных цифр. Она содержит номер секретной базы в Антарктиде, который является последовательностью из k десятичных цифр. При этом для того, чтобы отличить его от ненужной Вам информации, он повторен в шифровке хотя бы два раза (возможно, эти два вхождения перекрываются).\nOUTPUT.TXTNO213 20123400056789YESYES[Лучшие попытки]\nНапишите программу, которая по шифровке и длине номера секретной базы определяет, содержит ли шифровка номер базы. Учтите, что у базы может быть несколько номеров, и все они могут быть переданы в шифровке.\nВходные данные\nПервая строка входного файла INPUT.TXT содержит два целых числа: \nn (1 ≤ n ≤ 105)  и k (1 ≤ k ≤ 5) – длину шифровки и длину номера секретной базы соответственно. Вторая строка содержит n цифр – шифровку. Помните, что цифры в шифровке не разделяются пробелами.\nВыходные данные\nВ выходной файл OUTPUT.TXT выведите «YES», если шифровка содержит номер секретной базы, и «NO» в противном случае.",
    "complexity": 36,
    "memory": 16000,
    "time": 1000,
    "examples": [
      {
        "input": "10 5\n0123456789",
        "output": "NO"
      },
      {
        "input": "13 2\n0123400056789",
        "output": "YES"
      }
    ]
  },
  {
    "id": 48,
    "name": "Наихудший делитель",
    "description": "Будем говорить, что число a лучше числа b, если сумма цифр a больше суммы цифр числа b, а в случае равенства сумм их цифр, если число a меньше числа b. Например, число 124 лучше числа 123, так как у первого из них сумма цифр равна семи, а у второго — шести. Также, число 3 лучше числа 111, так как у них равны суммы цифр, но первое из них меньше.\nOUTPUT.TXT10223911[Лучшие попытки]\nДано число n. Найдите такой его делитель d (само число n и единица считаются делителями числа n), что любой другой делитель числа n лучше, чем d.\nВходные данные\nПервая строка входного файла INPUT.TXT содержит целое число n \n(1 ≤ n ≤ 105000).\nВыходные данные\nВ выходной файл OUTPUT.TXT выведите ответ на задачу.",
    "complexity": 23,
    "memory": 16000,
    "time": 1000,
    "examples": [
      {
        "input": "10",
        "output": "10"
      },
      {
        "input": "239",
        "output": "1"
      }
    ]
  },
  {
    "id": 47,
    "name": "Наилучший делитель",
    "description": "Будем говорить, что число a лучше числа b, если сумма цифр a больше суммы цифр числа b, а в случае равенства сумм их цифр, если число a меньше числа b. Например, число 124 лучше числа 123, так как у первого из них сумма цифр равна семи, а у второго – шести. Также, число 3 лучше числа 111, так как у них равны суммы цифр, но первое из них меньше.\nOUTPUT.TXT52239239239[Лучшие попытки]\nДано число n. Найдите такой его делитель (само число n и единица считаются делителями числа n), который лучше любого другого делителя числа n.\nВходные данные\nПервая строка входного файла содержит целое число n (1 ≤ n ≤ 105).\nВыходные данные\nВ выходной файл выведите ответ на задачу.",
    "complexity": 26,
    "memory": 16000,
    "time": 1000,
    "examples": [
      {
        "input": "10",
        "output": "5"
      },
      {
        "input": "239",
        "output": "239"
      }
    ]
  },
  {
    "id": 69,
    "name": "N-угольное колесо",
    "description": "На одном известном автозаводе страны N-мерики главный инженер-рационализатор внес предложение вместо круглых колес использовать колеса в форме правильных N-угольников. \"При этом\", — сказал он, \"важным показателем качества такого колеса будет разность между радиусом описанной окружности и радиусом вписанной окружности.\"  Причем колесо считается качественным, если его показатель качества меньше единицы.\nOUTPUT.TXTYES2239 566NONO[Лучшие попытки]\nЗадано число N и длина A стороны N-угольного колеса. Необходимо определить: является ли такое колесо качественным.\nВходные данные\nВходной файл INPUT.TXT содержит два натуральных числа: N и A (3 ≤ N ≤ 1000, 1 ≤ A ≤ 1000).\nВыходные данные\nВ выходной файл OUTPUT.TXT выведите «YES», если это качественное колесо и «NO» в противном случае.",
    "complexity": 28,
    "memory": 16000,
    "time": 1000,
    "examples": [
      {
        "input": "3 1",
        "output": "YES"
      },
      {
        "input": "239 566",
        "output": "NO"
      }
    ]
  },
  {
    "id": 46,
    "name": "Число E",
    "description": "Выведите в выходной файл округленное до n знаков после десятичной точки число E. В данной задаче будем считать, что число Е в точности равно 2.7182818284590452353602875.\nOUTPUT.TXT32252.71828182845904523536028752.71828182845904523536028752.7182818284590[Лучшие попытки]\nВходные данные3132.7182818284590\nВходной файл INPUT.TXT содержит целое число n (0 ≤ n ≤ 25).\nВыходные данные\nВ выходной файл OUTPUT.TXT выведите ответ на задачу.",
    "complexity": 20,
    "memory": 16000,
    "time": 1000,
    "examples": [
      {
        "input": "0",
        "output": "3"
      },
      {
        "input": "25",
        "output": "2.7182818284590452353602875"
      },
      {
        "input": "13",
        "output": "2.7182818284590"
      }
    ]
  },
  {
    "id": 71,
    "name": "Две кучки камней",
    "description": "У Вас есть N камней с массами W1, W2 , … WN. Требуется разложить камни на 2 кучки так, чтобы разница масс этих кучек была минимальной.\nNNOUTPUT.TXT3[Лучшие попытки]\nВходные данныеi\nВ первой строке входного файла INPUT.TXT записано число N – количество камней (1 ≤ N ≤ 18). Во второй строке через пробел перечислены массы камней W1, W2 , … WN (1 ≤ Wi ≤ 105).\n5\nВыходные данные\nВ единственную строку выходного файла OUTPUT.TXT нужно вывести одно неотрицательное целое число – минимально возможную разницу между массами  двух кучек.",
    "complexity": 43,
    "memory": 16000,
    "time": 1000,
    "examples": [
      {
        "input": "5\n5 8 13 27 14",
        "output": "3"
      }
    ]
  },
  {
    "id": 68,
    "name": "Дом - Школа - Дом",
    "description": "Мальчик Вася каждый день ездит на метро. Утром он едет в школу, а вечером того же дня, обратно из школы, домой. Для того, чтобы немного сэкономить, он покупает электронную смарт-карту на X поездок. Когда он хочет зайти в метро, он прикладывает карту к турникету. Если на карте осталось ненулевое количество поездок, то турникет пропускает Васю и списывает с карты одну поездку. Если же на карте не осталось поездок, то турникет не пропускает Васю, и он (Вася) вынужден купить на этой же станции новую карту на X поездок и вновь пройти через турникет.\nOUTPUT.TXTYes2School2NoNo[Лучшие попытки]\nВася заметил, что в связи с тем, что утром метро переполнено, покупать новую карту утром накладно по времени, и он может опоздать в школу. В связи с этим он хочет понять: будет ли такой день, что с утра, поехав в школу, Вася обнаружит у себя на карточке ноль поездок.\nВася больше никуда на метро не ездит и поэтому заходит в метро только на станции около дома и на станции около школы.\nВходные данные\nВо входном файле INPUT.TXT содержится ровно 2 строки. В первой содержится слово «School» или «Home» в зависимости от того, где первый раз Вася купил карточку на X поездок. Во второй строке содержится натуральное число X, 1 ≤ X ≤ 1000.\nВыходные данные\nВ выходной файл OUTPUT.TXT следует вывести «Yes», если будет такой день, что дома утром у Васи на карточке окажется ноль поездок и «No» в противном случае.",
    "complexity": 21,
    "memory": 16000,
    "time": 1000,
    "examples": [
      {
        "input": "Home\n1",
        "output": "Yes"
      },
      {
        "input": "School\n2",
        "output": "No"
      }
    ]
  },
  {
    "id": 3,
    "name": "Пятью пять - двадцать пять!",
    "description": "Вася и Петя учатся в школе в одном классе. Недавно Петя поведал Васе о хитром способе возведения в квадрат натуральных чисел, оканчивающихся на цифру 5. Теперь Вася может с легкостью возводить в квадрат двузначные (и даже некоторые трехзначные) числа, оканчивающиеся на 5. Способ заключается в следующем: для возведения в квадрат числа, оканчивающегося на 5 достаточно умножить число, полученное из исходного вычеркиванием последней пятерки на следующее по порядку число, затем остается лишь приписать «25» к получившемуся результату справа. Например, для того, чтобы возвести число 125 в квадрат достаточно 12 умножить на 13 и приписать 25, т.е. приписывая к числу 12*13=156 число 25, получаем результат 15625, т.е. 1252=15625. Напишите программу, возводящую число, оканчивающееся на 5, в квадрат для того, чтобы Вася смог проверить свои навыки.OUTPUT.TXT252755625562518105025[Лучшие попытки]\nВходные данные3425518105025[Решение]\nВ единственной строке входного файла INPUT.TXT записано одно натуральное число А, оканчивающееся на цифру 5, не превышающее 4*105.\nВыходные данные\nВ выходной файл OUTPUT.TXT выведите одно натуральное число - A2 без лидирующих нулей.",
    "complexity": 8,
    "memory": 16000,
    "time": 1000,
    "examples": [
      {
        "input": "5",
        "output": "25"
      },
      {
        "input": "75",
        "output": "5625"
      },
      {
        "input": "4255",
        "output": "18105025"
      }
    ]
  },
  {
    "id": 70,
    "name": "Степень строки",
    "description": "",
    "complexity": 30,
    "memory": 16000,
    "time": 1000,
    "examples": [
      {
        "input": "abc\n\n3",
        "output": "abcabcabc"
      },
      {
        "input": "abcdabcd\n\n-2",
        "output": "abcd"
      },
      {
        "input": "abcd\n\n-4",
        "output": "NO SOLUTION"
      }
    ]
  },
  {
    "id": 35,
    "name": "Конечные автоматы",
    "description": "Однажды известный профессор обнаружил описания k конечных автоматов. По его мнению, нетривиальность конечного автомата, имеющего n состояний и m переходов, можно описать целым числом d = 19m + (n + 239)*(n + 366) / 2 . Чем больше d, тем больший интерес для науки представляет изучение его свойств.\niOUTPUT.TXT443444813445699494582215 201000 26000487671340237\n487671340237\n[Лучшие попытки]\nПомогите профессору вычислить нетривиальность имеющихся у него автоматов.\ni\nВходные данныеi\nПервая строка входного файла INPUT.TXT содержит целое число k (1 ≤ k ≤ 10000) – количество конечных автоматов. Следующие  k строк содержат по два целых числа ni (0 ≤ ni ≤ 1000) и mi (0 ≤ mi ≤ 26ni2) – число состояний и переходов i-го автомата.\n2\nВыходные данные\nВыходной файл OUTPUT.TXT должен состоять из k строк. На i-й строке выходного файла выведите одно число – нетривиальность i-го автомата.",
    "complexity": 11,
    "memory": 16000,
    "time": 1000,
    "examples": [
      {
        "input": "4\n2 0\n13 20\n5 23\n18 6",
        "output": "44344\n48134\n45699\n49458"
      },
      {
        "input": "2\n15 20\n1000 26000",
        "output": "48767\n1340237"
      }
    ]
  },
  {
    "id": 79,
    "name": "Последняя цифра A^B",
    "description": "Требуется написать программу, которая находит цифру, на которую оканчивается число AB.\nOUTPUT.TXT423 7774[Лучшие попытки]\nВходные данные324 94\nВходной файл INPUT.TXT состоит из единственной строки, содержащей два целых числа A и B, разделенных пробелом (1 ≤ A,B ≤ 10000).\nВыходные данные\nВ единственную строку выходного файла OUTPUT.TXT нужно вывести цифру, на которую оканчивается AB.",
    "complexity": 21,
    "memory": 16000,
    "time": 1000,
    "examples": [
      {
        "input": "2 2",
        "output": "4"
      },
      {
        "input": "3 7",
        "output": "7"
      },
      {
        "input": "24 9",
        "output": "4"
      }
    ]
  },
  {
    "id": 72,
    "name": "Анаграмма",
    "description": "Пусть задано некоторое слово, состоящее из букв английского алфавита длиной не более 80 символов (например, “WORD”). Рассмотрим набор возможных перестановок, состоящих из букв данного слова (например, “RDOW”, “WODR” и т.д.). Требуется выбрать из этого множества слово, следующее по алфавиту за исходным.\nOUTPUT.TXTacbd2wordwrdowrdo[Лучшие попытки]\nВходные данные\nВ единственной строке входного файла INPUT.TXT записано слово, не последнее по алфавиту среди возможных его перестановок.\nВыходные данные\nВ единственную строку выходного файла OUTPUT.TXT нужно вывести следующее слово по алфавиту.",
    "complexity": 45,
    "memory": 16000,
    "time": 1000,
    "examples": [
      {
        "input": "abdc",
        "output": "acbd"
      },
      {
        "input": "word",
        "output": "wrdo"
      }
    ]
  },
  {
    "id": 73,
    "name": "Расшифровка",
    "description": "Рассмотрим работу простейшего шифра. Шифруемое сообщение состоит из английских букв, записанных в нижнем регистре и символа пробела. Шифрование происходит посимвольно. Каждой букве ставим в соответствие число: a – 1, b – 2, … , z – 26, ‘ ‘ – 27. Далее индекс символа складывается с номером в сообщении по модулю 27, а результат сложения представляется в системе счисления с основанием 27 (0, 1, …, Q в верхнем регистре). \nOUTPUT.TXTtest2576J9FLFdecodingdecoding[Лучшие попытки]\nНеобходимо написать дешифратор.\nВходные данные\nВ единственной строке входного файла INPUT.TXT содержится закодированная строка, длиной от 1 до 255 символов. Строка записана в верхнем регистре.\nВыходные данные\nВ единственную строку выходного файла OUTPUT.TXT нужно вывести расшифровку заданной строки, при этом символы английского алфавита следует выводить в нижнем регистре.",
    "complexity": 28,
    "memory": 16000,
    "time": 1000,
    "examples": [
      {
        "input": "L7MO",
        "output": "test"
      },
      {
        "input": "576J9FLF",
        "output": "decoding"
      }
    ]
  },
  {
    "id": 36,
    "name": "Постулат Бертрана",
    "description": "Постулат Бертрана (теорема Бертрана-Чебышева, теорема Чебышева) гласит, что для любого n \u003e 1 найдется простое число p в интервале n \u003c p \u003c 2n. Такая гипотеза была выдвинута в 1845 году французским математиком Джозефем Бертраном (проверившим ее до n=3000000) и доказана в 1850 году Пафнутием Чебышевым. Раманужан в 1920 году нашел более простое доказательство, а Эрдеш в 1932 – еще более простое.\nOUTPUT.TXT122393939353[Лучшие попытки]\nВаша задача состоит в том, чтобы решить несколько более общую задачу – а именно по числу n найти количество простых чисел p из интервала n \u003c p \u003c 2n.\n33000353[Решение]\nНапомним, что число называется простым, если оно делится только само на себя и на единицу.\nВходные данные\nВходной файл INPUT.TXT содержит целое число n (2 ≤ n ≤ 50000).\nВыходные данные\nВ выходной файл OUTPUT.TXT выведите одно число – ответ на задачу.",
    "complexity": 30,
    "memory": 16000,
    "time": 1000,
    "examples": [
      {
        "input": "2",
        "output": "1"
      },
      {
        "input": "239",
        "output": "39"
      },
      {
        "input": "3000",
        "output": "353"
      }
    ]
  },
  {
    "id": 37,
    "name": "Сжимающий оператор",
    "description": "Оператором А, действующим из множества Х в множество Y (или просто оператором из X в Y) называется правило, согласно которому каждому элементу x множества X сопоставляется элемент y=Ax из множества Y. Пусть X и Y – множества точек на плоскости. Оператор A из X в Y называется сжимающим с коэффициентом q, где q – вещественное число из полуинтервала [0, 1), если для любого x из X выполнено ||Ax|| ≤ q*||x|| (здесь ||x|| - норма точки x – расстояние от x до начала координат). Проще говоря, оператор называется сжимающим с коэффициентом q если он сопоставляет каждой точке точку, которая не менее, чем в q раз ближе к началу координат.\nOUTPUT.TXTYes22 0.1\n0 10 5 0\n10 0 0 1\nNoNoYes[Лучшие попытки]\nДля заданного оператора А требуется проверить является ли он сжимающим с коэффициентом q.\n32 0.9\n0 0 0 0\n10 0 0 1\nYes\nВходные данные\nПервая строка входного файла INPUT.TXT содержит количество точек n (1 ≤ n ≤ 100) и число q (0 ≤ q \u003c 1), заданное не более чем с 3 знаками после десятичной точки. Следующие n строк содержат по 4 целых числа, по модулю не превосходящих 1000, разделенные пробелами – координаты точки множества X и сопоставленной ей точки из множества Y.\nВыходные данные\nВ выходной файл OUTPUT.TXT выведите одно слово: “Yes” если оператор является сжимающим с коэффициентом q и “No” в противном случае.",
    "complexity": 34,
    "memory": 16000,
    "time": 1000,
    "examples": [
      {
        "input": "2 0.5\n\n0 10 5 0\n\n10 0 0 1",
        "output": "Yes"
      },
      {
        "input": "2 0.1\n\n0 10 5 0\n\n10 0 0 1",
        "output": "No"
      },
      {
        "input": "2 0.9\n\n0 0 0 0\n\n10 0 0 1",
        "output": "Yes"
      }
    ]
  },
  {
    "id": 75,
    "name": "Сумма произведений",
    "description": "Требуется вычислить сумму произведений цифр каждого N-значного числа. При этом следует учесть, что если в числе встречается цифра 0, то произведение его цифр равно нулю. Для N=3 искомая сумма представлена следующим рядом:\nOUTPUT.TXT45239112591125184528125[Лучшие попытки]\nS = 1*0*0 + 1*0*1 + 1*0*2 + … + 9*9*8 + 9*9*9 = 91125\n35184528125\nВходные данные\nВ единственной строке входного файла INPUT.TXT записано натуральное число N (N \u003c 1000).\nВыходные данные\nВ единственную строку выходного файла OUTPUT.TXT нужно вывести одно целое число — сумму произведений цифр всех N-значных чисел.",
    "complexity": 48,
    "memory": 16000,
    "time": 1000,
    "examples": [
      {
        "input": "1",
        "output": "45"
      },
      {
        "input": "3",
        "output": "91125"
      },
      {
        "input": "5",
        "output": "184528125"
      }
    ]
  },
  {
    "id": 38,
    "name": "Игра - 2",
    "description": "Вы любите играть в игры? Конечно, любите! Но про эту игру, возможно, ничего не знаете и не слышали даже. Что ж, расскажем о новой игре. На доске написана последовательность n целых чисел. Играют двое. На очередном ходе игрок выбирает число с правого или с левого края последовательности, затем это число стирается и последовательность становится на одно число меньше, а ход переходит к противнику. Выигрывает тот, кто наберет в сумме больше. Написать программу, определяющую победителя в конкретной игре, при условии, что игроки будут играть оптимально. \nOUTPUT.TXT1265 5 5 5 5 50021[Лучшие попытки]\nВходные данные392 1 3 2 9 1 2 3 12\nВ первой строке входного файла INPUT.TXT записано целое число n (0 \u003c n \u003c 100). Во второй строке через пробел заданы n натуральных чисел, не превосходящих 1000.\n4102 5 3 12 4 6 13 7 1 31\nВыходные данные\nВ единственную строку выходного файла OUTPUT.TXT нужно вывести 1, если победит первый игрок, 2 – если победит второй игрок и 0 – в случае ничьей.",
    "complexity": 45,
    "memory": 16000,
    "time": 1000,
    "examples": [
      {
        "input": "4\n3 2 5 4",
        "output": "1"
      },
      {
        "input": "6\n5 5 5 5 5 5",
        "output": "0"
      },
      {
        "input": "9\n2 1 3 2 9 1 2 3 1",
        "output": "2"
      },
      {
        "input": "10\n2 5 3 12 4 6 13 7 1 3",
        "output": "1"
      }
    ]
  },
  {
    "id": 74,
    "name": "Прыжки с шестом",
    "description": "В соревнованиях по прыжкам с шестом было замечено одно интересное явление: на очередном этапе соревнований успешные и неуспешные попытки прыжков чередовались: успешный, неуспешный, успешный, неуспешный и т.д. (первый был успешным). Спортсменам разрешалась только одна попытка. Тот, кто преодолевал планку, переходил в следующий тур (этап), а тот, кто делал неудачную попытку – выбывал из соревнований. Таким образом, первым выбывал всегда спортсмен с номером 2, а последним – победитель с номером 1.\nOUTPUT.TXT124 1447[Лучшие попытки]\nТребуется написать программу, которая по количеству участников и номеру спортсмена вычислит, каким по счету данный спортсмен выбыл из соревнований.\n39 57\nВходные данные\nВ единственной строке входного файла INPUT.TXT содержатся два натуральных числа: общее число спортсменов N и порядковый номер спортсмена в стартовом списке M. Числа разделены пробелом (1 ≤ M,N ≤ 109).\nВыходные данные\nВ единственную строку выходного файла OUTPUT.TXT нужно вывести каким по счету спортсмен M выбыл из соревнований. Если это победитель состязания, то выводится число N.",
    "complexity": 38,
    "memory": 16000,
    "time": 1000,
    "examples": [
      {
        "input": "4 2",
        "output": "1"
      },
      {
        "input": "4 1",
        "output": "4"
      },
      {
        "input": "9 5",
        "output": "7"
      }
    ]
  },
  {
    "id": 76,
    "name": "Музей",
    "description": "В музее регистрируется в течение суток время прихода и ухода каждого посетителя. Таким образом, за день получены N пар значений, где первое значение в паре показывает время прихода посетителя и второе значение - время его ухода. Требуется найти максимальное число посетителей, которые находились в музее одновременно.\nOUTPUT.TXT4[Лучшие попытки]\nВходные данные\nВ первой строке входного файла INPUT.TXT записано натуральное число N (N \u003c 105) – количество зафиксированных посетителей в музее в течение суток. Далее, идут N строк с информацией о времени визитов посетителей: в каждой  строке располагается отрезок времени посещения в формате «ЧЧ:ММ ЧЧ:ММ»\n(00:00 ≤ ЧЧ:ММ  ≤  23:59).\nВыходные данные\nВ единственную строку выходного файла OUTPUT.TXT нужно вывести одно целое число — максимальное количество посетителей, одновременно находящихся в музее.",
    "complexity": 50,
    "memory": 16000,
    "time": 1000,
    "examples": [
      {
        "input": "6\n\n09:00 10:07\n\n10:20 11:35\n\n12:00 17:00\n\n11:00 11:30\n\n11:20 12:30\n\n11:30 18:15",
        "output": "4"
      }
    ]
  },
  {
    "id": 49,
    "name": "Шаблоны",
    "description": "Шаблоном размера n назовем строку длины n, каждый из символов которой входит в множество {0, 1, 2, 3, 4, 5, 6, 7, 8, 9, a, b, c, d, e, f, g, ?}. Шаблоны преобразуются в строки из цифр по следующим правилам:\nOUTPUT.TXT642???000110[Лучшие попытки]\n3abc9990\nДаны два шаблона: p1 и p2. Рассмотрим множество S1 строк, которые могут быть получены из p1 по описанным правилам, и множество S2 строк, которые могут быть получены из p2. Необходимо найти количество строк, входящих в оба этих множества.\nВходные данные\nПервая строка входного файла INPUT.TXT содержит шаблон p1, вторая — шаблон p2. Шаблоны имеют одинаковый положительный размер, не больше 9.\nВыходные данные\nВ выходной файл OUTPUT.TXT выведите ответ на задачу.",
    "complexity": 35,
    "memory": 16000,
    "time": 1000,
    "examples": [
      {
        "input": "???\nabc",
        "output": "64"
      },
      {
        "input": "???\n000",
        "output": "1"
      },
      {
        "input": "abc\n999",
        "output": "0"
      }
    ]
  },
  {
    "id": 50,
    "name": "Строки",
    "description": "Циклическим сдвигом строки s называется строка sksk+1sk+2…s|s|s1s2…sk-1 для некоторого k, здесь |s| - длина строки s. Подстрокой строки s называется строка sisi+1…sj-1sj для некоторых i и j. Вам даны две строки a и b. Выведите количество подстрок строки a, являющихся циклическими сдвигами строки b.\n\nВходные данные\nПервая строка входного файла INPUT.TXT содержит строку a (1 ≤ |a| ≤ 1000). Во второй строке входного файла записана строка b (1 ≤ |b| ≤ min(100,|a|)). Обе строки состоят только из символов английского алфавита и цифр.\n\nВыходные данные\nВ выходной файл OUTPUT.TXT выведите целое число – ответ на задачу.",
    "complexity": 29,
    "memory": 16000,
    "time": 1000,
    "examples": [
      {
        "input": "abcabc\nabc",
        "output": "4"
      },
      {
        "input": "abcabc\nacb",
        "output": "0"
      },
      {
        "input": "aaaaaaa\naa",
        "output": "6"
      },
      {
        "input": "aAaa8aaAa\naAa",
        "output": "4"
      }
    ]
  },
  {
    "id": 51,
    "name": "Факториалы!!!",
    "description": "Определение 1:\nOUTPUT.TXT28029 !!9459456[Лучшие попытки]\nn!!...!=n(n-k)(n-2k)...(n mod k), если n не делится на k,\n33 !6\nn!!...!=n(n-k)(n-2k)...k, если n делится на k (знаков ! в обоих случаях k штук).\nОпределение 2:\nX mod Y — остаток от деления X на Y.\nНапример, 10 mod 3 = 1; 3! = 3•2•1; 10!!! = 10•7•4•1;\nМы по заданным n и k смогли вычислить значение выражения из определения 1. А вам слабо?\nВходные данные\nВо входном файле INPUT.TXT содержится ровно одна строка. Сначала – целое число n, (1 ≤ n ≤ 10) , затем ровно один пробел, затем k восклицательных знаков (1 ≤ k ≤ 20).\nВыходные данные\nВ выходной файл OUTPUT.TXT выведите одно число – значение n!!..! .",
    "complexity": 21,
    "memory": 16000,
    "time": 1000,
    "examples": [
      {
        "input": "10 !!!",
        "output": "280"
      },
      {
        "input": "9 !!",
        "output": "945"
      },
      {
        "input": "3 !",
        "output": "6"
      }
    ]
  },
  {
    "id": 78,
    "name": "Бутылки",
    "description": "Группа программистов собралась в понедельник и на все свои деньги купила «Sprite» в бутылках емкостью по 0.25 л., не забыв взять сдачу.\nOUTPUT.TXT83[Лучшие попытки]\nВо вторник они сдали пустую посуду, добавили оставшуюся сдачу и вновь купили столько таких же бутылок «Sprite», сколько могли.\nТак они действовали до пятницы. В пятницу, сдав посуду и добавив сдачу с четверга, они смогли купить только одну бутылку напитка. При этом денег у них уже не осталось.\nТребуется написать программу, определяющую минимальную сумму, которой располагали программисты в понедельник.\nВходные данные\nВходной файл INPUT.TXT состоит из единственной строки, содержащей два целых числа F (стоимость одной бутылки «Sprite») и P (стоимость одной пустой бутылки из под «Sprite»), разделенных пробелом.\nОграничения: 1 ≤ P \u003c F ≤ 109, начальная сумма не превосходит 2×109.\nВыходные данные\nВ единственную строку выходного файла OUTPUT.TXT нужно вывести одно целое число – минимальную сумму, которой располагали программисты в понедельник.",
    "complexity": 48,
    "memory": 16000,
    "time": 1000,
    "examples": [
      {
        "input": "7 3",
        "output": "83"
      }
    ]
  },
  {
    "id": 77,
    "name": "Нолики",
    "description": "Для заданных натуральных чисел N и K требуется вычислить количество чисел от 1 до N, имеющих в двоичной записи ровно K нулей. \nOUTPUT.TXT3213 244210[Лучшие попытки]\nНапример, если N=8 и K=1, то мы можем записать все числа от 1 до 8 в двоичной системе счисления:\n31000 5210\n1, 10, 11, 100, 101, 110, 111 и 1000.\nОткуда видно, что только числа 10, 101 и 110 имеют ровно один ноль в записи, т.е. правильный ответ – 3.\nВходные данные\nВ единственной строке входного файла INPUT.TXT записано два натуральных числа через пробел N и K, не превышающих 109.\nВыходные данные\nВ единственную строку выходного файла OUTPUT.TXT нужно вывести одно целое число — количество чисел от 1 до N с K нулями в двоичном представлении.",
    "complexity": 63,
    "memory": 16000,
    "time": 1000,
    "examples": [
      {
        "input": "8 1",
        "output": "3"
      },
      {
        "input": "13 2",
        "output": "4"
      },
      {
        "input": "1000 5",
        "output": "210"
      }
    ]
  },
  {
    "id": 52,
    "name": "Счастливый билет",
    "description": "Вы пользуетесь общественным транспортом? Вероятно, вы расплачивались за проезд и получали билет с номером. Счастливым билетом называют такой билет с шестизначным номером, где сумма первых трех цифр равна сумме последних трех. Т.е. билет с номером 385916 – счастливый, т.к. 3+8+5=9+1+6. Вам требуется написать программу, которая проверяет счастливость билета.\nOUTPUT.TXTYES2123456NONO[Лучшие попытки]\nВходные данные[Решение]\nВ единственной строке входного файла INPUT.TXT записано шесть десятичных цифр без пробелов.\nВыходные данные\nВ выходной файл OUTPUT.TXT нужно вывести «YES», если билет с номером N счастливый и «NO» в противном случае.",
    "complexity": 12,
    "memory": 16000,
    "time": 1000,
    "examples": [
      {
        "input": "385916",
        "output": "YES"
      },
      {
        "input": "123456",
        "output": "NO"
      }
    ]
  },
  {
    "id": 61,
    "name": "Баскетбол",
    "description": "Известны результаты каждой из 4х четвертей баскетбольной встречи. Нужно определить победителя матча. Побеждает команда, набравшая больше очков в течение всего матча.\nOUTPUT.TXT1214 15 \n17 18 \n20 20 \n15 17\n22DRAW[Лучшие попытки]\nВходные данные315 16 \n18 17 \n10 12 \n14 12\nDRAW[Решение]\nВходной файл INPUT.TXT содержит 4 строки, в каждой строке находится два целых числа a и b – итоговый счет в соответствующей четверти. а – количество набранных очков за четверть первой командой, b – количество очков, набранных за четверть второй командой. (0 ≤ a,b ≤ 100).\nВыходные данные\nВ выходной файл OUTPUT.TXT выведите номер выигравшей команды, в случае ничьей следует вывести «DRAW».",
    "complexity": 5,
    "memory": 16000,
    "time": 1000,
    "examples": [
      {
        "input": "26 17\n\n13 15\n\n19 11\n\n14 16",
        "output": "1"
      },
      {
        "input": "14 15\n \n17 18\n \n20 20\n \n15 17",
        "output": "2"
      },
      {
        "input": "15 16\n \n18 17\n \n10 12\n \n14 12",
        "output": "DRAW"
      }
    ]
  },
  {
    "id": 81,
    "name": "Арбузы",
    "description": "Иван Васильевич пришел на рынок и решил купить два арбуза: один для себя, а другой для тещи. Понятно, что для себя нужно выбрать арбуз потяжелей, а для тещи полегче. Но вот незадача: арбузов слишком много и он не знает как же выбрать самый легкий и самый тяжелый арбуз? Помогите ему!\nOUTPUT.TXT1 9[Лучшие попытки]\nВходные данные[Решение]\nВ первой строке входного файла INPUT.TXT задано одно число N – количество арбузов. Вторая строка содержит N чисел, записанных через пробел. Здесь каждое число – это масса соответствующего арбуза. Все числа натуральные и не превышают 30000.\nВыходные данные\nВ выходной файл OUTPUT.TXT нужно вывести два числа через пробел: массу арбуза, который Иван Васильевич купит теще и массу арбуза, который он купит себе.",
    "complexity": 14,
    "memory": 16000,
    "time": 1000,
    "examples": [
      {
        "input": "5\n5 1 6 5 9",
        "output": "1 9"
      }
    ]
  },
  {
    "id": 63,
    "name": "Загадка",
    "description": "Петя и Катя – брат и сестра. Петя – студент, а Катя – школьница. Петя помогает Кате по математике. Он задумывает два натуральных числа X и Y (X,Y≤1000), а Катя должна их отгадать. Для этого Петя делает две подсказки. Он называет сумму этих чисел S и их произведение P. Помогите Кате отгадать задуманные Петей числа.\nOUTPUT.TXT2 225 62 32 3[Лучшие попытки]\nВходные данные[Решение]\nВходной файл INPUT.TXT содержит два натуральных числа S и P, разделенных пробелом.\nВыходные данные\nВ выходной файл OUTPUT.TXT выведите два числа Х и Y, загаданные Петей. Числа следует вывести в порядке неубывания своих значений, разделенные пробелом.",
    "complexity": 18,
    "memory": 16000,
    "time": 1000,
    "examples": [
      {
        "input": "4 4",
        "output": "2 2"
      },
      {
        "input": "5 6",
        "output": "2 3"
      }
    ]
  },
  {
    "id": 92,
    "name": "Журавлики",
    "description": "Петя, Катя и Сережа делают из бумаги журавликов.  Вместе  они сделали  S журавликов. Сколько журавликов сделал каждый ребенок, если известно, что Петя и Сережа сделали одинаковое количество журавликов, а Катя сделала в два раза больше журавликов, чем Петя и Сережа вместе?\nOUTPUT.TXT1 4 12244 16 44 16 410 40 10[Лучшие попытки]\nВходные данные36010 40 10[Решение]\nВ единственной строке входного файла INPUT.TXT записано одно натуральное число S – общее количество сделанных журавликов (S \u003c 106).\nВыходные данные\nВ единственную строку выходного файла OUTPUT.TXT нужно вывести три числа, разделенных пробелами – количество журавликов, которые сделал каждый ребенок (Петя, Катя и Сережа).",
    "complexity": 7,
    "memory": 16000,
    "time": 1000,
    "examples": [
      {
        "input": "6",
        "output": "1 4 1"
      },
      {
        "input": "24",
        "output": "4 16 4"
      },
      {
        "input": "60",
        "output": "10 40 10"
      }
    ]
  },
  {
    "id": 62,
    "name": "Клетки",
    "description": "Известно, что шахматная доска имеет размерность 8х8 и состоит из клеток двух цветов, например, черного и белого (см. рисунок). Каждая клетка имеет координату, состоящую из буквы и цифры. Горизонтальное расположение клетки определяется буквой от A до H, а вертикальное – цифрой от 1 до 8. Заметим, что клетка с координатой А1 имеет черный цвет. Требуется по заданной координате определить цвет клетки.\nOUTPUT.TXTBLACK2G8WHITEWHITE[Лучшие попытки]\nВходные данные\nВ единственной строке входного файла INPUT.TXT записана координата клетки на шахматной доске: всего два символа – буква и цифра (без пробелов).\nВыходные данные\nВ выходной файл OUTPUT.TXT нужно вывести «WHITE», если указанная клетка имеет белый цвет и «BLACK», если она черная.",
    "complexity": 15,
    "memory": 16000,
    "time": 1000,
    "examples": [
      {
        "input": "C3",
        "output": "BLACK"
      },
      {
        "input": "G8",
        "output": "WHITE"
      }
    ]
  },
  {
    "id": 84,
    "name": "Выпуклая оболочка",
    "description": "Рассмотрим бесконечный лист клетчатой бумаги. Закрасим некоторое множество клеток в черный цвет. Теперь мы хотим закрасить минимальное количество клеток, так, чтобы множество черных клеток стало выпуклым.\nOUTPUT.TXT.**.\n.**.\n24 3\n.*.\n.*.\n.*.\n.*.\n.*.\n.*.\n.*.\n.*.\n.*.\n.*.\n.*.\n.*.\n[Лучшие попытки]\nНапомним, что геометрическая фигура Φ называется выпуклой, если для любых точек A из Φ и В из Φ с вещественными координатами отрезок [AB] принадлежит Φ.\nВходные данные\nВ первой строке входного файла INPUT.TXT содержатся два числа N и M \n(1 ≤ N, M ≤ 100) — размеры куска бумаги, куда попали все черные клетки. В каждой из следующих N строк содержится М символов «*» или «.». Символ «*» обозначает черную клетку, а «.» белую.\nВыходные данные\nВ выходной файл OUTPUT.TXT выведите выпуклое множество, содержащее минимальное количество дополнительно покрашенных черных клеток, в ровно N строках по M символов «*» или «.» в каждой.",
    "complexity": 27,
    "memory": 16000,
    "time": 1000,
    "examples": [
      {
        "input": "2 4\n\n..*.\n\n.**.",
        "output": ".**.\n\n.**."
      },
      {
        "input": "4 3\n\n.*.\n\n.*.\n\n.*.\n\n.*.",
        "output": ".*.\n\n.*.\n\n.*.\n\n.*."
      }
    ]
  },
  {
    "id": 80,
    "name": "Тождество",
    "description": "Вам необходимо проверить домашнюю работу Васи Пупкина, в которой он написал равенство. Например, запись вида «2+3=5» является правильной, а «23*7=421» неверная, но корректная. Корректной записью выражения будем называть последовательность: число, операция («+», «-», «*», «/»), число, знак равенства, число. Числом будем считать последовательность из одной или более десятичных цифр, перед которой может стоять один знак минус. В корректной записи выражения нет пробелов.\nOUTPUT.TXTYES23*7=20NONOERROR[Лучшие попытки]\nЕсли запись не соответствует описанному правилу, то она считается некорректной. Например, записи «2*=3», «173» и «2+2=a» некорректны.\n3two plus three is fiveERROR\nВходные данные\nВходной файл INPUT.TXT состоит из единственной строки, содержащей запись арифметического выражения. Все числа в записи не превышают по абсолютной величине 30000.  Длина арифметического выражения может быть от 0 до 100 символов.\nВыходные данные\nВ выходной файл OUTPUT.TXT выведите «YES», если указанная запись правильна (т.е. равенство представляет собой тождество), «NO» - если корректная, но неверная и «ERROR», если запись некорректная.",
    "complexity": 37,
    "memory": 16000,
    "time": 1000,
    "examples": [
      {
        "input": "2+3=5",
        "output": "YES"
      },
      {
        "input": "3*7=20",
        "output": "NO"
      },
      {
        "input": "two plus three is five",
        "output": "ERROR"
      }
    ]
  },
  {
    "id": 83,
    "name": "Симпатичные узоры",
    "description": "Компания BrokenTiles планирует заняться выкладыванием во дворах у состоятельных клиентов узор из черных и белых плиток, каждая из которых имеет размер 1×1 метр. Известно, что дворы всех состоятельных людей имеют наиболее модную на сегодня  форму прямоугольника M×N метров. \nOUTPUT.TXT1423 3322322[Лучшие попытки]\nОднако при составлении финансового плана у директора этой организации появилось целых две серьезных проблемы: во первых, каждый новый клиент очевидно захочет, чтобы узор, выложенный у него во дворе, отличался от узоров всех остальных клиентов этой фирмы, а во вторых, этот узор должен быть симпатичным. Как показало исследование, узор является симпатичным, если в нем нигде не встречается квадрата 2×2 метра, полностью покрытого плитками одного цвета. На рисунке 1 показаны примеры различных симпатичных узоров, а на рисунке 2 – несимпатичных.\nДля составления финансового плана директору необходимо узнать, сколько клиентов он сможет обслужить, прежде чем симпатичные узоры данного размера закончатся. Помогите ему!\nВходные данные\nВ первой строке входного файла INPUT.TXT находятся два положительных целых числа, разделенные пробелом – M и N (1 ≤ M∙N ≤ 30).\nВыходные данные\nВыведите в выходной файл OUTPUT.TXT единственное число – количество различных симпатичных узоров, которые можно выложить во дворе размера M×N. Узоры, получающиеся друг из друга сдвигом, поворотом или отражением считаются различными.",
    "complexity": 66,
    "memory": 16000,
    "time": 1000,
    "examples": [
      {
        "input": "2 2",
        "output": "14"
      },
      {
        "input": "3 3",
        "output": "322"
      }
    ]
  },
  {
    "id": 82,
    "name": "Пересечение множеств",
    "description": "Даны два неупорядоченных набора целых чисел (может быть, с повторениями). Выдать без повторений в порядке возрастания все те числа, которые встречаются в обоих наборах.\nOUTPUT.TXT6 12[Лучшие попытки]\nВходные данные[Решение]\nВ первой строке входного файла INPUT.TXT записано через пробел два целых числа N и М (1 ≤ N, М ≤ 300 000) — количество элементов первого и второго наборов, соответственно. Во второй строке записано N чисел первого набора через пробел. В третьей строке записано M чисел второго набора через пробел. Каждое из этих чисел попадает в промежуток от 0 до 105.\nВыходные данные\nВ выходной файл OUTPUT.TXT нужно записать в возрастающем порядке без повторений все числа, которые входят как в первый, так и во второй набор. Числа разделять одним пробелом. Если таких чисел нет, то выходной файл должен оставаться пустым.",
    "complexity": 34,
    "memory": 64000,
    "time": 1000,
    "examples": [
      {
        "input": "11 6\n\n2 4 6 8 10 12 10 8 6 4 2\n\n3 6 9 12 15 18",
        "output": "6 12"
      }
    ]
  },
  {
    "id": 85,
    "name": "Единичный НОД",
    "description": "Заданы два натуральных числа в десятичной системе счисления, состоящие из единиц. В первом числе ровно N единиц, а во втором их ровно M. Требуется найти НОД этих чисел.\nOUTPUT.TXT121 211[Лучшие попытки]\nНапомним, что НОД (наибольший общий делитель) двух чисел a и b — это такое максимальное число c, что b делится на c и a делится на c.\nВходные данные\nВ единственной строке входного файла INPUT.TXT записаны два целых числа N и M (1 ≤ N, M ≤ 2000).\nВыходные данные\nВ выходной файл OUTPUT.TXT выведите ответ без ведущих нулей.",
    "complexity": 23,
    "memory": 16000,
    "time": 1000,
    "examples": [
      {
        "input": "1 1",
        "output": "1"
      },
      {
        "input": "1 2",
        "output": "1"
      }
    ]
  },
  {
    "id": 1,
    "name": "A+B",
    "description": "Требуется сложить два целых числа А и В.\nOUTPUT.TXT5[Лучшие попытки]\nВходные данные[Решение]\nВ единственной строке входного файла INPUT.TXT записаны два натуральных числа через пробел. Значения чисел не превышают 109.\nВыходные данные\nВ единственную строку выходного файла OUTPUT.TXT нужно вывести одно целое число — сумму чисел А и В.",
    "complexity": 2,
    "memory": 16000,
    "time": 1000,
    "examples": [
      {
        "input": "2 3",
        "output": "5"
      }
    ]
  },
  {
    "id": 86,
    "name": "Головоломка про ферзей",
    "description": "OUTPUT.TXT2[Лучшие попытки]\nВероятно, что многие из вас играли в шахматы. Поэтому вы знаете, что ферзь может двигаться по горизонталям, вертикалям и диагоналям.\nВася недавно начал заниматься шахматами и где-то прочел головоломку, в которой нужно было расставить максимальное количество ферзей на доске 8х8 так, чтобы хотя бы одно поле оказалось небитым. Эта задача легко решается для доски 3х3, т.к. понятно, что более двух ферзей расставить таким образом на ней невозможно.\nПомогите Васе решить эту задачу для доски N×N.\nВходные данные\nВ единственной строке входного файла INPUT.TXT записано натуральное число N – размеры шахматной доски N×N (1 ≤ N ≤ 100).\nВыходные данные\nВ единственную строку выходного файла OUTPUT.TXT нужно вывести максимальное количество ферзей, которых можно расставить на шахматной доске N×N так, чтобы одна клетка оставалась небитой.",
    "complexity": 15,
    "memory": 16000,
    "time": 1000,
    "examples": [
      {
        "input": "3",
        "output": "2"
      }
    ]
  },
  {
    "id": 64,
    "name": "Простой ряд",
    "description": "Простым числом называется натуральное число (большее 1), которое делится нацело только на 1 и на само себя. Например, числа 2, 3, 5, 7, 11 и 23 - простые . Назовем простым рядом последовательность цифр, полученную следующим образом: подряд идущие по возрастанию простые числа (начиная с 2) записываются друг за другом. Начало данного ряда выглядит так: 23571113171923… Необходимо найти цифру, стоящую в простом ряду на указанном месте. Нумерация позиций начинается с единицы.\nOUTPUT.TXT27125\n2 5 6 8 12\n3113931139[Лучшие попытки]\nВходные данные\nВ первой строке входного файла INPUT.TXT записано натуральное число M – количество тестов. Во второй строке записано M чисел через пробел, каждое число – номер позиции в простом ряду (1 ≤  M ≤ 1000, 1 ≤ номер позиции ≤ 10000).\nВыходные данные\nВ выходной файл OUTPUT.TXT для каждой позиции выведите цифру из простого ряда, стоящую на этой позиции. Вывести следует M цифр в одной строке, не разделяя цифры пробелами.",
    "complexity": 27,
    "memory": 16000,
    "time": 1000,
    "examples": [
      {
        "input": "3\n \n1 4 11",
        "output": "271"
      },
      {
        "input": "5\n\n2 5 6 8 12",
        "output": "31139"
      }
    ]
  },
  {
    "id": 56,
    "name": "Jивой Jурнал",
    "description": "Программист Саша участвует в создании блог-сервиса Jивой Jурнал. Планируется, что этот сервис будет предоставлять гораздо больше возможностей, чем известный всем LiveJournal. В настоящее же время проблему составляет реализация всех базовых возможностей LiveJournal'а. Одной из таких возможностей является поддержка списков друзей для пользователей.\nOUTPUT.TXTFriends: bill-hates, ivan-ivanov, vasya-pupkin\nMutual Friends: vasya-pupkin\nAlso Friend of: destroyer\n20\n0\nFriends:\nMutual Friends:\nAlso Friend of:\nFriends:\nMutual Friends:\nAlso Friend of:\n[Лучшие попытки]\nЗаданы: список пользователей, являющихся друзьями данного пользователя, и список пользователей, у которых данный пользователь содержится в списке друзей.\nНеобходимо получить список друзей данного пользователя (Friends), список его взаимных друзей (Mutual Friends), и список тех пользователей, у кого данный пользователь содержится в списке друзей, но которые не являются его взаимными друзьями (Also Friend of).\nВходные данные\nПервая строка входного файла INPUT.TXT содержит число n (0 ≤ n ≤ 200) друзей данного пользователя. Последующие n строк содержат каждая по одному имени пользователя, который является другом данного. (n + 2)-ая строка содержит число m (0 ≤ m ≤ 200) пользователей, у которых данный содержится в списке друзей. Далее заданы имена пользователей, у которых данный находится в списке друзей. Эти пользователи заданы в том же формате, что и друзья данного.\nИмена пользователей - строки длиной от 1 до 20 символов, содержащие только строчные буквы английского алфавита и символы тире (\"-\"). Каждый пользователь указан не более одного раза в каждом из списков.\nВыходные данные\nВ выходной файл OUTPUT.TXT следует вывести список друзей данного пользователя (Friends), список его взаимных друзей (Mutual Friends), и список тех пользователей, у кого данный пользователь содержится в списке друзей, но которые не являются его взаимными друзьями (Also Friend of). В каждом списке пользователи должны быть отсортированы по алфавиту. Следуйте формату, приведенному в примерах.",
    "complexity": 29,
    "memory": 16000,
    "time": 1000,
    "examples": [
      {
        "input": "3\n\nvasya-pupkin\n\nbill-hates\n\nivan-ivanov\n\n2\n\nvasya-pupkin\n\ndestroyer",
        "output": "Friends: bill-hates, ivan-ivanov, vasya-pupkin\n\nMutual Friends: vasya-pupkin\n\nAlso Friend of: destroyer"
      },
      {
        "input": "0\n\n0",
        "output": "Friends:\n\nMutual Friends:\n\nAlso Friend of:"
      }
    ]
  },
  {
    "id": 53,
    "name": "Раскраска таблицы умножения",
    "description": "Таблицей умножения назовем таблицу размера n строк на m столбцов, в которой на пересечении i-ой строки и j-ого столбца стоит число i∙j (строки и столбцы нумеруются с единицы). \nOUTPUT.TXTRED   : 21\nGREEN : 39\nBLUE  : 36\nBLACK : 4\n25 2RED   : 5\nGREEN : 2\nBLUE  : 2\nBLACK : 1\nRED   : 5\nGREEN : 2\nBLUE  : 2\nBLACK : 1\n[Лучшие попытки]\nВ одной из математических школ было решено провести педагогический эксперимент. Для того, чтобы ученикам было проще запоминать таблицу умножения, некоторые числа в ней будут покрашены в красный, некоторые - в синий, а некоторые - в зеленый цвет (оставшиеся числа будут черными).\nПроцесс покраски чисел можно условно разбить на четыре этапа. На первом этапе все числа красятся в черный цвет. На втором - все четные числа красятся в красный цвет, на третьем – все числа, делящиеся на 3, красятся в зеленый цвет, на четвертом - все числа, делящиеся на 5, красятся в синий цвет.\nДиректор школы хочет знать, какое количество картриджей для принтеров необходимо закупить для печати таблиц. Поэтому ему необходима информация о том, сколько чисел какого цвета будет в одной раскрашенной таблице умножения n на m. Напишите программу, решающую задачу подсчета соответствующих количеств.\nВходные данные\nВходной файл INPUT.TXT содержит два натуральных числа n и m (1 ≤ n,m ≤ 1000).\nВыходные данные\nВ первой строке выходного файла OUTPUT.TXT выведите количество чисел, покрашенных в красный цвет, во второй - в зеленый, в третьей - в синий, в четвертой - в черный. Следуйте формату, приведенному в примерах.",
    "complexity": 22,
    "memory": 16000,
    "time": 1000,
    "examples": [
      {
        "input": "10 10",
        "output": "RED   : 21\n\nGREEN : 39\n\nBLUE  : 36\n\nBLACK : 4"
      },
      {
        "input": "5 2",
        "output": "RED   : 5\n\nGREEN : 2\n\nBLUE  : 2\n\nBLACK : 1"
      }
    ]
  },
  {
    "id": 87,
    "name": "Строки - 2",
    "description": "",
    "complexity": 42,
    "memory": 16000,
    "time": 1000,
    "examples": [
      {
        "input": "aa\n\naaaa\n\nab\n\nabaa\n\nENDOFINPUT",
        "output": "2"
      },
      {
        "input": "abc\n\nbcd\n\ndef\n\nENDOFINPUT",
        "output": "0"
      }
    ]
  },
  {
    "id": 54,
    "name": "Теория игр",
    "description": "Выходные данные\nВ выходной файл OUTPUT.TXT выведите нижнее и верхнее значение игры через пробел.",
    "complexity": 28,
    "memory": 16000,
    "time": 1000,
    "examples": [
      {
        "input": "3 3\n\n4 -1 -3\n\n-2 1 3\n\n0 2 -3",
        "output": "-2 2"
      },
      {
        "input": "3 4\n\n-1 0 2 1\n\n-2 0 1 0\n\n2 1 -1 -2",
        "output": "-1 1"
      }
    ]
  },
  {
    "id": 55,
    "name": "Фонарики",
    "description": "«Одна голова хорошо, а две лучше. Одна лампочка хорошо, а две лучше!» - подумал Миша, и решил собрать фонарик с двумя лампочками. Теперь он хочет узнать, насколько фонарик с двумя лампочками лучше, чем фонарик с одной. Заметим, что лампочки в фонаре с двумя лампочками отличаются от лампочки в фонаре с одной лампочкой. Для этого Миша посветил фонариком на стену, и каждая из лампочек осветила на ней круг.\n2OUTPUT.TXTYES21 1\n100 100\n1\n7\nNONO[Лучшие попытки]\nЭффективность фонарика Миша хочет оценить через площадь освещенной части стены. Миша догадался измерить координаты центров освещенных кругов и их радиусы (которые оказались одинаковыми). Причем, площадь, освещаемая фонариком с одной лампочкой известна, т.к. описана в документации, прилагаемой к фонарику. Но что делать дальше он не знает. Напишите программу, которая поможет Мише.\n2\nВходные данные1\nВ первых двух строчках входного файла INPUT.TXT содержатся координаты (x1,y1) и (x2,y2) - центры кругов от лампочек собранного Мишей фонарика. В третьей строке задан радиус r описанных выше кругов, а четвертая строка содержит площадь освещения s фонариком из одной лампочки. Все числа целые и удовлетворяют следующим ограничениям: 1 ≤ x1,y1,x2,y2,r ≤ 100, 1 ≤ s ≤ 105. Так же заметим, что площади, освещаемые разными фонариками, отличаются друг от друга более чем на 10-3.\n1\n2Выходные данные\n2\nВ выходной файл OUTPUT.TXT выведите «YES», если Мишин фонарик лучше старого (т.е. освещает большую площадь) и «NO» в противном случае.\n5Примеры\n-3\n№INPUT.TXTOUTPUT.TXT\n11 2\n3 4\n2\n22\nYES\n21 1\n100 100\n1\n7\nNO\nДля отправки решения задачи необходимо зарегистрироваться и авторизоваться!\n[Обсуждение]\n\n  [Все попытки]\n\n  [Лучшие попытки]\nwindow.yaContextCb.push(()=\u003e{\n  Ya.Context.AdvManager.render({\n    renderTo: 'yandex_rtb_R-A-122393-3',\n    blockId: 'R-A-122393-3'\n  })\n})",
    "complexity": 31,
    "memory": 16000,
    "time": 1000,
    "examples": [
      {
        "input": "1 2\n\n3 4\n\n2\n\n22",
        "output": "YES"
      },
      {
        "input": "1 1\n\n100 100\n\n1\n\n7",
        "output": "NO"
      }
    ]
  },
  {
    "id": 65,
    "name": "Расстояние Хэмминга",
    "description": "В связи с особенностями линии связи, используемой для передачи сообщений из пункта A в пункт B, каждый бит принятого сообщения с вероятностью 0.001 содержит ошибку.\nn2OUTPUT.TXT22 3[Лучшие попытки]\nИз пункта A в пункт B было послано одно из n сообщений m1, m2, ..., mn. В пункте B было принято сообщение s.\nn\nВаша задача заключается в определении наиболее вероятного исходного сообщения. Очевидно, что оно будет одним из тех сообщений, расстояние Хэмминга между которым и строкой s минимально.\nРасстоянием Хэмминга двух строк a и b одинаковой длины называется количество позиций, в которых эти строки различаются (количество элементов в множестве {i | 1 ≤ i ≤ |a|, ai ≠ bi }).\nВходные данные\nПервая строка входного файла INPUT.TXT содержит s — принятое сообщение. Вторая строка содержит целое число n — количество сообщений, которые могли быть отправлены. Следующие n строк содержат mi — эти сообщения.\nДлины всех сообщений равны (|s| = |m1| = |m2| = ... = |mn|). Сообщения непустые, состоят только из символов 0 и 1.\nРазмер входного файла не превосходит 60 Кб.\nВыходные данные\nВ первую строку выходного файла OUTPUT.TXT выведите k — количество сообщений, на которых достигается минимум расстояния Хэмминга. Во вторую строку выведите в порядке возрастания k чисел — номера этих сообщений.",
    "complexity": 27,
    "memory": 16000,
    "time": 1000,
    "examples": [
      {
        "input": "010101\n\n3\n\n110011\n\n011001\n\n000111",
        "output": "2\n2 3"
      }
    ]
  },
  {
    "id": 66,
    "name": "Клавиатура",
    "description": "Для данной буквы английского алфавита нужно вывести справа стоящую букву на стандартной клавиатуре. При этом клавиатура замкнута, т.е. справа от буквы «p» стоит буква «a», от буквы «l» стоит буква «z», а от буквы «m» — буква «q».\nOUTPUT.TXTw2tyyazq[Лучшие попытки]\nВходные данные3pa\nПервая строка входного файла INPUT.TXT содержит один символ — маленькую букву английского алфавита.\n4lz\nВыходные данные5mq\nВ выходной файл OUTPUT.TXT следует вывести букву стоящую справа от заданной буквы, с учетом замкнутости клавиатуры.",
    "complexity": 11,
    "memory": 16000,
    "time": 1000,
    "examples": [
      {
        "input": "q",
        "output": "w"
      },
      {
        "input": "t",
        "output": "y"
      },
      {
        "input": "p",
        "output": "a"
      },
      {
        "input": "l",
        "output": "z"
      },
      {
        "input": "m",
        "output": "q"
      }
    ]
  },
  {
    "id": 90,
    "name": "Треугольные страны",
    "description": "Эта история происходила на одной плоской планете. С незапамятных времен на ней существовал город N, находящийся в точке xn,yn. Кроме этого, в разное время на этой же планете существовали страны, каждая из которых имела форму треугольника.\n1OUTPUT.TXT2\n1 2\n20 2\n2\n-2 0 2 0 0 2\n-3 0 3 0 0 3\n1\n2\n1\n2\n[Лучшие попытки]\nТеперь перед историками встала серьезная задача — по имеющимся у них данным о треугольных странах определить, в какие страны мог входить город N. Город мог входить в страну, если он находится строго внутри нее.\n1\nВходные данные2\nПервая строка входного файла содержит два числа: xn и yn — координаты города N. Вторая строка входного файла содержит количество k треугольных стран (1 ≤ k ≤ 1000). Последующие k строк каждая описывают одну треугольную страну. Описание треугольной страны состоит из шести целых чисел x1,y1,x2,y2,x3,y3, где (x1,y1), (x2,y2), (x3,y3) — координаты вершин этой страны.\n2\n3\nГарантируется, что все страны имеют ненулевую площадь. Все координаты не превосходят 10000 по абсолютной величине.\n3Выходные данные\n1\nВ первой строке выходного файла выведите количество стран, в которые мог входить город N. Во второй строке выведите через пробел номера этих стран в возрастающем порядке. Страны нумеруются с единицы в том порядке, в каком они заданы во входном файле.\n1Примеры\n2\n№INPUT.TXTOUTPUT.TXT\n10 1\n2\n-2 0 2 0 0 2\n-3 0 3 0 0 3\n2\n1 2\n\n20 2\n2\n-2 0 2 0 0 2\n-3 0 3 0 0 3\n1\n2\n2\n3Для отправки решения задачи необходимо зарегистрироваться и авторизоваться!\n3\n\n  [Обсуждение]\n\n  [Все попытки]\n\n  [Лучшие попытки]\nwindow.yaContextCb.push(()=\u003e{\n  Ya.Context.AdvManager.render({\n    renderTo: 'yandex_rtb_R-A-122393-3',\n    blockId: 'R-A-122393-3'\n  })\n})",
    "complexity": 37,
    "memory": 16000,
    "time": 1000,
    "examples": [
      {
        "input": "0 1\n\n2\n\n-2 0 2 0 0 2\n\n-3 0 3 0 0 3",
        "output": "2\n\n1 2"
      },
      {
        "input": "0 2\n\n2\n\n-2 0 2 0 0 2\n\n-3 0 3 0 0 3",
        "output": "1\n\n2"
      }
    ]
  },
  {
    "id": 89,
    "name": "Быстрый поезд",
    "description": "Между двумя крупнейшими городами нашей страны Санкт-Петербургом и Москвой ежедневно совершают рейсы n поездов. Для каждого поезда известно его время отправления из Санкт-Петербурга и время прибытия в Москву.\nOUTPUT.TXTThe fastest train is \"ER-200\".\nIts speed is 165 km/h, approximately.\n23\n\"Train1\" 00:00 00:00\n\"Train2\" 00:00 00:01\n\"Train3\" 00:01 00:01\nThe fastest train is \"Train2\".\nIts speed is 39000 km/h, approximately.\nThe fastest train is \"Train2\".\nIts speed is 39000 km/h, approximately.\nThe fastest train is \"Slow Train 1\".\nIts speed is 27 km/h, approximately.\n[Лучшие попытки]\nНайдите самый быстрый поезд и его скорость в предположении, что длина железной дороги между Санкт-Петербургом и Москвой равна 650 км.\n32\n\"Slow Train 1\" 10:00 09:59\n\"Slow Train 2\" 10:00 10:00\nThe fastest train is \"Slow Train 1\".\nIts speed is 27 km/h, approximately.\nВходные данные\nПервая строка входного файла INPUT.TXT содержит целое число n (1 ≤ n ≤ 100). Каждая из последующих n строк описывает ровно один поезд.\nОписание поезда состоит из его названия, времени отправления и времени прибытия. Название поезда – строка длиной от 1 до 50 символов, заключенная в кавычки. Она может содержать буквы английского алфавита, пробелы, цифры, символы тире («–») и подчеркивания («_»). Время отправления и прибытия заданы в формате ЧЧ:ММ. Строчные и заглавные буквы в названиях поездов различаются.\nВремя в пути для каждого из поездов составляет хотя бы одну минуту и не превышает 24 часов.\nГарантируется, что самый быстрый поезд определяется единственным образом.\nВыходные данные\nВ выходной файл OUTPUT.TXT выведите название самого быстрого поезда и его скорость. Скорость выводите в километрах в час и округляйте к ближайшему целому по математическим правилам. Следуйте формату вывода, приведенному в примерах.",
    "complexity": 30,
    "memory": 16000,
    "time": 1000,
    "examples": [
      {
        "input": "3\n\n\u0026#34;ER-200\u0026#34; 06:43 10:40\n\n\u0026#34;Red Arrow\u0026#34; 23:55 07:55\n\n\u0026#34;Express\u0026#34; 23:59 08:00",
        "output": "The fastest train is \u0026#34;ER-200\u0026#34;.\n\nIts speed is 165 km/h, approximately."
      },
      {
        "input": "3\n\n\u0026#34;Train1\u0026#34; 00:00 00:00\n\n\u0026#34;Train2\u0026#34; 00:00 00:01\n\n\u0026#34;Train3\u0026#34; 00:01 00:01",
        "output": "The fastest train is \u0026#34;Train2\u0026#34;.\n\nIts speed is 39000 km/h, approximately."
      },
      {
        "input": "2\n\n\u0026#34;Slow Train 1\u0026#34; 10:00 09:59\n\n\u0026#34;Slow Train 2\u0026#34; 10:00 10:00",
        "output": "The fastest train is \u0026#34;Slow Train 1\u0026#34;.\n\nIts speed is 27 km/h, approximately."
      }
    ]
  },
  {
    "id": 88,
    "name": "Судоку",
    "description": "Судоку размера n называется квадрат со стороной n2, разделенный на n2 средних квадратов со стороной n, каждый из которых разделен на n2 маленьких квадратов. В каждом маленьком квадрате записано число от 1 до n2.\n2OUTPUT.TXTCorrect2110IncorrectIncorrect[Лучшие попытки]\n2\nСудоку называется правильным, если в каждом столбце, каждой строке и каждом среднем квадрате встречаются все числа от 1 до n2.\n[Решение]\nНедавно Вася нарисовал Судоку размера n. Ваша задача – помочь ему определить правильный ли он.\nВходные данные\nВ первой строке входного файла INPUT.TXT содержится число n (1 ≤ n ≤ 10). В следующих n2 строчках содержится по n2 чисел, задающих нарисованный Васей Судоку.\nВсе числа во входном файле натуральные и не превосходят 100 по модулю.\nВыходные данные\nЕсли Судоку правильный, то выведите в выходной файл OUTPUT.TXT слово «Correct», иначе выведите «Incorrect».",
    "complexity": 27,
    "memory": 16000,
    "time": 1000,
    "examples": [
      {
        "input": "3\n\n1 3 2 5 4 6 9 8 7\n\n4 6 5 8 7 9 3 2 1\n\n7 9 8 2 1 3 6 5 4\n\n9 2 1 4 3 5 8 7 6\n\n3 5 4 7 6 8 2 1 9\n\n6 8 7 1 9 2 5 4 3\n\n5 7 6 9 8 1 4 3 2\n\n2 4 3 6 5 7 1 9 8\n\n8 1 9 3 2 4 7 6 5",
        "output": "Correct"
      },
      {
        "input": "1\n10",
        "output": "Incorrect"
      }
    ]
  },
  {
    "id": 58,
    "name": "Проверка на симпатичность",
    "description": "Рассмотрим таблицу, содержащую n строк и m столбцов, в каждой клетке которой расположен ноль или единица. Назовем такую таблицу симпатичной, если в ней нет ни одного квадрата 2 на 2, заполненного целиком нулями или целиком единицами.\nOUTPUT.TXTYES\nYES\nNO\n[Лучшие попытки]\nТак, например, таблица 4 на 4, расположенная слева, является симпатичной, а расположенная справа таблица 3 на 3 - не является.\n[Решение]\nЗадано несколько таблиц. Необходимо для каждой из них выяснить, является ли она симпатичной.\nВходные данные\nПервая строка входного файла INPUT.TXT содержит количество t (1 ≤ t ≤ 10) наборов входных данных. Далее следуют описания этих наборов. Описание каждого набора состоит из строки, содержащей числа n и m (1 ≤ n,m ≤ 100), и n строк, каждая из которых содержит по m чисел, разделенных пробелами. j-ое число в i+1-ой строке описания набора входных данных - элемент aij соответствующей таблицы. Гарантируется, что все aij равны либо нулю, либо единице.\nВыходные данные\nДля каждого набора входных данных выведите в файл OUTPUT.TXT единственную строку, содержащую слово «YES», если соответствующая таблица является симпатичной, и слово «NO» - в противном случае.",
    "complexity": 28,
    "memory": 16000,
    "time": 1000,
    "examples": [
      {
        "input": "3\n\n1 1\n\n0\n\n4 4\n\n1 0 1 0\n\n1 1 1 0\n\n0 1 0 1\n\n0 0 0 0\n\n3 3\n\n0 0 1\n\n0 0 1\n\n1 1 1",
        "output": "YES\n\nYES\n\nNO"
      }
    ]
  },
  {
    "id": 60,
    "name": "Сверхпростые числа",
    "description": "Простым числом будем называть натуральное число, большее единицы и делящееся только на единицу и на само себя. Выпишем все простые числа в порядке возрастания и i-ое в этом порядке число обозначим pi (число 2 при этом будет иметь номер 1). Так, например, p1 = 2, p2 = 3, p3 = 5, p52 = 239.\n3OUTPUT.TXT32255113911[Лучшие попытки]\n52\nСкажем, что число pi является сверхпростым, если i = pk для некоторого k. Иными словами, сверхпростое число — это простое число, номер которого в списке простых чисел, упорядоченном по возрастанию, является простым числом.\n3311\nДано натуральное число k. Упорядочим все сверхпростые числа по возрастанию. Найдите k-ое сверхпростое число в этом порядке.\n41003911\nВходные данные\nВходной файл INPUT.TXT содержит натуральное число k (1 ≤ k ≤ 500).\nВыходные данные\nВ выходной файл OUTPUT.TXT выведите k-ое сверхпростое число.",
    "complexity": 39,
    "memory": 16000,
    "time": 1000,
    "examples": [
      {
        "input": "1",
        "output": "3"
      },
      {
        "input": "2",
        "output": "5"
      },
      {
        "input": "3",
        "output": "11"
      },
      {
        "input": "100",
        "output": "3911"
      }
    ]
  },
  {
    "id": 57,
    "name": "Компьютерная сеть",
    "description": "Компания «Маша и медведи» является самым крупным интернет-провайдером во всем  лесу. Именно поэтому, с просьбой подключить их к интернету обратились N поросят. Домики поросят расположены в различных точках (xi, yi). Ближайшая точка подключения расположена в точке (xnet, ynet). \nnet15OUTPUT.TXTYES23 1 5\n1 1\n2 2\n3 3\n4 4\nNONO[Лучшие попытки]\nneti\ni\nnet\nПоросята платят деньги в зависимости от длины провода. Количество денег у них ограничено и составляет p тугриков. Они хотят определить: хватит ли им денег на подключение? Так же известно, что единица длины провода стоит c тугриков. Помогите им сделать необходимые расчеты!\nnet\nВходные данные-2\nВ первой строке входного файла INPUT.TXT находится числа N, с и p – целые числа со следующими ограничениями: 1 ≤ N ≤ 103, 0 ≤ c ≤ 104, 0 ≤ p ≤ 1015 . В следующих N строках находятся координаты домов поросят (xi; yi). В последней строке записаны координаты точки соединения (xnet, ynet). Все координаты целые и не превосходят 1000 по модулю. Гарантируется, что необходимая для подключения суммарная длина проводов либо целая, либо отличается от целой более чем на 10-2.\nВыходные данные\nВ выходной файл OUTPUT.TXT следует вывести «YES», если у поросят достаточно денег для подключения и «NO» в противном случае.",
    "complexity": 28,
    "memory": 16000,
    "time": 1000,
    "examples": [
      {
        "input": "3 2 6\n\n0 0\n\n1 0\n\n0 1\n\n-1 0",
        "output": "YES"
      },
      {
        "input": "3 1 5\n\n1 1\n\n2 2\n\n3 3\n\n4 4",
        "output": "NO"
      }
    ]
  },
  {
    "id": 59,
    "name": "Несложное вычисление",
    "description": "Задано натуральное число n. Необходимо перевести его в k-ичную систему счисления и найти разность между произведением и суммой его цифр в этой системе счисления.\nOUTPUT.TXT9021000000000 7-34-34[Лучшие попытки]\nНапример, пусть n = 239, k = 8. Тогда представление числа n в восьмеричной системе счисления — 357, а ответ на задачу равен 3 × 5 × 7 − (3 + 5 + 7) = 90.\n[Решение]\nВходные данные\nВходной файл INPUT.TXT содержит два натуральных числа: n и k (1 ≤ n ≤ 109, 2 ≤ k ≤ 10). Оба этих числа заданы в десятичной системе счисления.\nВыходные данные\nВ выходной файл OUTPUT.TXT выведите ответ на задачу (в десятичной системе счисления).",
    "complexity": 25,
    "memory": 16000,
    "time": 1000,
    "examples": [
      {
        "input": "239 8",
        "output": "90"
      },
      {
        "input": "1000000000 7",
        "output": "-34"
      }
    ]
  },
  {
    "id": 167,
    "name": "Количество треугольников",
    "description": "OUTPUT.TXT1225527[Лучшие попытки]\nРассмотрим фигуру, аналогичную показанной на рисунке (большой равносторонний треугольник, составленный из маленьких равносторонних треугольников). На рисунке приведена фигура, состоящая из 4-х уровней треугольников.\n3427\nТребуется написать программу, которая будет определять, сколько всего в ней треугольников (необходимо учитывать не только \"маленькие\" треугольники, а вообще все треугольники — в частности, треугольник, выделенный жирным, а также вся фигура, являются интересующими нас треугольниками).\nВходные данные\nВходной файл INPUT.TXT содержит одно число N — количество уровней в фигуре (1 ≤ N ≤ 105).\nВыходные данные\nВыходной файл OUTPUT.TXT должен содержать одно число - количество треугольников в такой фигуре.",
    "complexity": 51,
    "memory": 16000,
    "time": 1000,
    "examples": [
      {
        "input": "1",
        "output": "1"
      },
      {
        "input": "2",
        "output": "5"
      },
      {
        "input": "4",
        "output": "27"
      }
    ]
  },
  {
    "id": 39,
    "name": "Волосатый бизнес",
    "description": "Одного неформала выгнали с работы, и теперь ему надо как-то зарабатывать себе на жизнь. Поразмыслив, он решил, что сможет иметь очень неплохие деньги на продаже собственных волос. Известно, что пункты приема покупают волосы произвольной длины стоимостью С у.е. за каждый сантиметр. Так как волосяной рынок является очень динамичным, то цена одного сантиметра волос меняется каждый день как и курс валют. Неформал является очень хорошим бизнес-аналитиком. Он смог вычислить, какой будет цена одного сантиметра волос в каждый из ближайших N дней (для удобства пронумеруем дни в хронологическом порядке от 0 до N-1). Теперь он хочет определить, в какие из этих дней ему следует продавать волосы, чтобы по истечению всех N дней заработать максимальное количество денег. Заметим, что волосы у неформала растут только ночью и вырастают на 1 сантиметр за ночь. Следует также учесть, что до 0-го дня неформал с горя подстригся наголо и к 0-му дню длина его волос составляла 1 сантиметр. \nOUTPUT.TXT3802101 2 3 4 5 6 7 8 9 1010010055[Лучшие попытки]\nВходные данные31010 9 8 7 6 5 4 3 2 155[Решение]\nВ первой строке входного файла INPUT.TXT записано целое число N (0 \u003c N ≤ 100). Во второй строке через пробел заданы N натуральных чисел, не превосходящих 100, соответствующие стоимости C[i] 1 сантиметра волос  за каждый i-й день.\nВыходные данные\nВ единственную строку выходного файла OUTPUT.TXT нужно вывести максимальную денежную сумму, которую может заработать неформал за N дней.",
    "complexity": 32,
    "memory": 16000,
    "time": 1000,
    "examples": [
      {
        "input": "5\n73 31 96 24 46",
        "output": "380"
      },
      {
        "input": "10\n1 2 3 4 5 6 7 8 9 10",
        "output": "100"
      },
      {
        "input": "10\n10 9 8 7 6 5 4 3 2 1",
        "output": "55"
      }
    ]
  },
  {
    "id": 117,
    "name": "Опасная зона",
    "description": "Группа экспертов обнаружила на территории нежилого массива множество опасных участков, соприкосновение с которыми небезопасно для жизни человека. \n\n\nВ целях безопасности требуется создать защитный периметр в форме выпуклого многоугольника, который бы смог обезопасить проникновение человека в эту зону.\n\n\nПо заданным координатам опасных участков требуется вычислить минимально возможную площадь опасной зоны, которая попадет в защитный периметр.\n\n\n\n\nПо заданным координатам опасных участков требуется вычислить минимально возможную площадь опасной зоны, которая попадет в защитный периметр.\nOUTPUT.TXT26[Лучшие попытки]\nВходные данные\nВ первой строке входного файла INPUT.TXT записано натуральное число N – количество опасных участков. В каждой из N последующих строк находятся два числа Xi и Yi  - координаты участков, размерами которых можно пренебречь. При этом участки могут повторяться.\nВсе числа целые, не превосходящие 1000 по абсолютной величине.\nВыходные данные\nВ выходной файл OUTPUT.TXT необходимо вывести одно число — площадь опасной зоны, округленной до целого значения.",
    "complexity": 57,
    "memory": 16000,
    "time": 1000,
    "examples": [
      {
        "input": "10\n\n4 6\n\n2 5\n\n6 4\n\n7 7\n\n4 4\n\n1 5\n\n3 8\n\n3 2\n\n5 7\n\n7 3",
        "output": "26"
      }
    ]
  },
  {
    "id": 93,
    "name": "Боги",
    "description": "Археологами найден набор древних копий старинных манускриптов с мифами – различными историями о древних богах. К несчастью, переписчики этих манускриптов не отличались особой грамотностью и умудрились в каждом имени сделать ровно по одной орфографической ошибке – т.е ровно одну из букв божественного имени заменили какой-то другой буквой. Археологи смогли составить список правильных написаний имен богов, так же им удалось выписать из манускриптов все имена собственные. Однако сопоставлять два списка – свыше их сил. Помогите им в этом!\nOUTPUT.TXT2 1 0[Лучшие попытки]\nВходные данные\nПервая строка входного файла INPUT.TXT содержит число N – количество имен богов в списке. Следующие N строк – имена богов. Далее идет строка, содержащая число M – количество «подозрительных»  слов, выписанных из манускриптов. Следующие M строк – «подозрительные» слова. Каждое из имен богов и «подозрительных» слов – последовательность из K заглавных букв английского алфавита (1 ≤ N, M, K ≤ 30).\nВыходные данные\nВ выходной файл OUTPUT.TXT выводится N чисел – для каждого божьего имени выводится число “подозрительных” слов, которые являются именем данного бога с одной ошибкой.",
    "complexity": 26,
    "memory": 16000,
    "time": 1000,
    "examples": [
      {
        "input": "3\n\nZEUS\n\nPOSEIDON\n\nAFINA\n\n4\n\nZEVS\n\nPOSEYDON\n\nAVYNA\n\nZERS",
        "output": "2 1 0"
      }
    ]
  },
  {
    "id": 91,
    "name": "Две последовательности",
    "description": "",
    "complexity": 29,
    "memory": 16000,
    "time": 1000,
    "examples": [
      {
        "input": "4",
        "output": "7\n8"
      },
      {
        "input": "10",
        "output": "25\n16"
      },
      {
        "input": "6578",
        "output": "19731\n9868"
      }
    ]
  },
  {
    "id": 119,
    "name": "Сортировка времени",
    "description": "Требуется выполнить сортировку временных моментов, заданных в часах, минутах и секундах.\nOUTPUT.TXT7 30 0\n10 20 30\n13 30 30\n23 59 59\n[Лучшие попытки]\nВходные данные[Решение]\nВо входном файле INPUT.TXT в первой строке записано число N (1 ≤ N ≤ 100), а в последующих N строках N моментов времени. Каждый момент времени задается 3 целыми числами - часы (от 0 до 23), минуты (от 0 до 59) и секунды (от 0 до 59).\nВыходные данные\nВ выходной файл OUTPUT.TXT выведите моменты времени, упорядоченные в порядке неубывания без ведущих нулей.",
    "complexity": 23,
    "memory": 16000,
    "time": 1000,
    "examples": [
      {
        "input": "4\n\n10 20 30\n\n7 30 00\n\n23 59 59\n\n13 30 30",
        "output": "7 30 0\n\n10 20 30\n\n13 30 30\n\n23 59 59"
      }
    ]
  },
  {
    "id": 143,
    "name": "A-B",
    "description": "Требуется найти разность между неотрицательными числами А и В.\nOUTPUT.TXT22517-12-12[Лучшие попытки]\nВходные данные[Решение]\nВо входном файле INPUT.TXT в двух строках записаны два неотрицательных целых числа A и B, не превышающие 101000.\nВыходные данные\nВ выходной файл OUTPUT.TXT выведите значение A-B.",
    "complexity": 44,
    "memory": 16000,
    "time": 1000,
    "examples": [
      {
        "input": "7\n5",
        "output": "2"
      },
      {
        "input": "5\n17",
        "output": "-12"
      }
    ]
  },
  {
    "id": 129,
    "name": "Табличка",
    "description": "Вам дана табличка, состоящая из N строк и M столбцов. В каждой клетке таблицы стоит либо 0, либо 1. Расстоянием между клетками (x1,y1) и (x2,y2) называется |x1-x2|+|y1-y2|. Вам нужно построить другую таблицу, в которой в каждой клетке стоит расстояние от данной до ближайшей клетки, содержащей 1 (в начальной таблице). Гарантируется, что хотя бы одна 1 в таблице есть.\nOUTPUT.TXT1 1 0\n0 1 1\n[Лучшие попытки]\nВходные данные\nВ первой строке входного файла INPUT.TXT содержатся два натуральных числа, не превосходящих 100 - N и M. Далее идут N строк по M чисел - элементы таблицы.\nВыходные данные\nВыходной файл OUTPUT.TXT должен содержать N строк по M чисел - элементы искомой таблицы.",
    "complexity": 51,
    "memory": 16000,
    "time": 1000,
    "examples": [
      {
        "input": "2 3\n\n0 0 1\n\n1 0 0",
        "output": "1 1 0\n\n0 1 1"
      }
    ]
  },
  {
    "id": 118,
    "name": "Задача Иосифа Флавия",
    "description": "Существует легенда, что Иосиф Флавий - известный историк первого века - выжил и стал известным благодаря математической одаренности. В ходе иудейской войны он в составе отряда из 41 иудейского воина был загнан римлянами в пещеру. Предпочитая самоубийство плену, воины решили выстроиться в круг и последовательно убивать каждого третьего из живых до тех пор, пока не останется ни одного человека. Однако Иосиф наряду с одним из своих единомышленников счел подобный конец бессмысленным - он быстро вычислил спасительные места в порочном круге, на которые поставил себя и своего товарища. И лишь поэтому мы знаем его историю…\nOUTPUT.TXT4[Лучшие попытки]\nВ нашем варианте мы начнем с того, что выстроим в круг N человек, пронумерованных числами от 1 до N, и будем исключать каждого k-ого до тех пор, пока не уцелеет только один человек.\nНапример, если N=10, K=3, то сначала умрет 3-й, потом 6-й, затем 9-й, затем 2-й, затем 7-й, потом 1-й, потом 8-й, за ним - 5-й, и потом 10-й. Таким образом, уцелеет 4-й.\nТребуется написать программу, которая по заданным N и K будет определять номер уцелевшего человека.\nВходные данные\nВходной файл INPUT.TXT содержит два натуральных числа N и K. Ограничения: N ≤ 500, K ≤ 100.\nВыходные данные\nВ выходной файл OUTPUT.TXT нужно вывести номер уцелевшего человека.",
    "complexity": 29,
    "memory": 16000,
    "time": 1000,
    "examples": [
      {
        "input": "10 3",
        "output": "4"
      }
    ]
  },
  {
    "id": 131,
    "name": "Перепись",
    "description": "В доме живет N жильцов. Однажды решили провести перепись всех жильцов данного дома и составили список, в котором указали возраст и пол каждого жильца. Требуется найти номер самого старшего жителя мужского пола.\nOUTPUT.TXT22225 025 122[Лучшие попытки]\nВходные данные\nВо входном файле INPUT.TXT в первой строке задано натуральное число N – количество жильцов (N ≤ 100). В последующих N строках располагается информация о всех жильцах: каждая строка содержит два целых числа: V и S – возраст и пол человека (1 ≤ V ≤ 100, S – 0 или 1). Мужскому полу соответствует значение S=1, а женскому – S=0.\nВыходные данные\nВыходной файл OUTPUT.TXT должен содержать номер самого старшего мужчины в списке. Если таких жильцов несколько, то следует вывести наименьший номер. Если жильцов мужского пола нет, то выведите -1.",
    "complexity": 15,
    "memory": 16000,
    "time": 1000,
    "examples": [
      {
        "input": "4\n25 1\n70 1\n100 0\n3 1",
        "output": "2"
      },
      {
        "input": "2\n25 0\n25 1",
        "output": "2"
      }
    ]
  },
  {
    "id": 135,
    "name": "Алгоритм Флойда",
    "description": "Полный ориентированный взвешенный граф задан матрицей смежности. Постройте матрицу кратчайших путей между его вершинами. Гарантируется, что в графе нет циклов отрицательного веса.\nOUTPUT.TXT0 5 7 13 \n12 0 2 8\n11 16 0 7\n4 9 11 0 \n[Лучшие попытки]\nВходные данные\nВ первой строке входного файла INPUT.TXT записано единственное число N (1 ≤ N ≤ 100) - количество вершин графа. В следующих N строках по N чисел - матрица смежности графа (j-ое число в i-ой строке соответствует весу ребра из вершины i в вершину j). Все числа по модулю не превышают 100. На главной диагонали матрицы - всегда нули.\nВыходные данные\nВ выходной файл OUTPUT.TXT выведите N строк по N чисел - матрицу кратчайших расстояний между парами вершин. j-ое число в i-ой строке должно быть равно весу кратчайшего пути из вершины i в вершину j.",
    "complexity": 36,
    "memory": 16000,
    "time": 1000,
    "examples": [
      {
        "input": "4\n\n0 5 9 100\n\n100 0 2 8\n\n100 100 0 7\n\n4 100 100 0",
        "output": "0 5 7 13\n \n12 0 2 8\n\n11 16 0 7\n\n4 9 11 0"
      }
    ]
  },
  {
    "id": 188,
    "name": "День рождения",
    "description": "Иван Иванович пригласил на свой день рождения много гостей. Он написал на карточках фамилии всех гостей и разложил эти карточки на столе, полагая, что каждый гость сядет там, где обнаружит карточку со своей фамилией (фамилии у всех гостей различны). Однако гости не обратили внимания на карточки и сели за стол в произвольном порядке. При этом Иван Иванович с удивлением обнаружил, что ни один гость не сел на предназначенное ему место.\nOUTPUT.TXT0221144895014631192902121[Лучшие попытки]\nТребуется написать программу, которая найдет сколькими способами можно рассадить гостей так, чтобы ни один из них не сидел там, где лежала карточка с его фамилией.\n3544\nВходные данные420895014631192902121\nВо входном файле INPUT.TXT задано целое число N – количество гостей (1 ≤ N ≤ 100).\nВыходные данные\nВыходной файл OUTPUT.TXT должен содержать одно целое число – количество способов рассадить гостей.",
    "complexity": 65,
    "memory": 16000,
    "time": 1000,
    "examples": [
      {
        "input": "1",
        "output": "0"
      },
      {
        "input": "2",
        "output": "1"
      },
      {
        "input": "5",
        "output": "44"
      },
      {
        "input": "20",
        "output": "895014631192902121"
      }
    ]
  },
  {
    "id": 130,
    "name": "Два коня",
    "description": "На стандартной шахматной доске (8х8) живут 2 шахматных коня: красный и зеленый. Обычно они беззаботно скачут по просторам доски, пощипывая шахматную травку, но сегодня особенный день: у зеленого коня день рождения. зеленый конь решил отпраздновать это событие вместе с красным. Но для осуществления этого прекрасного плана им нужно оказаться на одной клетке. Заметим, что красный и зеленый шахматные кони сильно отличаются от черного с белым: они ходят не по очереди, а одновременно, и если оказываются на одной клетке, никто никого не съедает. Сколько ходов им потребуется, чтобы насладиться праздником?\nOUTPUT.TXT1[Лучшие попытки]\nВходные данные\nВо входном файле INPUT.TXT содержатся координаты коней, записанные по стандартным шахматным правилам (т.е. двумя символами - маленькая английская буква (от a до h) и цифра (от 1 до 8), задающие столбец и строку соответственно).\nВыходные данные\nВыходной файл OUTPUT.TXT должен содержать наименьшее необходимое количество ходов, либо -1, если кони не могут встретиться.",
    "complexity": 55,
    "memory": 16000,
    "time": 1000,
    "examples": [
      {
        "input": "a1 a3",
        "output": "1"
      }
    ]
  },
  {
    "id": 168,
    "name": "Натуральный ряд чисел",
    "description": "Натуральные числа записаны в строку без каких-либо разделителей. Начало этой строки имеет вид 123456789101112131415161718192021… .\nOUTPUT.TXT42101101073[Лучшие попытки]\nТребуется написать программу, которая определит первое вхождение десятичной записи заданного числа N в этой строке.\n314273\nВходные данные\nВходной файл INPUT.TXT содержит заданное число N (1 ≤ N ≤ 104).\nВыходные данные\nВыходной файл OUTPUT.TXT должен содержать одно число – позицию, начиная с которой в строке записано первое вхождение заданного числа. Нумерация позиций начинается с единицы.",
    "complexity": 23,
    "memory": 16000,
    "time": 1000,
    "examples": [
      {
        "input": "45",
        "output": "4"
      },
      {
        "input": "101",
        "output": "10"
      },
      {
        "input": "142",
        "output": "73"
      }
    ]
  },
  {
    "id": 169,
    "name": "Магазин",
    "description": "На расстоянии N шагов от магазина стоит человек. Каждую минуту он выбирает, куда сделать шаг: к магазину или в противоположном направлении.\nOUTPUT.TXT225 511[Лучшие попытки]\nТребуется написать программу, которая определит, сколькими способами он может попасть в магазин, пройдя ровно K шагов и оказавшись в магазине только после выполнения последнего шага.\nВходные данные\nВходной файл INPUT.TXT содержит два числа N и K, записанные через пробел. Известно, что 1 ≤ N ≤ K ≤ 37.\nВыходные данные\nВыходной файл OUTPUT.TXT должен содержать одно число – количество способов попадания в магазин.",
    "complexity": 34,
    "memory": 16000,
    "time": 1000,
    "examples": [
      {
        "input": "2 4",
        "output": "2"
      },
      {
        "input": "5 5",
        "output": "1"
      }
    ]
  },
  {
    "id": 170,
    "name": "Разложение числа",
    "description": "Любое натуральное число можно представить в виде суммы нескольких последовательных натуральных чисел. Например, число 25 можно представить в виде суммы из одного (25), двух (12+13) или пяти (3+4+5+6+7) чисел.\nOUTPUT.TXT125225[Лучшие попытки]\nТребуется написать программу, которая определит максимальное количество чисел в таком разложении.\n3255\nВходные данные\nВходной  файл INPUT.TXT содержит одно натуральное число N (1 ≤ N ≤ 109).\nВыходные данные\nВыходной файл OUTPUT.TXT должен содержать одно натуральное число – максимальное количество чисел в разложении числа N на сумму последовательных натуральных чисел.",
    "complexity": 35,
    "memory": 16000,
    "time": 1000,
    "examples": [
      {
        "input": "2",
        "output": "1"
      },
      {
        "input": "5",
        "output": "2"
      },
      {
        "input": "25",
        "output": "5"
      }
    ]
  },
  {
    "id": 133,
    "name": "Заправки",
    "description": "В стране N городов, некоторые из которых соединены между собой дорогами. Для того, чтобы проехать по одной дороге требуется один бак бензина. В каждом городе бак бензина имеет разную стоимость. Вам требуется добраться из первого города в N-ый, потратив как можно меньшее количество денег.\nOUTPUT.TXT3[Лучшие попытки]\nВходные данные\nВо входном файле INPUT.TXT записано сначала число N (1 ≤ N ≤ 100), затем идет N чисел, i-ое из которых задает стоимость бензина в i-ом городе (все числа целые из диапазона от 0 до 100). Далее идет число M - количество дорог в стране, далее идет описание самих дорог. Каждая дорога задается двумя числами - номерами городов, которые она соединяет. Все дороги двухсторонние (то есть по ним можно ездить как в одну, так и в другую сторону); между двумя городами всегда существует не более одной дороги; не существует дорог, ведущих из города в себя.\nВыходные данные\nВ выходной файл OUTPUT.TXT выведите одно число - суммарную стоимость маршрута или -1, если добраться невозможно.",
    "complexity": 49,
    "memory": 16000,
    "time": 1000,
    "examples": [
      {
        "input": "4\n\n1 10 2 15\n\n4\n\n1 2\n\n1 3\n\n4 2\n\n4 3",
        "output": "3"
      }
    ]
  },
  {
    "id": 95,
    "name": "Нумеролог",
    "description": "Чтобы предсказать судьбу человека, нумеролог берет время жизни человека в секундах, затем складывает все цифры этого числа. Если полученное число состоит более чем из одной цифры, операция повторяется, пока в числе не останется одна цифра. Затем по полученной цифре и числу операций, необходимых для преобразования числа в цифру нумеролог предсказывает судьбу человека. Нумеролог плохо умеет считать, а числа, с которыми он работает, могут быть очень большими. Напишите программу, которая бы делала все расчеты за него.\nOUTPUT.TXT1 02101 11 19 2[Лучшие попытки]\nВходные данные3999 2\nВходной файл INPUT.TXT содержит число N – время жизни человека в секундах (1 ≤ N ≤ 101000).\nВыходные данные\nВ выходной файл  OUTPUT.TXT выведите два числа через пробел: полученную цифру из числа N и число преобразований.",
    "complexity": 24,
    "memory": 16000,
    "time": 1000,
    "examples": [
      {
        "input": "1",
        "output": "1 0"
      },
      {
        "input": "10",
        "output": "1 1"
      },
      {
        "input": "99",
        "output": "9 2"
      }
    ]
  },
  {
    "id": 94,
    "name": "Принц и дракон",
    "description": "Волшебник Мерлин продает волшебные мечи принцам, желающим убить дракона. Основная характеристика меча – число драконьих голов, которые он срубает за удар. Основная характеристика дракона – число голов, которые он может отрастить за сеанс регенерации. Бои принцев с драконами всегда протекают одинаково – принц атакует, и прячется за щитом; дракон атакует огненным дыханием и регенерирует; так продолжается до тех пор, пока после очередного удара у дракона не кончатся головы. Ясно, впрочем, что не каждым мечом можно победить каждого дракона. Заказ, поступающий Мерлину, всегда содержит число голов дракона и скорость его регенерации. Подсчитайте по известной атакующей силе меча, сможет ли принц убить такого дракона таким мечом и, если да, то сколько ударов потребуется.\nOUTPUT.TXT424 4 511NO[Лучшие попытки]\nВходные данные35 10 6NO[Решение]\nЕдинственная строка входного файла INPUT.TXT содержит число N – число голов, которые меч срубает одним ударом. Далее идет число M – число голов дракона. За ним идет K – число голов, которые дракон регенерирует за раз (1 ≤ N, M, K ≤ 105). Все числа разделены пробелом.\nВыходные данные\nВ выходной файл  OUTPUT.TXT выведите число ударов, которые необходимо нанести принцу, чтобы убить дракона, если это возможно. Если таким мечом убить дракона нельзя, то следует вывести «NO».",
    "complexity": 22,
    "memory": 16000,
    "time": 1000,
    "examples": [
      {
        "input": "3 6 2",
        "output": "4"
      },
      {
        "input": "4 4 5",
        "output": "1"
      },
      {
        "input": "5 10 6",
        "output": "NO"
      }
    ]
  },
  {
    "id": 172,
    "name": "Деление с остатком",
    "description": "Заданы два числа: N и K. Необходимо найти остаток от деления N на K.\nOUTPUT.TXT1524638746747645731289347483927 678478910017831001783[Лучшие попытки]\nВходные данные[Решение]\nВходной файл INPUT.TXT содержит два целых числа: N и K (1 ≤ N ≤ 10100, 1 ≤ K ≤ 109).\nВыходные данные\nВ выходной файл OUTPUT.TXT выведите остаток от деления N на K.",
    "complexity": 39,
    "memory": 16000,
    "time": 1000,
    "examples": [
      {
        "input": "239 16",
        "output": "15"
      },
      {
        "input": "4638746747645731289347483927 6784789",
        "output": "1001783"
      }
    ]
  },
  {
    "id": 171,
    "name": "Количество делителей",
    "description": "Пусть х — натуральное число. Назовем у его делителем, если 1 ≤ у ≤ х и остаток от деления х на у равен нулю.\nOUTPUT.TXT6223922[Лучшие попытки]\nЗадано число х. Найдите количество его делителей.\n[Решение]\nВходные данные\nВходной файл INPUT.TXT содержит заданное число x (1 ≤ x ≤ 1018). Все простые делители числа x не превосходят 1000.\nВыходные данные\nВ выходной файл OUTPUT.TXT выведите ответ на задачу.",
    "complexity": 50,
    "memory": 16000,
    "time": 1000,
    "examples": [
      {
        "input": "12",
        "output": "6"
      },
      {
        "input": "239",
        "output": "2"
      }
    ]
  },
  {
    "id": 96,
    "name": "Винни-пух",
    "description": "Винни-Пух стоит на прямоугольном поле размером N×M клеток. В каждой клетке растет по одной ягоде. В начальный момент времени он стоит на левой верхней клетке. Он  начинает собирать ягоды по верхнему краю поля. Если он доходит до края поля или до пустой клетки, он поворачивается на 90 градусов вправо и продолжает собирать ягоды. Но дойдя до очередной клетки Винни вспоминает, что его ждет Пятачок, и он уходит с поля.\nOUTPUT.TXT123 32 34418[Лучшие попытки]\nВходные данные35 52 318\nВ первой строке входного файла INPUT.TXT стоят размеры поляны N и M (0 \u003c N, M ≤ 100) – высота и ширина, во второй числа Y и X (0 \u003c Y ≤ N, 0 \u003c X ≤ M) –номера строки и столбца клетки, дойдя до которой Винни-Пух прекращает собирать ягоды.\nВыходные данные\nВ выходной файл  OUTPUT.TXT выведите число ягод, которые соберет Пух.",
    "complexity": 41,
    "memory": 16000,
    "time": 1000,
    "examples": [
      {
        "input": "1 1\n1 1",
        "output": "1"
      },
      {
        "input": "3 3\n2 3",
        "output": "4"
      },
      {
        "input": "5 5\n2 3",
        "output": "18"
      }
    ]
  },
  {
    "id": 97,
    "name": "Заповедники",
    "description": "В райской долине расположены N заповедников, имеющих форму прямоугольников. Однажды на собрании директоров было принято решение об увеличении площадей заповедников. Для этого директор каждого заповедника выбрал Ri - количество метров, на которое он хочет увеличить зону своего заповедника, смотрите рисунок. Однако после подписания соглашения выяснилось, что некоторые заповедники имеют общие земли. Такие заповедники было решено объединить в один, если объединенный заповедник пересекался с еще каким-нибудь заповедником их опять объединяли и так до тех пор пока не остались заповедник(и) не имеющие общих земель.\n2OUTPUT.TXT2[Лучшие попытки]\nВаша задача посчитать, сколько заповедников стало в долине после объединения.\n2\nВходные данные1\nПервая строка входного файла INPUT.TXT содержит число N (1 ≤ N ≤ 100) – количество заповедников. Далее идет N строк содержащих по пять целых чисел x1, y1, x2, y2, R. (x1, y1) и (x2, y2) – координаты противоположных вершин заповедника в метрах  (-104 ≤ x1, y1, x2, y2 ≤ 104 ).  Стороны заповедников параллельны осям координат. Заповедники, имеющие общую границу, считаются пересекающимися. R (0 ≤ R ≤ 104) – расстояние на которое отодвигается граница заповедника.\n1\n2Выходные данные\n2\nВ выходной файл OUTPUT.TXT выведите одно натуральное число – количество оставшихся заповедников после объединения.\n4Пример\n1\n№INPUT.TXTOUTPUT.TXT\n133 1 6 4 11 -2 2 -3 1-2 -2 -1 -3 22\n1\n2Для отправки решения задачи необходимо зарегистрироваться и авторизоваться!\n2\n\n  [Обсуждение]\n\n  [Все попытки]\n\n  [Лучшие попытки]\n4\n4\n\n\n\nwindow.yaContextCb.push(()=\u003e{\n  Ya.Context.AdvManager.render({\n    renderTo: 'yandex_rtb_R-A-122393-3',\n    blockId: 'R-A-122393-3'\n  })\n})",
    "complexity": 50,
    "memory": 16000,
    "time": 1000,
    "examples": [
      {
        "input": "3\n3 1 6 4 1\n1 -2 2 -3 1\n-2 -2 -1 -3 2",
        "output": "2"
      }
    ]
  },
  {
    "id": 176,
    "name": "Скобочки",
    "description": "Строка, состоящая из символов «(» и «)», называется скобочной последовательностью. Скобочная последовательность называется правильной, если она может быть получена из некоторого корректного арифметического выражения удалением всех символов, кроме скобок. Например, правильная скобочная последовательность «(())()» может быть получена из выражения «(2-(3+4)*6)*(1+1)». \nOUTPUT.TXT3237 23203685956218528203685956218528[Лучшие попытки]\nГлубиной правильной скобочной последовательности называется максимальная разность между количеством открывающихся и закрывающихся скобок в префиксе последовательности (префиксом строки S называется строка, которую можно получить из S удалением некоторого количества последних символов, например, префиксами строки «ABCAB» являются строки «», «A», «AB», «ABC», «ABCA» и «ABCAB»). Например, глубина последовательности «()()(())» равна двум, т.к. префикс «()()((» имеет 4 открывающиеся и 2 закрывающиеся скобки.\nТребуется написать программу, определяющую по заданным значениям N и K количество правильных скобочных последовательностей с N открывающимися скобками, которые имеют глубину, равную K.\nВходные данные\nВходной файл INPUT.TXT содержит в одной строке целые числа N и K (1 ≤ K ≤ N ≤ 50), разделенные пробелом.\nВыходные данные\nВыходной файл OUTPUT.TXT должен содержать одно число — количество правильных скобочных последовательностей с n открывающимися скобками, которые имеют глубину k.",
    "complexity": 69,
    "memory": 16000,
    "time": 1000,
    "examples": [
      {
        "input": "3 2",
        "output": "3"
      },
      {
        "input": "37 23",
        "output": "203685956218528"
      }
    ]
  },
  {
    "id": 174,
    "name": "Свадьба",
    "description": "Одна предприимчивая и очень симпатичная дамочка с прелестнейшим именем Горгона решила заработать себе денег на роскошную жизнь. N молодых людей так влюблены в нее, что предложили руку и сердце. К несчастью для них, Горгона видит в них только мешок с деньгами. Она планирует выйти замуж и почти сразу же развестись с некоторыми из молодых людей ради денежной выгоды. Все, что ей нужно, это подзаработать как можно больше денег (и уж, конечно, остаться незамужней). По законам этой прекрасной страны при разводе каждый из супругов получает половину всего имущества.\nOUTPUT.TXT7.500000231 3 202.1250002.125000[Лучшие попытки]\nВы планируете опубликовать статью, в которой опишете всю подлость и меркантильность этой особы. Для того чтобы статья получилась особенно красочной, нужно указать максимальную сумму денег, которую сможет получить Горгона.\nВходные данные\nВ первой строке входного файла INPUT.TXT записано целое число N — количество молодых людей, без памяти влюбленных в Горгону (1 \u003c N ≤ 40). Далее следует N чисел — сумма денег на счету каждого молодого человека. В последней строке записано целое число А — сумма денег на счету Горгоны. Суммы денег на счету — целые неотрицательные числа, не превосходящие 109.\nВыходные данные\nВ выходной файл OUTPUT.TXT выведите единственное число — максимальную сумму денег, которой сможет обладать Горгона после своей махинации. Ответ выводите в формате с фиксированной точкой с ровно шестью знаками после десятичной точки.",
    "complexity": 32,
    "memory": 16000,
    "time": 1000,
    "examples": [
      {
        "input": "2\n5 10\n5",
        "output": "7.500000"
      },
      {
        "input": "3\n1 3 2\n0",
        "output": "2.125000"
      }
    ]
  },
  {
    "id": 173,
    "name": "Число - палиндром",
    "description": "Напомним, что палиндромом называется строка, одинаково читающаяся с обеих сторон. Например, строка «ABBA» является палиндромом, а строка «ABC» - нет.\n36OUTPUT.TXTunique62111multiple6 10 36multiple6 10 36none[Лучшие попытки]\nНеобходимо определить, в каких системах счисления с основанием от 2 до 36 представление заданного числа N является палиндромом.\n103102892748none\nВ системах счисления с основанием большим 10 в качестве цифр используются буквы английского алфавита: A, B, ... , Z. Например, A11 = 1010, Z36 = 3510.\nВходные данные\nВходной файл INPUT.TXT содержит заданное число N в десятичной системе счисления (1 ≤ N ≤ 109).\nВыходные данные\nЕсли соответствующее основание системы счисления определяется единственным образом, то выведите в первой строке выходного файла OUTPUT.TXT слово «unique», если оно не единственно — выведите в первой строке выходного файла слово «multiple». Если же такого основания системы счисления не существует — выведите в первой строке выходного файла слово «none».\nВ случае существования хотя бы одного требуемого основания системы счисления выведите через пробел в возрастающем порядке во второй строке выходного файла все основания системы счисления, удовлетворяющие требованиям.",
    "complexity": 29,
    "memory": 16000,
    "time": 1000,
    "examples": [
      {
        "input": "123",
        "output": "unique\n6"
      },
      {
        "input": "111",
        "output": "multiple\n6 10 36"
      },
      {
        "input": "102892748",
        "output": "none"
      }
    ]
  },
  {
    "id": 178,
    "name": "Преобразование последовательности",
    "description": "Задана последовательность, содержащая n целых чисел. Необходимо найти число, которое встречается в этой последовательности наибольшее количество раз, а если таких чисел несколько, то найти минимальное из них, и после этого переместить все такие числа в конец заданной последовательности. Порядок расположения остальных чисел должен остаться без изменения.\nOUTPUT.TXT1 3 3 1 2 2 2[Лучшие попытки]\nНапример, последовательность 1, 2, 3, 2, 3, 1, 2 после преобразования должна превратиться в последовательность 1, 3, 3, 1, 2, 2, 2.\nТребуется написать программу, которая решает данную задачу.\nВходные данные\nПервая строка входного файла INPUT.TXT содержит число n — количество чисел во входной последовательности (1 ≤ n ≤ 200000). Следующая строка содержит входную последовательность, состоящую из n целых чисел, не превышающих по модулю 106. Все числа в строке разделены пробелом.\nВыходные данные\nВ выходной файл OUTPUT.TXT выводится последовательность чисел, которая получается в результате названного преобразования. Все числа в последовательности должны быть разделены пробелом.",
    "complexity": 35,
    "memory": 64000,
    "time": 1000,
    "examples": [
      {
        "input": "7\n1 2 3 2 3 1 2",
        "output": "1 3 3 1 2 2 2"
      }
    ]
  },
  {
    "id": 179,
    "name": "Последовательность",
    "description": "Рассмотрим числовую последовательность, первоначально состоящую из двух единиц: 1, 1. Далее на каждом последующем шаге будем вставлять между соседними элементами их сумму. В примере добавляемые элементы выделены:\n11, 2, 15OUTPUT.TXT282105905059050[Лучшие попытки]\nНомер шагаПоследовательность\n01, 1\n11, 2, 1\n21, 3, 2, 3, 1\n31, 4, 3, 5, 2, 5, 3, 4, 1\n21, 3, 2, 3, 14\n31, 4, 3, 5, 2, 5, 3, 4, 1\nТребуется написать программу, которая подсчитает сумму членов последовательности, построенной за K шагов.\nВходные данные\nВходной файл INPUT.TXT содержит одно натуральное число K (0 ≤ K ≤ 100) – номер последнего шага.\nВыходные данные\nВыходной файл OUTPUT.TXT должен содержать одно натуральное число – сумму элементов последовательности, построенной за K шагов.",
    "complexity": 47,
    "memory": 16000,
    "time": 1000,
    "examples": [
      {
        "input": "1, 1",
        "output": ""
      },
      {
        "input": "1, 2, 1",
        "output": ""
      },
      {
        "input": "1, 3, 2, 3, 1",
        "output": ""
      },
      {
        "input": "1, 4, 3, 5, 2, 5, 3, 4, 1",
        "output": ""
      },
      {
        "input": "3",
        "output": "28"
      },
      {
        "input": "10",
        "output": "59050"
      }
    ]
  },
  {
    "id": 175,
    "name": "Наручные часы",
    "description": "Вы приобрели новые электронные наручные часы с жидкокристаллическим дисплеем. Дисплей отображает часы и минуты с помощью четырех элементов, каждый из которых отображает одну цифру. \nOUTPUT.TXT1200202:3910411041[Лучшие попытки]\nТри из них состоят из семи полосок, каждая из которых может быть либо белой (неотличимой от фона), либо черной. Вид такого элемента и отображаемые им цифры показаны на рисунке:\nЧетвертый элемент предназначен для отображения старшей цифры часа. Если она равна нулю, то элемент полностью неактивен (все полоски белые), иначе показывается соответствующая цифра. Вот как выглядит этот элемент с цифрами:\nВам хочется проверить: все ли в порядке с новым приобретением, а именно, нет ли таких полосок в каком-либо из элементов, которые либо всегда белые, либо всегда черные. Вы хотите начать проверку в некоторое начальное время. Требуется определить, сколько Вам потребуется минут для убеждения в исправности часов.\nВходные данные\nВ первой строке входного файла INPUT.TXT находится время начала проверки в формате HH:MM. Часы и минуты записаны с лидирующими нулями, если таковые имеются. (00 ≤ HH ≤ 23, 00 ≤ MM ≤ 59).\nВыходные данные\nВ выходной файл OUTPUT.TXT выведите минимальное число минут, необходимое для проверки Ваших часов, если она началась в заданное время.",
    "complexity": 37,
    "memory": 16000,
    "time": 1000,
    "examples": [
      {
        "input": "00:00",
        "output": "1200"
      },
      {
        "input": "02:39",
        "output": "1041"
      }
    ]
  },
  {
    "id": 177,
    "name": "Склад",
    "description": "На роботизированном складе имеется n отсеков, в которые робот может размещать грузы. Отсек с номером i имеет вместимость ci. Груз с номером i имеет размер si, поступает на склад в момент времени ai и забирается со склада в момент времени di. Вместимость отсека и размер груза имеют одну и ту же размерность. Если в отсеке с вместимостью c находится несколько грузов с суммарным размером d, то свободное место в этом отсеке равно c – d.\ni9take cargo X from cell Y - взять груз с номером X из отсека с номером Y.OUTPUT.TXT\nput cargo 1 to cell 1\ntake cargo 1 from cell 1\n23 53 2 101 1 63 2 89 3 52 4 912 7 10\nput cargo 1 to cell 2\nput cargo 2 to cell 1\nput cargo 3 to cell 3\nmove cargo 1 from cell 2 to cell 3\nput cargo 4 to cell 2\ntake cargo 3 from cell 3\ntake cargo 1 from cell 3\ncargo 5 cannot be stored\ntake cargo 2 from cell 1\ntake cargo 4 from cell 2\n\nput cargo 1 to cell 2\nput cargo 2 to cell 1\nput cargo 3 to cell 3\nmove cargo 1 from cell 2 to cell 3\nput cargo 4 to cell 2\ntake cargo 3 from cell 3\ntake cargo 1 from cell 3\ncargo 5 cannot be stored\ntake cargo 2 from cell 1\ntake cargo 4 from cell 2\n[Лучшие попытки]\ni\nКогда груз с номером i поступает на склад, робот сначала пытается найти отсек, в котором достаточно свободного места для размещения этого груза. Если отсеков, в которых достаточно свободного места, несколько, то робот помещает груз в тот из них, в котором свободного места меньше. Если и таких отсеков несколько, то робот выбирает отсек с минимальным номером.\nicargo X cannot be stored - груз X невозможно переместить\nЕсли отсеков с достаточным количеством свободного места нет, робот пытается переместить грузы, уже расположенные в отсеках. Для этого он пытается найти такой отсек и такой груз в нем, что перемещение его в другой отсек обеспечивает достаточное количество свободного места для размещения поступившего груза. Если таких вариантов перемещения грузов несколько, то выбирается тот вариант, в котором потребуется перемещение груза с минимальным размером. Если и таких вариантов несколько, то выбирается вариант перемещения, при котором в отсеке, из которого перемещается груз, свободное место после перемещения этого груза будет минимально, а при прочих равных условиях — тот вариант, при котором в отсеке, куда осуществляется перемещение, свободное место после этого перемещения будет также минимально. Если и после этого остается более одного варианта, то выбирается тот вариант, при котором номер перемещаемого груза минимален и номер отсека, в который он перемещается, – также минимален. Если варианта с перемещением одного груза найти не удалось, то груз не принимается на склад.\ni\nТребуется написать программу, которая по списку грузов, поступающих для размещения на складе, выводит последовательность действий, выполняемых роботом.\ni\nВходные данныеi\nПервая строка входного файла содержит два целых числа: n — количество отсеков, и m — количество грузов (1 ≤ n ≤ 10, 1 ≤ m ≤100). Вторая строка содержит n целых чисел ci, определяющих вместимости отсеков (1 ≤ ci ≤ 109). Последующие m строк описывают грузы: каждый груз описывается тремя целыми числами: своим размером si, временем поступления на склад ai и временем, когда его забирают со склада di (1 ≤ si ≤ 109, 1 ≤ ai \u003c di ≤ 1000, все времена во входном файле различны, грузы упорядочены по возрастанию времени поступления на склад). Все числа в строках разделены пробелом.\n9\niВыходные данные\ni\nВыведите последовательность действий робота в том порядке, в котором они выполняются. Следуйте формату выходного файла, приведенного в примере. Возможны следующие сообщения:\nput cargo X to cell Y - разместить груз с номером X в отсеке с номером Y;\nmove cargo X from cell Y to cell Z - переместить груз с номером X из отсека с номером Y в отсек с номером Z;\ntake cargo X from cell Y - взять груз с номером X из отсека с номером Y.\ncargo X cannot be stored - груз X невозможно переместить",
    "complexity": 58,
    "memory": 16000,
    "time": 1000,
    "examples": [
      {
        "input": "1 1\n3\n3 1 2",
        "output": "put cargo 1 to cell 1\n\ntake cargo 1 from cell 1"
      },
      {
        "input": "3 5\n3 2 10\n1 1 6\n3 2 8\n9 3 5\n2 4 9\n12 7 10",
        "output": "put cargo 1 to cell 2\n\nput cargo 2 to cell 1\n\nput cargo 3 to cell 3\n\nmove cargo 1 from cell 2 to cell 3\n\nput cargo 4 to cell 2\n\ntake cargo 3 from cell 3\n\ntake cargo 1 from cell 3\n\ncargo 5 cannot be stored\n\ntake cargo 2 from cell 1\n\ntake cargo 4 from cell 2"
      }
    ]
  },
  {
    "id": 132,
    "name": "Алгоритм Дейкстры",
    "description": "Дан ориентированный взвешенный граф. Для него вам необходимо найти кратчайшее расстояние от вершины S до вершины F.\nOUTPUT.TXT3[Лучшие попытки]\nВходные данные\nВ первой строке входного файла INPUT.TXT записаны три числа: N, S и F \n(1 ≤ N ≤ 100; 1 ≤ S, F ≤ N), где N - количество вершин графа. В следующих N строках записаны по N чисел - матрица смежности графа, где число в i-ой строке \nj-ом столбце соответствует ребру из i в j: -1 означает отсутствие ребра между вершинами, а любое неотрицательное целое число (от 0 до 100) - наличие ребра данного веса. На главной диагонали матрицы всегда записаны нули.\nВыходные данные\nВ выходной файл OUTPUT.TXT необходимо вывести искомое расстояние или -1, если пути между указанными вершинами не существует.",
    "complexity": 47,
    "memory": 16000,
    "time": 1000,
    "examples": [
      {
        "input": "3 2 1\n\n0 1 1\n\n4 0 1\n\n2 1 0",
        "output": "3"
      }
    ]
  },
  {
    "id": 180,
    "name": "Счастливая страница",
    "description": "В новом выпуске Большой Галактической Энциклопедии N страниц. Петя считает страницу счастливой, если произведение цифр, входящих в ее номер, равно K. Например, если N=100, то для K=42 есть счастливая страница (например, с номером 76), а для K=128 счастливой страницы нет.\nOUTPUT.TXTYES2100 128NONO[Лучшие попытки]\nТребуется написать программу, которая поможет Пете определить, есть ли счастливые страницы в новом выпуске энциклопедии.\nВходные данные\nВходной текстовый файл INPUT.TXT содержит числа N (1 ≤ N ≤ 109) и K (1 ≤ K ≤ 109), записанные через пробел.\nВыходные данные\nВыходной текстовый файл OUTPUT.TXT должен содержать «YES», если счастливые страницы есть, и «NO» иначе.",
    "complexity": 46,
    "memory": 16000,
    "time": 1000,
    "examples": [
      {
        "input": "100 42",
        "output": "YES"
      },
      {
        "input": "100 128",
        "output": "NO"
      }
    ]
  },
  {
    "id": 145,
    "name": "A div B",
    "description": "Даны два целых числа A и B. Требуется найти их целую часть от их частного.\nOUTPUT.TXT2[Лучшие попытки]\nВходные данные[Решение]\nВо входном файле INPUT.TXT записаны целые числа A и B по одному в строке (0 ≤ A ≤ 10100, 0 \u003c B ≤ 10000).\nВыходные данные\nВ выходной файл OUTPUT.TXT выведите единственное число без лидирующих нулей: A div B.",
    "complexity": 40,
    "memory": 16000,
    "time": 1000,
    "examples": [
      {
        "input": "7\n3",
        "output": "2"
      }
    ]
  },
  {
    "id": 181,
    "name": "Космический мусорщик",
    "description": "Выходные данные\nВыведите в выходной файл OUTPUT.TXT единственное число - количество перемещений, которое совершит ловушка. Гарантируется, что ответ не превышает 109.",
    "complexity": 42,
    "memory": 16000,
    "time": 1000,
    "examples": [
      {
        "input": "N",
        "output": ""
      },
      {
        "input": "NUSDDUSE",
        "output": ""
      },
      {
        "input": "UEWWD",
        "output": ""
      },
      {
        "input": "U",
        "output": ""
      },
      {
        "input": "WED",
        "output": ""
      },
      {
        "input": "N\n\nNUSDDUSE\n\nUEWWD\n\n\n\nU\n\nWED\n\nS 3",
        "output": "34"
      }
    ]
  },
  {
    "id": 155,
    "name": "Конденсаторы",
    "description": "",
    "complexity": 59,
    "memory": 16000,
    "time": 1000,
    "examples": [
      {
        "input": "3 1.66\n1 2 1",
        "output": "YES"
      }
    ]
  },
  {
    "id": 161,
    "name": "Восстановление перестановки",
    "description": "Перестановкой из N элементов называется упорядоченный набор из N различных чисел от 1 до N. \nOUTPUT.TXT2 3 1[Лучшие попытки]\nПусть дана перестановка π. Обозначим φ[i] - количество таких j, что π[j] \u003e π[i], а j \u003c i. φ называется таблицей инверсий перестановки π.\nТребуется по данной таблице инверсий восстановить перестановку.\nВходные данные\nВ первой строке входного файла INPUT.TXT записано число 0 \u003c N ≤ 2000 - порядок перестановки. Во второй строке записана таблица инверсий.\nВыходные данные\nВ выходной файл OUTPUT.TXT выведите искомую перестановку.",
    "complexity": 44,
    "memory": 16000,
    "time": 1000,
    "examples": [
      {
        "input": "3\n0 0 2",
        "output": "2 3 1"
      }
    ]
  },
  {
    "id": 146,
    "name": "Длинный корень",
    "description": "По заданному натуральному числу А требуется найти наибольшее число В такое, что B2 ≤ A.\nOUTPUT.TXT4[Лучшие попытки]\nВходные данные[Решение]\nВо входном файле INPUT.TXT записано натуральное число A (A ≤ 103000).\nВыходные данные\nВ выходной файл OUTPUT.TXT выведите максимальное натуральное число B, квадрат которого не превосходит A. Число B следует выводить без лидирующих нулей.",
    "complexity": 67,
    "memory": 16000,
    "time": 1000,
    "examples": [
      {
        "input": "17",
        "output": "4"
      }
    ]
  },
  {
    "id": 158,
    "name": "Великий комбинатор",
    "description": "В результате очередной хитроумной комбинации у Остапа Бендера и его компаньонов - K детей лейтенанта Шмидта оказалось X рублей пятирублевыми банкнотами. И вот дело, как водится, дошло до дележа...\nOUTPUT.TXT10[Лучшие попытки]\nШура Балаганов предложил \"по справедливости\", т.е. всем поровну. Паниковский порешил себе отдать половину, а остальным \"по заслугам\". Каждый из K детей лейтенанта предложил что-нибудь интересное. Однако, у Великого Комбинатора имелось свое мнение на этот счет...\n[Решение]\nВаша же задача состоит в нахождении количества способов разделить имеющиеся деньги между всеми участниками этих славных событий: K детьми лейтенанта Шмидта и Остапом Бендером.\nВходные данные\nВо входном файле INPUT.TXT записаны целые числа X (0 ≤ X ≤ 500) и \nK (0 ≤ K ≤ 100). Естественно, что число X делится на 5. Да и при дележе рвать пятирублевые банкноты не разрешается.\nВыходные данные\nВ выходной файл OUTPUT.TXT выведите одно целое число - количество способов дележа.",
    "complexity": 60,
    "memory": 16000,
    "time": 1000,
    "examples": [
      {
        "input": "15 2",
        "output": "10"
      }
    ]
  },
  {
    "id": 40,
    "name": "2^N",
    "description": "Необходимо вычислить значение 2n. \nOUTPUT.TXT8210102410244722366482869645213696[Лучшие попытки]\nВходные данные3724722366482869645213696\nВ единственной строке входного файла INPUT.TXT записано натуральное число n (0 \u003c n \u003c 1000).\nВыходные данные\nВ единственную строку выходного файла OUTPUT.TXT нужно вывести значение 2n.",
    "complexity": 30,
    "memory": 16000,
    "time": 1000,
    "examples": [
      {
        "input": "3",
        "output": "8"
      },
      {
        "input": "10",
        "output": "1024"
      },
      {
        "input": "72",
        "output": "4722366482869645213696"
      }
    ]
  },
  {
    "id": 156,
    "name": "Шахматы - 2",
    "description": "Требуется найти число способов расставить на шахматной доске N×N K ладей так, чтобы они не били друг друга. Все ладьи считаются одинаковыми. \nOUTPUT.TXT40320[Лучшие попытки]\nВходные данные\nВо входном файле INPUT.TXT записаны натуральные числа N и K (N, K ≤ 8).\nВыходные данные\nВ выходной файл OUTPUT.TXT выведите одно целое число – ответ на задачу.",
    "complexity": 46,
    "memory": 16000,
    "time": 1000,
    "examples": [
      {
        "input": "8 8",
        "output": "40320"
      }
    ]
  },
  {
    "id": 159,
    "name": "Обратная перестановка",
    "description": "По заданной перестановке требуется определить обратную.  \n-1OUTPUT.TXT3 1 2[Лучшие попытки]\nПерестановкой из N элементов называется упорядоченный набор из N различных чисел от 1 до N. Количество различных перестановок порядка N равно PN = N!\n-1\nПусть у нас есть упорядоченное множество из N элементов. Перестановка задает преобразование этого множества. А именно, она говорит, что на i место нужно поставить ai элемент множества, где ai - i-тый элемент перестановки. \n-1\nОбратной перестановкой к перестановке π называется такая перестановка π-1, что ππ-1 = π-1π = ε, где ε – тождественная перестановка. То есть если применить сначала перестановку π, а потом обратную к ней π-1, то в итоге получится такой результат, как если бы мы эти перестановки не применяли вообще. Такой же результат получится, если сначала применить обратную перестановку π-1, а потом прямую π.\n-1\nВходные данные\nВ первой строке входного файла INPUT.TXT записано число 0 \u003c N ≤ 20000 - порядок перестановки. Во второй строке записана сама перестановка.\nВыходные данные\nВ выходной файл OUTPUT.TXT выведите обратную перестановку.",
    "complexity": 25,
    "memory": 16000,
    "time": 1000,
    "examples": [
      {
        "input": "3\n2 3 1",
        "output": "3 1 2"
      }
    ]
  },
  {
    "id": 160,
    "name": "Степень перестановки",
    "description": "Требуется вычислить степень заданной перестановки.  \nOUTPUT.TXT3[Лучшие попытки]\nПерестановкой из N элементов называется упорядоченный набор из N различных чисел от 1 до N. Количество различных перестановок порядка N равно PN = N!\nПусть у нас есть упорядоченное множество из N элементов. Перестановка задает преобразование этого множества. А именно, она говорит, что на i место нужно поставить ai элемент множества, где ai - i-тый элемент перестановки.\nТождественной перестановкой ε называется такая перестановка, которая не меняет порядок элементов\nмножества.\nСтепенью перестановки π называется минимальное натуральное число k такое, что πk = ε, то есть\nперестановка π, применённая k раз, эквивалентна тождественной перестановке.\nВходные данные\nВ первой строке входного файла INPUT.TXT записано число 0 \u003c N ≤ 100 - порядок перестановки. Во второй строке записана сама перестановка.\nВыходные данные\nВ выходной файл OUTPUT.TXT выведите степень данной перестановки. Гарантируется, что ответ не превышает 109.",
    "complexity": 46,
    "memory": 16000,
    "time": 1000,
    "examples": [
      {
        "input": "3\n\n2 3 1",
        "output": "3"
      }
    ]
  },
  {
    "id": 157,
    "name": "Карточки",
    "description": "На день рождения Пете подарили набор карточек с буквами. Теперь Петя с большим интересом составляет из них разные слова. И вот, однажды, составив очередное слово, Петя заинтересовался вопросом: \"А сколько различных слов можно составить из тех же карточек, что и данное?\". \nOUTPUT.TXT12[Лучшие попытки]\nПомогите ему ответить на этот вопрос.\nВходные данные\nВо входном файле INPUT.TXT задано слово, составленное Петей - строка из маленьких английских букв не длиннее 15 символов.\nВыходные данные\nВ выходной файл OUTPUT.TXT выведите одно целое число - ответ на поставленную задачу.",
    "complexity": 38,
    "memory": 16000,
    "time": 1000,
    "examples": [
      {
        "input": "solo",
        "output": "12"
      }
    ]
  },
  {
    "id": 147,
    "name": "Числа Фибоначчи",
    "description": "",
    "complexity": 16,
    "memory": 16000,
    "time": 1000,
    "examples": [
      {
        "input": "7",
        "output": "13"
      }
    ]
  },
  {
    "id": 149,
    "name": "Разворот",
    "description": "Дано натуральное число N и последовательность из N элементов. Требуется вывести эту последовательность в обратном порядке.\nOUTPUT.TXT3 2 1[Лучшие попытки]\nВходные данные[Решение]\nВ первой строке входного файла INPUT.TXT записано натуральное число N (N ≤ 103). Во второй строке через пробел идут N целых чисел, по модулю не превосходящих 103 - элементы последовательности.\nВыходные данные\nВ выходной файл OUTPUT.TXT выведите заданную последовательность в обратном порядке.",
    "complexity": 9,
    "memory": 16000,
    "time": 1000,
    "examples": [
      {
        "input": "3\n1 2 3",
        "output": "3 2 1"
      }
    ]
  },
  {
    "id": 150,
    "name": "Друзья",
    "description": "В клубе N человек. Многие из них - друзья. Так же известно, что друзья друзей так же являются друзьями. Требуется выяснить, сколько всего друзей у конкретного человека в клубе.\nOUTPUT.TXT2[Лучшие попытки]\nВходные данные[Решение]\nВ первой строке входного файла INPUT.TXT заданы два числа: N и S (1 ≤ N ≤ 100; 1 ≤ S ≤ N), где N - количество человек в клубе, а S – номер конкретного человека. В следующих N строках записано по N чисел - матрица смежности, состоящая из единиц и нулей. Причем единица, стоящая в i-й строке и j-м столбце гарантирует, что люди с номерами i и j – друзья, а 0 – выражает неопределенность.\nВыходные данные\nВ выходной файл OUTPUT.TXT выведите количество гарантированных друзей у человека с номером S, помня о транзитивности дружбы.",
    "complexity": 41,
    "memory": 16000,
    "time": 1000,
    "examples": [
      {
        "input": "3 1\n\n0 1 0\n\n1 0 1\n\n0 1 0",
        "output": "2"
      }
    ]
  },
  {
    "id": 213,
    "name": "Подсчет баллов",
    "description": "Решение каждой задачи заочного тура проверяется на наборе заранее заготовленных тестов. По результатам работы программы на каждом тесте участнику либо начисляются баллы за этот тест (когда программа выдала правильный ответ), либо не начисляются (когда во время работы программы произошли ошибки или выданный ответ не верен). Тесты могут иметь разную стоимость.\nOUTPUT.TXT0\n13\n13\n[Лучшие попытки]\nДополнительные баллы начисляются участнику, если его программа прошла все тесты.\nУчастник может исправлять свое решение, и посылать его на проверку повторно (при этом решение проверяется на том же наборе тестов). При этом за каждую попытку из количества набранных по задаче баллов вычитается штраф, который равен 0 при 1-й попытке, а при каждой следующей возрастает на 2 (то есть 2 при второй, 4 — при третьей, 6 — при четвертой и т.д.).\nИз баллов, полученных участником за каждую из попыток (с учетом начисленных штрафов), выбирается максимальный результат, который и засчитывается как результат данного участника по этой задаче. Это нужно, в частности, для того, чтобы последующие попытки не ухудшали уже полученный участником результат по задаче.\nНапример, если участник делает первую попытку и набирает 10 баллов, его результат по задаче равен 10 баллов. Пусть на второй попытке участник посылает решение, которое набирает 8 баллов. С учетом штрафа за эту попытку участник имеет 6 баллов, однако результат команды по задаче остается равным 10. Пусть с 3-й попытки решение набрало 20 баллов, тогда (с учетом штрафа) результат участника по задаче становится равен 16 баллам. Наконец, пусть с 4-й попытки решение проходит все тесты, тогда участник получает сумму баллов за все тесты, плюс призовые баллы за прохождение всех тестов, минус 6 баллов штрафа (если, конечно, эта величина не меньше 16 баллов, которые уже были у данного участника).\nНапишите программу, которая определяет результат данного участника по этой задаче.\nВходные данные\nВо входном файле INPUT.TXT записано сначала число N — количество тестов, на которых проверяются решения данной задачи (1 ≤ N ≤ 100). Далее идет N натуральных чисел, не превышающих 100, — баллы, которые начисляются за прохождение каждого из тестов. Далее идет целое число из диапазона от 0 до 100 — количество баллов, которое дополнительно начисляется за прохождение всех тестов.\nДалее идет натуральное число M — количество попыток сдачи задачи (1 ≤ M ≤ 100). После чего идет M наборов по N чисел в каждом, задающих результаты проверки каждой из M попыток сдачи задачи на тестах. 0 обозначает, что соответствующий тест не пройден, 1 — пройден.\nРазбиение чисел на строки в тестах задачи соответствует разбиению чисел на строки в примере.\nВыходные данные\nВ выходной файл OUTPUT.TXT выведите M чисел. i-ое число должно соответствовать результату участника после совершения им первых i попыток.",
    "complexity": 27,
    "memory": 16000,
    "time": 1000,
    "examples": [
      {
        "input": "4\n\n1 2 3 4\n\n5\n\n3\n\n0 0 0 0\n\n1 1 1 1\n\n0 1 0 1",
        "output": "0\n\n13\n\n13"
      }
    ]
  },
  {
    "id": 191,
    "name": "Гладкие числа",
    "description": "Назовем число гладким, если его цифры, начиная со старшего разряда, образуют неубывающую последовательность. Упорядочим все такие числа в возрастающем порядке и присвоим каждому номер. \nOUTPUT.TXT121112121135[Лучшие попытки]\nВам требуется по номеру N вывести N-ое гладкое число.\n3239 1135\nВходные данные\nВо входном файле INPUT.TXT содержится номер N (1 ≤ N ≤ 2147483647).\nВыходные данные\nВыходной файл OUTPUT.TXT должен содержать искомое N-е гладкое число.",
    "complexity": 60,
    "memory": 16000,
    "time": 1000,
    "examples": [
      {
        "input": "1",
        "output": "1"
      },
      {
        "input": "11",
        "output": "12"
      },
      {
        "input": "239",
        "output": "1135"
      }
    ]
  },
  {
    "id": 190,
    "name": "По размещению!",
    "description": "Перестановкой из N элементов называется упорядоченный набор из N различных чисел от 1 до N.\nOUTPUT.TXT626 41 3 2 51414[Лучшие попытки]\nРазмещением порядка K называют подмножество элементов некоторой перестановки порядка N. Например, (1, 3) – размещение порядка 2 для перестановки (1, 2, 3) порядка 3.\nТребуется по заданному размещению определить его позицию в лексикографическом порядке всех возможных размещений, образованных из всевозможных перестановок порядка N.\nНапример, лексикографическая последовательность всевозможных размещений для K=2 и N=3 выглядит следующим образом:\n(1,2), (1,3), (2,1), (2,3), (3,1), (3,2)\nТаким образом, перемещение (2,3) имеет номер 4 в этой последовательности.\nВходные данные\nВ первой строке входного файла INPUT.TXT находятся числа N и K (1 ≤ K ≤ N ≤ 12). Во второй строке записаны K чисел из диапазона от 1 до N - размещение.\nВыходные данные\nВ выходной файл OUTPUT.TXT выведите единственное число - номер данного размещения.",
    "complexity": 56,
    "memory": 16000,
    "time": 1000,
    "examples": [
      {
        "input": "3 2\n3 2",
        "output": "6"
      },
      {
        "input": "6 4\n1 3 2 5",
        "output": "14"
      }
    ]
  },
  {
    "id": 148,
    "name": "НОД",
    "description": "Даны два натуральных числа A и B. Требуется найти их наибольший общий делитель (НОД).\nOUTPUT.TXT6[Лучшие попытки]\nВходные данные[Решение]\nВо входном файле INPUT.TXT в единственной строке записаны натуральные числа A и B через пробел (A, B ≤ 109).\nВыходные данные\nВ выходной файл OUTPUT.TXT выведите НОД чисел А и В.",
    "complexity": 15,
    "memory": 16000,
    "time": 1000,
    "examples": [
      {
        "input": "12 42",
        "output": "6"
      }
    ]
  },
  {
    "id": 189,
    "name": "Перестановка по номеру",
    "description": "Перестановкой из N элементов называется упорядоченный набор из N различных чисел от 1 до N. Количество всех перестановок порядка N равно PN = N!\nOUTPUT.TXT12321 3 21 3 2[Лучшие попытки]\nТребуется найти перестановку по ее номеру в лексикографическом порядке (по алфавиту). Например, для N=3 лексикографический порядок перестановок выглядит следующим образом:\n(1,2,3), (1,3,2), (2,1,3), (2,3,1), (3,1,2), (3,2,1).\nТаким образом, перестановка (2,3,1) имеет номер 4 в этой последовательности.\nВходные данные\nВ первой строке входного файла INPUT.TXT записано число N (1 ≤ N ≤ 12) - количество элементов в перестановке, во второй - число K (1 ≤ K ≤ N!) - номер перестановки.\nВыходные данные\nВ выходной файл OUTPUT.TXT выведите через пробел N чисел - искомую перестановку.",
    "complexity": 47,
    "memory": 16000,
    "time": 1000,
    "examples": [
      {
        "input": "1\n1",
        "output": "1"
      },
      {
        "input": "3\n2",
        "output": "1 3 2"
      }
    ]
  },
  {
    "id": 192,
    "name": "Следующая перестановка ...",
    "description": "Перестановкой из N элементов называется упорядоченный набор из N различных чисел от 1 до N. \nOUTPUT.TXT1252 4 5 3 12 5 1 3 42 5 1 3 4[Лучшие попытки]\nНайдите по заданной перестановке следующую в лексикографическом порядке (будем считать, что за перестановкой (N, N-1, ... , 3, 2, 1) следует тождественная перестановка, то есть (1, 2, 3, ... , N)).\nВходные данные\nВ первой строке входного файла INPUT.TXT содержится число N (1 ≤ N ≤ 104). Во второй строке содержится перестановка (последовательность натуральных чисел от 1 до N, разделенных пробелами).\nВыходные данные\nВыходной файл OUTPUT.TXT должен содержать искомую перестановку.",
    "complexity": 46,
    "memory": 16000,
    "time": 1000,
    "examples": [
      {
        "input": "1\n1",
        "output": "1"
      },
      {
        "input": "5\n2 4 5 3 1",
        "output": "2 5 1 3 4"
      }
    ]
  },
  {
    "id": 152,
    "name": "Построение",
    "description": "Группа солдат-новобранцев прибыла в армейскую часть N666. После знакомства с прапорщиком стало очевидно, что от работ на кухне по очистке картофеля спасти солдат может только чудо.\nOUTPUT.TXTYes[Лучшие попытки]\nПрапорщик, будучи не в состоянии запомнить фамилии, пронумеровал новобранцев от 1 до N. После этого он велел им построиться по росту (начиная с самого высокого). С этой несложной задачей могут справиться даже совсем необученные новобранцы, да вот беда, прапорщик уверил себя, что знает про некоторых солдат, кто из них кого выше, и это далеко не всегда соответствует истине.\nПосле трех дней обучения новобранцам удалось выяснить, что знает (а точнее, думает, что знает) прапорщик. Помогите им, используя эти знания, построиться так, чтобы товарищ прапорщик остался доволен.\nВходные данные\nВо входном файле INPUT.TXT сначала идут числа N и M (1 ≤ N ≤ 100, 1 ≤ M ≤ 5000) - количество солдат в роте и количество пар солдат, про которых прапорщик знает, кто из них выше. Далее идут эти пары чисел A и B по одной на строке (1 ≤ A,B ≤ N), что означает, что, по мнению прапорщика, солдат A выше, чем B.\nВыходные данные\nВ выходной файл OUTPUT.TXT выведите \"Yes\" если можно построиться так, чтобы прапорщик остался доволен и \"No\" если нельзя.",
    "complexity": 46,
    "memory": 16000,
    "time": 1000,
    "examples": [
      {
        "input": "5 4\n\n1 3\n\n1 4\n\n4 3\n\n5 2",
        "output": "Yes"
      }
    ]
  },
  {
    "id": 193,
    "name": "Поиск прямоугольников",
    "description": "На поле N×M клеток (N строк и M столбцов) положили K прямоугольников один поверх другого в случайном порядке. Длины сторон прямоугольников выражаются целым числом клеток. Прямоугольники не выходят за границы поля. Границы прямоугольников совпадают с границами клеток поля.\nOUTPUT.TXT0 0 2 21 1 5 4[Лучшие попытки]\nПолучившуюся ситуацию записали в таблицу чисел (каждой клетке поля соответствует клетка таблицы). Если клетка поля не закрыта прямоугольником, то в соответствующую клетку таблицы записали число 0. Если же клетка закрыта одним или несколькими прямоугольниками, то в соответствующую клетку таблицы записали число, соответствующее номеру самого верхнего прямоугольника, закрывающего эту клетку.\nТребуется написать программу, которая определит положение и размеры прямоугольников. Гарантируется, что во входных данных содержится информация, которой достаточно для однозначного определения размеров прямоугольников.\nВходные данные\nВходной файл INPUT.TXT содержит в первой строке целые числа N, M, K (1 ≤ N ≤ 200, 1 ≤ M ≤ 200, 1 ≤ K ≤ 255). Далее следует N строк по M чисел в каждой — содержимое таблицы. Все числа в таблице целые, находятся в диапазоне от 0 до K включительно.\nВыходные данные\nВыходной файл OUTPUT.TXT должен содержать K строк. Каждая строка должна описывать соответствующий ее номеру прямоугольник четырьмя числами X1 Y1 X2 Y2 (X1 и Y1 должны описывать координаты левого нижнего угла прямоугольника, а X2 и Y2 — координаты правого верхнего угла). Числа должны разделяться пробелом.\nНачало координат расположено в левом нижнем углу таблицы. Таким образом, координаты левого нижнего угла поля — (0,0), правого верхнего — (M,N).",
    "complexity": 34,
    "memory": 16000,
    "time": 1000,
    "examples": [
      {
        "input": "4 5 2\n\n0 2 2 2 2\n\n0 2 2 2 2\n\n1 1 2 2 2\n\n1 1 0 0 0",
        "output": "0 0 2 2\n1 1 5 4"
      }
    ]
  },
  {
    "id": 151,
    "name": "Банкет",
    "description": "На банкет были приглашены N Очень Важных Персон (ОВП). Были поставлены 2 стола. Столы достаточно большие, чтобы все посетители банкета могли сесть за любой из них. Проблема заключается в том, что некоторые ОВП не ладят друг с другом и не могут сидеть за одним столом. Вас попросили определить, возможно ли всех ОВП рассадить за двумя столами.\nOUTPUT.TXTYES[Лучшие попытки]\nВходные данные\nВ первой строке входного файла INPUT.TXT дано два целых числа: N и M (0 ≤ N,M ≤ 100), где N - количество ОВП, а M - количество пар ОВП, которые не могут сидеть за одним столом. В следующих M строках записано по 2 числа - пары ОВП, которые не могут сидеть за одним столом.\nВыходные данные\nЕсли способ рассадить ОВП существует, то в выходной файл OUTPUT.TXT выведите YES и NO в противном случае.",
    "complexity": 44,
    "memory": 16000,
    "time": 1000,
    "examples": [
      {
        "input": "3 2\n1 2\n1 3",
        "output": "YES"
      }
    ]
  },
  {
    "id": 153,
    "name": "Монетки - 2",
    "description": "В волшебной стране используются монетки достоинством A1, A2,..., AM. волшебный человечек пришел в магазин и обнаружил, что у него есть ровно по две монетки каждого достоинства. Ему нужно заплатить сумму N. Напишите программу, определяющую, сможет ли он расплатиться без сдачи.\nM2OUTPUT.TXT327 21 2-1-10[Лучшие попытки]\nВходные данныеM35 23 40\nВо входном файле INPUT.TXT записано сначала число N (1 ≤ N ≤ 109), затем - число M (1 ≤ M ≤ 15) и далее M попарно различных чисел A1, A2,..., AM (1 ≤ Ai ≤ 109).\ni\n9Выходные данные\nВ выходной файл OUTPUT.TXT выведите количество монет, которое придется отдать волшебному человечку, если он сможет заплатить указанную сумму без сдачи. Если решений несколько, выведите вариант, в котором волшебный человек отдаст наименьшее возможное количество монет. Если без сдачи не обойтись, то выведите одно число 0. Если же у волшебного человечка не хватит денег, чтобы заплатить указанную сумму, выведите одно число -1 (минус один).",
    "complexity": 51,
    "memory": 16000,
    "time": 1000,
    "examples": [
      {
        "input": "5 2\n1 2",
        "output": "3"
      },
      {
        "input": "7 2\n1 2",
        "output": "-1"
      },
      {
        "input": "5 2\n3 4",
        "output": "0"
      }
    ]
  },
  {
    "id": 206,
    "name": "Домой на электричках",
    "description": "Одна из команд-участниц олимпиады решила вернуться домой на электричках. При этом ребята хотят попасть домой как можно раньше. К сожалению, не все электрички идут от города, где проводится олимпиада, до станции, на которой живут ребята. И, что еще более обидно, не все электрички, которые идут мимо их станции, останавливаются на ней (равно как вообще, электрички останавливаются далеко не на всех станциях, мимо которых они идут).\n9OUTPUT.TXT20[Лучшие попытки]\nВсе станции на линии пронумерованы числами от 1 до N. При этом станция номер 1 находится в городе, где проводится олимпиада, и в момент времени 0 ребята приходят на станцию. Станция, на которую нужно попасть ребятам, имеет номер E.\nНапишите программу, которая по данному расписанию движения электричек вычисляет минимальное время, когда ребята могут оказаться дома.\nВходные данные\nВо входном файле INPUT.TXT записаны сначала числа N (2 ≤ N ≤ 100) и E (2 ≤ E ≤ N). Затем записано число M (0 ≤ M ≤ 100), обозначающее число рейсов электричек. Далее идет описание M рейсов электричек. Описание каждого рейса электрички начинается с числа Ki (2 ≤ Ki ≤ N) — количества станций, на которых она останавливается, а далее следует Ki пар чисел, первое число каждой пары задает номер станции, второе — время, когда электричка останавливается на этой станции (время выражается целым числом из диапазона от 0 до 109). Станции внутри одного рейса упорядочены в порядке возрастания времени. В течение одного рейса электричка все время движется в одном направлении — либо от города, либо к городу.\nВыходные данные\nВ выходной файл OUTPUT.TXT выведите одно число — минимальное время, когда ребята смогут оказаться на своей станции. Если существующими рейсами электричек они добраться не смогут, выведите –1.",
    "complexity": 50,
    "memory": 16000,
    "time": 1000,
    "examples": [
      {
        "input": "5 3\n\n4\n\n2 1 5 2 10\n\n2 2 10 4 15\n\n4 5 0 4 17 3 20 2 35\n\n3 1 2 3 40 4 45",
        "output": "20"
      }
    ]
  },
  {
    "id": 154,
    "name": "Сумма кубов",
    "description": "Известно, что любое натуральное число можно представить в виде суммы не более чем четырех квадратов натуральных чисел. Вася решил придумать аналогичное утверждение для кубов - он хочет узнать, сколько кубов достаточно для представления любого числа. Его первая рабочая гипотеза - восемь.\nOUTPUT.TXT2 2 12239IMPOSSIBLEIMPOSSIBLE[Лучшие попытки]\nВыяснилось, что почти все числа, которые Вася смог придумать, представляются в виде суммы не более чем восьми кубов. Однако число 239, например, не допускает такого представления. Теперь Вася хочет найти какие-либо другие такие числа, а также, возможно, какую-либо закономерность в представлениях всех остальных чисел, чтобы выдвинуть гипотезу относительно вида всех чисел, которые не представляются в виде суммы восьми кубов.\nПомогите Васе написать программу, которая проверяла бы, возможно ли представить данное натуральное число в виде суммы не более чем восьми кубов натуральных чисел, и если это возможно, то находила бы какое-либо такое представление.\nВходные данные\nВо входном файле INPUT.TXT записано натуральное число N (1 ≤ N ≤ 2×109).\nВыходные данные\nВ выходной файл OUTPUT.TXT выведите не более восьми натуральных чисел в порядке невозрастания, кубы которых в сумме дают N. Если вариантов несколько, то выведите любой. Если искомого представления не существует, то в выходной файл необходимо вывести слово IMPOSSIBLE.",
    "complexity": 52,
    "memory": 16000,
    "time": 1000,
    "examples": [
      {
        "input": "17",
        "output": "2 2 1"
      },
      {
        "input": "239",
        "output": "IMPOSSIBLE"
      }
    ]
  },
  {
    "id": 205,
    "name": "Таймер",
    "description": "Таймер - это часы, которые умеют подавать звуковой сигнал по прошествии некоторого периода времени. Напишите программу, которая определяет, когда должен быть подан звуковой сигнал.\nOUTPUT.TXT01:01:01+2 days201:01:0158:11902:01:0002:01:0000:00:00+1 days[Лучшие попытки]\nВходные данные323:59:59100:00:00+1 days\nВ первой строке входного файла INPUT.TXT записано текущее время в формате ЧЧ:ММ:СС (с ведущими нулями). При этом оно удовлетворяет ограничениям: ЧЧ - от 00 до 23, ММ и СС - от 00 до 59.\nВо второй строке записан интервал времени, который должен быть измерен. Интервал записывается в формате Ч:М:С (где Ч, М и С - от 0 до 109, без ведущих нулей). Дополнительно если Ч=0 (или Ч=0 и М=0), то они могут быть опущены. Например, 100:60 на самом деле означает 100 минут 60 секунд, что то же самое, что 101:0 или 1:41:0. А 42 обозначает 42 секунды. 100:100:100 - 100 часов, 100 минут, 100 секунд, что то же самое, что 101:41:40.\nВыходные данные\nВ выходной файл OUTPUT.TXT выведите в формате ЧЧ:ММ:СС время, во сколько прозвучит звуковой сигнал. При этом если сигнал прозвучит не в текущие сутки, то дальше должна следовать запись +\u003cкол во\u003e days. Например, если сигнал прозвучит на следующий день – то +1 days.",
    "complexity": 31,
    "memory": 16000,
    "time": 1000,
    "examples": [
      {
        "input": "01:01:01\n48:0:0",
        "output": "01:01:01+2 days"
      },
      {
        "input": "01:01:01\n58:119",
        "output": "02:01:00"
      },
      {
        "input": "23:59:59\n1",
        "output": "00:00:00+1 days"
      }
    ]
  },
  {
    "id": 204,
    "name": "Циклическая строка",
    "description": "Строка S была записана много раз подряд, после чего из получившейся строки взяли подстроку и дали Вам. Ваша задача определить минимально возможную длину исходной строки S.\nOUTPUT.TXT2[Лучшие попытки]\nВходные данные\nВ единственной строке входного файла INPUT.TXT записана строка, которая содержит только английские буквы, длина строки не превышает 50000 символов.\nВыходные данные\nВ выходной файл OUTPUT.TXT нужно вывести одно число - ответ на задачу.",
    "complexity": 53,
    "memory": 16000,
    "time": 1000,
    "examples": [
      {
        "input": "abababa",
        "output": "2"
      }
    ]
  },
  {
    "id": 185,
    "name": "Скачки",
    "description": "Иван Иванович любит ходить на скачки, надеясь на них заработать кругленькую сумму. Ему приглянулась лошадь с номером K, и он решил проверить, сможет ли она выиграть у всех остальных лошадей. Иван Иванович раздобыл информацию, в которой для некоторых пар лошадей сообщается, какая из этих лошадей быстрее. Также он узнал, что у всех лошадей разные скорости.\nOUTPUT.TXTYes23 22 30NoNoNo[Лучшие попытки]\nТребуется написать программу, которая поможет Ивану Ивановичу точно определить может ли выиграть выбранная им лошадь.\n34 23 12 30No\nВходные данные\nВходной файл INPUT.TXT содержит в первой строке два целых числа N (1 ≤ N ≤ 100) и K (1 ≤ K ≤ N), где N – количество лошадей, принимающих участие в скачках, K – номер лошади, на которую хочет сделать ставку Иван Иванович. Следующие строки содержат по два числа X и Y (1 ≤ X, Y ≤ N), обозначающие, что лошадь с номером X быстрее лошади с номером Y. Пары X и Y не повторяются. Набор данных завершается строкой, содержащей единственный ноль. Эту строку обрабатывать не надо.\nГарантируется, что информация, раздобытая Иваном Ивановичем, корректна.\nВыходные данные\nВыходной файл OUTPUT.TXT должен содержать слово «Yes», если Иван Иванович уверен в своем выигрыше и «No» в противном случае.",
    "complexity": 32,
    "memory": 16000,
    "time": 1000,
    "examples": [
      {
        "input": "3 1\n1 2\n1 3\n0",
        "output": "Yes"
      },
      {
        "input": "3 2\n2 3\n0",
        "output": "No"
      },
      {
        "input": "4 2\n3 1\n2 3\n0",
        "output": "No"
      }
    ]
  },
  {
    "id": 182,
    "name": "Прямоугольник - 2",
    "description": "Заданы координаты трех вершин прямоугольника. Необходимо определить координаты четвертой вершины.\n2OUTPUT.TXT5 3 21 4 8 3 7 6 2 1 2 1 [Лучшие попытки]\nВходные данные2\nВо входном файле INPUT.TXT записаны через пробел координаты трех вершин прямоугольника в произвольном порядке в формате x1 y1 x2 y2 x3 y3. Все числа целые, не превосходящие 1000 по абсолютной величине.\n3\n3Выходные данные\nВ выходной файл OUTPUT.TXT нужно вывести через пробел координаты четвертой вершины прямоугольника.",
    "complexity": 27,
    "memory": 16000,
    "time": 1000,
    "examples": [
      {
        "input": "0 3 0 0 5 0",
        "output": "5 3"
      },
      {
        "input": "1 4 8 3 7 6",
        "output": "2 1"
      }
    ]
  },
  {
    "id": 184,
    "name": "Рабочее время",
    "description": "Иван Иванович – очень ответственный, но очень рассеянный человек. Поэтому когда он начинает очередное дело, он на отдельном листочке пишет дату и время начала (например, 29.01. 10:30), а когда заканчивает, то так же на отдельном листочке – дату и время окончания (например, 02.02. 12:15). Листочки аккуратно укладываются в стопку один на другой. А так как одновременно Иван Иванович может заниматься только одним делом, то листочки однозначно упорядочены в стопке: листок начала какого-то дела, листок окончания этого дела, листок начала,  листок окончания… и т.д. Дело начинается в начале минуты, указанной в листочке начала этого дела, а заканчивается в конце минуты, указанной на листочке окончания. Иван Иванович ходит на работу каждый день и его рабочий день продолжается с 10:00 до 18:00. Таким образом, пара листочков «18.11. 15:13» — «20.11. 10:27» была написана при начале и окончании дела длительностью 11ч.15м.\nOUTPUT.TXT103:02[Лучшие попытки]\nОднажды в конце декабря уборщица Дуся нечаянно уронила эту стопку на пол и, не зная важной закономерности их укладки, собрала листочки обратно в каком-то произвольном порядке. Иван Иванович обнаружил этот прискорбный факт только 31 декабря, когда ему надо было произвести учет своего рабочего времени за год. Год был невисокосный.\nПомогите Ивану Ивановичу найти его суммарные затраты времени за год.\nВходные данные\nВходной файл INPUT.TXT содержит в первой строке число листочков K, (K – четное число, не большее 5000). Далее записаны K строк с данными на листочках в формате DD.MM. hh:mm, где DD – число, MM – номер месяца, hh – часы и mm – минуты.\nВыходные данные\nВыходной файл OUTPUT.TXT должен содержать запись вида h:mm – количество часов и минут, отработанных Иваном Ивановичем. При этом число h ≥ 0 выводится без ведущих нулей, а число 0 ≤ mm ≤ 59 выводится с ведущими нулями.",
    "complexity": 35,
    "memory": 16000,
    "time": 1000,
    "examples": [
      {
        "input": "4\n\n15.01. 17:00\n\n16.01. 12:00\n\n11.02. 14:00\n\n30.01. 10:00",
        "output": "103:02"
      }
    ]
  },
  {
    "id": 183,
    "name": "Энты",
    "description": "Энты были созданы в Первоначальную эпоху вместе с другими обитателями Средиземья. Эльфийские легенды гласят, что когда Варда зажгла звёзды и пробудились Эльфы, вместе с ними пробудились и Энты в Великих Лесах Арды. \nOUTPUT.TXT2 28 10 5 5 179 [Лучшие попытки]\nКогда Энты пришли в Арду, они ещё не умели говорить — этому искусству их обучали Эльфы, и Энтам это ужасно нравилось. Им доставляло удовольствие изучать разные языки, даже щебетание Людей. \n3360 1000 179 [Решение]\nЭльфы выработали хорошую технику обучения энтов своему языку. Первый энт, которого обучили эльфы, выучил всего два слова — «tancave» (да) и «la» (нет). Обученный энт выбрал одного старого и одного молодого энта, не умеющих говорить, и обучил их всем словам, которые знал сам. Затем обучение этих двух энтов продолжили сами эльфы. Каждый обучившийся у эльфов энт снова выбирал из неговорящих сородичей одного старого и одного молодого, обучал их всем словам, которые знал, передавал эльфам и так далее.\nВыяснилось, что более молодые энты выучивали у эльфов ещё ровно столько же слов, сколько они узнали от обучавшего их энта. А вот более старые, уже склонные к одеревенению энты, пополняли свой запас всего лишь одним словом. После обучения у эльфов энты до конца света уже не могли выучить ни одного нового слова.\nОбщее число энтов в Средиземье больше, чем вы думаете. Интересно, а сколько из них знают ровно 150 квенийских слов? Похожую задачу вам предстоит решить.\nВходные данные\nВходной файл INPUT.TXT содержит натуральные числа K и P (K ≤ 106; 1 ≤ P ≤ 109), записанные через пробел.\nВыходные данные\nМы понимаем, что число энтов, знающих в точности K слов, может быть слишком велико, поэтому просим вывести в выходной файл OUTPUT.TXT лишь количество энтов, знающих ровно K слов, по модулю P.",
    "complexity": 39,
    "memory": 64000,
    "time": 1000,
    "examples": [
      {
        "input": "4 10",
        "output": "2"
      },
      {
        "input": "8 10",
        "output": "5"
      },
      {
        "input": "360 1000",
        "output": "179"
      }
    ]
  },
  {
    "id": 210,
    "name": "Степень",
    "description": "Для того чтобы проверить, как её ученики умеют считать, Мария Ивановна каждый год задаёт им на дом одну и ту же задачу – для заданного натурального A найти минимальное натуральное N такое, что N в степени N (N, умноженное на себя N раз) делится на A. От года к году меняется только число A.\nOUTPUT.TXT42131313[Лучшие попытки]\nВы решили помочь будущим поколениям. Для этого вам необходимо написать программу, решающую эту задачу.\nВходные данные\nВо входном файле INPUT.TXT содержится единственное число A (1 ≤ A ≤ 109 – на всякий случай, вдруг Мария Ивановна задаст большое число, чтобы «завалить» кого-нибудь…).\nВыходные данные\nВ выходной файл OUTPUT.TXT необходимо вывести единственное число N.",
    "complexity": 59,
    "memory": 16000,
    "time": 1000,
    "examples": [
      {
        "input": "8",
        "output": "4"
      },
      {
        "input": "13",
        "output": "13"
      }
    ]
  },
  {
    "id": 207,
    "name": "Клад",
    "description": "OUTPUT.TXT3.000 2.00021\n8 10\n-7.071 7.071-7.071 7.071[Лучшие попытки]\nНайти закопанный пиратами клад просто: всё, что для этого нужно – это карта. Как известно, пираты обычно рисуют карты от руки и описывают алгоритм действий. Большая часть таких действий просто сводится к прохождению какого-то количества шагов в одном из восьми направлений (1 – север, 2 – северо-восток, 3 – восток, 4 – юго-восток, 5 – юг, 6 – юго-запад, 7 – запад, 8 – северо-запад) (см. рис). Длина шага в любом направлении равна 1.\nПутешествие по такому пути обычно является прекрасным способом посмотреть окрестности, однако в наше время постоянной спешки ни у кого нет времени на это. Поэтому кладоискатели хотят идти напрямую в точку, где зарыт клад. Например, вместо того, чтобы проходить три шага на север, один шаг на восток, один шаг на север, три шага на восток, два шага на юг и один шаг на запад, можно пройти напрямую, использовав около 3.6 шага (см. рисунок).\nВам необходимо узнать точку, в которой находится клад согласно указаниям пиратов.\nВходные данные\nПервая строка входного файла INPUT.TXT содержит число N – число указаний (1≤N≤40). Последующие N строк содержат сами указания – номер направления (целое число от 1 до 8) и количество шагов (целое число от 1 до 1000). Числа разделены пробелами.\nВыходные данные\nВ выходной файл OUTPUT.TXT выведите координаты X и Y точки (два вещественных числа, разделённые пробелом), где зарыт клад, считая, что ось OX направлена на восток, а ось OY – на север. В начале кладоискатель должен стоять в начале координат. Координаты необходимо вывести с точностью 10-3.",
    "complexity": 28,
    "memory": 16000,
    "time": 1000,
    "examples": [
      {
        "input": "6\n\n1 3\n\n3 1\n\n1 1\n\n3 3\n\n5 2\n\n7 1",
        "output": "3.000 2.000"
      },
      {
        "input": "1\n\n8 10",
        "output": "-7.071 7.071"
      }
    ]
  },
  {
    "id": 209,
    "name": "Целые точки",
    "description": "Многоугольник (не обязательно выпуклый) на плоскости задан координатами своих вершин. Требуется подсчитать количество точек с целочисленными координатами, лежащих внутри него (но не на его границе).\niOUTPUT.TXT123\n0 0\n0 2\n2 0\n 00[Лучшие попытки]\nВходные данныеi\nВ первой строке входного файла INPUT.TXT содержится N (3≤N≤103) – число вершин многоугольника. В последующих N строках идут координаты (Xi, Yi) вершин многоугольника в порядке обхода по часовой стрелке. Xi и Yi - целые числа, по модулю не превосходящие 106.\ni\n6Выходные данные\nВаша программа должна вывести в выходной файл OUTPUT.TXT одно целое число - ответ на задачу.",
    "complexity": 64,
    "memory": 16000,
    "time": 1000,
    "examples": [
      {
        "input": "4\n\n-1 -1\n\n-1 1\n\n1 1\n\n1 -1",
        "output": "1"
      },
      {
        "input": "3\n\n0 0\n\n0 2\n\n2 0",
        "output": "0"
      }
    ]
  },
  {
    "id": 211,
    "name": "Игра с фишками",
    "description": "OUTPUT.TXT5\n6\n0\n[Лучшие попытки]\nВы являетесь одним из разработчиков новой компьютерной игры. Игра происходит на прямоугольной доске, состоящей из W×H клеток. Каждая клетка может либо содержать, либо не содержать фишку. Важной частью игры является проверка того, соединены ли две фишки путем, удовлетворяющим следующим свойствам:\nПуть должен состоять из отрезков вертикальных и горизонтальных прямых.\nПуть не должен пересекать других фишек.\nПри этом часть пути может оказаться вне доски. Например:\nФишки с координатами (1,3) и (4,4) могут быть соединены. Фишки с координатами (2,3) и (5,3) тоже могут быть соединены. А вот фишки с координатами (2,3) и (3,4) соединить нельзя – любой соединяющий их путь пересекает другие фишки.\nВам необходимо написать программу, проверяющую, можно ли соединить две фишки путем, обладающим вышеуказанными свойствами, и, в случае положительного ответа, определяющую минимальную длину такого пути (считается, что путь имеет изломы, начало и конец только в центрах клеток (или «мнимых клеток», расположенных вне доски), а отрезок, соединяющий центры двух соседних клеток, имеет длину 1).\nВходные данные\nПервая строка входного файла INPUT.TXT содержит два натуральных числа: W – ширина доски, H – высота доски (1≤W,H≤75). Следующие H строк содержат описание доски: каждая строка состоит ровно из W символов: символ «X» (заглавная английская буква «экс») обозначает фишку, символ «.» (точка) обозначает пустое место. Все остальные строки содержат описания запросов: каждый запрос состоит из четырёх натуральных чисел, разделённых пробелами – X1, Y1, X2, Y2, причём 1≤X1,X2≤W, 1≤Y1,Y2≤H. Здесь (X1, Y1) и (X2, Y2) – координаты фишек, которые требуется соединить (левая верхняя клетка имеет координаты (1,1)). Гарантируется, что эти координаты не будут совпадать (кроме последнего запроса; см. далее). Последняя строка содержит запрос, состоящий из четырёх чисел 0; этот запрос обрабатывать не надо. Количество запросов не превосходит 20.\nВыходные данные\nДля каждого запроса в выходной файл OUTPUT.TXT необходимо вывести одно целое число на отдельной строке – длину кратчайшего пути, или 0, если такого пути не существует.",
    "complexity": 45,
    "memory": 16000,
    "time": 1000,
    "examples": [
      {
        "input": "5 4\n\nXXXXX\n\nX...X\n\nXXX.X\n\n.XXX.\n\n2 3 5 3\n\n1 3 4 4\n\n2 3 3 4\n\n0 0 0 0",
        "output": "5\n\n6\n\n0"
      }
    ]
  },
  {
    "id": 208,
    "name": "Забавная игра",
    "description": "Выходные данные\nВаша программа должна вывести в выходной файл OUTPUT.TXT одно целое число, равное результату игры.",
    "complexity": 25,
    "memory": 16000,
    "time": 1000,
    "examples": [
      {
        "input": "19",
        "output": "28"
      },
      {
        "input": "1212",
        "output": "1938"
      }
    ]
  },
  {
    "id": 124,
    "name": "Светофорчики",
    "description": "В подземелье M тоннелей и N перекрестков, каждый тоннель соединяет какие-то два перекрестка. Мышиный король решил поставить по светофору в каждом тоннеле перед каждым перекрестком. Напишите программу, которая посчитает, сколько светофоров должно быть установлено на каждом из перекрестков. Перекрестки пронумерованы числами от 1 до N.\nOUTPUT.TXT3 3 2 2 5 2 3[Лучшие попытки]\nВходные данные\nВо входном файле INPUT.TXT записано два числа N и M (0 \u003c N ≤ 100, 0 ≤ M ≤ N*(N-1)/2). В следующих M строках записаны по два числа i и j (1 ≤ i,j ≤ N), которые означают, что перекрестки i и j соединены тоннелем. Можно считать, что любые два перекрестка соединены не более, чем одним тоннелем. Нет тоннелей от перекрестка i до него самого.\nВыходные данные\nВ выходной файл OUTPUT.TXT вывести N чисел: k-ое число означает количество светофоров на k-ом перекрестке.",
    "complexity": 25,
    "memory": 16000,
    "time": 1000,
    "examples": [
      {
        "input": "7 10\n\n5 1\n\n3 2\n\n7 1\n\n5 2\n\n7 4\n\n6 5\n\n6 4\n\n7 5\n\n2 1\n\n5 3",
        "output": "3 3 2 2 5 2 3"
      }
    ]
  },
  {
    "id": 212,
    "name": "Деревни",
    "description": "В тридесятом государстве есть N деревень. Некоторые пары деревень соединены дорогами. В целях экономии, «лишних» дорог нет, т.е. из любой деревни в любую можно добраться по дорогам единственным образом.\nOUTPUT.TXT1211 6\n1 2\n1 3\n1 4\n1 5\n2 6\n2 7\n2 8\n4 9\n4 10\n4 11\n22[Лучшие попытки]\nНовейшие исследования показали, что тридесятое государство находится в сейсмически опасной зоне. Поэтому глава государства захотел узнать, какой именно ущерб может принести его державе землетрясение. А именно, он хочет узнать, какое минимальное число дорог должно быть разрушено, чтобы образовалась изолированная от остальных группа ровно из P деревень такая, что из любой деревни из этой группы до любой другой деревни из этой группы по-прежнему можно будет добраться по неразрушенным дорогам (группа изолирована от остальных, если никакая неразрушенная дорога не соединяет деревню из этой группы с деревней не из этой группы).\nВы должны написать программу, помогающую ему в этом.\nВходные данные\nПервая строка входного файла INPUT.TXT содержит два числа: N и P (1 ≤ P ≤ N ≤ 150). Все остальные строки содержат описания дорог, по одному на строке: описание дороги состоит из двух номеров деревень (от 1 до N), которые эта дорога соединяет. Все числа во входном файле разделены пробелами и/или переводами строки.\nВыходные данные\nВ выходной файл OUTPUT.TXT выведите единственное число – искомое количество дорог.",
    "complexity": 79,
    "memory": 16000,
    "time": 1000,
    "examples": [
      {
        "input": "3 2\n\n1 2\n\n3 2",
        "output": "1"
      },
      {
        "input": "11 6\n\n1 2\n\n1 3\n\n1 4\n\n1 5\n\n2 6\n\n2 7\n\n2 8\n\n4 9\n\n4 10\n\n4 11",
        "output": "2"
      }
    ]
  },
  {
    "id": 214,
    "name": "Великая сеча",
    "description": "Алеша Попович и Добрыня Никитич сражаются со стаей двух- и трехголовых драконов. Они по очереди взмахивают мечами, и одним махом могут отрубить любое натуральное число голов (по своему желанию), но только у одного дракона. Отрубивший последнюю голову у последнего дракона получает в жены прекрасную принцессу. \nOUTPUT.TXT221 211[Лучшие попытки]\nКто из богатырей (начинающий или второй) может получить в жены принцессу независимо от действий другого?\nВходные данные\nВо входном файле INPUT.TXT записано два числа N и M — количество двух- и трехголовых драконов соответственно (оба числа целые из диапазона от 0 до 100, N+M\u003e0).\nВыходные данные\nВ выходной файл OUTPUT.TXT выведите число 1 или 2 определяющее, кто из богатырей имеет все шансы получить в жены принцессу (1 — тот, кто начинает, 2 — второй).",
    "complexity": 58,
    "memory": 16000,
    "time": 1000,
    "examples": [
      {
        "input": "2 2",
        "output": "2"
      },
      {
        "input": "1 2",
        "output": "1"
      }
    ]
  },
  {
    "id": 121,
    "name": "Гвоздики",
    "description": "На прямой дощечке вбиты гвоздики. Любые два гвоздика можно соединить ниточкой. Требуется соединить некоторые пары гвоздиков ниточками так, чтобы к каждому гвоздику была привязана хотя бы одна ниточка, а суммарная длина всех ниточек была минимальна.\nOUTPUT.TXT5[Лучшие попытки]\nВходные данные\nВ первой строке входного файла INPUT.TXT записано число N - количество гвоздиков (2 ≤ N ≤ 100). В следующей строке записано N чисел - координаты всех гвоздиков (неотрицательные целые числа, не превосходящие 10000).\nВыходные данные\nВ выходной файл OUTPUT.TXT нужно вывести единственное число - минимальную суммарную длину всех ниточек.",
    "complexity": 34,
    "memory": 16000,
    "time": 1000,
    "examples": [
      {
        "input": "6\n\n3 4 12 6 14 13",
        "output": "5"
      }
    ]
  },
  {
    "id": 253,
    "name": "Часы с боем",
    "description": "Старинные часы бьют каждые полчаса. Причем в начале каждого часа они бьют столько раз, сколько сейчас часов (по 1 разу – в час ночи и в час дня, по 2 раза – в два часа ночи в два часа дня и т.д., в полночь и в полдень они бьют, соответственно, по 12 раз). И еще 1 раз они бьют в середине каждого часа.\nOUTPUT.TXT45210 255 201351350[Лучшие попытки]\nДан промежуток времени (известно, что прошло строго меньше 24 часов). Напишите программу, определяющую, сколько ударов сделали часы за это время.\n35 25 210\nВходные данные\nВ первой строке входного файла INPUT.TXT записан начальный момент времени, во второй строке — конечный. Моменты времени задаются двумя целыми числами, разделяющимися пробелом. Первое число задает часы (от 0 до 23), второе — минуты (от 1 до 59, при этом оно не равно 30).\nВыходные данные\nВ выходной файл OUTPUT.TXT выведите одно число — сколько ударов сделали часы за этот отрезок времени.",
    "complexity": 25,
    "memory": 16000,
    "time": 1000,
    "examples": [
      {
        "input": "5 20\n10 25",
        "output": "45"
      },
      {
        "input": "10 25\n5 20",
        "output": "135"
      },
      {
        "input": "5 2\n5 21",
        "output": "0"
      }
    ]
  },
  {
    "id": 123,
    "name": "Восстановление скобок",
    "description": "Задан шаблон, состоящий из круглых скобок и знаков вопроса. Требуется определить, сколькими способами можно заменить знаки вопроса круглыми скобками так, чтобы получилось правильное скобочное выражение.\nOUTPUT.TXT2[Лучшие попытки]\nВходные данные\nЕдинственная строка входного файла  INPUT.TXT содержит заданный шаблон длиной от 1 до 80 символов.\nВыходные данные\nВыведите в выходной файл OUTPUT.TXT искомое количество способов. Исходные данные будут таковы, что это количество не превзойдет 2×109.",
    "complexity": 54,
    "memory": 16000,
    "time": 1000,
    "examples": [
      {
        "input": "????(?",
        "output": "2"
      }
    ]
  },
  {
    "id": 293,
    "name": "Налоги",
    "description": "В некотором государстве действует N фирм, конкурирующих между собой. У каждой фирмы есть некоторая прибыль в год, равная V[i] американских рублей.  У царя есть любимые фирмы, а есть нелюбимые. Соответственно, налог для всех фирм разный и назначается царем в индивидуальном порядке. Налог на i-ую фирму равен p[i] процентов.\nOUTPUT.TXT122\n1 2\n3 2\n223[Лучшие попытки]\nСобиратели статистики решили посчитать, с какой фирмы в государственную казну идет наибольший доход (в казну идут все налоги). К сожалению, они не учили в детстве ни математику, ни информатику (так что учитесь, дети!), и их задача резко осложняется.\n33\n100 1 50\n0 100 3\n3\nПомогите им в этой нелегкой задаче.\nВходные данные\nВо входном файле INPUT.TXT сначала записано число N - число фирм (0 \u003c N ≤ 100). Далее идет N целых неотрицательных чисел, не превышающих 154 - доходы фирм, а затем еще N целых чисел от 0 до 100 - налоги фирм в процентах.\nВыходные данные\nВ выходной файл OUTPUT.TXT выведите одно число - номер фирмы, от которой государство получает наибольший налог. Если таких фирм несколько, выведите фирму с наименьшим номером.",
    "complexity": 20,
    "memory": 16000,
    "time": 1000,
    "examples": [
      {
        "input": "1\n\n1\n\n1",
        "output": "1"
      },
      {
        "input": "2\n\n1 2\n\n3 2",
        "output": "2"
      },
      {
        "input": "3\n\n100 1 50\n\n0 100 3",
        "output": "3"
      }
    ]
  },
  {
    "id": 122,
    "name": "Максимальная подпоследовательность",
    "description": "Дана числовая последовательность, требуется найти длину наибольшей возрастающей подпоследовательности.\nOUTPUT.TXT3[Лучшие попытки]\nВходные данные\nВ первой строке входного файла INPUT.TXT записано число N - длина последовательности (1 ≤ N ≤ 1000). Во второй строке записана сама последовательность (через пробел). Числа последовательности - целые числа, не превосходящие 10000 по модулю.\nВыходные данные\nВ выходной файл OUTPUT.TXT требуется вывести наибольшую длину возрастающей подпоследовательности.",
    "complexity": 38,
    "memory": 16000,
    "time": 1000,
    "examples": [
      {
        "input": "6\n\n3 29 5 5 28 6",
        "output": "3"
      }
    ]
  },
  {
    "id": 254,
    "name": "Выборы жрецов",
    "description": "В стране Олимпиадии снова выборы.\nOUTPUT.TXT3 3 1 3 3 1 3[Лучшие попытки]\nСтрана состоит из маленьких графств. Графства объединяются в конфедерации. Каждая конфедерация раз в год выбирает себе покровителя – одного из 200 жрецов. Этот ритуал называется Великими Перевыборами Жрецов и выглядит так: конфедерации одновременно подают заявления (одно от конфедерации) в Совет Жрецов о том, кого они хотели бы видеть своим покровителем (если заявление не подано, то считают, что конфедерация хочет оставить себе того же покровителя). После этого все заявки удовлетворяются. Если несколько конфедераций выбирают одного и того же Жреца, то они навсегда объединяются в одну. Таким образом, каждый Жрец всегда является покровителем не более чем одной конфедерации. Требуется написать программу, позволяющую Совету Жрецов выяснить номер Жреца-покровителя каждого графства после Великих Перевыборов. В Совете все графства занумерованы (начиная с 1). Все Жрецы занумерованы числами от 1 до 200 (некоторые из них сейчас могут не быть ничьими покровителями).\nВходные данные\nВо входном файле INPUT.TXT записано число N – количество графств в стране (1 ≤ N ≤ 5000) – и далее для каждого графства записан номер Жреца-покровителя конфедерации, в которую оно входит (графства считаются по порядку их номеров). Затем указаны заявления от конфедераций. Сначала записано число M – количество поданных заявлений, а затем M пар чисел (1 ≤ M ≤ 200): первое число – номер текущего Жреца-покровителя, второе – номер желаемого Жреца-покровителя.\nВсе числа во входном файле разделяются пробелами и (или) символами перевода строки.\nВыходные данные\nВ выходной файл OUTPUT.TXT вывести для каждого графства одно число – номер его Жреца-покровителя после Великих Перевыборов. Сначала – для первого графства, затем – для второго и т.д.",
    "complexity": 28,
    "memory": 16000,
    "time": 1000,
    "examples": [
      {
        "input": "7\n\n1 1 5 3 1 5 1\n\n2\n\n5 1\n\n1 3",
        "output": "3 3 1 3 3 1 3"
      }
    ]
  },
  {
    "id": 186,
    "name": "Субботник",
    "description": "В этом году Иван Иванович решил отметить приход осени субботником, чтобы убрать весь мусор во дворе дома номер 31 по улице Осенней. На субботник он пригласил N знакомых старушек, живущих в том же самом доме. Однако, в самом начале мероприятия выяснилось, что по одиночке старушки работают плохо, так как им хочется во время работы еще и поговорить друг с другом.\nOUTPUT.TXT999999999231 2 3220102[Лучшие попытки]\nИван Иванович подумал и принял волевое решение разбить старушек на группы так, чтобы в каждой группе было не менее 2 старушек. Старушки отличаются друг от друга уровнем разговорчивости, и если в одну группу попадут две старушки, у одной из которых маленький уровень разговорчивости, а у второй - большой, то они не могут поговорить друг с другом и работа будет стопориться.\n381 10 100 1000 1000 100 10 10\nНазовем разговорчивостью группы разность между максимальным и минимальным уровнями разговорчивости старушек в группе. Например, если уровни разговорчивости старушек в группе равны 7, 3 и 11, то разговорчивость группы равна 11 - 3 = 8. Разговорчивостью разбиения старушек на группы назовем максимальную из разговорчивостей групп, входящих в разбиение. \n410258 740 156 244 458 680 390 694 844 817102\nТребуется написать программу, которая поможет Ивану Ивановичу найти разбиение старушек на группы, разговорчивость которого минимальна.\nВходные данные\nВходной файл INPUT.TXT содержит в первой строке число N (2 ≤ N ≤ 1000) – количество старушек. Во второй строке записано N чисел от 1 до 109 – разговорчивости старушек.\nВыходные данные\nВыходной текстовый файл OUTPUT.TXT должен содержать одно целое число, равное минимально возможной разговорчивости разбиения старушек на группы.",
    "complexity": 44,
    "memory": 16000,
    "time": 1000,
    "examples": [
      {
        "input": "2\n1 1000000000",
        "output": "999999999"
      },
      {
        "input": "3\n1 2 3",
        "output": "2"
      },
      {
        "input": "8\n1 10 100 1000 1000 100 10 1",
        "output": "0"
      },
      {
        "input": "10\n258 740 156 244 458 680 390 694 844 817",
        "output": "102"
      }
    ]
  },
  {
    "id": 216,
    "name": "Коллекционирование этикеток",
    "description": "Вася коллекционирует спичечные этикетки. Для этого у него есть N альбомов вместимостью K1, K2, …, KN этикеток. Вася хочет, чтобы в случае утери одного любого альбома каждая этикетка осталась у него хотя бы в одном экземпляре. Для этого он покупает каждую этикетку в двух экземплярах, и наклеивает их в два разных альбома. Какое максимальное количество различных этикеток при этом может оказаться в его коллекции? \nNNOUTPUT.TXT2[Лучшие попытки]\nВходные данные\nВходной файл INPUT.TXT содержит сначала число N — количество альбомов, а затем N чисел K1, K2, …, KN, задающих вместимости альбомов. N — натуральное число из диапазона от 2 до 1000. Вместимость каждого альбома задается натуральным числом, суммарная вместимость всех альбомов не превышает 100 000 этикеток.\nВыходные данные\nВ выходной файл OUTPUT.TXT выведите число E — максимальное количество различных этикеток, которое может собрать Вася с соблюдением выдвинутого условия.",
    "complexity": 41,
    "memory": 16000,
    "time": 1000,
    "examples": [
      {
        "input": "4\n1 2 1 1",
        "output": "2"
      }
    ]
  },
  {
    "id": 255,
    "name": "Представление чисел",
    "description": "Дано натуральное число N. Требуется представить его в виде суммы двух натуральных чисел A и B таких, что НОД (наибольший общий делитель) чисел A и B — максимален.\nOUTPUT.TXT5 102168 88 8[Лучшие попытки]\nВходные данные\nВо входном файле INPUT.TXT записано натуральное число N (2 ≤ N ≤ 109)\nВыходные данные\nВ выходной файл OUTPUT.TXT выведите два искомых числа A и B. Если решений несколько, выведите то из них, где A принимает наименьшее возможное значение.",
    "complexity": 40,
    "memory": 16000,
    "time": 1000,
    "examples": [
      {
        "input": "15",
        "output": "5 10"
      },
      {
        "input": "16",
        "output": "8 8"
      }
    ]
  },
  {
    "id": 234,
    "name": "Сапер",
    "description": "Мальчику Васе очень нравится известная игра \"Сапер\" (\"Minesweeper\"). \nOUTPUT.TXT.111..1*1\n13*2..111\n1**3.....\n13*2.111.\n.111.2*2.\n233335*41\n********1\n*6*7*8*41\n13*4***2.\n.1122321.\n[Лучшие попытки]\nВ \"Сапер\" играет один человек. Игра идет на клетчатом поле (далее будем называть его картой) N×M (N строк, M столбцов). В K клетках поля стоят мины, в остальных клетках записано либо число от 1 до 8 — количество мин в соседних клетках, либо ничего не написано, если в соседних клетках мин нет. Клетки являются соседними, если они имеют хотя бы одну общую точку, в одной клетке не может стоять более одной мины. Изначально все клетки поля закрыты. Игрок за один ход может открыть какую-нибудь клетку. Если в открытой им клетке оказывается мина — он проигрывает, иначе игроку показывается число, которое стоит в этой клетке, и игра продолжается. Цель игры — открыть все клетки, в которых нет мин.\nУ Васи на компьютере есть эта игра, но ему кажется, что все карты, которые в ней есть, некрасивые и неинтересные. Поэтому он решил нарисовать свои. Однако фантазия у него богатая, а времени мало, и он хочет успеть нарисовать как можно больше карт. Поэтому он просто выбирает N, M и K и расставляет мины на поле, после чего все остальные клетки могут быть однозначно определены. Однако на определение остальных клеток он не хочет тратить свое драгоценное время. Помогите ему!\nПо заданным N, M, K и координатам мин восстановите полную карту.\nВходные данные\nВ первой строке входного файла INPUT.TXT содержатся числа N, M и K (1 ≤ N ≤ 200, 1 ≤ M ≤ 200, 0 ≤ K ≤ N×M). Далее идут K строк, в каждой из которых содержится по два числа, задающих координаты мин. Первое число в каждой строке задает номер строки клетки, где находится мина, второе число — номер столбца. Левая верхняя клетка поля имеет координаты (1,1), правая нижняя — координаты (N,M).\nВыходные данные\nВыходной файл OUTPUT.TXT должен содержать N строк по M символов — соответствующие строки карты. j-й символ i-й строки должен содержать символ ‘*‘ (звездочка) если в клетке (i,j) стоит мина, цифру от 1 до 8, если в этой клетке стоит соответствующее число, либо ‘.‘ (точка), если клетка (i,j) пустая.",
    "complexity": 28,
    "memory": 16000,
    "time": 1000,
    "examples": [
      {
        "input": "10 9 23\n\n1 8\n\n2 3  \n3 2  \n3 3  \n4 3  \n5 7\n\n6 7  \n7 1  \n7 2  \n7 3  \n7 4  \n7 5\n\n7 6  \n7 7  \n7 8  \n8 1  \n8 3  \n8 5\n\n8 7  \n9 3  \n9 5  \n9 6  \n9 7",
        "output": ".111..1*1\n\n13*2..111\n\n1**3.....\n\n13*2.111.\n\n.111.2*2.\n\n233335*41\n\n********1\n\n*6*7*8*41\n\n13*4***2.\n\n.1122321."
      }
    ]
  },
  {
    "id": 187,
    "name": "Пчелка",
    "description": "Представьте себе пчелиные соты –  поле из шестиугольных клеток со стороной N. В верхней левой клетке A находится пчелка. За один ход она может переползти на клетку вниз, на клетку вниз-вправо или на клетку вверх-вправо (вверх и влево пчелка не ползает).\nOUTPUT.TXT1123291291[Лучшие попытки]\nТребуется написать программу, которая найдет количество способов, которыми пчелка может доползти из клетки A в противоположную клетку B.\nВходные данные\nВходной файл INPUT.TXT содержит единственное число N – размеры шестиугольного поля (2 ≤ N ≤ 12).\nВыходные данные\nВыходной файл OUTPUT.TXT должен содержать единственное целое число – количество способов.",
    "complexity": 53,
    "memory": 16000,
    "time": 1000,
    "examples": [
      {
        "input": "2",
        "output": "11"
      },
      {
        "input": "3",
        "output": "291"
      }
    ]
  },
  {
    "id": 217,
    "name": "Еловая аллея",
    "description": "Мэр города Урюпинска решил посадить на главной аллее города, которая проходит с запада на восток, голубые ели. Причем сажать ели можно не во всех местах, а только на специально оставленных при асфальтировании аллеи клумбах. \nOUTPUT.TXT2[Лучшие попытки]\nКак оказалось, голубые ели бывают M различных сортов. Для ели каждого сорта известна максимальная длина ее тени в течение дня в западном и в восточном направлении (Wi и Ei соответственно). При этом известно, что ели растут гораздо лучше, если в течение дня они не оказываются в тени других елей.\nКоординатная ось направлена вдоль аллеи с запада на восток.\nПо заданным координатам клумб вычислите максимальное число елей, которое можно посадить, соблюдая условие о том, что никакая ель не должна попадать в тень от другой ели.\nВходные данные\nВо входном файле INPUT.TXT записано сначала натуральное число M — количество сортов елей (1 ≤ M ≤ 100). Затем идет M пар чисел Wi, Ei, описывающих максимальную длину тени в западном и восточном направлении в течение дня для каждого сорта ели (числа Wi, Ei — целые, из диапазона от 0 до 30000). Далее идет натуральное число N — количество клумб, в которых можно сажать ели (1 ≤ N ≤ 100). Далее идет N чисел, задающих координаты клумб (координаты — целые числа, по модулю не превышающие 30000). Клумбы перечислены с запада на восток (в порядке возрастания их координат).\nПримечание\nЕсли на клумбе с координатой X мы посадили ель, максимальная тень которой в восточном направлении равна E, то все клумбы с координатами от X+1 до X+E–1 попадают в тень от этой ели, а клумба с координатами X+E — уже нет. Аналогично для тени в западном направлении.\nВыходные данные\nВ выходной файл OUTPUT.TXT выведите число A — максимальное количество елей, которые удастся посадить.",
    "complexity": 47,
    "memory": 16000,
    "time": 1000,
    "examples": [
      {
        "input": "3\n\n1000 3\n\n1 200\n\n128 256\n\n3\n\n1 2 4",
        "output": "2"
      }
    ]
  },
  {
    "id": 215,
    "name": "Водостоки",
    "description": "Карту местности условно разбили на квадраты, и посчитали среднюю высоту над уровнем моря для каждого квадрата. \nOUTPUT.TXT2[Лучшие попытки]\nКогда идет дождь, вода равномерно выпадает на все квадраты. Если один из четырех соседних с данным квадратом квадратов имеет меньшую высоту над уровнем моря, то вода с текущего квадрата стекает туда (и, если есть возможность, то дальше), если же все соседние квадраты имеют большую высоту, то вода скапливается в этом квадрате.\nРазрешается в некоторых квадратах построить водостоки. Когда на каком-то квадрате строят водосток, то вся вода, которая раньше скапливалась в этом квадрате, будет утекать в водосток.\nЕсли есть группа квадратов, имеющих одинаковую высоту и образующих связную область, то если хотя бы рядом с одним из этих квадратов есть квадрат, имеющий меньшую высоту, то вся вода утекает туда, если же такого квадрата нет, то вода стоит во всех этих квадратах. При этом достаточно построить водосток в любом из этих квадратов, и вся вода с них будет утекать в этот водосток.\nТребуется определить, какое минимальное количество водостоков нужно построить, чтобы после дождя вся вода утекала в водостоки.\nВходные данные\nВо входном файле INPUT.TXT записаны сначала числа N и M, задающие размеры карты — натуральные числа, не превышающие 100. Далее, идет N строк, по M чисел в каждой, задающих высоту квадратов карты над уровнем моря. Высота задается натуральным числом, не превышающим 10000. Считается, что квадраты, расположенные за пределами карты, имеют высоту 10001 (то есть вода никогда не утекает за пределы карты).\nВыходные данные\nВ выходной файл OUTPUT.TXT выведите минимальное количество водостоков, которое необходимо построить.",
    "complexity": 55,
    "memory": 16000,
    "time": 1000,
    "examples": [
      {
        "input": "4 5\n\n1 2 3 1 10\n\n1 4 3 10 10\n\n1 5 5 5 5\n\n6 6 6 6 6",
        "output": "2"
      }
    ]
  },
  {
    "id": 203,
    "name": "Сдвиг текста",
    "description": "Мальчик Кирилл написал однажды на листе бумаги строчку, состоящую из больших и маленьких английских букв, а после этого ушел играть в футбол. Когда он вернулся, то обнаружил, что его друг Дима написал под его строкой еще одну строчку такой же длины. Дима утверждает, что свою строчку он получил циклическим сдвигом строки Кирилла направо на несколько шагов (циклический сдвиг строки abcde на 2 позиции направо даст строку deabc). Однако Дима известен тем, что может случайно ошибиться в большом количестве вычислений, поэтому Кирилл в растерянности - верить ли Диме? Помогите ему!\nOUTPUT.TXT2[Лучшие попытки]\nПо данным строкам выведите минимально возможный размер сдвига вправо или -1, если Дима ошибся.\nВходные данные\nПервые две строки входного файла INPUT.TXT содержат строки Кирилла и Димы соответственно. Строки состоят только из английских символов. Длины строк одинаковы, не превышают 10000 и не равны 0.\nВыходные данные\nВ выходной файл OUTPUT.TXT выведите единственное число - ответ на поставленную задачу.",
    "complexity": 31,
    "memory": 16000,
    "time": 1000,
    "examples": [
      {
        "input": "abcde\ndeabc",
        "output": "2"
      }
    ]
  },
  {
    "id": 256,
    "name": "Гексагон",
    "description": "Поле для игры в новую игру \"Гексагон\" разбито на шестиугольники (см. рисунок). Игрок, стартуя из некоторого начального шестиугольника, сделал несколько ходов. Каждый ход заключается в перемещении фишки в соседний шестиугольник (имеющий с тем, где находилась фишка до начала хода, общую сторону) — тем самым, ход делается вдоль одного из направлений X, Y или Z (см. рисунок). Игрок записал все свои ходы, причем если фишка двигалась вдоль какого-либо направления несколько раз подряд, то в записи это обозначается указанием направления и количества ходов, которые были сделаны.\nOUTPUT.TXT4[Лучшие попытки]\nНапишите программу, которая найдет кратчайший (по количеству совершаемых ходов) путь в начальную клетку из той, где фишка оказалась после ходов игрока.\nВходные данные\nВ первой строке входного файла INPUT.TXT записано число N — количество строк в записи перемещений фишки (1 ≤ N ≤ 100). Далее идет N строк с записью ходов: в каждой строке записана сначала большая буква X, Y или Z, задающая направление, затем пробел, и число, задающее количество ходов в данном направлении (число может быть и отрицательным, если игрок перемещал фишку параллельно оси, но в направлении, противоположном направлению оси). Все числа по модулю не превышают 200.\nВыходные данные\nВ выходной файл OUTPUT.TXT выведите длину кратчайшего пути обратно в начальную клетку.",
    "complexity": 38,
    "memory": 16000,
    "time": 1000,
    "examples": [
      {
        "input": "4\nZ -2\nY 3\nZ 3\nX -1",
        "output": "4"
      }
    ]
  },
  {
    "id": 134,
    "name": "Автобусы",
    "description": "Между некоторыми деревнями края Власюки ходят автобусы. Поскольку пассажиропотоки здесь не очень большие, то автобусы ходят всего несколько раз в день.\nOUTPUT.TXT5[Лучшие попытки]\nМарии Ивановне требуется добраться из деревни d в деревню v как можно быстрее (считается, что в момент времени 0 она находится в деревне d).\nВходные данные\nВо входном файле INPUT.TXT записано число N - общее число деревень (1 ≤ N ≤ 100), номера деревень d и v, затем количество автобусных рейсов R (0 ≤ R ≤ 10000). Затем идут описания автобусных рейсов. Каждый рейс задается номером деревни отправления, временем отправления, деревней назначения и временем прибытия (все времена - целые от 0 до 10000). Если в момент t пассажир приезжает в деревню, то уехать из нее он может в любой момент времени, начиная с t.\nВыходные данные\nВ выходной файл OUTPUT.TXT вывести минимальное время, когда Мария Ивановна может оказаться в деревне v. Если она не сможет с помощью указанных автобусных рейсов добраться из d в v, вывести -1.",
    "complexity": 50,
    "memory": 16000,
    "time": 1000,
    "examples": [
      {
        "input": "3\n\n1 3\n\n4\n\n1 0 2 5\n\n1 1 2 3\n\n2 3 3 5\n\n1 1 3 10",
        "output": "5"
      }
    ]
  },
  {
    "id": 98,
    "name": "Игра в числа",
    "description": "Игра в числа ведётся на одномерном массиве целых положительных чисел. Перед началом, жеребьёвкой определяется, кто будет ходить первым (первый игрок), а кто – вторым (второй игрок). Процесс игры состоит в том, что игроки по очереди (сначала первый игрок, затем второй, следом опять первый и так далее) вычёркивают числа из массива. Вычеркнуть можно только число, находящееся в конце или начале оставшегося массива. При этом всегда вычёркивается максимальное число из этих двух. Если первое и последнее числа массива равны, то вычёркивается первое. Игра продолжается до того момента, пока не будут вычеркнуты все числа. Каждое вычеркнутое число идёт в актив тому игроку, который его вычеркнул. После окончания игры каждый игрок суммирует вычеркнутые им числа. Победителем объявляется тот, кто наберет больше очков. \nOUTPUT.TXT9:92112341234:01234:0[Лучшие попытки]\nНекоторые игроки поняли, что результат не зависит от стратегии игры, и решили попросить Вас написать программу для получения результата.\nВходные данные\nВ первой строке входного файла INPUT.TXT находится одно целое число N – количество чисел в массиве (1 ≤ N ≤ 104). Во второй строке находятся N целых положительных чисел из диапазона [1, 32000], разделённых пробелом.\nВыходные данные\nВ выходной файл OUTPUT.TXT выведите два числа, разделенные двоеточием. Первое число – количество очков, набираемых первым игроком при игре на этом массиве, второе число – для второго.",
    "complexity": 23,
    "memory": 16000,
    "time": 1000,
    "examples": [
      {
        "input": "5\n4 4 1 5 4",
        "output": "9:9"
      },
      {
        "input": "1\n1234",
        "output": "1234:0"
      }
    ]
  },
  {
    "id": 120,
    "name": "Минимальный путь в таблице",
    "description": "OUTPUT.TXT825 5\n1 1 1 1 1\n3 100 100 100 100\n1 1 1 1 1\n2 2 2 2 1\n1 1 1 1 1\n1111[Лучшие попытки]\nВ прямоугольной таблице N×M (в каждой клетке которой записано некоторое число) в начале игрок находится в левой верхней клетке. За один ход ему разрешается перемещаться в соседнюю клетку либо вправо, либо вниз (влево и вверх перемещаться запрещено). При проходе через клетку с игрока берут столько у.е., какое число записано в этой клетке (деньги берут также за первую и последнюю клетки его пути).\nТребуется найти минимальную сумму у.е., заплатив которую игрок может попасть в правый нижний угол.\nВходные данные\nВо входном файле INPUT.TXT задано два числа N и M - размеры таблицы (1 ≤ N ≤ 20, 1 ≤ M ≤ 20). Затем идет N строк по M чисел в каждой - размеры штрафов в у.е. за прохождение через соответствующие клетки (числа от 0 до 100).\nВыходные данные\nВ выходной файл OUTPUT.TXT выведите минимальную сумму, потратив которую можно попасть в правый нижний угол.",
    "complexity": 32,
    "memory": 16000,
    "time": 1000,
    "examples": [
      {
        "input": "3 4\n\n1 1 1 1\n\n5 2 2 100\n\n9 4 2 1",
        "output": "8"
      },
      {
        "input": "5 5\n\n1 1 1 1 1\n\n3 100 100 100 100\n\n1 1 1 1 1\n\n2 2 2 2 1\n\n1 1 1 1 1",
        "output": "11"
      }
    ]
  },
  {
    "id": 235,
    "name": "Робот К-79",
    "description": "Петя написал программу движения робота К-79. Программа состоит из следующих команд:\nR — повернуться на 90 градусов вправоOUTPUT.TXT52LSSSS-1-1[Лучшие попытки]\nS — сделать шаг вперед\n  L — повернуться на 90 градусов влево\n  R — повернуться на 90 градусов вправо\nНапишите программу, которая по заданной программе для робота определит, сколько шагов он сделает прежде, чем впервые вернется на то место, на котором уже побывал до этого, либо установит, что этого не произойдет.\nВходные данные\nВо входном файле INPUT.TXT записана одна строка из заглавных английских букв S, L, R, описывающая программу для робота. Общее число команд в программе от 1 до 200, при этом команд S — не более 50.\nВыходные данные\nВ выходной файл OUTPUT.TXT выведите, сколько шагов будет сделано (то есть выполнено команд S) прежде, чем робот впервые окажется в том месте, через которое он уже проходил. Если такого не произойдет, выведите в выходной файл число –1.",
    "complexity": 30,
    "memory": 16000,
    "time": 1000,
    "examples": [
      {
        "input": "SSLSLSLSSRSRS",
        "output": "5"
      },
      {
        "input": "LSSSS",
        "output": "-1"
      }
    ]
  },
  {
    "id": 144,
    "name": "A*B",
    "description": "Даны два целых неотрицательных числа A и B. Требуется найти их произведение.\nOUTPUT.TXT35[Лучшие попытки]\nВходные данные[Решение]\nВо входном файле INPUT.TXT записаны целые неотрицательные числа A и B по одному в строке (A \u003c 10100, B ≤ 10000).\nВыходные данные\nВ выходной файл OUTPUT.TXT выведите единственное число без лидирующих нулей: A*B.",
    "complexity": 37,
    "memory": 16000,
    "time": 1000,
    "examples": [
      {
        "input": "5\n7",
        "output": "35"
      }
    ]
  },
  {
    "id": 108,
    "name": "Неглухой телефон",
    "description": "Возможно, что Вы когда то играли в игру «Глухой телефон», либо слышали о ней. В этой игре участникам приходится передавать информацию друг другу различными способами: словесно, образно, бывает даже приходится писать левой рукой текст, который другой участник команды должен будет прочитать. Так же известно, что практически никогда передаваемая информация не доходит до конечного адресата. Обозначим за Fi(x) функцию, которая преобразует текст передаваемой информации x в ту, которую получит участник i+1 от участника i. Тогда последний n-й участник получит данные y, которые будут выражаться следующей формулой:\n2OUTPUT.TXT5[Лучшие попытки]\ny = Fn-1(Fn-2(…F2(F1(x))))\n1[Решение]\nНо Вам необходимо исключить какие-либо внешние факторы, которые могут исказить исходную информацию и Вы должны реализовать программу «неглухой телефон», которая сможет безошибочно доставлять исходные данные, т.е. в нашем случае функция Fi(x) = x для всех i от 1 до n-1.\nВходные данные\nВ единственной строке входного файла INPUT.TXT записано натуральное число от 1 до 100.\nВыходные данные\nВ выходной файл OUTPUT.TXT нужно вывести в точности то же число, которое задано во входном файле.",
    "complexity": 1,
    "memory": 16000,
    "time": 1000,
    "examples": [
      {
        "input": "5",
        "output": "5"
      }
    ]
  },
  {
    "id": 142,
    "name": "Минимальный каркас",
    "description": "От вас требуется определить вес минимального остовного дерева для неориентированного взвешенного связного графа.\nOUTPUT.TXT3[Лучшие попытки]\nВходные данные\nВ первой строке входного файла INPUT.TXT находятся числа N и M (1 ≤ N ≤ 100; 1 ≤ M ≤ 6000), где N - количество вершин в графе, а M - количество рёбер. В каждой из последующих M строк записано по тройке чисел A, B, C, где A и B - номера вершин, соединённых ребром, а C - вес ребра (натуральное число, не превышающее 30000).\nВыходные данные\nВ выходной файл OUTPUT.TXT  выведите одно число - искомый вес.",
    "complexity": 53,
    "memory": 16000,
    "time": 1000,
    "examples": [
      {
        "input": "3 3\n\n1 2 1\n\n2 3 2\n\n3 1 3",
        "output": "3"
      }
    ]
  },
  {
    "id": 136,
    "name": "Алгоритм Флойда - 2",
    "description": "Дан ориентированный взвешенный граф. Вам необходимо найти пару вершин, кратчайшее расстояние от одной из которых до другой максимально среди всех пар вершин.\nOUTPUT.TXT16[Лучшие попытки]\nВходные данные\nВ первой строке входного файла INPUT.TXT записано единственное число N (1 ≤ N ≤ 100) - количество вершин графа. В следующих N строках по N чисел - матрица смежности графа, где -1 означает отсутствие ребра между вершинами, а любое неотрицательное число - присутствие ребра данного веса. Элементы матрицы - целые числа от -1 до 100. На главной диагонали матрицы - всегда нули. Гарантируется, что в графе есть хотя бы одно ребро.\nВыходные данные\nВ выходной файл OUTPUT.TXT требуется вывести искомое максимальное кратчайшее расстояние.",
    "complexity": 39,
    "memory": 16000,
    "time": 1000,
    "examples": [
      {
        "input": "4\n\n0 5 9 -1\n\n-1 0 2 8\n\n-1 -1 0 7\n\n4 -1 -1 0",
        "output": "16"
      }
    ]
  },
  {
    "id": 236,
    "name": "Многочлен",
    "description": "Васе задали несколько однотипных задач по математике: «найти значение многочлена».  Он хочет написать программу, которая по заданному многочлену и значению x находила бы ответ. Напишите такую программу!\nOUTPUT.TXT612-2+x^1-3*x^2+x^2+100*x^3-2*x0-2-2[Лучшие попытки]\nВходные данные\nВ первой строке входного файла INPUT.TXT записан многочлен в виде суммы одночленов. Между одночленами находится знак + или –. Перед первым одночленом может быть знак –. Одночлен записывается как [\u003cКоэффициент\u003e*]x[^\u003cСтепень\u003e] или \u003cКоэффициент\u003e, где \u003cКоэффициент\u003e – неотрицательное целое число, не превосходящее 100, x – символ переменной (всегда маленькая английская буква x), \u003cСтепень\u003e — натуральное число, не превосходящее 4. Параметры, взятые в квадратные скобки, могут быть опущены. Общее число символов в записи многочлена не превышает 80. Во второй строке записано одно целое число — значение x, не превышающее 100 по абсолютной величине.\nВыходные данные\nВ выходной файл OUTPUT.TXT нужно записать одно число – значение данного многочлена при данном значении x.",
    "complexity": 41,
    "memory": 16000,
    "time": 1000,
    "examples": [
      {
        "input": "8*x+5\n7",
        "output": "61"
      },
      {
        "input": "-2+x^1-3*x^2+x^2+100*x^3-2*x\n0",
        "output": "-2"
      }
    ]
  },
  {
    "id": 109,
    "name": "A / B",
    "description": "Требуется получить точное значение частного А/В для двух натуральных чисел A и B.\nOUTPUT.TXT1.(428571)21/30.(3)0.(3)4[Лучшие попытки]\nВходные данные3100/254\nВ единственной строке входного файла INPUT.TXT записано частное двух натуральных чисел, не превышающих 1000. Числа разделены символом «/» без лишних пробелов.\nВыходные данные\nВ выходной файл OUTPUT.TXT нужно вывести точное значение A/B без лишних точек, нулей и пробелов. В случае присутствия бесконечной записи числа следует вывести период в скобках.\nНапример, неправильно выведены числа: 08.92, 3.20, 120.6(6), 0.(33), 5.(0), 2. , .3, 0.33(03) . Их следует выводить как 8.92, 3.2, 120.(6), 0.(3), 5, 2, 0.3, 0.3(30) .",
    "complexity": 43,
    "memory": 16000,
    "time": 1000,
    "examples": [
      {
        "input": "10/7",
        "output": "1.(428571)"
      },
      {
        "input": "1/3",
        "output": "0.(3)"
      },
      {
        "input": "100/25",
        "output": "4"
      }
    ]
  },
  {
    "id": 110,
    "name": "Красивые числа",
    "description": "Саша считает красивыми числа, десятичная запись которых не содержит других цифр, кроме 0 и k (1 ≤ k ≤ 9). Например, если k = 2, то такими числами будут 2, 20, 22, 2002 и т.п. Остальные числа Саше не нравятся, поэтому он представляет их в виде суммы красивых чисел. Например, если k = 3, то число 69 можно представить так: 69 = 33 + 30 + 3 + 3.\nmOUTPUT.TXT69=3+33+3326 56=0.5+5.56=0.5+5.510=9.(9)[Лучшие попытки]\nОднако, не любое натуральное число можно разложить в сумму красивых целых чисел. Например, при k = 5 число 6 нельзя представить в таком виде. Но если использовать красивые десятичные дроби, то это можно сделать: 6 = 5.5 + 0.5.\n1310 910=9.(9)\nНедавно Саша изучил периодические десятичные дроби и начал использовать и их в качестве слагаемых. Например, если k = 3, то число 43 можно разложить так: 43 = 33.(3) + 3.(3) + 3 + 3.(3). \n2\nОказывается, любое натуральное число можно представить в виде суммы положительных красивых чисел. Но такое разложение не единственно — например, число 69 можно также представить и как 69 = 33 + 33 + 3. Сашу заинтересовало, какое минимальное количество слагаемых требуется для представления числа n в виде суммы красивых чисел.\nm\nТребуется написать программу, которая для заданных чисел n и k находит разложение числа n в сумму положительных красивых чисел с минимальным количеством слагаемых.\nВходные данные\nВо входном файле INPUT.TXT записаны два натуральных числа n и k (1 ≤ n ≤ 109; 1 ≤ k ≤ 9).\nВыходные данные\nВ выходной файл OUTPUT.TXT выведите разложение числа n в сумму положительных чисел, содержащих только цифры 0 и k, количество слагаемых в котором минимально. Разложение должно быть представлено в виде: n=a1+a2+...+am. Слагаемые a1, a2, ..., am должны быть выведены без ведущих нулей, без лишних нулей в конце дробной части. Запись каждого слагаемого должна быть такой, что длины периода и предпериода дробной части имеют минимально возможную длину. Если решений несколько, то следует вывести то, где меньше слагаемых и по возможности с наименьшим количеством чисел с периодической дробью.\nНапример, неправильно выведены числа: 07.7; 2.20; 55.5(5); 0.(66); 7.(0); 7. ; .5; 0.33(03). Их следует выводить так: 7.7; 2.2; 55.(5); 0.(6); 7; 7; 0.5; 0.3(30). Предпериод и период каждого из выведенных чисел должны состоять не более чем из 100 цифр. Гарантируется, что хотя бы одно такое решение существует. Если искомых решений несколько, выведите любое. Порядок слагаемых может быть произвольным.",
    "complexity": 78,
    "memory": 16000,
    "time": 1000,
    "examples": [
      {
        "input": "69 3",
        "output": "69=3+33+33"
      },
      {
        "input": "6 5",
        "output": "6=0.5+5.5"
      },
      {
        "input": "10 9",
        "output": "10=9.(9)"
      }
    ]
  },
  {
    "id": 137,
    "name": "Существование пути",
    "description": "Дан ориентированный взвешенный граф. По его матрице смежности нужно для каждой пары вершин определить: существует кратчайший путь между ними или нет.\nOUTPUT.TXT1 1 1 0 0\n1 1 1 0 0\n1 1 1 0 0\n0 0 0 2 2\n0 0 0 2 2\n[Лучшие попытки]\nКратчайший путь может не существовать по двум причинам: либо нет ни одного пути, либо есть путь сколь угодно маленького веса.\nВходные данные\nВ первой строке входного файла INPUT.TXT записано единственное число N (1 ≤ N ≤ 100) - количество вершин графа. В следующих N строках по N целых чисел - матрица смежности графа (j-ое число в i-ой строке соответствует весу ребра из вершины i в вершину j), в которой число 0 обозначает отсутствие ребра, а любое другое число - наличие ребра соответствующего веса. Все числа по модулю не превышают 100.\nВыходные данные\nВ выходной файл OUTPUT.TXT выведите N строк по N чисел: j-ое число в i-ой строке должно быть равно 0, если путь из i в j не существует, 1 - если существует кратчайший путь, и 2 - если существует путь сколь угодно маленького веса.",
    "complexity": 65,
    "memory": 16000,
    "time": 1000,
    "examples": [
      {
        "input": "5\n\n0 1 2 0 0\n\n1 0 3 0 0\n\n2 3 0 0 0\n\n0 0 0 0 -1\n\n0 0 0 -1 0",
        "output": "1 1 1 0 0\n\n1 1 1 0 0\n\n1 1 1 0 0\n\n0 0 0 2 2\n\n0 0 0 2 2"
      }
    ]
  },
  {
    "id": 195,
    "name": "Эния",
    "description": "Неспокойно сейчас на стапелях шестого дока межгалактического порта планеты Торна. Всего через месяц закончится реконструкция малого броненесущего корвета “Эния”. И снова этому боевому кораблю и его доблестной команде предстоят тяжелые бои за контроль над плутониевыми рудниками Сибелиуса. Работа не прекращается ни на секунду, лазерные сварочные аппараты работают круглые сутки. От непрерывной работы плавятся шарниры роботов-ремонтников. Но задержаться нельзя ни на секунду.\nOUTPUT.TXT60214 23 532203220[Лучшие попытки]\nИ вот в этой суматохе обнаруживается, что термозащитные панели корвета вновь требуют срочной обработки сульфидом тория. Известно, что на обработку одного квадратного метра панели требуется 1 нанограмм сульфида. Всего необходимо обработать N прямоугольных панелей размером A на B метров. Вам необходимо как можно скорее подсчитать, сколько всего сульфида необходимо на обработку всех панелей “Энии”. И не забудьте, что панели требуют обработки с обеих сторон.\n[Решение]\nВходные данные\nПервая строка входного файла INPUT.TXT содержит 3 целых положительных числа через пробел: N (N ≤ 100), A (A ≤ 100), B (B ≤ 100)\nВыходные данные\nВ выходной файл OUTPUT.TXT нужно вывести единственное число – вес необходимого для обработки сульфида тория в нанограммах.",
    "complexity": 3,
    "memory": 16000,
    "time": 1000,
    "examples": [
      {
        "input": "5 2 3",
        "output": "60"
      },
      {
        "input": "14 23 5",
        "output": "3220"
      }
    ]
  },
  {
    "id": 194,
    "name": "Фотограф-зануда",
    "description": "Однажды глава семейства заказал фотографию своей большой семьи, состоящей из N человек, возраст которых 1 год, 2 года, …, N-1 лет и N лет. На фотографии должны присутствовать все родственники, и для этого они должны расположиться в один ряд. Сначала было решено расположить родственников по старшинству, начиная с самого младшего. Но фотограф сказал, что, возможно, на фото это будет выглядеть неестественно. Тогда было решено использовать следующее размещение: \nOUTPUT.TXT4271414[Лучшие попытки]\nслева сидит ребенок возрастом в 1 год\n  разность возрастов двух соседних родственников не превышает 2 года\nДействительно, на фотографии, таким образом, все будут все равно выглядеть, будто расположенные по старшинству (ведь среди людей возрастом, к примеру, 25 и 27 лет не так легко определить старшего). Способов такой посадки существует, понятно, несколько. Фотограф снял все такие способы. Сколько же фотографий получилось в итоге?\nВходные данные\nВо входном файле INPUT.TXT содержится число N (1 ≤ N ≤ 55) – количество членов большой семьи.\nВыходные данные\nВыходной файл OUTPUT.TXT должен содержать искомое число фотографий.",
    "complexity": 55,
    "memory": 16000,
    "time": 1000,
    "examples": [
      {
        "input": "4",
        "output": "4"
      },
      {
        "input": "7",
        "output": "14"
      }
    ]
  },
  {
    "id": 162,
    "name": "Манхэттенский полицейский",
    "description": "Недавно Билл устроился на работу полицейским. Теперь ему предстоит каждый вечер обходить свой участок, который представляет собой прямоугольник, состоящий из N×M кварталов. Каждый квартал имеет вид квадрата размером 100 х 100 метров, кварталы отделены друг от друга прямыми улицами.\nOUTPUT.TXT422 2161638[Лучшие попытки]\nТаким образом, через участок Билла проходит N+1 улица, идущая с запада на восток, и M+1 улица, идущая с севера на юг. Перекрестки разбивают улицы на (N+1)*M + (M+1)*N отрезков, каждый из которых имеет длину 100 метров.\n34 338\nСовершая обход, Билл выходит из полицейского управления, расположенного около юго-западного угла его участка, обходит свой участок и возвращается в управление. Во время обхода Билл должен пройти по каждому отрезку улицы на территории своего участка как минимум один раз. Известно, что во время обхода Билл проходит отрезок длиной 100 метров за одну минуту. Выясните, какое минимальное число минут потребуется Биллу, чтобы совершить обход.\nВходные данные\nВходной файл INPUT.TXT содержит натуральные числа N и M, не превышающие 10 000.\nВыходные данные\nВ выходной файл OUTPUT.TXT выведите минимальное время, за которое Билл может совершить обход.",
    "complexity": 56,
    "memory": 16000,
    "time": 1000,
    "examples": [
      {
        "input": "1 1",
        "output": "4"
      },
      {
        "input": "2 2",
        "output": "16"
      },
      {
        "input": "4 3",
        "output": "38"
      }
    ]
  },
  {
    "id": 125,
    "name": "Цветной дождь",
    "description": "В Банановой республике очень много холмов, соединенных мостами. На химическом заводе произошла авария, в результате чего испарилось экспериментальное удобрение \"зован\". На следующий день выпал цветной дождь, причем он прошел только над холмами. В некоторых местах падали красные капли, в некоторых - синие, а в остальных - зеленые, в результате чего холмы стали соответствующего цвета. Президенту Банановой республики это понравилось, но ему захотелось покрасить мосты между вершинами холмов так, чтобы мосты были покрашены в цвет холмов, которые они соединяют. К сожалению, если холмы разного цвета, то покрасить мост таким образом не удастся. Посчитайте количество таких \"плохих\" мостов.\nOUTPUT.TXT4[Лучшие попытки]\nВходные данные\nВ файле INPUT.TXT в первой строке записано N (0 \u003c N ≤ 100) - число холмов. Далее идет матрица смежности, описывающая наличие мостов между холмами (1-мост есть, 0-нет). Предпоследняя строка пустая, а в последней строке записано N чисел, обозначающих цвет холмов: 1 - красный; 2 - синий; 3 - зеленый.\nВыходные данные\nВ файл OUTPUT.TXT вывести количество \"плохих\" мостов.",
    "complexity": 26,
    "memory": 16000,
    "time": 1000,
    "examples": [
      {
        "input": "7\n\n0 1 0 0 0 1 1 \n\n1 0 1 0 0 0 0 \n\n0 1 0 0 1 1 0 \n\n0 0 0 0 0 0 0 \n\n0 0 1 0 0 1 0 \n\n1 0 1 0 1 0 0 \n\n1 0 0 0 0 0 0 \n\n\n\n1 1 1 1 1 3 3",
        "output": "4"
      }
    ]
  },
  {
    "id": 111,
    "name": "Игра «Пуговицы»",
    "description": "Правила игры очень просты. Перед двумя играющими находится кучка из K пуговиц. Играющие по очереди берут пуговицы из кучки, причем за один ход каждый из них может взять от 1 до L пуговиц. Выигрывает тот из спортсменов, которому удастся взять последнюю пуговицу.\nOUTPUT.TXT2226121230[Лучшие попытки]\nТот из игроков, которому по жребию выпадает делать первый ход, получает возможность собственноручно назначить число K. Тот из игроков, который будет ходить вторым, выбирает, в свою очередь, число L.\n33130\nВам необходимо определить наилучшую стратегию для участника, который ходит вторым.\nВходные данные\nВо входном файле INPUT.TXT записано одно натуральное число K (1 ≤ K ≤ 108) – общее количество пуговиц.\nВыходные данные\nВ выходной файл OUTPUT.TXT необходимо вывести целое число L (2 ≤ L \u003c K) — максимальное количество пуговиц, которое можно взять за один ход, обеспечивающее победу второму игроку. Если таких чисел несколько, то следует вывести наименьшее из них. Если таких чисел нет, то следует вывести число 0.",
    "complexity": 48,
    "memory": 16000,
    "time": 1000,
    "examples": [
      {
        "input": "3",
        "output": "2"
      },
      {
        "input": "26",
        "output": "12"
      },
      {
        "input": "31",
        "output": "30"
      }
    ]
  },
  {
    "id": 138,
    "name": "Алгоритм Форда-Беллмана",
    "description": "Дан ориентированный граф, в котором могут быть кратные ребра и петли. Каждое ребро имеет вес, выражающийся целым числом (возможно, отрицательным). Гарантируется, что циклы отрицательного веса отсутствуют. \nOUTPUT.TXT0 10 11 30000[Лучшие попытки]\nТребуется посчитать длины кратчайших путей от вершины номер 1 до всех остальных вершин.\nВходные данные\nВ первой строке входного файла INPUT.TXT записаны целые числа N и M  - количество вершин и количество ребер графа (1 ≤ N ≤ 100, 0 ≤ M ≤ 10000). В каждой из последующих M строк записана тройка чисел, описывающих ребра: начало ребра, конец ребра и вес (вес - целое число от -100 до 100).\nВыходные данные\nВ выходной файл OUTPUT.TXT выведите N чисел - расстояния от вершины номер 1 до всех вершин графа. Если пути до соответствующей вершины не существует, вместо длины пути выведите число 30000.",
    "complexity": 38,
    "memory": 16000,
    "time": 1000,
    "examples": [
      {
        "input": "4 5\n\n1 2 10\n\n2 3 10\n\n1 3 100\n\n3 1 -10\n\n2 3 1",
        "output": "0 10 11 30000"
      }
    ]
  },
  {
    "id": 112,
    "name": "Армия",
    "description": "Всем известно, что в армии без строевой подготовки и порядка дело не обходится и за этим там строго следят. Однажды утром сержант построил всех своих подчиненных в K рядов по N человек в каждом, но оказалось, что солдаты выстроились не по росту, и поэтому сержант решил их наказать. Солдаты должны были выстроиться по росту в каждом отдельном ряде так, что слева должны были стоять самые низкие, а справа самые высокие.  Ну а поскольку в армии виноваты всегда слабые (низкие), то наказание было следующим:  каждый солдат должен был отжаться столько раз, сколько солдат стоит от него слева выше его ростом.\nOUTPUT.TXT425 21 5 2 4 32 3 1 5 477[Лучшие попытки]\nОказалось, что все солдаты были разного роста, и многим пришлось отжиматься достаточно много раз. Сержанту стало интересно: сколько же раз в общей сложности пришлось отжаться солдатам?\nПомогите ему решить эту задачу!\nВходные данные\nВ первой строке входного файла INPUT.TXT записаны два натуральных числа N и K (2 ≤ N ≤ 104, 1≤ K ≤20) – число солдат в каждом ряде и число рядов. Следующие K строк файла содержат ровно N разных натуральных чисел от 1 до N – рост солдат. Первое число ряда – рост первого солдата (самого левого в ряду), второе – рост второго, и т.д.\nВыходные данные\nВ выходной файл OUTPUT.TXT необходимо вывести общее количество отжиманий, которые должны были выполнить солдаты.",
    "complexity": 58,
    "memory": 16000,
    "time": 1000,
    "examples": [
      {
        "input": "3 3\n1 2 3\n2 1 3\n3 2 1",
        "output": "4"
      },
      {
        "input": "5 2\n1 5 2 4 3\n2 3 1 5 4",
        "output": "7"
      }
    ]
  },
  {
    "id": 237,
    "name": "Головоломка",
    "description": "OUTPUT.TXTAENRSW23 2\nISQ\nABC\nIQW\nI\nIS\nABCQQWABCQQW[Лучшие попытки]\nПетя разгадывает головоломку, которая устроена следующим образом. Дана квадратная таблица размера N×N, в каждой клетке которой записана какая-нибудь английская буква. Кроме того, дан список ключевых слов. Пете нужно, взяв очередное ключевое слово, найти его в таблице. То есть найти в таблице все буквы этого слова, причем они должны быть расположены так, чтобы клетка, в которой расположена каждая последующая буква слова, была соседней с клеткой, в которой записана предыдущая буква (клетки называются соседними, если они имеют общую сторону — то есть соседствуют по вертикали или по горизонтали). Например, на рисунке показано, как может быть расположено в таблице слово olympiad.\nКогда Петя находит слово, он вычеркивает его из таблицы. Использовать уже вычеркнутые буквы в других ключевых словах нельзя. После того, как найдены и вычеркнуты все ключевые слова, в таблице остаются еще несколько букв, из которых Петя должен составить слово, зашифрованное в головоломке.\nПомогите Пете в решении этой головоломки, написав программу, которая по данной таблице и списку ключевых слов выпишет, из каких букв Петя должен сложить слово, то есть какие буквы останутся в таблице после вычеркивания ключевых слов.\nВходные данные\nВо входном файле INPUT.TXT записаны два числа N (1 ≤ N ≤ 10) и M (0 ≤ M ≤ 100). Следующие N строк по N заглавных английских букв описывают ребус. Следующие M строк содержат слова. Слова состоят только из заглавных английских букв, каждое слово имеет длину от 1 до 100 символов. Гарантируется, что в таблице можно найти и вычеркнуть по описанным выше правилам все ключевые слова.\nВыходные данные\nВ выходной файл OUTPUT.TXT выведите в алфавитном порядке оставшиеся в таблице буквы.",
    "complexity": 35,
    "memory": 16000,
    "time": 1000,
    "examples": [
      {
        "input": "5 3\n\nPOLTE\n\nRWYMS\n\nOAIPT\n\nBDANR\n\nLEMES\n\nOLYMPIAD\n\nPROBLEM\n\nTEST",
        "output": "AENRSW"
      },
      {
        "input": "3 2\n\nISQ\n\nABC\n\nIQW\n\nI\n\nIS",
        "output": "ABCQQW"
      }
    ]
  },
  {
    "id": 245,
    "name": "Сплоченная команда",
    "description": "Как показывает опыт, для создания успешной футбольной команды важны не только умения отдельных её участников, но и сплочённость команды в целом. Характеристикой умения игрока является показатель его профессионализма (ПП). Команда является сплочённой, если ПП каждого из игроков не превосходит суммы ПП любых двух других (в частности, любая команда из одного или двух игроков является сплоченной). Перед тренерским составом молодёжной сборной была поставлена задача сформировать сплоченную сборную с максимальной суммой ПП игроков (ограничений на количество игроков в команде нет).\nOUTPUT.TXT1125\n100\n20\n20\n20\n20\n120120[Лучшие попытки]\nВаша задача состоит в том, чтобы помочь сделать правильный выбор из N человек, для каждого из которых известен его ПП.\nВходные данные\nВ первой строке входного файла INPUT.TXT записано целое число N (0 ≤ N ≤ 30 000). В последующих N строках записано по одному целому числу Pi (0 ≤ Pi ≤ 60 000), представляющему собой ПП соответствующего игрока.\nВыходные данные\nВ выходной файл OUTPUT.TXT выведите максимально возможную сумму ПП игроков сплоченной команды.",
    "complexity": 42,
    "memory": 16000,
    "time": 1000,
    "examples": [
      {
        "input": "4\n\n1\n\n5\n\n3\n\n3",
        "output": "11"
      },
      {
        "input": "5\n\n100\n\n20\n\n20\n\n20\n\n20",
        "output": "120"
      }
    ]
  },
  {
    "id": 196,
    "name": "Спираль",
    "description": "Требуется вывести квадрат, состоящий из N×N клеток, заполненных числами от 1 до N2 по спирали (см. примеры).\nOUTPUT.TXT1 2 3\n    8    9    4\n    7    6    524\n 1  2  3   4\n12 13 14    5\n11 16 15    6\n10    9    8    7\n 1  2  3   4\n12 13 14    5\n11 16 15    6\n10    9    8    7 1  2  3  4  5\n16 17 18 19  6\n15 24 25 20  7\n14 23 22 21  8\n13 12 11 10  9\n[Лучшие попытки]\nВходные данные35 1  2  3  4  5\n16 17 18 19  6\n15 24 25 20  7\n14 23 22 21  8\n13 12 11 10  9\nВо входном файле INPUT.TXT задано целое число N – размер квадратной матрицы (2 ≤ N ≤ 100).\nВыходные данные\nВ выходной файл  OUTPUT.TXT выведите матрицу, заполненную числами от 1 до N2 по спирали, при этом между числами может быть любое количество пробелов. Не допускается начинать спираль в ином, кроме верхнего левого, углу, закручивать спираль против часовой стрелки или изнутри наружу.",
    "complexity": 38,
    "memory": 16000,
    "time": 1000,
    "examples": [
      {
        "input": "3",
        "output": "1 2 3\n\n    8    9    4\n\n    7    6    5"
      },
      {
        "input": "4",
        "output": "1  2  3   4\n\n12 13 14    5\n\n11 16 15    6\n\n10    9    8    7"
      },
      {
        "input": "5",
        "output": "1  2  3  4  5\n\n16 17 18 19  6\n\n15 24 25 20  7\n\n14 23 22 21  8\n\n13 12 11 10  9"
      }
    ]
  },
  {
    "id": 126,
    "name": "Издевательство",
    "description": "Штирлиц ехал на машине, увидел голосующего Бормана, и проехал мимо. Через некоторое время он снова увидел голосующего Бормана, и снова проехал мимо. Вскоре он опять увидел голосующего Бормана.\n - Издевается! - подумал Борман.\n - Кольцевая! - догадался Штирлиц.\n\nOUTPUT.TXT24[Лучшие попытки]\nВ городе N площадей. Любые две площади соединены между собой ровно одной дорогой с двусторонним движением. В этом городе живет Штирлиц. У Штирлица есть хобби - он любит воскресным утром выйти из дома, сесть в машину, выбрать какой-нибудь кольцевой маршрут, проходящий ровно по трем площадям (то есть сначала он едет с какой-то площади на какую-то другую, потом - на третью, затем возвращается на начальную, и опять едет по этому маршруту). Он воображает, что где-то на этом пути стоит Борман. И так вот ездит Штирлиц все воскресенье, пока голова не закружится, и радуется...\nЕстественно, что Штирлицу хочется проезжать мимо точки, в которой, как он воображает, стоит Борман, как можно чаще. Для этого, естественно, выбранный Штирлицем маршрут должен быть как можно короче. Напишите программу, которая выберет оптимальный для Штирлица маршрут.\nВходные данные\nВо входном файле INPUT.TXT записано сначала число N (3 ≤ N ≤ 100), а затем матрица N×N расстояний между площадями (число в позиции i,j обозначает длину дороги, соединяющей i-ую и j-ую площади). Все числа в матрице (кроме стоящих на главной диагонали) - натуральные, не превышающие 1000. Матрица симметрична относительно главной диагонали, на главной диагонали стоят 0.\nВыходные данные\nВ выходной файл OUTPUT.TXT выведите длину оптимального маршрута.",
    "complexity": 28,
    "memory": 16000,
    "time": 1000,
    "examples": [
      {
        "input": "5\n\n0 20 10 30 40\n\n20 0 30 1 2\n\n10 30 0 40 1000\n\n30 1 40 0 21\n\n40 2 1000 21 0",
        "output": "24"
      }
    ]
  },
  {
    "id": 199,
    "name": "Римские числа",
    "description": "Выходные данные\nВ выходной файл OUTPUT.TXT выведите сокращенную дробь в римской системе счисления. В тех случаях, когда первое число делится на второе, следует выводить результат в виде только одного римского числа. В том случае, когда во входных данных содержится ошибка, следует вывести ERROR.",
    "complexity": 50,
    "memory": 16000,
    "time": 1000,
    "examples": [
      {
        "input": "VII - 7",
        "output": "XLVI - 46"
      },
      {
        "input": "VIII - 8",
        "output": "L - 50"
      },
      {
        "input": "IX - 9",
        "output": "LXXV - 75"
      },
      {
        "input": "X - 10",
        "output": "XCII - 92"
      },
      {
        "input": "XVIII - 18",
        "output": "IC - 99"
      },
      {
        "input": "XXXI - 31",
        "output": "C - 100"
      },
      {
        "input": "II/IV",
        "output": "I/II"
      },
      {
        "input": "XXIV/VIII",
        "output": "III"
      },
      {
        "input": "12/16",
        "output": "ERROR"
      }
    ]
  },
  {
    "id": 226,
    "name": "Перегоны",
    "description": "На некоторой железнодорожной ветке расположено N станций, которые последовательно пронумерованы числами от 1 до N. Известны расстояния между некоторыми станциями. Требуется точно вычислить длины всех перегонов между соседними станциями или указать, что это сделать невозможно (то есть приведенная информация является противоречивой или ее недостаточно).\nOUTPUT.TXTYES \n1.250 1.750\n24 4\n1 2 1.250\n3 1 1.255\n2 4 0.010\n1 1 0.000\nYES\n1.250 0.005 0.005\nYES\n1.250 0.005 0.005\nNONO[Лучшие попытки]\nВходные данные33 1\n1 1 1\nNO\nВо входном файле INPUT.TXT записаны сначала числа N — количество станций (2 ≤ N ≤ 100) и E — количество пар станций, расстояния между которыми заданы (0 ≤ E ≤ 10000). Далее, идет E троек чисел, первые два числа каждой тройки задают номера станций (это числа из диапазона от 1 до N), а третье — расстояние между этими станциями (все эти расстояния заданы точно и выражаются вещественными неотрицательными числами  не более чем с 3-я знаками после десятичной точки).\n43 3\n1 2 1.250\n1 3 1.300\n2 3 1.000\nNO\nВыходные данные\nВ случае, когда восстановить длины перегонов можно однозначно, в выходной файл OUTPUT.TXT выведите сначала «YES», а затем N–1 вещественное число. Первое из этих чисел должно соответствовать расстоянию от 1-й станции до 2-й, второе — от 2-й до 3-й, и так далее. Все числа должны быть выведены с точностью до 3-х знаков после десятичной точки (например, число 2.3 следует выводить как 2.300). Если приведенная информация о расстояниях между станциями является противоречивой или не позволяет однозначно точно восстановить длины перегонов, выведите в выходной файл «NO».",
    "complexity": 50,
    "memory": 16000,
    "time": 1000,
    "examples": [
      {
        "input": "3 2\n\n1 2 1.250\n\n3 1 3",
        "output": "YES\n \n1.250 1.750"
      },
      {
        "input": "4 4\n\n1 2 1.250\n\n3 1 1.255\n\n2 4 0.010\n\n1 1 0.000",
        "output": "YES\n\n1.250 0.005 0.005"
      },
      {
        "input": "3 1\n\n1 1 1",
        "output": "NO"
      },
      {
        "input": "3 3\n\n1 2 1.250\n\n1 3 1.300\n\n2 3 1.000",
        "output": "NO"
      }
    ]
  },
  {
    "id": 114,
    "name": "Без двух нулей подряд",
    "description": "Требуется вычислить количество N-значных чисел в системе счисления с основанием K, таких что их запись не содержит двух подряд идущих нулей.\nOUTPUT.TXT9024 255328[Лучшие попытки]\nВходные данные36 3328[Решение]\nВо входном файле INPUT.TXT записаны два натуральных числа N и K  в десятичной системе счисления (2 ≤ K ≤ 10; 2 ≤ N; 4 ≤ N+K ≤ 18).\nВыходные данные\nВ выходной файл OUTPUT.TXT необходимо вывести целое число в десятичной записи – ответ на задачу.",
    "complexity": 37,
    "memory": 16000,
    "time": 1000,
    "examples": [
      {
        "input": "2 10",
        "output": "90"
      },
      {
        "input": "4 2",
        "output": "5"
      },
      {
        "input": "6 3",
        "output": "328"
      }
    ]
  },
  {
    "id": 243,
    "name": "Маскарад",
    "description": "По случаю введения больших новогодних каникул устраивается великий праздничный бал-маскарад. До праздника остались считанные дни, поэтому срочно нужны костюмы для участников. Для пошивки костюмов требуется L метров ткани. Ткань продается в N магазинах, в которых предоставляются скидки оптовым покупателям. В магазинах можно купить только целое число метров ткани. Реклама магазина номер i гласит \"Мы с радостью продадим Вам метр ткани за Pi рублей, однако если Вы купите не менее Ri метров, то получите прекрасную скидку — каждый купленный метр обойдется Вам всего в Qi рублей\". Чтобы воплотить в жизнь лозунг \"экономика страны должна быть экономной\", правительство решило потратить на закупку ткани для костюмов минимальное количество рублей из государственной казны. При этом ткани можно купить больше, чем нужно, если так окажется дешевле. Ответственный за покупку ткани позвонил в каждый магазин и узнал, что: \nOUTPUT.TXT8821 20\n1 1 1 1\n-1-1[Лучшие попытки]\nреклама каждого магазина содержит правдивую информацию о ценах и скидках;\n  магазин номер i готов продать ему не более Fi метров ткани.\nОтветственный за покупку очень устал от проделанной работы и поэтому поставленную перед ним задачу «закупить ткань за минимальные деньги» переложил на своих помощников. Напишите программу, которая определит, сколько ткани нужно купить в каждом из магазинов так, чтобы суммарные затраты были минимальны.\nВходные данные\nВ первой строке входного файла записаны два целых числа N и L (1 ≤ N ≤ 100, 0 ≤ L ≤ 100). В каждой из последующих N строк находится описание магазина номер i — 4 целых числа Pi, Ri, Qi, Fi (1 ≤ Qi ≤ Pi ≤ 1000, 1 ≤ Ri ≤ 100, 0 ≤ Fi ≤ 100).\nВыходные данные\nВ выходной файл OUTPUT.TXT выведите минимально возможную стоимость материи. Если покупка невозможна, выведите -1.",
    "complexity": 63,
    "memory": 16000,
    "time": 1000,
    "examples": [
      {
        "input": "2 14\n\n7 9 6 10\n\n7 8 6 10",
        "output": "88"
      },
      {
        "input": "1 20\n\n1 1 1 1",
        "output": "-1"
      }
    ]
  },
  {
    "id": 244,
    "name": "Билетики",
    "description": "В процессе установки турникетов в автобусах, разработчики столкнулись с проблемой проверки подлинности билета. Для ее решения был придуман следующий способ защиты от подделок.\nOUTPUT.TXTOK\n0\n28 5\n0 1 1 0 1 0 0 1\nOK\n2\nOK\n2\nFAIL[Лучшие попытки]\nИнформация, записанная на билете, кодируется K числами (0 или 1). При этом непосредственно на билете записывается последовательность из N чисел (N ≥ K) так, что числа, записанные на расстоянии K, совпадают. Таким образом, для проверки подлинности билета достаточно проверить, что все числа на расстоянии K совпадают. К сожалению, при считывании информации с билета иногда могут происходить ошибки — считается, что одно из чисел может исказиться (то есть 0 замениться на 1, или 1 — на 0). Такой билет все равно нужно считать подлинным. Во всех остальных случаях билет считается поддельным.\n36 2\n1 1 1 0 0 0\nFAIL\nНапишите программу, которая по информации, считанной с билета, устанавливает его подлинность, и указывает на то, при считывании какого из чисел могла произойти ошибка.\nВходные данные\nВ первой строке входного файла  INPUT.TXT записаны числа N и K (1 ≤ N ≤ 50000, 1 ≤ K ≤ 1000, K ≤ N). Во второй строке записано N чисел, каждое из которых является 0 или 1 — информация, считанная с билета.\nВыходные данные\nВ первой строке выходного файла OUTPUT.TXT должно быть записано OK, если билет подлинный и FAIL, если поддельный. В случае, если билет подлинный, во второй строке выведите 0, если все числа были считаны правильно, или номер числа, в котором при считывании произошла ошибка. Если возможных искаженных номеров несколько, выведите наименьший из них.",
    "complexity": 37,
    "memory": 16000,
    "time": 1000,
    "examples": [
      {
        "input": "6 2\n\n1 0 1 0 1 0",
        "output": "OK\n\n0"
      },
      {
        "input": "8 5\n\n0 1 1 0 1 0 0 1",
        "output": "OK\n\n2"
      },
      {
        "input": "6 2\n\n1 1 1 0 0 0",
        "output": "FAIL"
      }
    ]
  },
  {
    "id": 263,
    "name": "Метро",
    "description": "Витя работает недалеко от одной из станций кольцевой линии метро, а живет рядом с другой станцией той же линии. Требуется выяснить, мимо какого наименьшего количества промежуточных станций необходимо проехать Вите по кольцу, чтобы добраться с работы домой.\nOUTPUT.TXT0210 1 911[Лучшие попытки]\nВходные данные\nВо входном файле INPUT.TXT заданы три числа: сначала N – общее количество станций кольцевой линии, а затем i и j – номера станции, на которой Витя садится, и станции, на которой он должен выйти. Станции пронумерованы подряд натуральными числами 1, 2, 3, …, N (1-я станция – соседняя с N-й), N не превосходит 100. Числа i и j не совпадают. Все числа разделены пробелом.\nВыходные данные\nВ выходной файл OUTPUT.TXT требуется вывести минимальное количество промежуточных станций (не считая станции посадки и высадки), которые необходимо проехать Вите.",
    "complexity": 16,
    "memory": 16000,
    "time": 1000,
    "examples": [
      {
        "input": "100 5 6",
        "output": "0"
      },
      {
        "input": "10 1 9",
        "output": "1"
      }
    ]
  },
  {
    "id": 262,
    "name": "Коммерческий калькулятор",
    "description": "Фирма OISAC выпустила новую версию калькулятора. Этот калькулятор берет с пользователя деньги за совершаемые арифметические операции. Стоимость каждой операции в долларах равна 5% от числа, которое является результатом операции.\nOUTPUT.TXT4.60221 10.100.10[Лучшие попытки]\nНа этом калькуляторе требуется вычислить сумму N натуральных чисел (числа известны). Нетрудно заметить, что от того, в каком порядке мы будем складывать эти числа, иногда зависит, в какую сумму денег нам обойдется вычисление суммы чисел (тем самым, оказывается нарушен классический принцип «от перестановки мест слагаемых сумма не меняется»  ).\nНапример, пусть нам нужно сложить числа 10, 11, 12 и 13. Тогда если мы сначала сложим 10 и 11 (это обойдется нам в $1.05), потом результат — с 12 ($1.65), и затем — с 13 ($2.3), то всего мы заплатим $5, если же сначала отдельно сложить 10 и 11 ($1.05), потом — 12 и 13 ($1.25) и, наконец, сложить между собой два полученных числа ($2.3), то в итоге мы заплатим лишь $4.6.\nНапишите программу, которая будет определять, за какую минимальную сумму денег можно найти сумму данных N чисел.\nВходные данные\nВо входном файле INPUT.TXT записано число N (2 ≤ N ≤ 100000). Далее идет N натуральных чисел, которые нужно сложить, каждое из них не превышает 10000.\nВыходные данные\nВ выходной файл OUTPUT.TXT выведите, сколько денег нам потребуется на нахождение суммы этих N чисел. Результат должен быть выведен с двумя знаками после десятичной точки без лидирующих нулей.",
    "complexity": 32,
    "memory": 16000,
    "time": 1000,
    "examples": [
      {
        "input": "4\n10 11 12 13",
        "output": "4.60"
      },
      {
        "input": "2\n1 1",
        "output": "0.10"
      }
    ]
  },
  {
    "id": 99,
    "name": "Лабиринт",
    "description": "Открыв глаза, Принц Персии обнаружил, что находится на верхнем уровне подземного лабиринта Джаффара. Лабиринт состоит из h уровней, расположенных строго друг под другом. Каждый уровень представляет собой прямоугольную площадку, разбитую на m х n участков. На некоторых участках стоят колонны, поддерживающие потолок, на такие участки Принц заходить не может.\nOUTPUT.TXT60[Лучшие попытки]\nПринц может перемещаться с одного участка на другой соседний свободный участок того же уровня, так же он может проломить пол под собой и оказаться уровнем ниже (на самом нижнем уровне пол проломить нельзя). Любое перемещение занимает у Принца 5 секунд.\n[Решение]\nНа одном из участков нижнего уровня Принца ждет Принцесса. Помогите Принцу найти Принцессу, потратив на это как можно меньше времени.\nВходные данные\nВ первой строке входного файла INPUT.TXT содержатся натуральные числа h, m и n — высота и горизонтальные размеры лабиринта (2 ≤ h, m, n ≤ 50). Далее во входном файле приведены h блоков, описывающих уровни лабиринта в порядке от верхнего к нижнему. Каждый блок содержит m строк, по n символов в каждой: «.» обозначает свободный участок, «о» обозначает участок с колонной, «1» обозначает свободный участок, в котором оказался Принц в начале своего путешествия, «2» обозначает свободный участок, на котором томится Принцесса. Символы «1» и «2» встречаются во входном файле ровно по одному разу: символ «1» — в описании самого верхнего уровня, а символ «2» — в описании самого нижнего. Соседние блоки разделены одной пустой строкой.\nВыходные данные\nВ выходной файл OUTPUT.TXT выведите минимальное время в секундах, необходимое Принцу, чтобы найти Принцессу. Поскольку добро всегда побеждает Зло, гарантируется, что Принц может это сделать.",
    "complexity": 55,
    "memory": 16000,
    "time": 1000,
    "examples": [
      {
        "input": "3 3 3\n\n1..\n\noo.\n\n...\n\n\n\nooo\n\n..o\n\n.oo\n\n\n\nooo\n\no..\n\no.2",
        "output": "60"
      }
    ]
  },
  {
    "id": 101,
    "name": "Магараджа",
    "description": "Магараджа — это шахматная фигура, сочетающая возможности ферзя и коня. Таким образом, магараджа может ходить и бить на любое количество клеток по диагонали, горизонтали и вертикали (т.е. как ферзь), а также либо на две клетки по горизонтали и на одну по вертикали, либо на одну по горизонтали и на две по вертикали (как конь).\nOUTPUT.TXT924 2202048[Лучшие попытки]\nВаша задача — найти число способов расставить на доске N на N ровно K магараджей так, чтобы они не били друг друга.\n35 348\nВходные данные\nВходной файл INPUT.TXT содержит два целых числа: N и K (1 ≤ K ≤ N ≤ 10).\nВыходные данные\nВ выходной файл OUTPUT.TXT выведите ответ на задачу.",
    "complexity": 60,
    "memory": 16000,
    "time": 1000,
    "examples": [
      {
        "input": "3 1",
        "output": "9"
      },
      {
        "input": "4 2",
        "output": "20"
      },
      {
        "input": "5 3",
        "output": "48"
      }
    ]
  },
  {
    "id": 230,
    "name": "Луч света в темном царстве",
    "description": "Темное царство представляет собой лабиринт N×M, некоторые клетки которого окружены зеркальными стенами, а остальные — пустые. Весь лабиринт также окружен зеркальной стеной. В одной из пустых клеток лабиринта поставили светофор, который испускает лучи в 4 направлениях: под 45 градусов относительно стен лабиринта. Требуется изобразить траекторию этих лучей.\nOUTPUT.TXT./*./\\\n/..X./\n\\./.X*\n*X.//*\n/\\X/*.\n23 3\n...\n.X.\n...\n\\./\n.X.\n/.\\\\./\n.X.\n/.\\[Лучшие попытки]\nКогда луч приходит в угол, через который проходят зеркальные стены, дальше он идет так, как показано на рисунках (серым цветом показаны клетки, которые окружены зеркальными стенами). Аналогичным образом луч ведет себя, когда приходит на границу лабиринта.\nВходные данные\nВ первой строке входного файла INPUT.TXT записаны два натуральных числа N и M — число строк и столбцов в лабиринте (каждое из чисел не меньше 1 и не больше 100). В следующих N строках записано ровно по M символов в каждой — карта лабиринта. Символ * (звездочка) обозначает клетку, окруженную зеркальными стенками, . (точка) — пустую клетку, символ X (заглавная английская буква X) — клетку, в которой расположен светофор (такая клетка ровно одна).\nВыходные данные\nВ выходной файл OUTPUT.TXT выведите N строк по M символов в каждой — изображение лабиринта с траекториями лучей. Здесь, как и раньше, * (звездочка) должна обозначать клетки, окруженные зеркальными стенами, . (точка) — пустые клетки, через которые лучи света не проходят, / (слеш) — клетки, через которые луч света проходит из левого нижнего угла в правый верхний (или обратно — из правого верхнего в левый нижний), \\ (обратный слеш) — клетки, через которые луч проходит из левого верхнего угла в правый нижний (или обратно), а символ X (заглавная английская буква X) — клетки, через которые лучи проходят по обеим диагоналям.",
    "complexity": 63,
    "memory": 16000,
    "time": 1000,
    "examples": [
      {
        "input": "5 6\n\n..*...\n\n......\n\n.....*\n\n*X...*\n\n....*.",
        "output": "./*./\\\n\n/..X./\n\n\\./.X*\n\n*X.//*\n\n/\\X/*."
      },
      {
        "input": "3 3\n\n...\n\n.X.\n\n...",
        "output": "\\./\n\n.X.\n\n/.\\"
      }
    ]
  },
  {
    "id": 264,
    "name": "Оттепель",
    "description": "Уставшие от необычно теплой зимы, жители решили узнать, действительно ли это самая длинная оттепель за всю историю наблюдений за погодой. Они обратились к синоптикам, а те, в свою очередь, занялись исследованиями статистики за прошлые годы. Их интересует, сколько дней длилась самая длинная оттепель.\nOUTPUT.TXT22810 20 30 1 -10 1 2 3440[Лучшие попытки]\nОттепелью они называют период, в который среднесуточная температура ежедневно превышала 0 градусов Цельсия. Напишите программу, помогающую синоптикам в работе.\n35-10 0 -10 0 -100[Решение]\nВходные данные\nВо входном файле INPUT.TXT сначала записано число N – общее количество рассматриваемых дней (1 ≤ N ≤ 100). В следующей строке через пробел располагается N целых чисел, разделенных пробелами. Каждое число – среднесуточная температура в соответствующий день. Температуры – целые числа и лежат в диапазоне от –50 до 50.\nВыходные данные\nВ выходной файл OUTPUT.TXT требуется вывести одно число – длину самой продолжительной оттепели, то есть наибольшее количество последовательных дней, на протяжении которых среднесуточная температура превышала 0 градусов. Если температура в каждый из дней была неположительной, выведите 0.",
    "complexity": 17,
    "memory": 16000,
    "time": 1000,
    "examples": [
      {
        "input": "6\n-20 30 -40 50 10 -10",
        "output": "2"
      },
      {
        "input": "8\n10 20 30 1 -10 1 2 3",
        "output": "4"
      },
      {
        "input": "5\n-10 0 -10 0 -10",
        "output": "0"
      }
    ]
  },
  {
    "id": 115,
    "name": "Прямоугольник",
    "description": "Задан целочисленный прямоугольный массив M×N. Необходимо определить прямоугольную область данного массива, сумма элементов которого максимальна.\nOUTPUT.TXT2424 5\n-7 8 -1 0 -2\n2 -9 2 4 -6\n-7 0 6 8 1\n4 -8 -1 0 -6\n2020[Лучшие попытки]\nВходные данные\nВ первой строке входного файла INPUT.TXT записаны два натуральных числа N и M (1 ≤  N, M ≤ 100) – количество строк и столбцов прямоугольной матрицы. Далее идут N строк по M чисел, записанных через пробел – элементы массива, целые числа, не превосходящие 100 по абсолютной величине.\nВыходные данные\nВ выходной файл OUTPUT.TXT необходимо вывести целое число – сумму элементов найденного прямоугольного подмассива. Подмассив должен содержать хотя бы один элемент.",
    "complexity": 42,
    "memory": 16000,
    "time": 1000,
    "examples": [
      {
        "input": "2 3\n\n5 0 9\n\n1 2 7",
        "output": "24"
      },
      {
        "input": "4 5\n\n-7 8 -1 0 -2\n\n2 -9 2 4 -6\n\n-7 0 6 8 1\n\n4 -8 -1 0 -6",
        "output": "20"
      }
    ]
  },
  {
    "id": 100,
    "name": "Счастливые билеты",
    "description": "Требуется вычислить количество N - значных счастливых билетов. Напомним, что билет называется счастливым, если сумма первой половины его цифр равна сумме другой его половины. Например, билет 064109 счастливый, т.к. 0+6+4=1+0+9. \nOUTPUT.TXT67026552525525239581170420[Лучшие попытки]\nВходные данные31239581170420\nВ единственной строке входного файла INPUT.TXT записано натуральное четное число N (N ≤ 100) – количество цифр в билете.\nВыходные данные\nВ единственную строку выходного файла OUTPUT.TXT нужно вывести одно целое число –  количество N-значных счастливых билетов.",
    "complexity": 68,
    "memory": 16000,
    "time": 1000,
    "examples": [
      {
        "input": "4",
        "output": "670"
      },
      {
        "input": "6",
        "output": "55252"
      },
      {
        "input": "12",
        "output": "39581170420"
      }
    ]
  },
  {
    "id": 139,
    "name": "Лабиринт знаний",
    "description": "В стране Умландии построили аттракцион \"Лабиринт знаний\". Лабиринт представляет собой N комнат, занумерованных от 1 до N, между некоторыми из которых есть двери. Когда человек проходит через дверь, показатель его знаний изменяется на определенную величину, фиксированную для данной двери. Вход в лабиринт находится в комнате 1, выход - в комнате N. Каждый ученик проходит лабиринт ровно один раз и попадает в ту или иную учебную группу в зависимости от количества набранных знаний (при входе в лабиринт этот показатель равен нулю). Ваша задача показать наилучший результат.\nOUTPUT.TXT5[Лучшие попытки]\nВходные данные\nПервая строка входного файла INPUT.TXT содержит целые числа N (1 ≤ N ≤ 2000) - количество комнат и M (0 ≤ M ≤ 10000) - количество дверей. В каждой из следующих M строк содержится описание двери - номера комнат, из которой она ведет и в которую она ведет (через дверь можно ходить только в одном направлении), а также целое число, которое прибавляется к количеству знаний при прохождении через дверь (это число по модулю не превышает 10000). Двери могут вести из комнаты в нее саму, между двумя комнатами может быть более одной двери.\nВыходные данные\nВ выходной файл OUTPUT.TXT выведите \":)\" - если можно получить неограниченно большой запас знаний, \":(\" - если лабиринт пройти нельзя, и максимальное количество набранных знаний в противном случае.",
    "complexity": 63,
    "memory": 16000,
    "time": 1000,
    "examples": [
      {
        "input": "2 2\n\n1 2 5\n\n1 2 -5",
        "output": "5"
      }
    ]
  },
  {
    "id": 225,
    "name": "Покупка билетов",
    "description": "За билетами на премьеру нового мюзикла выстроилась очередь из N человек, каждый из которых хочет купить 1 билет. На всю очередь работала только одна касса, поэтому продажа билетов шла очень медленно, приводя «постояльцев» очереди в отчаяние. Самые сообразительные быстро заметили, что, как правило, несколько билетов в одни руки кассир продаёт быстрее, чем когда эти же билеты продаются по одному. Поэтому они предложили нескольким подряд стоящим людям отдавать деньги первому из них, чтобы он купил билеты на всех.\nOUTPUT.TXT1222\n3 4 5\n1 1 1\n44[Лучшие попытки]\nОднако для борьбы со спекулянтами кассир продавала не более 3-х билетов в одни руки, поэтому договориться таким образом между собой могли лишь 2 или 3 подряд стоящих человека.\nИзвестно, что на продажу i-му человеку из очереди одного билета кассир тратит Ai секунд, на продажу двух билетов — Bi секунд, трех билетов — Ci секунд. Напишите программу, которая подсчитает минимальное время, за которое могли быть обслужены все покупатели.\nОбратите внимание, что билеты на группу объединившихся людей всегда покупает первый из них. Также никто в целях ускорения не покупает лишних билетов (то есть билетов, которые никому не нужны).\nВходные данные\nВо входном файле INPUT.TXT записано сначала число N — количество покупателей в очереди (1≤N≤5000). Далее идет N троек натуральных чисел Ai, Bi, Ci. Каждое из этих чисел не превышает 3600. Люди в очереди нумеруются, начиная от кассы.\nВыходные данные\nВ выходной файл OUTPUT.TXT выведите одно число — минимальное время в секундах, за которое могли быть обслужены все покупатели.",
    "complexity": 43,
    "memory": 16000,
    "time": 1000,
    "examples": [
      {
        "input": "5\n\n5 10 15\n\n2 10 15\n\n5 5 5\n\n20 20 1\n\n20 1 1",
        "output": "12"
      },
      {
        "input": "2\n\n3 4 5\n\n1 1 1",
        "output": "4"
      }
    ]
  },
  {
    "id": 102,
    "name": "Треугольник и точка",
    "description": "В декартовой системе координат на плоскости заданы координаты вершин треугольника и еще одной точки. Требуется написать программу, определяющую, принадлежит ли эта точка треугольнику.\n2OUTPUT.TXTOut20 0 \n100 0\n0 100\n10 10\nInInInIn[Лучшие попытки]\nВходные данные230 0\n100 0\n0 100\n50 50\nIn\nВ четырех строках входного файла INPUT.TXT находятся пары целых чисел - координаты точек. Числа в первых трех строках - это координаты вершин треугольника (x1,y1), (x2,y2), (х3,у3), в четвертой строке - координаты тестируемой точки (x4,у4). Все координаты не превышают 10000 по абсолютной величине.\n340 0\n100 0\n0 100\n0 0\nIn\n3Выходные данные\n4\nВ выходной файл OUTPUT.TXT необходимо вывести слово «In», если точка находится внутри треугольника и «Out» в противном случае.\n4Примеры\n№INPUT.TXTOUTPUT.TXT\n10 0\n100 0\n0 100\n100 100\nOut\n20 0 \n100 0\n0 100\n10 10\nIn\n30 0\n100 0\n0 100\n50 50\nIn\n40 0\n100 0\n0 100\n0 0\nIn\nДля отправки решения задачи необходимо зарегистрироваться и авторизоваться!\n[Обсуждение]\n\n  [Все попытки]\n\n  [Лучшие попытки]\nwindow.yaContextCb.push(()=\u003e{\n  Ya.Context.AdvManager.render({\n    renderTo: 'yandex_rtb_R-A-122393-3',\n    blockId: 'R-A-122393-3'\n  })\n})",
    "complexity": 32,
    "memory": 16000,
    "time": 1000,
    "examples": [
      {
        "input": "0 0\n\n100 0\n\n0 100\n\n100 100",
        "output": "Out"
      },
      {
        "input": "0 0\n \n100 0\n\n0 100\n\n10 10",
        "output": "In"
      },
      {
        "input": "0 0\n\n100 0\n\n0 100\n\n50 50",
        "output": "In"
      },
      {
        "input": "0 0\n\n100 0\n\n0 100\n\n0 0",
        "output": "In"
      }
    ]
  },
  {
    "id": 104,
    "name": "Шаблон",
    "description": "Будем рассматривать слова из больших английских букв и шаблоны, состоящие из больших английских букв и символов «?» и «*». Говорят, что слово подходит под шаблон, если в шаблоне можно заменить каждый символ «?» на большую английскую букву, а каждый символ «*» - на последовательность (возможно, пустую) больших английских букв, так, чтобы получилось требуемое слово. Требуется написать программу, определяющую, подходит ли слово под шаблон.\nOUTPUT.TXTYES[Лучшие попытки]\nВходные данные\nВ первых двух строках входного файла INPUT.TXT записаны шаблон и слово: в одной строке записан шаблон - последовательность больших английских букв, «?» и «*», в другой - слово, состоящее только из больших английских букв. Обе строки входного файла содержат от 1 до 255 символов.\nВыходные данные\nВ выходной файл OUTPUT.TXT необходимо вывести слово «YES», если слово подходит под шаблон и «NO» в противном случае.",
    "complexity": 65,
    "memory": 32000,
    "time": 1000,
    "examples": [
      {
        "input": "ABBCDA\nA*CDA",
        "output": "YES"
      }
    ]
  },
  {
    "id": 106,
    "name": "Монетки",
    "description": "На столе лежат N монеток. Некоторые из них лежат вверх решкой, а некоторые – гербом. Определите минимальное число монеток, которые нужно перевернуть, чтобы все монетки были повернуты вверх одной и той же стороной.\nOUTPUT.TXT2[Лучшие попытки]\n[Решение]\nВходные данные\nВ первой строке входного файла INPUT.TXT записано натуральное число N (1 ≤ N ≤ 100) –  число монеток. В каждой из последующих N строк содержится одно целое число – 1 если монетка лежит решкой вверх и 0 если вверх гербом.\nВыходные данные\nВ выходной файл OUTPUT.TXT выведите минимальное количество монет, которые нужно перевернуть.",
    "complexity": 8,
    "memory": 16000,
    "time": 1000,
    "examples": [
      {
        "input": "5\n1\n0\n1\n1\n0",
        "output": "2"
      }
    ]
  },
  {
    "id": 141,
    "name": "Дерево",
    "description": "Неориентированный граф без петель и кратных ребер задан матрицей смежности. Требуется определить, является ли этот граф деревом.\nOUTPUT.TXTYES[Лучшие попытки]\nВходные данные\nВо входном файле INPUT.TXT записано сначала число N - количество вершин графа (от 1 до 100). Далее записана матрица смежности размером N×N, в которой 1 обозначает наличие ребра, 0 - его отсутствие. Матрица симметрична относительно главной диагонали.\nВыходные данные\nВ выходной файл OUTPUT.TXT выведите сообщение YES, если граф является деревом, и NO в противном случае.",
    "complexity": 42,
    "memory": 16000,
    "time": 1000,
    "examples": [
      {
        "input": "3\n0 1 0\n\n1 0 1\n\n0 1 0",
        "output": "YES"
      }
    ]
  },
  {
    "id": 231,
    "name": "Распаковка строки",
    "description": "Будем рассматривать только строчки, состоящие из заглавных английских букв. Например, рассмотрим строку AAAABCCCCCDDDD. Длина этой строки равна 14. Поскольку строка состоит только из английских букв, повторяющиеся символы могут быть удалены и заменены числами, определяющими количество повторений. Таким образом, данная строка может быть представлена как 4AB5C4D. Длина такой строки 7. Описанный метод мы назовем упаковкой строки. \nOUTPUT.TXTAAABBBBDDDDDDD222D7AC18FGDDDDDDDDDDDDDDDDDDDDDDDAAAAAAACFFFFFFFFFF\nFFFFFFFFGD\nDDDDDDDDDDDDDDDDDDDDDDAAAAAAACFFFFFFFFFF\nFFFFFFFFGD\nAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA\nAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA\nAAAAAAAAAAAAAAAB\nAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA\nBAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA\n[Лучшие попытки]\nНапишите программу, которая берет упакованную строчку и восстанавливает по ней исходную строку.\n395ABAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA\nAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA\nAAAAAAAAAAAAAAAB\nВходные данные440AB39AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA\nBAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA\nВходной файл INPUT.TXT содержит одну упакованную строку. В строке могут встречаться только конструкции вида nA, где n — количество повторений символа (целое число от 2 до 99), а A — заглавная английская буква, либо конструкции вида A, то есть символ без числа, определяющего количество повторений. Строка содержит от 1 до 80 символов.\nВыходные данные\nВ выходной файл OUTPUT.TXT выведите восстановленную строку. При этом строка должна быть разбита на строчки длиной ровно по 40 символов (за исключением последней, которая может содержать меньше 40 символов).",
    "complexity": 25,
    "memory": 16000,
    "time": 1000,
    "examples": [
      {
        "input": "3A4B7D",
        "output": "AAABBBBDDDDDDD"
      },
      {
        "input": "22D7AC18FGD",
        "output": "DDDDDDDDDDDDDDDDDDDDDDAAAAAAACFFFFFFFFFF\n\nFFFFFFFFGD"
      },
      {
        "input": "95AB",
        "output": "AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA\n\nAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA\n\nAAAAAAAAAAAAAAAB"
      },
      {
        "input": "40AB39A",
        "output": "AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA\n\nBAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA"
      }
    ]
  },
  {
    "id": 249,
    "name": "Скобки",
    "description": "Назовем строку S правильной скобочной последовательностью, если она состоит только из символов '{', '}', '[', ']', '(', ')' и выполнено хотя бы одно из следующих трех условий:\n3S можно представить в виде S='{'+C+'}' или S='['+C+']' или S='('+C+')', где C является правильной скобочной последовательностью.OUTPUT.TXT22([{}])00[Лучшие попытки]\nS — пустая строка;\nS можно представить в виде S=S1+S2+S3+...+SN (N\u003e1), где Si — непустые правильные скобочные последовательности, а знак \"+\" обозначает конкатенацию (приписывание) строк;\nS можно представить в виде S='{'+C+'}' или S='['+C+']' или S='('+C+')', где C является правильной скобочной последовательностью.\nN\ni\nДана строка, состоящая только из символов '{', '}', '[', ']', '(', ')'. Требуется определить, какое минимальное количество символов надо вставить в эту строку для того, чтобы она стала правильной скобочной последовательностью.\nВходные данные\nВ первой строке входного файла INPUT.TXT записана строка, состоящая только из символов '{', '}', '[',']', '(', ')'. Длина строки не превосходит 100 символов.\nВыходные данные\nВ выходной файл OUTPUT.TXT выведите ответ на поставленную задачу.",
    "complexity": 50,
    "memory": 16000,
    "time": 1000,
    "examples": [
      {
        "input": "{(})",
        "output": "2"
      },
      {
        "input": "([{}])",
        "output": "0"
      }
    ]
  },
  {
    "id": 105,
    "name": "Раскопки",
    "description": "Во время недавних раскопок на Марсе были обнаружены листы бумаги с таинственными символами на них. После долгих исследований учёные пришли к выводу, что надписи на них на самом деле могли быть обычными числовыми равенствами. Кроме того, из других источников было получено веское доказательство того, что марсиане знали только три операции - сложение, умножение и вычитание (марсиане никогда не использовали «унарный минус»: вместо «-5» они писали «0-5»). Также ученые доказали, что марсиане не наделяли операции разным приоритетом, а просто вычисляли выражения (если в них не было скобок) слева направо: например, 3+3*5 у них равнялось 30, а не 18. К сожалению, символы арифметических действий стерлись. Например, если была запись «18=7 (5 3) 2», то возможно восстановить эту запись как «18=7+(5-3)*2». Требуется написать программу, находящую требуемую расстановку знаков или сообщающую, что таковой не существует.\nOUTPUT.TXT18=7+(5-3)*225= 3 3-1-1[Лучшие попытки]\nВходные данные\nПервая строка входного файла INPUT.TXT состоит из натурального числа, не превосходящего 230, знака равенства, и последовательности натуральных чисел (не более десяти), произведение которых также не превосходит 230. Некоторые группы чисел (одно или более) могут быть окружены скобками. Длина входной строки не будет превосходить 80 символов, и других ограничений на количество и вложенность скобок нет. Между двумя соседними числами, не разделенными скобками, всегда будет хотя бы один пробел, во всех остальных местах может быть любое (в том числе и 0) число пробелов (естественно, внутри числа пробелов нет).\nВыходные данные\nВ выходной файл OUTPUT.TXT необходимо вывести одну строку, содержащую полученное равенство (т.е., исходное равенство со вставленными знаками арифметических действий без лишних пробелов). В случае если требуемая расстановка знаков невозможна, вывести строку, состоящую из единственного числа «-1». Выходная строка не должна содержать пробелов.",
    "complexity": 76,
    "memory": 16000,
    "time": 1000,
    "examples": [
      {
        "input": "18=7 (5 3) 2",
        "output": "18=7+(5-3)*2"
      },
      {
        "input": "5= 3 3",
        "output": "-1"
      }
    ]
  },
  {
    "id": 281,
    "name": "Игра с монеткой",
    "description": "Петя играет в интересную игру. Для этой игры необходима монетка. Петя подбрасывает ее n раз и считает, сколько раз выпадает «решка». Если решка выпадает хотя бы m раз, то Петя считает, что он выиграл игру.\nOUTPUT.TXT423 244[Лучшие попытки]\nОднажды Петя задумался, какова вероятность того, что он выиграет игру. Для этого он хочет найти количество последовательностей результатов подбрасывания монетки, содержащих ровно n подбрасываний, при которых «решка» выпала хотя бы m раз.\nПомогите Пете — найдите это число, считая, что при каждом броске монетка может выпасть либо «орлом», либо «решкой».\nВходные данные\nВходной файл INPUT.TXT содержит два целых числа: n и m (1 ≤ n ≤ 20, 0 ≤ m ≤ n).\nВыходные данные\nВ выходной файл OUTPUT.TXT выведите ответ на задачу.",
    "complexity": 39,
    "memory": 16000,
    "time": 1000,
    "examples": [
      {
        "input": "2 0",
        "output": "4"
      },
      {
        "input": "3 2",
        "output": "4"
      }
    ]
  },
  {
    "id": 247,
    "name": "Кафе",
    "description": "Около Петиного университета недавно открылось новое кафе, в котором действует следующая система скидок: при каждой покупке более чем на 100 рублей покупатель получает купон, дающий право на один бесплатный обед (при покупке на сумму 100 рублей и меньше такой купон покупатель не получает). \nOUTPUT.TXT235\n0 1\n[Лучшие попытки]\nОднажды Пете на глаза попался прейскурант на ближайшие N дней. Внимательно его изучив, он  решил, что будет обедать в этом кафе все N дней, причем каждый день он будет покупать в кафе ровно один обед. Однако стипендия у Пети небольшая, и поэтому он хочет по максимуму использовать предоставляемую систему скидок так, чтобы его суммарные затраты были минимальны.\nВходные данные\nВ первой строке входного файла INPUT.TXT записано целое число N (0 ≤ N ≤ 100). В каждой из последующих N строк записано одно целое число, обозначающее стоимость обеда в рублях на соответствующий день. Стоимость — неотрицательное целое число, не превосходящее 300.\nВыходные данные\nВ первой строке выходного файла OUTPUT.TXT выдайте минимальную возможную суммарную стоимость обедов. Во второй строке выдайте два числа K1 и K2 — количество купонов, которые останутся неиспользованными у Пети после этих N дней и количество использованных им купонов соответственно. Если существует несколько решений с минимальной суммарной стоимостью, то выдайте то из них, в котором значение K1 максимально (на случай, если Петя когда-нибудь ещё решит заглянуть в это кафе).",
    "complexity": 46,
    "memory": 16000,
    "time": 1000,
    "examples": [
      {
        "input": "5\n\n35\n\n40\n\n101\n\n59\n\n63",
        "output": "235\n\n0 1"
      }
    ]
  },
  {
    "id": 268,
    "name": "Почти палиндром",
    "description": "Слово называется палиндромом, если его первая буква совпадает с последней, вторая – с предпоследней и т.д. Например: \"abba\", \"madam\", \"x\".\nOUTPUT.TXT1223 3aaa66[Лучшие попытки]\nДля заданного числа K слово называется  почти палиндромом, если в нем можно изменить не более K любых букв так, чтобы получился палиндром. Например, при K = 2 слова \"reactor\", \"kolobok\", \"madam\" являются почти палиндромами (подчеркнуты буквы, заменой которых можно получить палиндром).\nПодсловом данного слова являются все слова, получающиеся путем вычеркивания из данного нескольких (возможно, одной или нуля) первых букв и нескольких последних. Например, подсловами слова \"cat\" являются слова \"c\", \"a\", \"t\", \"ca\", \"at\" и само слово \"cat\" (а \"ct\" подсловом слова \"cat\" не является).\nТребуется для данного числа K определить, сколько подслов данного слова S являются почти палиндромами.\nВходные данные\nВ первой строке входного файла INPUT.TXT вводятся два натуральных числа: N (1 ≤ N ≤  5 000) – длина слова и K (0 ≤ K ≤  N). Во второй строке записано слово S, состоящее из N строчных английских букв.\nВыходные данные\nВ выходной файл OUTPUT.TXT требуется вывести одно число – количество подслов слова S, являющихся почти палиндромами (для данного K).",
    "complexity": 40,
    "memory": 16000,
    "time": 1000,
    "examples": [
      {
        "input": "5 1\nabcde",
        "output": "12"
      },
      {
        "input": "3 3\naaa",
        "output": "6"
      }
    ]
  },
  {
    "id": 116,
    "name": "Фермер - 2",
    "description": "После решения задачи с пашней земли, фермер хочет построить на этой земле как можно больший по площади сарай прямоугольной формы. Но на его участке есть деревья и хозяйственные постройки, которые он не хочет никуда переносить. Для простоты представим ферму прямоугольной сеткой размера M×N. Каждое из деревьев и построек размещается в одном или нескольких узлах сетки. Сарай должен быть построен на свободных узлах сетки.\nOUTPUT.TXT21[Лучшие попытки]\nПомогите фермеру определить максимально возможную площадь сарая.\nВходные данные\nВ первой строке входного файла INPUT.TXT записаны два натуральных числа N и M (1 ≤ N,M ≤ 1000) – размеры фермы. Далее, следует N строк, в каждой из которых находится последовательность (без пробелов) из M нулей и единиц, описывающих ферму. Единицы соответствуют свободным для постройки участкам.\nВыходные данные\nВ выходной файл OUTPUT.TXT необходимо вывести максимально возможную площадь сарая, который может построить фермер на своем участке.",
    "complexity": 60,
    "memory": 64000,
    "time": 1000,
    "examples": [
      {
        "input": "5 10\n\n1011011111\n\n0111111110\n\n1111111111\n\n1011111111\n\n1101110111",
        "output": "21"
      }
    ]
  },
  {
    "id": 288,
    "name": "Комментарии",
    "description": "Программист Билл недавно узнал, что, чем больше комментариев содержит исходный текст, тем он лучше. Теперь он хочет проверить, насколько хороши его собственные программы, написанные на языке Pascal. Но поскольку самому считать комментарии очень утомительно, Билл попросил Вас сделать эту работу за него.\n (* ... *) OUTPUT.TXT12const comments = '{}(**)//';\nbegin\n  writeln(comments);\nend.\n002[Лучшие попытки]\nИсходный текст может содержать комментарии трёх типов:\n3// comment\nbegin\n  writeln('{ string }');\n  { while (true) do; }\nend.\n2\n// ... \n { ... } \n (* ... *)\nКомментарий первого типа начинается составным символом  // и продолжается до конца строки. Комментарий второго типа начинается символом { и заканчивается символом }. Он может размещаться в нескольких строках. Комментарий третьего типа начинается составным символом (* и заканчивается составным символом *). Он также может размещаться в нескольких строках.\nКомментарии не могут быть вложены друг в друга, так что запись вида {…//…(*…*)…} является одним комментарием второго типа. Комментарии не могут размещаться внутри символьных строк, так что запись ‘…(**)…{}…’ не содержит ни одного комментария.\nВходные данные\nВо входном файле INPUT.TXT записан исходный текст программы на языке Pascal. Размер текста не превосходит 16 Кб.\nВыходные данные\nВ выходной файл OUTPUT.TXT выведите одно число – количество комментариев в исходном тексте программы.",
    "complexity": 42,
    "memory": 16000,
    "time": 1000,
    "examples": [
      {
        "input": "{ my first program }\n\nbegin \n\n  writeln(\u0026#39;hello world\u0026#39;);\n\nend.",
        "output": "1"
      },
      {
        "input": "const comments = \u0026#39;{}(**)//\u0026#39;;\n\nbegin\n\n  writeln(comments);\n\nend.",
        "output": "0"
      },
      {
        "input": "// comment\n\nbegin\n\n  writeln(\u0026#39;{ string }\u0026#39;);\n\n  { while (true) do; }\n\nend.",
        "output": "2"
      }
    ]
  },
  {
    "id": 267,
    "name": "Ксерокопии",
    "description": "Секретарша Ирочка сегодня опоздала на работу и ей срочно нужно успеть к обеду сделать N копий одного документа. В ее распоряжении имеются два ксерокса, один из которых копирует лист за х секунд, а другой – за y секунд. (Разрешается использовать как один ксерокс, так и оба одновременно. Можно копировать не только с оригинала, но и с копии.) Помогите ей выяснить, какое минимальное время для этого потребуется.\nOUTPUT.TXT325 1 244[Лучшие попытки]\nВходные данные\nВо входном файле INPUT.TXT записаны три натуральных числа N, x и y, разделенные пробелом (1 ≤ N ≤ 2∙108, 1 ≤ x, y ≤ 10).\nВыходные данные\nВ выходной файл OUTPUT.TXT выведите одно число – минимальное время в секундах, необходимое для получения N копий.",
    "complexity": 38,
    "memory": 16000,
    "time": 1000,
    "examples": [
      {
        "input": "4 1 1",
        "output": "3"
      },
      {
        "input": "5 1 2",
        "output": "4"
      }
    ]
  },
  {
    "id": 200,
    "name": "Марсианские факториалы",
    "description": "В 3141 году очередная экспедиция на Марс обнаружила в одной из пещер таинственные знаки. Они однозначно доказывали существование на Марсе разумных существ. Однако смысл этих таинственных знаков долгое время оставался неизвестным. Недавно один из ученых, профессор Очень-Умный, заметил один интересный факт: всего в надписях, составленных из этих знаков, встречается ровно K различных символов. Более того, все надписи заканчиваются на длинную последовательность одних и тех же символов.\nOUTPUT.TXT12100 102424480[Лучшие попытки]\nВывод, который сделал из своих наблюдений профессор, потряс всех ученых Земли. Он предположил, что эти надписи являются записями факториалов различных натуральных чисел в системе счисления с основанием K. А символы в конце – это конечно же нули – ведь, как известно, факториалы больших чисел заканчиваются большим количеством нулей. Например, в нашей десятичной системе счисления факториалы заканчиваются на нули начиная с 5! = 1·2·3·4·5 = 120. А у числа 100! в конце следует 24 нуля в десятичной системе счисления и 48 нулей в системе счисления с основанием 6 – так что у предположения профессора есть разумные основания!\n3100 648\nТеперь ученым срочно нужна программа, которая по заданным числам N и K найдет количество нулей в конце записи в системе счисления с основанием K числа N! = 1·2·3·…·(N-1)·N, чтобы они могли проверить свою гипотезу. Вам придется написать им такую программу!\n43 100\nВходные данные\nВходной файл INPUT.TXT содержит числа N и K, разделенные пробелом. (1 ≤ N ≤ 109, 2 ≤ K ≤ 1000).\nВыходные данные\nВыведите в выходной файл OUTPUT.TXT число X - количество нулей в конце записи числа N!  в системе счисления с основанием K.",
    "complexity": 60,
    "memory": 16000,
    "time": 1000,
    "examples": [
      {
        "input": "5 10",
        "output": "1"
      },
      {
        "input": "100 10",
        "output": "24"
      },
      {
        "input": "100 6",
        "output": "48"
      },
      {
        "input": "3 10",
        "output": "0"
      }
    ]
  },
  {
    "id": 218,
    "name": "Шашки",
    "description": "OUTPUT.TXT.b.b.b.b\nb.b.b.b.\n.b.b.w.b\n-.-.-.-.\n.-.-.-.-\nw.-.w.w.\n.w.w.w.w\nw.w.w.w.\n[Лучшие попытки]\nПетя и Вася играли в шашки по описанным ниже правилам. В какой-то момент забежавший в комнату кот перевернул доску, на которой играли Петя и Вася. К счастью, у них осталась запись сделанных ходов, используя которую можно восстановить расположение шашек к моменту, когда забежал кот.\nНапишите программу, которая выведет положение шашек на доске после выполнения описанных ходов.\nИгра происходит на стандартной доске (8х8), которая располагается так, что у игрока, играющего белыми, левая нижняя клетка является черной, и с нее начинается нумерация как строк, так и столбцов. Строки доски нумеруются числами от 1 до 8, столбцы — английскими буквами от a до h.\nВ начале игры каждый из двух игроков имеет по 12 шашек своего цвета (белого или черного соответственно). Белые шашки располагаются на клетках a1, a3, b2, c1, c3, d2, e1, e3, f2, g1, g3, h2. Черные шашки располагаются на клетках a7, b6, b8, c7, d6, d8, e7, f6, f8, g7, h6, h8.\nИгроки совершают ходы по очереди. Игрок, играющий белыми, ходит первым.\nШашки в процессе игры бывают двух видов: обычная шашка и дамка. В начале игры все шашки обычные. Белая шашка становится дамкой, если она оказывается в строке 8. Соответственно, черная шашка становится дамкой, если она оказывается в строке 1.\nШашка может совершать ходы двух типов:\n1. Простой ход заключается в перемещении одной из шашек на одну клетку вперед по диагонали. Например, белая шашка с e3 может сходить на d4 или f4 (если соответствующая клетка свободна). А черная шашка с e3 может сходить на d2 или f2.\n2. Рубка заключается в том, что шашка перепрыгивает через шашку (или дамку) противника, находящуюся в диагонально соседней с ней клетке при условии, что следующая клетка этой диагонали свободна. Шашка противника, которую срубили, убирается с доски. Если сразу после окончания рубки та же самая шашка может продолжить рубку, она ее продолжает этим же ходом. Рубка возможна в любом из 4-х диагональных направлений. Если в процессе рубки шашка оказывается в 1-й строке (для черных) или в 8-й (для белых), она становится дамкой.\nДамка может совершать следующие ходы:\n3. Простой ход заключается в перемещении дамки по диагонали на любое число клеток (при этом все клетки, через которые происходит перемещение, должны быть свободны).\n4. Рубка заключается в том, что шашка перепрыгивает через шашку (или дамку) противника, находящуюся на той же диагонали, что и рубящая дамка. Это можно делать при условии, что все клетки между рубящей дамкой и шашкой, которую рубят, а также клетка, следующая за шашкой, которую рубят, свободны. После рубки дамка может встать на любую клетку данной диагонали за клеткой, на которой стояла срубленная шашка (при условии, что все клетки на ее пути свободны). Если из своего нового положения дамка может совершить рубку, она должна ее совершить этим же ходом.\nВходные данные\nВ первой строке входного файла INPUT.TXT записано одно число N — количество ходов, которое было сделано с начала партии. Это количество не превышает 1000.\nВ каждой из следующих N строк записаны описания ходов (нечетные ходы совершались белыми, четные — черными). Описание каждого хода занимает ровно одну строку и записывается в следующем виде.\nПростой ход записывается в виде \u003cначальная клетка\u003e–\u003cконечная клетка\u003e. Например, ход с c3 на d4 записывается как c3-d4.\nРубка записывается в виде \u003cначальная клетка\u003e:\u003cклетка после рубки\u003e. Если рубка продолжается, то ставится еще одно двоеточие, и записывается клетка, где окажется шашка после следующей рубки и т.д. Например, e3:c5:e7 (шашка, изначально расположенная на e3, рубит шашку на d4 и оказывается на c5, после чего рубит шашку на d6 и оказывается на e7).\nРубка a1:h8 может быть осуществлена только дамкой (например, дамка с a1 рубит шашку, стоящую в c3, и заканчивает ход в h8). Рубка дамкой может быть и такой a1:d4:f6:h4 (дамка рубит шашку, стоящую на b2, затем продолжает рубку и рубит шашку на e5, и, наконец, рубит шашку на g5). При этом после каждой рубки указывается клетка, на которой останавливается дамка перед следующей рубкой.\nСтроки с описанием ходов не содержат пробельных символов.\nВыходные данные\nВ выходной файл OUTPUT.TXT выведите изображение доски с расположенными на ней шашками. В первой строке выходного файла должна быть выведена 8-я строка доски, во второй — 7-я и т.д. В каждой строке должно быть ровно 8 символов, описывающих клетки столбцов с a по h.\nБелая клетка должна быть изображена символом “.” (точка), пустая черная клетка — символом “–“ (минус). Черная клетка, в которой стоит белая шашка — символом “w” (маленькая английская буква w), а клетка с белой дамкой — символом “W” (заглавная английская буква W). Аналогично клетка с черной шашкой должна быть изображена символом “b” (маленькая английская буква b), а клетка с черной дамкой — символом “B” (большая английская буква B).",
    "complexity": 45,
    "memory": 16000,
    "time": 1000,
    "examples": [
      {
        "input": "3\n\nc3-d4\n\nf6-e5\n\nd4:f6",
        "output": ".b.b.b.b\n\nb.b.b.b.\n\n.b.b.w.b\n\n-.-.-.-.\n\n.-.-.-.-\n\nw.-.w.w.\n\n.w.w.w.w\n\nw.w.w.w."
      }
    ]
  },
  {
    "id": 269,
    "name": "Тормозной механизм",
    "description": "Исследовательская лаборатория одной известной автомобильной компании разработала специальный механизм, позволяющий повысить эффективность тормозов путем равномерной нагрузки деталей, используемых в тормозах.\nOUTPUT.TXT10212121212\n21212121\n8815[Лучшие попытки]\nОдним из основных компонентов механизма являются 2 прокладки, которые в процессе взаимодействия накладываются друг на друга. Каждая прокладка длины n разделена на n разделов, каждый из которых имеет высоту h или 2h. Таким образом, прокладки имеют зубчатую форму без закруглений.\n32211221122\n21212\n15\nВ процессе взаимодействия прокладок важно, чтобы они накладывались друг на друга и при этом общая длина получившегося соединения была наименьшей.\nПо заданной конфигурации прокладок требуется определить наименьшую длину их возможного соединения, при котором общая высота конструкции не превышает значения 3h. При этом вращать прокладки и удалять зубцы запрещено.\nВходные данные\nВходной файл INPUT.TXT содержит 2 строки с описанием конфигурации 2х прокладок. Каждая конфигурация определяется последовательностью цифр 1 и 2, соответствующих высоте каждого зубца прокладки. Каждая из строк не пуста и имеет длину, не превышающую 100.\nВыходные данные\nВ выходной файл OUTPUT.TXT требуется вывести наименьшую длину конструкции из заданных прокладок.",
    "complexity": 40,
    "memory": 16000,
    "time": 1000,
    "examples": [
      {
        "input": "2112112112\n\n2212112",
        "output": "10"
      },
      {
        "input": "12121212\n\n21212121",
        "output": "8"
      },
      {
        "input": "2211221122\n\n21212",
        "output": "15"
      }
    ]
  },
  {
    "id": 246,
    "name": "Вагоны",
    "description": "Ежедневно диспетчеру железнодорожной станции приходится переставлять вагоны во многих поездах, чтобы они шли в заданном порядке. Для этого диспетчер может расцепить пришедший на станцию состав в произвольных местах и переставить образовавшиеся сцепки из одного или нескольких вагонов в произвольном порядке. Порядок вагонов в одной сцепке менять нельзя, также нельзя развернуть всю сцепку так, чтобы последний вагон в сцепке оказался первым в ней. \nOUTPUT.TXT225\n5 4 3 2 1\n440[Лучшие попытки]\nДиспетчер просит вашей помощи в определении того, какое минимальное число соединений между вагонами необходимо расцепить, чтобы переставить вагоны в составе в требуемом порядке.\n32\n1 2\n0\nВходные данные\nВ первой строке входного файла INPUT.TXT содержится целое число N (1 ≤ N ≤ 100). Во второй строке содержится перестановка натуральных чисел от 1 до N (то есть все натуральные числа от 1 до N в некотором порядке). Числа разделяются одним пробелом. Эта перестановка задает номера вагонов в приходящем на станцию составе. Требуется, чтобы в уходящем со станции составе вагоны шли в порядке их номеров.\nВыходные данные\nПрограмма должна записать в выходной файл OUTPUT.TXT единственное целое число, равное минимальному количеству соединений между вагонами, которое нужно расцепить в данном составе, чтобы их можно было переставить по порядку.",
    "complexity": 23,
    "memory": 16000,
    "time": 1000,
    "examples": [
      {
        "input": "4\n\n3 1 2 4",
        "output": "2"
      },
      {
        "input": "5\n\n5 4 3 2 1",
        "output": "4"
      },
      {
        "input": "2\n\n1 2",
        "output": "0"
      }
    ]
  },
  {
    "id": 272,
    "name": "Сумма максимума и минимума",
    "description": "Задана последовательность целых чисел. Числа нумеруются по порядку следования, начиная с единицы.\n1OUTPUT.TXT321 -2 3 -4 5-1-1[Лучшие попытки]\nТребуется написать программу, которая найдет сумму максимума из чисел с четными номерами и минимума из чисел с нечетными номерами – max{a2, a4, …}+min{a1, a3, …}.\n3\nВходные данные\nВходной текстовый файл INPUT.TXT содержит в единственной строке последовательность от 2 до 2×105 целых чисел, которые по модулю не превышают 10000.\nВыходные данные\nВыходной текстовый файл OUTPUT.TXT должен содержать одно целое число - сумму максимума из чисел с четными номерами и минимума из чисел с нечетными номерами.",
    "complexity": 26,
    "memory": 32000,
    "time": 1000,
    "examples": [
      {
        "input": "1 2",
        "output": "3"
      },
      {
        "input": "1 -2 3 -4 5",
        "output": "-1"
      }
    ]
  },
  {
    "id": 275,
    "name": "Делимость на 7",
    "description": "Требуется определить делимость на 7 ряда целых чисел, записанных в двоичной системе счисления.\nOUTPUT.TXTYes\nNo\nYes2111NoNo[Лучшие попытки]\nВходные данные[Решение]\nВ первой строке входного файла INPUT.TXT содержится N – количество чисел (N \u003c 50). В следующих N строках содержатся двоичные числа (по одному в каждой строке). Каждое двоичное число состоит не более чем из 1000 цифр.\nВыходные данные\nВыходной файл OUTPUT.TXT должен содержать N строк. Для каждого теста в отдельной строке надо выдать сообщение “Yes”, если соответствующее число кратно 7 или “No” в противном случае.",
    "complexity": 42,
    "memory": 16000,
    "time": 1000,
    "examples": [
      {
        "input": "3\n\n1110\n\n1010101\n\n111111111111111111111111111",
        "output": "Yes\n\nNo\n\nYes"
      },
      {
        "input": "1\n11",
        "output": "No"
      }
    ]
  },
  {
    "id": 274,
    "name": "Дружные числа",
    "description": "Будем называть два числа дружными, если они состоят из одних и тех же цифр. Например, числа 1132 и 32321 являются дружными, а 12 и 123 – нет (в первом числе нет цифры 3). Требуется написать программу, которая определит, являются ли два заданных числа дружными.\nOUTPUT.TXTYES2212 12311 111NOYESNOYES[Лучшие попытки]\nВходные данные\nВходной текстовый файл INPUT.TXT содержит в первой строке натуральное число K – количество тестов. Количество тестов не превышает 10. В следующих K строках содержатся по два целых числа A и B, разделенные одним пробелом (0 \u003c A \u003c 109, 0 \u003c B \u003c 109).\nВыходные данные\nВыходной текстовый файл OUTPUT.TXT должен содержать K строк. Для каждого теста в отдельной строке надо выдать сообщение “YES”, если A и B являются дружными, или “NO”, если не являются. В сообщениях кавычки не печатать.",
    "complexity": 25,
    "memory": 16000,
    "time": 1000,
    "examples": [
      {
        "input": "1\n1132 32321",
        "output": "YES"
      },
      {
        "input": "2\n12 123\n11 111",
        "output": "NO\nYES"
      }
    ]
  },
  {
    "id": 271,
    "name": "Числа Фибоначчи - 2",
    "description": "Числа Фибоначчи строятся следующим образом: 1, 1, 2, 3, 5, …. В этой последовательности, начиная с третьего числа, каждый следующий член равен сумме двух предыдущих. Получаем, что, например, шестое число равно 8, а  десятое - 55.\nOUTPUT.TXT1621000[Лучшие попытки]\nТребуется написать программу, которая определяет, является ли заданное число числом Фибоначчи.\nВходные данные\nВходной текстовый файл INPUT.TXT содержит одно натуральное число в диапазоне от 2 до 1200000000.\nВыходные данные\nВыходной файл OUTPUT.TXT должен содержать в первой строке 1, если заданное число является числом Фибоначчи, и 0, иначе. В первом случае во вторую строку требуется вывести его порядковый номер.",
    "complexity": 20,
    "memory": 16000,
    "time": 1000,
    "examples": [
      {
        "input": "8",
        "output": "1\n6"
      },
      {
        "input": "10",
        "output": "0"
      }
    ]
  },
  {
    "id": 223,
    "name": "Анаграммер",
    "description": "Анаграммер — специальное устройство для получения из слова его анаграмм (то есть слов, записанных теми же буквами, но в другом порядке). Это устройство умеет выполнять 2 операции:\nOUTPUT.TXT2 2MADAM\nADAMM\n 4 4 0 1430 [Лучшие попытки]\nВзять очередную букву исходного слова и поместить ее в стек.\nВзять букву из стека и добавить ее в конец выходного слова.\n3LONG\nGONG\n0\nСтек — это хранилище данных, которое работает по принципу \"первый пришел — последний ушел\". Стек можно представить себе в виде пирамидки. Когда мы добавляем букву в стек, это соответствует тому, что на стержень пирамидки сверху мы надеваем кольцо, на котором написана соответствующая буква. Когда берем букву из стека, то это соответствует тому, что мы снимаем со стержня верхнее кольцо, и смотрим, какая буква на нем написана.\n4AAAAAAAA\nAAAAAAAA\n1430\nНапример, слово TROT в слово TORT может быть преобразовано анаграммером двумя различными последовательностями операций: 11112222 или 12112212.\nНапишите программу, которая по двум заданным словам вычисляет количество различных последовательностей операций анаграммера, которые преобразуют первое из этих слов во второе.\nВходные данные\nПервая строка входного файла INPUT.TXT содержит исходное слово, а вторая — слово, которое необходимо получить. Слова состоят только из заглавных английских букв и имеют длину от 1 до 50 символов. Оба слова имеют одинаковую длину. В этих строках не содержится пробелов.\nВыходные данные\nВ первой строке выходного файла OUTPUT.TXT должно содержаться количество последовательностей операций анаграммера, с помощью которых можно преобразовать первое слово во второе.",
    "complexity": 75,
    "memory": 16000,
    "time": 1000,
    "examples": [
      {
        "input": "TROT\n\nTORT",
        "output": "2"
      },
      {
        "input": "MADAM\n\nADAMM",
        "output": "4"
      },
      {
        "input": "LONG\n\nGONG",
        "output": "0"
      },
      {
        "input": "AAAAAAAA\n\nAAAAAAAA",
        "output": "1430"
      }
    ]
  },
  {
    "id": 248,
    "name": "EuroEnglish",
    "description": "Европейская комиссия планирует принять решение о том, что официальным языком Евросоюза станет английский. Был также разработан план упрощения английской письменности, который планируется реализовать за четыре года. \nпробелы между словами и знаками препинания должны остаться там и только там, где они были в исходной строке, в начале и в конце строки пробелов быть не должно.OUTPUT.TXTkakao and kofi2Cinderella! Where Is The Dress???Sinderela! Wher Is Dres???Sinderela! Wher Is Dres???'' is leter!!!Helo!!!--\"word\"A then k\"\"- sukses[Лучшие попытки]\nПервоочередной задачей будет избавление от буквы c, которая в сочетаниях сi и сe будет изменяться на s, в сочетании ck — опускаться, а в остальных случаях заменяться на k. При этом все замены будут производиться в строгом порядке слева направо. То есть, например, в слове success сначала первая из двух букв c заменится на k, а затем вторая — на s, то есть получится suksess. А слово cck превратится в kk.\n3'A' is a letter '' is leter\nНа второй год из английских слов изымут все удвоенные буквы: ee изменят на i, oo - на u, a в остальных комбинациях будут просто писать одну букву вместо двух одинаковых. Такие замены также будут делать строго в порядке слева направо. Так, слово ooo превратится в uo, а oou — просто в u (в нем сначала oo заменится на u, а затем uu — на u), слово iee превратится в i (в нем сначала ee заменится на i, а затем ii — на i).\n4!!!Hello!!!A-the-\"word\"!!!Helo!!!--\"word\"\nНа третий год на конце слова станут опускать букву е, если она не единственная буква в слове. \n5Aaaa then the ckckckA then k\nНаконец, завершением реформы станет отмена артиклей (в английском языке три артикля: а, an и the). При этом удаляться эти артикли будут только тогда, когда они в исходном тексте были словами a, an, the. То есть, например, текст the table после реформ первых трех лет превратиться в th tabl, а после реформы четвертого года — просто в tabl. А слово aaaaa после реформы первых лет станет словом a, но поскольку изначально оно не было словом a (артиклем), то оно в итоге так и останется словом a.\n6\"A\"-the an\"\"-\nНапишите программу, которая будет переводить классический английский текст на Eвроинглиш.\n7A the an\nВходные данные8successsukses\nВо входном файле INPUT.TXT записана одна строка текста, состоящая не более чем из 200 символов: английских строчных и заглавных букв, пробелов и знаков препинания (в тексте могут встречаться: точка, запятая, вопросительный и восклицательный знаки, двоеточие, тире, точка с запятой, открывающаяся и закрывающаяся скобки, апострофы, кавычки). Заглавные буквы могут встречаться только в начале слова. Нигде подряд не могут стоять два пробела. В начале и в конце строки не может стоять пробел. Слова отделяются друг от друга пробелами и/или знаками препинания.\nВыходные данные\nВ выходной файл OUTPUT.TXT нужно выдать преобразованную строку при ограничениях:\nначинаться с заглавной буквы должны те и только те слова, которые начинались с заглавной буквы в исходном тексте;\nне должно встречаться двух пробелов подряд;\nпробелы между словами и знаками препинания должны остаться там и только там, где они были в исходной строке, в начале и в конце строки пробелов быть не должно.",
    "complexity": 55,
    "memory": 16000,
    "time": 1000,
    "examples": [
      {
        "input": "cacao and coffee",
        "output": "kakao and kofi"
      },
      {
        "input": "Cinderella! Where Is The Dress???",
        "output": "Sinderela! Wher Is Dres???"
      },
      {
        "input": "\u0026#39;A\u0026#39; is a letter",
        "output": "\u0026#39;\u0026#39; is leter"
      },
      {
        "input": "!!!Hello!!!A-the-\u0026#34;word\u0026#34;",
        "output": "!!!Helo!!!--\u0026#34;word\u0026#34;"
      },
      {
        "input": "Aaaa then the ckckck",
        "output": "A then k"
      },
      {
        "input": "\u0026#34;A\u0026#34;-the an",
        "output": "\u0026#34;\u0026#34;-"
      },
      {
        "input": "A the an",
        "output": ""
      },
      {
        "input": "success",
        "output": "sukses"
      }
    ]
  },
  {
    "id": 289,
    "name": "Делители",
    "description": "По заданному количеству делителей числа требуется найти само это число.\nOUTPUT.TXT424666050400[Лучшие попытки]\nВходные данные31260\nВо входном файле INPUT.TXT записано количество делителей D некоторого натурального числа N (1 ≤ D ≤ 5000).\n4605040\nВыходные данные549110\nВ выходной файл OUTPUT.TXT запишите число N. Если решений несколько, выведите наименьшее из них. Если решения нет, или наименьшее из решений превосходит 1015+1, запишите в файл число 0.",
    "complexity": 76,
    "memory": 16000,
    "time": 1000,
    "examples": [
      {
        "input": "3",
        "output": "4"
      },
      {
        "input": "4",
        "output": "6"
      },
      {
        "input": "12",
        "output": "60"
      },
      {
        "input": "60",
        "output": "5040"
      },
      {
        "input": "4911",
        "output": "0"
      }
    ]
  },
  {
    "id": 163,
    "name": "Уравнение для 5 класса!",
    "description": "Уравнение для пятиклассников представляет собой строку длиной 5 символов. Второй символ строки является либо знаком '+' (плюс) либо '-' (минус), четвёртый символ — знак '=' (равно). Из первого, третьего и пятого символов ровно два являются цифрами из диапазона от 0 до 9, и один — буквой x, обозначающей неизвестное. \nOUTPUT.TXT223-x=9-6-6[Лучшие попытки]\nТребуется написать программу, которая позволит решить данное уравнение относительно x.\nВходные данные\nВходной файл INPUT.TXT состоит из одной строки, в которой записано уравнение.\nВыходные данные\nВ выходной файл OUTPUT.TXT выведите целое число — значение x.",
    "complexity": 20,
    "memory": 16000,
    "time": 1000,
    "examples": [
      {
        "input": "x+5=7",
        "output": "2"
      },
      {
        "input": "3-x=9",
        "output": "-6"
      }
    ]
  },
  {
    "id": 233,
    "name": "Автобусная экскурсия",
    "description": "Оргкомитет Московской городской олимпиады решил организовать обзорную экскурсию по Москве для участников олимпиады. Для этого был заказан двухэтажный автобус (участников олимпиады достаточно много и в обычный они не умещаются) высотой 437 сантиметров. На экскурсионном маршруте встречаются N мостов. Жюри и оргкомитет олимпиады очень обеспокоены тем, что высокий двухэтажный автобус может не проехать под одним из них. Им удалось выяснить точную высоту каждого из мостов. Автобус может проехать под мостом тогда и только тогда, когда высота моста превосходит высоту автобуса. \nOUTPUT.TXTNo crash23763 245 113Crash 2Crash 2Crash 1[Лучшие попытки]\nПомогите организаторам узнать, закончится ли экскурсия благополучно, а если нет, то установить, где произойдет авария.\n31437Crash 1[Решение]\nВходные данные\nПервая строка входного файла INPUT.TXT содержит число N (1 ≤ N ≤ 1000). Вторая строка содержит N натуральных чисел, не превосходящих 10000, через пробел - высоты мостов в сантиметрах в том порядке, в котором они встречаются на пути автобуса.\nВыходные данные\nВ единственную строку выходного файла OUTPUT.TXT нужно вывести фразу \"No crash\", если экскурсия закончится благополучно. Если же произойдет авария, то нужно вывести сообщение \"Crash k\", где k - номер моста, где произойдет авария. Фразы выводить без кавычек ровно с одним пробелом внутри.",
    "complexity": 14,
    "memory": 16000,
    "time": 1000,
    "examples": [
      {
        "input": "1\n763",
        "output": "No crash"
      },
      {
        "input": "3\n763 245 113",
        "output": "Crash 2"
      },
      {
        "input": "1\n437",
        "output": "Crash 1"
      }
    ]
  },
  {
    "id": 232,
    "name": "Дремучий лес - 2",
    "description": "Просека — эта такая прямая линия, которая проходит через лес (то есть деревья есть как с одной стороны от этой линии, так и с другой), и при этом она не проходит ни через одно из деревьев леса, а также не касается деревьев. Будем говорить, что лес является дремучим, если в нем нет ни одной просеки.\nOUTPUT.TXTNO23\n0 0 1\n2.05 0 1\n1.02 -1.9 1\nYESYES[Лучшие попытки]\nНа плане леса все деревья изображаются кругами. Никакие два круга не пересекаются и не касаются друг друга. Требуется по этому плану определить, является ли лес дремучим.\nВходные данные\nВо входном файле INPUT.TXT содержится сначала целое число N — количество деревьев (1 ≤ N ≤ 200). Затем идет N троек чисел, задающих деревья. Первые два числа задают координаты центра, а третье — радиус. Все данные задаются точно, и выражаются вещественными числами, не более чем с 2 знаками после десятичной точки, по модулю не превосходящими 1000.\nВыходные данные\nВ первой строке выходного файла OUTPUT.TXT должно содержаться сообщение YES, если лес является дремучим, и NO иначе.",
    "complexity": 77,
    "memory": 16000,
    "time": 1000,
    "examples": [
      {
        "input": "3\n\n0 10 2\n\n5 11 2\n\n12.04 7 2",
        "output": "NO"
      },
      {
        "input": "3\n\n0 0 1\n\n2.05 0 1\n\n1.02 -1.9 1",
        "output": "YES"
      }
    ]
  },
  {
    "id": 273,
    "name": "Вычеркивание",
    "description": "Задано натуральное число N. Требуется написать программу, вычисляющую количество различных трехзначных чисел получающихся из N вычеркиванием цифр из его десятичной записи.\nOUTPUT.TXT0211111111111001111111144[Лучшие попытки]\nВходные данные\nВходной текстовый файл INPUT.TXT содержит одно натуральное число N (1 ≤ N ≤ 10100).\nВыходные данные\nВыходной текстовый файл OUTPUT.TXT должен содержать одно целое число - найденное количество трехзначных чисел.",
    "complexity": 28,
    "memory": 16000,
    "time": 1000,
    "examples": [
      {
        "input": "12",
        "output": "0"
      },
      {
        "input": "111111111110011111111",
        "output": "4"
      }
    ]
  },
  {
    "id": 270,
    "name": "Java vs C++",
    "description": "Сторонники языков Java и C++ часто спорят о том, какой язык лучше для решения олимпиадных задач. Одни говорят, что в Java есть масса полезных библиотек для работы со строками, хорошо реализованы механизмы чтения и вывода данных, а так же радует встроенные возможности для реализации длинной арифметики. С другой стороны, С++ является классическим языком, скорость выполнения программ благодаря существующим компиляторам (например, Intel Compiler 10.0) гораздо выше, чем у Java.\nOUTPUT.TXTlongAndMnemonicIdentifier2anotherExampleanother_exampleanother_exampleiError![Лучшие попытки]\nНо сейчас нас интересует лишь небольшие отличия, а именно соглашения, которыми пользуются программисты при описании имен переменных в Java и C++. Известно, что для понимания значений переменных часто используют английские слова или даже целые предложения, описывающие суть переменных, содержащих те или иные значения. Приведем ниже правила описания переменных, которыми руководствуются программисты, реализующие программы на Java и C++.\n3ii\nВ языке Java принято первое слово, входящее в название переменной записывать с маленькой английской буквы, следующее слово идет с большой буквы (только первая буква слова большая), слова не имеют разделителей и состоят только из английских букв. Например, правильные записи переменных в Java могут выглядеть следующим образом: javaIdentifier, longAndMnemonicIdentifier, name, nEERC.\n4bad_StyleError!\nВ языке C++ для описания переменных используются только маленькие английские символы и символ «_», который отделяет непустые слова друг от друга. Примеры: java_identifier, long_and_mnemonic_identifier, name, n_e_e_r_c.\nВам требуется написать программу, которая преобразует переменную, записанную на одном языке в формат другого языка.\nВходные данные\nВо входном файле INPUT.TXT задано наименование переменной длиной от 1 до 100 символов, в котором могут встречаться только заглавные и строчные буквы английского алфавита, а также символ подчёркивания.\nВыходные данные\nВ выходной файл OUTPUT.TXT требуется вывести аналог имени переменной в другом языке. Т.е. если переменная представлена в формате Java, то следует перевести в формат C++ и наоборот. В том случае, когда имя переменной не соответствует ни одному из вышеописанных языков, следует вывести «Error!»",
    "complexity": 34,
    "memory": 16000,
    "time": 1000,
    "examples": [
      {
        "input": "long_and_mnemonic_identifier",
        "output": "longAndMnemonicIdentifier"
      },
      {
        "input": "anotherExample",
        "output": "another_example"
      },
      {
        "input": "i",
        "output": "i"
      },
      {
        "input": "bad_Style",
        "output": "Error!"
      }
    ]
  },
  {
    "id": 197,
    "name": "Змейка",
    "description": "Требуется заполнить змейкой квадратную матрицу так, как показано на рисунке справа: заполнение происходит с единицы из левого верхнего угла и заканчивается в правом нижнем числом N2, где N – порядок матрицы.\nOUTPUT.TXT1  3  4 10\n 2  5  9 11\n 6  8 12 15\n 7 13 14 16\n[Лучшие попытки]\nВходные данные\nВо входном файле INPUT.TXT задано натуральное число N – размер квадратной матрицы (N ≤ 100).\nВыходные данные\nВ выходной файл  OUTPUT.TXT выведите матрицу, заполненную числами от 1 до N2 змейкой, при этом между числами может быть любое количество пробелов.",
    "complexity": 40,
    "memory": 16000,
    "time": 1000,
    "examples": [
      {
        "input": "4",
        "output": "1  3  4 10\n\n 2  5  9 11\n\n 6  8 12 15\n\n 7 13 14 16"
      }
    ]
  },
  {
    "id": 221,
    "name": "Левый лабиринт",
    "description": "В спортзале размером N×M метров построили современный аттракцион под названием \"Левый лабиринт\". Для этого на полу спортзала с интервалом в 1 метр начертили линии, параллельные стенам спортзала. Таким образом, спортзал разбили на N×M клеток. Дальше некоторые из этих клеток покрасили в черный цвет. Аттракцион заключается в том, что участника ставят в некоторой клетке спортзала и просят как можно быстрее добежать до некоторой другой клетки. При этом накладываются следующие условия:\nЗа все время пути участнику разрешается повернуть направо (то есть пойти из текущей клетки направо относительно того, откуда он пришел в данную клетку) не более K раз.OUTPUT.TXT1220 1 3\n2 1 3\n-1-1[Лучшие попытки]\nУчастнику запрещено ходить по черным клеткам.\n  Придя в какую-то клетку, участник может пойти либо прямо, либо налево, либо направо (если в соответствующем направлении клетка не покрашена в черный цвет): ходить назад, а также ходить по диагонали запрещается.\n  За все время пути участнику разрешается повернуть направо (то есть пойти из текущей клетки направо относительно того, откуда он пришел в данную клетку) не более K раз.\n  В начальной клетке участник может встать лицом в ту сторону, в какую ему захочется. С какой стороны участник прибежит в конечную клетку также не важно.\nВ начальной клетке участник может встать лицом в ту сторону, в какую ему захочется. С какой стороны участник прибежит в конечную клетку также не важно.\nИзвестно, что на то, чтобы перебежать из клетки в соседнюю, участник тратит ровно 1 секунду. Требуется вычислить минимальное время, за которое участник сможет достичь конечной клетки.\nВходные данные\nВо входном файле INPUT.TXT сначала записано число K — количество разрешенных поворотов направо (целое число из диапазона от 0 до 5), затем записаны числа N и M, задающие размеры спортзала — натуральные числа, не превышающие 20. Далее записано N строк по M чисел в каждой. Число 0 обозначает неокрашенную клетку, число 1 — покрашенную, число 2 — клетку, откуда стартует участник и число 3 — клетку, куда нужно добежать (клетки, помеченные 2 и 3 являются неокрашенными). В лабиринте всегда есть ровно одна начальная клетка и ровно одна клетка, в которую нужно попасть.\nВыходные данные\nВ выходной файл OUTPUT.TXT выведите минимальное время, за которое можно добраться в конечную клетку. Если попасть в конечную клетку нельзя, выведите –1.",
    "complexity": 57,
    "memory": 16000,
    "time": 1000,
    "examples": [
      {
        "input": "1 5 5\n\n2 0 0 1 1\n\n0 1 0 0 1\n\n1 1 0 0 1\n\n0 0 0 0 1\n\n3 1 0 0 1",
        "output": "12"
      },
      {
        "input": "0 1 3\n\n2 1 3",
        "output": "-1"
      }
    ]
  },
  {
    "id": 280,
    "name": "Количество делителей - 2",
    "description": "Пусть х — натуральное число. Назовем у его делителем, если 1 ≤ у ≤ х и остаток от деления х на у равен нулю.\nOUTPUT.TXT2223911[Лучшие попытки]\nЗадано число х. Найдите количество его делителей, делящихся на каждое из простых чисел, на которое делится х.\nВходные данные\nВходной файл INPUT.TXT содержит целое число x (1 ≤ х ≤ 1018). Все простые делители числа х не превосходят тысячу.\nВыходные данные\nВ выходной файл OUTPUT.TXT выведите ответ на задачу.",
    "complexity": 51,
    "memory": 16000,
    "time": 1000,
    "examples": [
      {
        "input": "12",
        "output": "2"
      },
      {
        "input": "239",
        "output": "1"
      }
    ]
  },
  {
    "id": 259,
    "name": "A-функция от строчки",
    "description": "Дана строка S, состоящая из N символов. Определим функцию A(i) от первых i символов этой строки следующим образом:\nOUTPUT.TXT1 2 0 1 5[Лучшие попытки]\nA(i) = максимально возможному k, что равны следующие строки:\nS[1]+S[2]+S[3]+…+S[k]\nS[i]+S[i–1]+S[i–2]+…+S[i–k+1]\nгде S[i] – i-ый символ строки S, а знак + означает, что символы записываются в строчку непосредственно друг за другом.\nНапишите программу, которая вычислит значения функции A для заданной строчки для всех возможных значений i от 1 до N.\nВходные данные\nВ первой строке входного файла INPUT.TXT записано одно число N. 1 ≤ N ≤ 200000. Во второй строке записана строка длиной N символов, состоящая только из больших и/или маленьких английских букв.\nВыходные данные\nВ выходной файл OUTPUT.TXT выведите N чисел — значения функции A(1), A(2), … A(N).",
    "complexity": 59,
    "memory": 16000,
    "time": 1000,
    "examples": [
      {
        "input": "5\naabaa",
        "output": "1 2 0 1 5"
      }
    ]
  },
  {
    "id": 278,
    "name": "Вычислительная биология",
    "description": "",
    "complexity": 28,
    "memory": 16000,
    "time": 1000,
    "examples": [
      {
        "input": "GTA\nAGCTA",
        "output": "YES"
      },
      {
        "input": "AAAG\nGAAAAAT",
        "output": "NO"
      }
    ]
  },
  {
    "id": 279,
    "name": "Скобочки - 2",
    "description": "Напомним, что называется правильной скобочной последовательностью:\nесли строки а и b — правильные скобочные последовательности, то строка ab — тоже правильная скобочная последовательность.OUTPUT.TXT02[(])22-1[Лучшие попытки]\nпустая строка является правильной скобочной последовательностью;\nесли строка а — правильная скобочная последовательность, то строки (а), [а] — тоже правильные скобочные последовательности;\nесли строки а и b — правильные скобочные последовательности, то строка ab — тоже правильная скобочная последовательность.\n3((]]]-1\nЗадана строка S, состоящая из квадратных и круглых скобок. Разрешается заменять квадратную открывающую скобку ([) на круглую открывающую (() и наоборот, а также квадратную закрывающую скобку (]) на круглую закрывающую ()) и наоборот.\nЗа одно действие разрешается изменить ровно один символ строки. Необходимо за минимальное число действий преобразовать S в правильную скобочную последовательность.\nВходные данные\nВходной файл INPUT.TXT содержит строку S. Ее длина не превосходит 100 000 символов.\nВыходные данные\nВ выходной файл OUTPUT.TXT выведите искомое минимальное число действий или -1, если преобразовать S в правильную скобочную последовательность невозможно.",
    "complexity": 37,
    "memory": 16000,
    "time": 1000,
    "examples": [
      {
        "input": "(())[]",
        "output": "0"
      },
      {
        "input": "[(])",
        "output": "2"
      },
      {
        "input": "((]]]",
        "output": "-1"
      }
    ]
  },
  {
    "id": 219,
    "name": "Симпатичные таблицы",
    "description": "Рассмотрим таблицу размера N×M, в клетках которой стоят целые неотрицательные числа. Скажем, что таблица является симпатичной, если для всех i сумма чисел ее i-ой строки не превышает Ri и для всех j сумма чисел ее j-го столбца не превышает Cj.\nNOUTPUT.TXT3[Лучшие попытки]\nВам задана таблица Z размера N×M (N строк и M столбцов), в некоторых клетках которой уже стоят целые  неотрицательные числа. Найдите симпатичную таблицу с максимальной суммой элементов такую, что она совпадает с Z на тех клетках, в которых в Z стоят числа.\n1\nВходные данные2\nПервая строка входного файла INPUT.TXT содержит числа N и M (1 ≤ M, N ≤ 20). Следующая строка содержит N целых неотрицательных чисел - R1, R2, ..., RN. Следующая строка содержит M целых неотрицательных чисел C1, C2, ..., CM. Все числа не превышают 106. Следующие N строк содержат по M целых чисел, которые задают Z. Если на некотором месте в таблице отсутствует число, то на этом месте во входном файле стоит число -1.\nM\n6Выходные данные\nВыведите в выходной файл OUTPUT.TXT выведите целое число - сумму элементов найденной таблицы. Если решение не существует, то выведите единственное число -1.",
    "complexity": 75,
    "memory": 16000,
    "time": 1000,
    "examples": [
      {
        "input": "2 2\n\n2 2\n\n1 2\n\n1 -1\n\n-1 -1",
        "output": "3"
      }
    ]
  },
  {
    "id": 265,
    "name": "Шахматная доска",
    "description": "Из шахматной доски по границам клеток выпилили связную (не распадающуюся на части) фигуру без дыр. Требуется определить ее периметр.\nOUTPUT.TXT8218 844[Лучшие попытки]\nВходные данные\nВо входном файле INPUT.TXT сначала записано число N (1 ≤ N ≤ 64) – количество выпиленных клеток. В следующих N строках указаны координаты выпиленных клеток, разделенные пробелом (номер строки и столбца – числа от 1 до 8). Каждая выпиленная клетка указывается один раз.\nВыходные данные\nВ выходной файл OUTPUT.TXT выведите одно число – периметр выпиленной фигуры (сторона клетки равна единице).",
    "complexity": 26,
    "memory": 16000,
    "time": 1000,
    "examples": [
      {
        "input": "3\n1 1\n1 2\n2 1",
        "output": "8"
      },
      {
        "input": "1\n8 8",
        "output": "4"
      }
    ]
  },
  {
    "id": 224,
    "name": "Наибольшее произведение",
    "description": "Дано N целых чисел. Требуется выбрать из них три таких числа, произведение которых максимально.\nOUTPUT.TXT81023\n-5 -30000 -12\n -1800000-1800000[Лучшие попытки]\nВходные данные\nВо входном файле INPUT.TXT записано сначала число N — количество чисел в последовательности (3 ≤ N ≤ 106). Далее записана сама последовательность: N целых чисел, по модулю не превышающих 30000.\nВыходные данные\nВ выходной файл OUTPUT.TXT выведите значение наибольшего произведения искомых трех чисел.",
    "complexity": 38,
    "memory": 128000,
    "time": 1000,
    "examples": [
      {
        "input": "9\n\n3 5 1 7 9 0 9 -3 10",
        "output": "810"
      },
      {
        "input": "3\n\n-5 -30000 -12",
        "output": "-1800000"
      }
    ]
  },
  {
    "id": 238,
    "name": "Побег с космической станции",
    "description": "Представьте, что вы состоите на службе во внешней разведке Межгалактического Альянса Республиканских Сил (МАРС). Одному из агентов разведки крупно не повезло, и он был захвачен на засекреченной космической базе. К счастью, внешней разведке МАРС удалось заполучить план этой базы. И вот теперь вам поручено разработать план побега. \nAOUTPUT.TXT4[Лучшие попытки]\nБаза представляет собой прямоугольник размером NхM, со всех сторон окружённый стенами, и состоящий из квадратных отсеков единичной площади. База снабжена K выходами, до одного из которых агенту необходимо добраться. В некоторых отсеках базы находятся стены. Ваш агент может перемещаться из отсека в любой из четырех соседних с ним, если в том отсеке, куда он хочет переместиться, нет стены. \nA\nКроме того, база снабжена системой гипертуннелей, способных перемещать агента из одного отсека базы (вход в гипертуннель) в другой (выход из гипертуннеля). Когда агент находится в отсеке, где есть вход в гипертуннель, он может (но не обязан) им воспользоваться.\n1\nНачальное положение вашего агента известно. Вам необходимо найти кратчайший путь побега (то есть путь, проходящий через минимальное количество отсеков).\n1\nВходные данные2\nВ первой строке входного файла INPUT.TXT записаны числа N и M (2 ≤ N ≤ 100, 2 ≤ M ≤ 100), задающие размеры базы: N — количество строк в плане базы, M — количество столбцов. Во второй строке записаны начальные координаты агента XA,YA (1 ≤ XA ≤ N, 1 ≤ YA ≤ M). Первая координата задает номер строки, вторая — номер столбца. Строки нумеруются сверху вниз, столбцы слева направо. Далее следуют N строк по M чисел, задающих описание стен внутри базы: 1 соответствует стенке, 0 — её отсутствию. Далее в отдельной строке записано число H (0 ≤ H ≤ 1000) — количество гипертуннелей. В последующих H строках идут описания гипертуннелей. Каждый гипертуннель задается 4 числами: X1, Y1, X2, Y2 (1 ≤ X1,X2 ≤ N; 1 ≤ Y1,Y2 ≤ M) — координатами входа и выхода гипертуннеля. Никакие два гипертуннеля не имеют общего входа. После этого в отдельной строке следует число K (1 ≤ K ≤ 10) — количество выходов с базы. В последующих K строках идут описания выходов с базы. Каждый выход задается двумя координатами X и Y (1 ≤ X ≤ N; 1 ≤ Y ≤ M).\n2\n1\nГарантируется, что начальные координаты агента не совпадают ни с одним из выходов и он не стоит в отсеке, занятом стеной. Никакие входы и выходы гипертуннелей, а также выходы с базы не находятся в отсеках, занятых стенами. Никакой вход в гипертуннель не совпадает с выходом с базы.\n2Выходные данные\n1\nЕсли побег невозможен, выведите в выходной файл OUTPUT.TXT \"Impossible\". В противном случае следует вывести количество отсеков в кратчайшем пути побега.\n2Пример\n№INPUT.TXTOUTPUT.TXT\n14 5\n2 1\n0 0 0 0 0\n0 1 0 0 0\n0 0 0 0 0\n0 0 0 0 0\n2\n1 2 1 4\n3 1 1 4\n1 \n2 4\n4\nДля отправки решения задачи необходимо зарегистрироваться и авторизоваться!\n[Обсуждение]\n\n  [Все попытки]\n\n  [Лучшие попытки]\nwindow.yaContextCb.push(()=\u003e{\n  Ya.Context.AdvManager.render({\n    renderTo: 'yandex_rtb_R-A-122393-3',\n    blockId: 'R-A-122393-3'\n  })\n})",
    "complexity": 46,
    "memory": 16000,
    "time": 1000,
    "examples": [
      {
        "input": "4 5\n\n2 1\n\n0 0 0 0 0\n\n0 1 0 0 0\n\n0 0 0 0 0\n\n0 0 0 0 0\n\n2\n\n1 2 1 4\n\n3 1 1 4\n\n1\n \n2 4",
        "output": "4"
      }
    ]
  },
  {
    "id": 103,
    "name": "Снова A+B",
    "description": "Требуется сложить два целых числа А и В.\nOUTPUT.TXT5[Лучшие попытки]\nВходные данные[Решение]\nВо входном файле INPUT.TXT записано два неотрицательных целых числа, не превышающих 10100, по одному в каждой строке.\nВыходные данные\nВ единственную строку выходного файла OUTPUT.TXT нужно вывести одно целое число — сумму чисел А и В, без лидирующих нулей.",
    "complexity": 35,
    "memory": 16000,
    "time": 1000,
    "examples": [
      {
        "input": "2\n3",
        "output": "5"
      }
    ]
  },
  {
    "id": 140,
    "name": "Цикл отрицательного веса",
    "description": "Дан взвешенный граф. Определить, есть ли в нем цикл отрицательного веса.\nOUTPUT.TXTYES[Лучшие попытки]\nВходные данные\nВо входном файле INPUT.TXT в первой строке записано число N (1 ≤ N ≤ 100) - количество вершин графа. В следующих N строках находится по N чисел - матрица смежности графа. Веса ребер не превышают по модулю 10000. Если ребра нет, соответствующее значение равно 100000.\nВыходные данные\nВ выходной файл OUTPUT.TXT выведите \"YES\", если цикл существует, или \"NO\" в противном случае.",
    "complexity": 46,
    "memory": 16000,
    "time": 1000,
    "examples": [
      {
        "input": "2\n\n0 -1\n\n-1 0",
        "output": "YES"
      }
    ]
  },
  {
    "id": 260,
    "name": "Олимпиада по алхимии",
    "description": "В государстве алхимиков есть N населённых пунктов, пронумерованных числами от 1 до N, и M дорог. Населённые пункты бывают двух типов: деревни и города. Кроме того, в государстве есть одна столица (она может располагаться как в городе, так и в деревне). Каждая дорога соединяет два населённых пункта, и для проезда по ней требуется Ti минут. В столице было решено провести 1-ю государственную командную олимпиаду по алхимии. Для этого во все города из столицы были отправлены гонцы (по одному на город) с информацией про олимпиаду. \nOUTPUT.TXT1 0\n2 1\n3 11\n4 111\n5 211\n25 5 3 1\n2 4 5\n2 1 1\n2 3 10\n3 4 100\n4 5 100\n1 5 1\n2 1\n5 1\n4 101\n2 1\n5 1\n4 101\n[Лучшие попытки]\nНапишите программу, которая посчитает, в каком порядке и через какое время каждый из гонцов доберётся до своего города. Считается, что гонец во время пути нигде не задерживается.\nВходные данные\nВо входном файле INPUT.TXT сначала записаны 3 числа N, M, K — количество населенных пунктов, количество дорог и количество городов (2 ≤ N ≤ 1000, 1 ≤ M ≤ 10000, 1 ≤ K ≤ N). Далее записан номер столицы C (1 ≤ C ≤ N). Следующие K чисел задают номера городов. Далее следуют M троек чисел Si, Ei, Ti, описывающих дороги: Si и Ei — номера населенных пунктов, которые соединяет данная дорога, а Ti — время для проезда по ней (1 ≤ Ti ≤ 100).\nГарантируется, что до каждого города из столицы можно добраться по дорогам (возможно, через другие населенные пункты) и то, что любые два населенных пункта соединены не более, чем одной дорогой.\nВыходные данные\nВ выходной файл OUTPUT.TXT выведите K пар чисел: для каждого города должен быть выведен его номер и минимальное время, когда гонец может в нем оказаться (время измеряется в минутах с того момента, как гонцы выехали из столицы). Пары в выходном файле должны быть упорядочены по времени прибытия гонца, а в случае совпадения времени следует сортировать эти пары по номерам городов.",
    "complexity": 53,
    "memory": 16000,
    "time": 1000,
    "examples": [
      {
        "input": "5 4 5 1\n\n1 2 3 4 5\n\n1 2 1\n\n2 3 10\n\n3 4 100\n\n4 5 100",
        "output": "1 0\n\n2 1\n\n3 11\n\n4 111\n\n5 211"
      },
      {
        "input": "5 5 3 1\n\n2 4 5\n\n2 1 1\n\n2 3 10\n\n3 4 100\n\n4 5 100\n\n1 5 1",
        "output": "2 1\n\n5 1\n\n4 101"
      }
    ]
  },
  {
    "id": 266,
    "name": "Кассы",
    "description": "На одном из московских вокзалов билеты продают N касс. Каждая касса работает без перерыва определенный промежуток времени по фиксированному расписанию (одному и тому же каждый день). Требуется определить, на протяжении какого времени в течение суток работают все кассы одновременно.\nOUTPUT.TXT12022\n9 30 14 0\n14 15 21 0\n001[Лучшие попытки]\nВходные данные32\n14 00 18 00\n10 00 14 01\n1\nВо входном файле INPUT.TXT сначала располагается одно целое число N (0 \u003c N ≤ 1000). В каждой из следующих N строк через пробел расположены 4 целых числа, первые два из которых обозначают время открытия кассы в часах и минутах (часы — целое число от 0 до 23, минуты — целое число от 0 до 59), остальные два — время закрытия в том же формате. Числа разделены пробелами.\nВремя открытия означает, что в соответствующую ему минуту касса уже работает, а время закрытия — что в соответствующую минуту касса уже не работает. Например, касса, открытая с 10 ч 30 мин до 18 ч 30 мин, ежесуточно работает 480 минут.\nЕсли времена открытия и закрытия совпадают, то это означает, что касса работает круглосуточно. Если первое время больше второго, то это означает, что касса начинает работу до полуночи, а заканчивает — на следующий день.\nВыходные данные\nВ выходной файл OUTPUT.TXT требуется вывести одно число — суммарное время за сутки (в минутах), на протяжении которого работают все N касс.",
    "complexity": 39,
    "memory": 16000,
    "time": 1000,
    "examples": [
      {
        "input": "3\n\n1 0 23 0\n\n12 0 12 0\n\n22 0 2 0",
        "output": "120"
      },
      {
        "input": "2\n\n9 30 14 0\n\n14 15 21 0",
        "output": "0"
      },
      {
        "input": "2\n\n14 00 18 00\n\n10 00 14 01",
        "output": "1"
      }
    ]
  },
  {
    "id": 164,
    "name": "Счастливый билет - 2",
    "description": "Билет называется счастливым, если его можно разрезать прямой линией между цифр на две части таким образом, что оказавшиеся на них числа имеют одинаковые цифровые корни. Чтобы вычислить цифровой корень числа, его цифры складывают, если в результате получится число большее или равное 10, то цифры складывают снова и так далее, пока не получится число от 0 до 9 – это и есть цифровой корень. Например, билет с номером 0015420 является счастливым, так как разрезав его на части с числами 0015 и 420 имеем у этих чисел одинаковые цифровые корни.\nOUTPUT.TXTYES200100NONO[Лучшие попытки]\nТребуется написать программу, которая определит, является ли счастливым билет с заданным номером.\nВходные данные\nВходной файл INPUT.TXT содержит номер счастливого билета. Номер может начинаться с нулей и содержит от 1 до 100 цифр.\nВыходные данные\nВ выходной текстовый файл OUTPUT.TXT выведите «YES», если билет счастливый и «NO» иначе.",
    "complexity": 26,
    "memory": 16000,
    "time": 1000,
    "examples": [
      {
        "input": "0015420",
        "output": "YES"
      },
      {
        "input": "00100",
        "output": "NO"
      }
    ]
  },
  {
    "id": 127,
    "name": "Путь",
    "description": "В неориентированном графе требуется найти длину кратчайшего пути между двумя вершинами.\nOUTPUT.TXT3[Лучшие попытки]\nВходные данные\nВо входном файле INPUT.TXT записано сначала число N - количество вершин в графе (1 ≤ N ≤ 100). Затем записана матрица смежности (0 обозначает отсутствие ребра, 1 - наличие ребра). Затем записаны номера двух вершин - начальной и конечной.\nВыходные данные\nВ выходной файл OUTPUT.TXT выведите длину кратчайшего пути. Если пути не существует, выведите одно число -1.",
    "complexity": 40,
    "memory": 16000,
    "time": 1000,
    "examples": [
      {
        "input": "5\n\n0 1 0 0 1\n\n1 0 1 0 0\n\n0 1 0 0 0\n\n0 0 0 0 0\n\n1 0 0 0 0\n\n3 5",
        "output": "3"
      }
    ]
  },
  {
    "id": 202,
    "name": "Поиск подстроки",
    "description": "Найти все вхождения строки T в строке S.\nOUTPUT.TXT0 5 7[Лучшие попытки]\nВходные данные\nВ первой строке входного файла INPUT.TXT записана строка S, во второй строке записана строка T. Обе строки состоят только из английских букв. Длины строк могут быть в диапазоне от 1 до 50 000 включительно.\nВыходные данные\nВ выходной файл OUTPUT.TXT нужно вывести все вхождения строки T в строку S в порядке возрастания. Нумерация позиций строк начинается с нуля.",
    "complexity": 38,
    "memory": 16000,
    "time": 1000,
    "examples": [
      {
        "input": "ababbababa\naba",
        "output": "0 5 7"
      }
    ]
  },
  {
    "id": 201,
    "name": "Пакетная обработка процессов",
    "description": "Для ускорения прохождения «коротких» заданий на ЭВМ выбран пакетный режим работы с квантованием времени процессора. Это значит, что всем заданиям пакета по очереди представляется процессор на одинаковое время 10 с (круговой циклический алгоритм разделения времени). Если в течение этого времени заканчивается выполнение задания, оно покидает систему и освобождает процессор. Если же очередного кванта времени не хватает для завершения задания, оно помещается в конец очереди — пакета. Последнее задание пакета выполняется без прерываний. Пакет считается готовым к вводу в ЭВМ, если в нем содержится K заданий. Новый пакет вводится в ЭВМ после окончания обработки предыдущего. Задания поступают в систему с интервалом времени 60 ± 30 с и характеризуются временем работы процессора 50 ± 45 с.OUTPUT.TXT\n00:02:14 00:04:17\n00:02:24 00:04:33\n00:04:33 00:04:57\n00:04:43 00:05:06\n00:05:45 00:06:12\n00:05:55 00:07:17\n[Лучшие попытки]\nТребуется смоделировать процесс обработки N заданий и определить время начала и окончания каждого процесса.\nВходные данные\nНа первой строке входного файла INPUT.TXT находятся числа N и K  - число процессов и количество процессов в пакете (1 ≤ N ≤ 1000, 1 ≤ K ≤ 100). Гарантируется, что N делится на K. Далее следуют N строк с информацией о времени формирования и необходимое время на выполнение для каждого процесса. Все процессы стартуют в один день и следуют в порядке возрастания времени ввода их в систему.\nВыходные данные\nВыведите в выходной файл OUTPUT.TXT для каждого процесса в отдельной строке время его старта и время окончания через пробел в формате ЧЧ:ММ:СС.",
    "complexity": 53,
    "memory": 16000,
    "time": 1000,
    "examples": [
      {
        "input": "6 2\n\n00:01:02 63\n\n00:02:14 76\n\n00:03:16 14\n\n00:04:02 19\n\n00:04:36 17\n\n00:05:45 75",
        "output": "00:02:14 00:04:17\n\n00:02:24 00:04:33\n\n00:04:33 00:04:57\n\n00:04:43 00:05:06\n\n00:05:45 00:06:12\n\n00:05:55 00:07:17"
      }
    ]
  },
  {
    "id": 241,
    "name": "Праздники",
    "description": "Парламент некоторой страны принял новый закон о праздничных днях. Согласно этому закону первые K дней года, а также 23 февраля и 8 марта объявляются праздничными, а все остальные праздники отменяются. При этом все выходные (суббота и воскресенье), попавшие на праздничные дни, переносятся на следующие за этими праздниками рабочие дни. \nOUTPUT.TXT42101616[Лучшие попытки]\nВ зависимости от того, на какой день недели приходится 1 января, количество нерабочих дней, которые идут подряд, может меняться.\nТребуется определить, какое наибольшее количество нерабочих дней может идти подряд.\nВходные данные\nВо входном файле INPUT.TXT записано единственное число K (1 ≤ K ≤ 50).\nВыходные данные\nВ выходной файл OUTPUT.TXT требуется записать единственное число — наибольшее количество нерабочих дней, идущих подряд.",
    "complexity": 39,
    "memory": 16000,
    "time": 1000,
    "examples": [
      {
        "input": "2",
        "output": "4"
      },
      {
        "input": "10",
        "output": "16"
      }
    ]
  },
  {
    "id": 286,
    "name": "Больше-меньше - 2",
    "description": "Программист Билл занимается разработкой программного обеспечения для новейшего робота-исследователя, которого учёные планируют отправить на Марс с целью поиска там следов разумной жизни. Модули, которые отвечают за передвижение робота и сбор проб грунта, Билл уже скачал из Интернета. Оставалось лишь научить робота отличать разумные формы жизни от неразумных. Для этого Боб несколько месяцев посещал программистские форумы, и, наконец, нашёл подходящий модуль. Теперь, чтобы определить, является ли тот или иной объект представителем внеземной расы, роботу достаточно сравнить два вещественных числа.\nOUTPUT.TXT\u003c212312.3\u003e\u003e=\u003c[Лучшие попытки]\nОднако за несколько часов до запуска корабля на Марс обнаружилось, что робот неправильно сравнивает вещественные числа! Чтобы исправить эту ошибку, учёные обратились за помощью к Вам.\n31234567812345678.0=\nВходные данные4-1.01.0\u003c\nВходной файл INPUT.TXT состоит из двух строк, в каждой из которых записано по одному вещественному числу без ведущих нулей. Целая и дробная части отделяются точкой, которая может быть опущена, если число целое. Каждое из чисел содержит не более 10000 цифр. Если число равно нулю, то знака минус в его записи нет.\nВыходные данные\nВ выходной файл OUTPUT.TXT выведите один символ ‘\u003c’, если первое число меньше второго, ‘\u003e’, если больше, и ‘=’, если числа равны.",
    "complexity": 43,
    "memory": 16000,
    "time": 1000,
    "examples": [
      {
        "input": "2.39\n3.61",
        "output": "\u0026lt;"
      },
      {
        "input": "123\n12.3",
        "output": "\u0026gt;"
      },
      {
        "input": "12345678\n12345678.0",
        "output": "="
      },
      {
        "input": "-1.0\n1.0",
        "output": "\u0026lt;"
      }
    ]
  },
  {
    "id": 222,
    "name": "Дремучий лес",
    "description": "Будем говорить, что для наблюдателя лес является дремучим, если из своего текущего положения наблюдатель видит только деревья. Вам дана карта леса и координаты точки, в которой находится наблюдатель. Требуется определить, кажется ли лес дремучим данному наблюдателю.\niOUTPUT.TXTYES22\n10 10\n0 0 1\n0.5 0 2\nNONO[Лучшие попытки]\nНа карте леса все деревья изображаются кругами. При этом в лесу бывают сросшиеся деревья (изображения таких деревьев на карте пересекаются), также одно дерево может находиться внутри другого. Точка, в которой стоит наблюдатель, не лежит внутри или на границе ни одного из деревьев. \n5\nВходные данныеi\nВо входном файле INPUT.TXT содержится сначала целое число N — количество деревьев (1 ≤ N ≤ 50 000). Затем идут два числа, задающих координаты наблюдателя. Затем идет N троек чисел, задающих деревья. Первые два числа  xi и yi задают координаты центра, а третье ri — радиус. Все координаты и радиусы деревьев задаются точно, и выражаются вещественными числами не более чем с 2 знаками после десятичной точки (-105 ≤ xi, yi ≤ 105, 0 \u003c ri ≤ 105).\ni\n5Выходные данные\ni\nВ выходной файл OUTPUT.TXT нужно вывести сообщение YES, если лес является дремучим, и NO иначе.\n5Примеры\n№INPUT.TXTOUTPUT.TXT\n14\n0 0\n2 2 2\n-2 2 2\n-2 -2 2\n2 -2 2\nYES\n22\n10 10\n0 0 1\n0.5 0 2\nNO\nДля отправки решения задачи необходимо зарегистрироваться и авторизоваться!\n[Обсуждение]\n\n  [Все попытки]\n\n  [Лучшие попытки]\nwindow.yaContextCb.push(()=\u003e{\n  Ya.Context.AdvManager.render({\n    renderTo: 'yandex_rtb_R-A-122393-3',\n    blockId: 'R-A-122393-3'\n  })\n})",
    "complexity": 59,
    "memory": 16000,
    "time": 1000,
    "examples": [
      {
        "input": "4\n\n0 0\n\n2 2 2\n\n-2 2 2\n\n-2 -2 2\n\n2 -2 2",
        "output": "YES"
      },
      {
        "input": "2\n\n10 10\n\n0 0 1\n\n0.5 0 2",
        "output": "NO"
      }
    ]
  },
  {
    "id": 276,
    "name": "Разбиение на части",
    "description": "Необходимо представить целое число N в виде суммы M примерно равных целых чисел. Будем считать, что числа примерно равны, если они отличаются друг от друга не более чем на единицу.\nOUTPUT.TXT3 3 3 4272 89 9 9 9 9 9 9 99 9 9 9 9 9 9 9[Лучшие попытки]\nВходные данные\nВо входном файле INPUT.TXT записаны два натуральных числа N и M через пробел, каждое из которых не превосходит 30000.\nВыходные данные\nВыходной файл OUTPUT.TXT должен содержать M примерно равных целых чисел, сумма которых должна быть равна N. Все числа следует вывести в одной строке в порядке неубывания через пробел.",
    "complexity": 21,
    "memory": 16000,
    "time": 1000,
    "examples": [
      {
        "input": "13 4",
        "output": "3 3 3 4"
      },
      {
        "input": "72 8",
        "output": "9 9 9 9 9 9 9 9"
      }
    ]
  },
  {
    "id": 284,
    "name": "Подмассив массива",
    "description": "",
    "complexity": 15,
    "memory": 16000,
    "time": 1000,
    "examples": [
      {
        "input": "6\n \n1 2 3 4 5 6\n\n5\n\n1 1\n\n2 6\n\n3 4\n\n5 6\n\n2 4",
        "output": "1\n\n2 3 4 5 6\n\n3 4\n\n5 6\n\n2 3 4"
      }
    ]
  },
  {
    "id": 287,
    "name": "Профессор",
    "description": "В одном очень известном университете один очень известный профессор очень быстро произносил свои лекции, так, что ничего невозможно было разобрать. Но недавно студент Вилли решил провести исследование по изучению словарного запаса профессора. С этой целью он даже посетил одну лекцию и записал всё сказанное на ней на диктофон. Затем, прокручивая дома запись с десятикратным замедлением, Вилли смог записать всё, что сказал профессор.\nOUTPUT.TXT3210 3bbaabbbabb66[Лучшие попытки]\nНо вот незадача – профессор говорил так быстро, что, даже прослушивая замедленную запись, нельзя было точно сказать, где он делал паузы между словами. Таким образом, у Вилли есть некоторый текст, состоящий из n маленьких английских букв – лекция, которая была прочитана профессором. Теперь Вилли хочет знать, какое количество различных слов длины m мог использовать в своей лекции профессор.\nВходные данные\nПервая строка входного файла INPUT.TXT содержит два числа n и m (1 ≤ m ≤ n ≤ 100) – длина лекции и длина слова. Вторая строка содержит n английских символов - текст лекции профессора.\nВыходные данные\nВ выходной файл OUTPUT.TXT выведите одно число – количество слов длины m, которые профессор мог использовать в своей лекции.",
    "complexity": 26,
    "memory": 16000,
    "time": 1000,
    "examples": [
      {
        "input": "3 1\nabc",
        "output": "3"
      },
      {
        "input": "10 3\nbbaabbbabb",
        "output": "6"
      }
    ]
  },
  {
    "id": 198,
    "name": "Система линейных уравнений",
    "description": "Требуется решить невырожденную систему, состоящую из N линейных уравнений с N неизвестными:\nijnOUTPUT.TXT7 323\n7 -9  1   2\n0  6  5 -15\n3 -3  2  -9\n8 5 -98 5 -9[Лучшие попытки]\ni\nВходные данные4\nВ первой строке входного файла INPUT.TXT задано натуральное число N – ранг системы, далее следуют N строк, каждая из которых состоит из N+1 целых чисел: коэффициенты i-й строки уравнения – N чисел aij и bi. (N ≤ 100, |aij|\u003c10, |bi|\u003c104). Числа разделены одним или несколькими пробелами. Перед первым числом строки может быть ноль, один или несколько пробелов.\nВыходные данные\nВ единственную строку выходного файла OUTPUT.TXT нужно вывести через пробел корни приведенной во входном файле системы линейных уравнений. Корни следует выводить в порядке возрастания их номеров (x1, x2, ... xn). Гарантируется, что все корни целые и не превосходят значения 10 по абсолютной величине.",
    "complexity": 57,
    "memory": 16000,
    "time": 1000,
    "examples": [
      {
        "input": "2\n\n5  9  62\n\n9 -3  54",
        "output": "7 3"
      },
      {
        "input": "3\n\n7 -9  1   2\n\n0  6  5 -15\n\n3 -3  2  -9",
        "output": "8 5 -9"
      }
    ]
  },
  {
    "id": 251,
    "name": "Калах",
    "description": "OUTPUT.TXT7 0 0 022 2\n1\n1\n2\n2\n1 11 1[Лучшие попытки]\nДля игры в калах используют несколько коробочек, расставленных по кругу, в которых лежат шарики. Ход осуществляется следующим образом. Берутся все шарики из одной коробочки, и начинают раскладываться по одному в коробочки подряд начиная со следующей по часовой стрелке. Если шариков больше, чем коробочек, то процесс продолжается (шарики раскладываются по второму кругу, по третьему и т.д.), пока не будут разложены все шарики. В коробочку, из которой взяли шарики, их тоже кладут. Пример одного хода приведен на рисунке. Справа шарики пронумерованы в том порядке, в котором они раскладывались по коробочкам.\nПетя, тренируясь перед соревнованиями, разложил шарики по коробочкам произвольным образом, и стал делать произвольные ходы. После каждого хода он записывал номер коробочки, в которую попадал последний шарик. В некоторый момент он решил восстановить начальную конфигурацию по конечной и по тем записям, которые он делал. Напишите программу, которая поможет ему в этом.\nВходные данные\nВ первой строке входного файла INPUT.TXT записано два натуральных числа: N ≤ 100 — количество коробочек и M ≤ 100 — количество сделанных Петей ходов. Коробочки пронумерованы последовательно по часовой стрелке числами от 1 до N. В следующих N строках (либо в одной строке через пробел) записано количество шариков в первой, второй, …, N ой коробочках в конечной конфигурации. В следующих M строках (либо в одной строке через пробел) записаны номера коробочек, в которые был положен последний шарик на первом, втором, ..., M-ом ходу соответственно. Общее количество шариков не превосходит 109.\nВыходные данные\nВ выходной файл OUTPUT.TXT требуется вывести N чисел: первоначальное количество шариков в первой, второй, ..., N-ой коробочках.",
    "complexity": 57,
    "memory": 16000,
    "time": 1000,
    "examples": [
      {
        "input": "4 1\n\n1 2 2 2\n\n4",
        "output": "7 0 0 0"
      },
      {
        "input": "2 2\n\n1\n\n1\n\n2\n\n2",
        "output": "1 1"
      }
    ]
  },
  {
    "id": 290,
    "name": "База террористов",
    "description": "Спецслужбы получили информацию о том, что в труднодоступной части Муравийской пустыни расположена хорошо замаскированная база террористов. В руки спецслужб попал и план этой базы, которая с большой высоты выглядит как группа скальных обломков, весьма часто встречающихся среди Муравийских песков. Президент отдал приказ уничтожить базу крылатыми ракетами. Ваша задача - по карте пустыни, полученной со спутника и плану базы определить количество возможных положений базы террористов. Помните, что террористы могли привезти на территорию базы камни!\nbOUTPUT.TXT421 3\n#..\n3 6\n##..##\n.#.#.#\n#.#...\n664[Лучшие попытки]\nВходные данныеb33 3\n#..\n#.#\n#..\n5 36\n#......#........................#...\n#.#....#.#...#.........#............\n#......#.#...##....#...##......###..\n.......#.....#...#.#...##........#.#\n...................#.....#.......#..\n4\nВ первой cтроке файла INPUT.TXT записаны числа Nb и Mb (1 ≤ Nb, Mb ≤ 20). В следующих Nb строках записан план базы. Каждая из этих строк содержит по Mb символов \"#\" (ASCII 35 ) или \".\" (ASCII 46). Символ \"#\" обозначает фрагмент базы, а символ \".\" - песок. В следующей строке записаны числа Nd и Md (1 ≤ Nd, Md ≤ 100). И остаток файла содержит карту участка пустыни на котором, предположительно, находится база террористов -  Nd строк по Md символов \"#\" или \".\" в каждой.\nb\nbВыходные данные\nd\nЗапишите в файл OUTPUT.TXT количество возможных положений базы террористов.\ndПримеры\nd\n№INPUT.TXTOUTPUT.TXT\n12 2\n#.\n##\n3 5\n#.#.#\n#####\n.###.\n4\n21 3\n#..\n3 6\n##..##\n.#.#.#\n#.#...\n6\n33 3\n#..\n#.#\n#..\n5 36\n#......#........................#...\n#.#....#.#...#.........#............\n#......#.#...##....#...##......###..\n.......#.....#...#.#...##........#.#\n...................#.....#.......#..\n4\nd\ndДля отправки решения задачи необходимо зарегистрироваться и авторизоваться!\nd\n\n  [Обсуждение]\n\n  [Все попытки]\n\n  [Лучшие попытки]\nwindow.yaContextCb.push(()=\u003e{\n  Ya.Context.AdvManager.render({\n    renderTo: 'yandex_rtb_R-A-122393-3',\n    blockId: 'R-A-122393-3'\n  })\n})",
    "complexity": 32,
    "memory": 16000,
    "time": 1000,
    "examples": [
      {
        "input": "2 2\n\n#.\n\n##\n\n3 5\n\n#.#.#\n\n#####\n\n.###.",
        "output": "4"
      },
      {
        "input": "1 3\n\n#..\n\n3 6\n\n##..##\n\n.#.#.#\n\n#.#...",
        "output": "6"
      },
      {
        "input": "3 3\n\n#..\n\n#.#\n\n#..\n\n5 36\n\n#......#........................#...\n\n#.#....#.#...#.........#............\n\n#......#.#...##....#...##......###..\n\n.......#.....#...#.#...##........#.#\n\n...................#.....#.......#..",
        "output": "4"
      }
    ]
  },
  {
    "id": 257,
    "name": "Кубическое уравнение",
    "description": "Напишите программу, которая будет искать все целые X, удовлетворяющие уравнению A*X3 + B*X2 + C*X + D = 0, где A, B, C, D – заданные целые коэффициенты.\nOUTPUT.TXT1 320 1 2 300[Лучшие попытки]\nВходные данные\nВо входном файле INPUT.TXT записаны четыре целых числа: A, B, C, D. Все числа по модулю не превышают 2×109.\nВыходные данные\nВ выходной файл OUTPUT.TXT выведите сначала количество различных корней этого уравнения в целых числах, а затем сами корни в возрастающем порядке. Если уравнение имеет бесконечно много корней, то следует вывести в выходной файл одно число -1 (минус один).",
    "complexity": 56,
    "memory": 16000,
    "time": 1000,
    "examples": [
      {
        "input": "1 0 0 -27",
        "output": "1 3"
      },
      {
        "input": "0 1 2 3",
        "output": "0"
      }
    ]
  },
  {
    "id": 113,
    "name": "Фермер",
    "description": "Фермер решил на своем квадратном участке земли вспахать пашню квадратной формы максимальной площади, т.к. он посчитал, что именно квадратная форма пашни наиболее удобна для обработки. Но на его участке присутствуют деревья и хозяйственные постройки, которые он никуда не хочет переносить, а так же иные места, не пригодные для пашни. Для удобства он составил квадратную карту местности N×N в форме матрицы и пометил нулями непригодные для пашни зоны, в остальные зоны он поставил единицу.\nOUTPUT.TXT9[Лучшие попытки]\nНеобходимо помочь фермеру определить максимальную площадь пашни.\nВходные данные\nВ первой строке входного файла INPUT.TXT записано единственное натуральное число N (1 ≤ N ≤ 1000) – длина стороны квадратного участка фермы. Далее, следует N строк, в каждой из которых находится последовательность (без пробелов) нулей и единиц, описывающих ферму.\nВыходные данные\nВ выходной файл OUTPUT.TXT необходимо вывести максимально возможную площадь пашни.",
    "complexity": 46,
    "memory": 128000,
    "time": 1000,
    "examples": [
      {
        "input": "7\n\n1101101\n\n1111110\n\n1011100\n\n0011100\n\n1000010\n\n1100111\n\n1001110",
        "output": "9"
      }
    ]
  },
  {
    "id": 239,
    "name": "Узор",
    "description": "В комнате решили сделать паркетный пол. Причем есть задумка выложить на полу некоторый узор. Плитки паркета, которыми выкладывается пол комнаты, состоят из квадратиков 1×1, каждый из которых может быть либо белым, либо черным.  В свою очередь, комната имеет размеры N×M. На плане комнаты указано, какой квадрат комнаты какого цвета должен быть. Существует несколько форм паркетных плиток:\nOUTPUT.TXT15[Лучшие попытки]\nКвадратики одной паркетной плитки могут быть окрашены по-разному. Может существовать несколько типов плиток одинаковой формы, но окрашенных по-разному. Плитки разных типов могут иметь разную стоимость. Количество плиток каждого типа не ограничено. Плитки разрешается как угодно поворачивать (на углы, кратные 90 градусам). Не разрешается разламывать плитки, а также класть их лицевой стороной вниз.\nИзначально, какая-то часть пола может уже быть выложена плиткой. Требуется определить минимальную стоимость плитки, необходимой для того, чтобы замостить оставшуюся часть комнаты.\nВходные данные\nВ первой строке входного файла INPUT.TXT записаны три числа: N, M (размеры комнаты) и K (количество доступных видов плитки). 1 ≤ N ≤ 8, 1 ≤ M ≤ 8, 1 ≤ K ≤ 10. Далее идет описание желаемой раскраски пола. Описание представляет собой N строчек по M чисел в каждой, где 0 обозначает белый цвет, 1 — черный, 2 — то, что квадрат уже выложен плиткой. В последних K строчках находятся описания доступных типов плитки в следующем формате:\n\u003cформа\u003e \u003cстоимость\u003e \u003cокраска\u003e\n\u003cФорма\u003e — это число от 1 до 4, описывающее форму плитки (см. рисунок выше)\n\u003cСтоимость\u003e — это натуральное число, не превосходящее 10000, задающее стоимость одной плитки такого типа\n\u003cОкраска\u003e — это от одного до трех чисел 0 или 1. Количество чисел совпадает с количеством квадратиков, из которых состоит плитка. Числа задают цвета квадратиков плитки в том порядке, в каком квадратики пронумерованы на рисунке.\nВыходные данные\nВ выходной файл OUTPUT.TXT выведите единственное число — минимальную стоимость укладки или –1, если требуемым образом уложить плитку невозможно.",
    "complexity": 80,
    "memory": 16000,
    "time": 1000,
    "examples": [
      {
        "input": "4 3 3\n\n2 2 2\n\n2 0 0\n\n2 1 2\n\n2 2 2\n\n2 10 0 0\n\n1 5 1\n\n4 6 0 0 1",
        "output": "15"
      }
    ]
  },
  {
    "id": 166,
    "name": "Сообщество роботов",
    "description": "Сообщество роботов живет по следующим законам:\nроботы объединяются так, чтобы собрать за год наибольшее количество новых роботов;OUTPUT.TXT828 22222[Лучшие попытки]\nодин раз в начале года они объединяются в группы по три или пять роботов;\nза год группа из трех роботов собирает 5 новых, а группа из 5 роботов – 9 новых;\nроботы объединяются так, чтобы собрать за год наибольшее количество новых роботов;\nкаждый робот живет ровно три года после сборки.\nкаждый робот живет ровно три года после сборки.\nВ начале первого года было K роботов и все они были только что собраны.\nТребуется написать программу, которая найдет количество роботов в начале N-го года.\nВходные данные\nВходной файл INPUT.TXT содержит записанные через пробел числа K (1 ≤ K ≤ 500) и N  (1 ≤ N ≤ 100).\nВыходные данные\nВыходной файл OUTPUT.TXT должен содержать одно число - количество роботов в начале N-го года. Количество роботов меньше, чем 231.",
    "complexity": 31,
    "memory": 16000,
    "time": 1000,
    "examples": [
      {
        "input": "3 2",
        "output": "8"
      },
      {
        "input": "8 2",
        "output": "22"
      }
    ]
  },
  {
    "id": 228,
    "name": "Валютные махинации",
    "description": "Петя, изучая, как меняется курс рубля по отношению к доллару и евро, вывел закон, по которому происходят эти изменения (или думает, что вывел :) ). По этому закону Петя рассчитал, каков будет курс рубля по отношению к доллару и евро в ближайшие N дней. \nOUTPUT.TXT4000.00[Лучшие попытки]\nУ Пети есть 100 рублей. В каждый из дней он может обменивать валюты друг на друга по текущему курсу без ограничения количества (при этом курс доллара по отношению к евро соответствует величине, которую можно получить, обменяв доллар на рубли, а потом эти рубли — на евро). Поскольку Петя будет оперировать не с наличной валютой, а со счетом в банке, то он может совершать операции обмена с любым (в том числе и нецелым) количеством единиц любой валюты.\nНапишите программу, которая вычисляет, какое наибольшее количество рублей сможет получить Петя к исходу N-го дня.\nЗаконы изменения курсов устроены так, что в течение указанного периода рублевый эквивалент той суммы, которая может оказаться у Пети, не превысит 108 рублей.\nВходные данные\nПервая строка входного файла INPUT.TXT содержит одно число N (1 ≤ N ≤ 5000). В каждой из следующих N строк записано по 2 числа, вычисленных по Петиным законам для соответствующего дня — сколько рублей будет стоить 1 доллар, и сколько рублей будет стоить 1 евро. Все эти значения не меньше 0.01 и не больше 10000. Значения заданы точно и выражаются вещественными числами не более, чем с двумя знаками после десятичной точки.\nВыходные данные\nВ выходной файл OUTPUT.TXT выведите искомую величину с двумя знаками после десятичной точки.",
    "complexity": 39,
    "memory": 16000,
    "time": 1000,
    "examples": [
      {
        "input": "4\n\n1 10\n\n10 5.53\n\n5.53 1.25\n\n6 5",
        "output": "4000.00"
      }
    ]
  },
  {
    "id": 227,
    "name": "Сломанный калькулятор",
    "description": "У калькулятора есть две ячейки памяти: содержимое первой из них всегда отображается на табло, вторая является буфером. В начальный момент времени на табло калькулятора отображается целое число X, а в буфере записано число 0. У калькулятора работают только две клавиши: «+» и «=». При нажатии на «+» число, которое в данный момент отображено на табло, копируется в буфер. При нажатии на «=» число из буфера прибавляется к числу, отображенному на табло, и результат отображается на табло, число в буфере при этом не меняется.\nOUTPUT.TXT02-2 -63+==36-1[Лучшие попытки]\nТребуется за наименьшее число нажатий клавиш на калькуляторе добиться того, чтобы на табло было отображено число Y.\nПояснение +==31 86+===+=+===+=\nВходные данные42 5-1\nВходной файл INPUT.TXT содержит два целых числа X и Y. Каждое из этих чисел по модулю не превышает 109.\nВыходные данные\nВ выходной файл OUTPUT.TXT выведите одно число — количество нажатий клавиш, которое потребуется для получения числа Y. Если из числа X получить число Y с помощью указанных операций невозможно, в выходной файл выведите одно число –1.",
    "complexity": 52,
    "memory": 16000,
    "time": 1000,
    "examples": [
      {
        "input": "1 1",
        "output": "0"
      },
      {
        "input": "-2 -6",
        "output": "3"
      },
      {
        "input": "1 8",
        "output": "6"
      },
      {
        "input": "2 5",
        "output": "-1"
      }
    ]
  },
  {
    "id": 229,
    "name": "Двухтуровая олимпиада",
    "description": "Как известно, личная олимпиада по информатике проходит в два тура. На каждом из туров участники получают какие-то баллы, при этом итоговый балл определяется как сумма полученных баллов. Известны баллы, которые каждый участник получил на каждом из туров. Жюри хочет фальсифицировать итоги олимпиады так, чтобы победил «нужный» участник. \nOUTPUT.TXT2\n2 4\n[Лучшие попытки]\nПри этом жюри может делать следующие «подтасовки» (можно делать несколько «подтасовок» применительно как к одному и тому же, так и к разным турам):\nПрибавить к результатам всех участников по одному из туров одно и то же положительное число.\n  Умножить результаты участников по одному из туров на некоторый коэффициент, больший 1.\nПри этом должна сохраниться правдоподобность результатов, которая заключается в том, что никто из участников не должен получить больше 100 баллов за каждый из туров.\nОпределите список участников, которые в результате таких фальсификаций могут оказаться победителями олимпиады (то есть в сумме за два тура иметь не меньше баллов, чем каждый из остальных участников).\nВходные данные\nВо входном файле INPUT.TXT записано сначала число участников N (1 ≤ N ≤ 1000), затем N пар чисел — результаты каждого участника за 1-й и за 2-й туры (результат участника за тур — это вещественное число от 0 до 100) не более, чем с 3 знаками после десятичной точки.\nВыходные данные\nВ выходной файл OUTPUT.TXT выведите сначала количество участников, которые смогут стать победителями олимпиады, а затем в возрастающем порядке их номера.",
    "complexity": 58,
    "memory": 16000,
    "time": 1000,
    "examples": [
      {
        "input": "4\n\n45 90\n\n70 80\n\n0 0\n\n75 75",
        "output": "2\n\n2 4"
      }
    ]
  },
  {
    "id": 285,
    "name": "Костер",
    "description": "Во время военного похода на морского пехотинца Джо было возложено ответственное задание – развести костёр и поддерживать в нём огонь ровно m минут. Для этого у Джо есть спички и n поленьев, причём Джо известно точное время сгорания каждого полена.\nnOUTPUT.TXTyes22 53 9nonono[Лучшие попытки]\nДжо разжигает огонь в момент времени t = 0 и сразу бросает в него одно или несколько поленьев. Затем он должен подбрасывать в огонь новые поленья, не позволяя костру угаснуть (т.е. если последнее полено в костре догорает в момент времени t, то новое полено может быть брошено в огонь не позднее t – 1). Поленья, брошенные в огонь, загораются мгновенно. Одновременно Джо может бросить в огонь любое количество поленьев. Джо должен бросить в огонь все n поленьев.\ni34 103 3 3 3no\nПомогите Джо определить, сможет ли он подбрасывать поленья в огонь таким образом, чтобы костер горел ровно m минут.\ni\nВходные данные\nПервая строка входного файла INPUT.TXT содержит целые числа n и m \n(1 ≤ n ≤ 100, 1 ≤ m ≤ 1000) – количество поленьев и время, в течение которого Джо должен поддерживать огонь в костре. Вторая строка входного файла содержит n целых чисел a1, a2, ..., an, где ai (2 ≤ ai ≤ 1000) – время сгорания i-ого полена в минутах.\nВыходные данные\nВ выходной файл OUTPUT.TXT выведите строку «yes», если Джо сможет поддерживать огонь в костре ровно m минут, и строку «no» в противном случае.",
    "complexity": 24,
    "memory": 16000,
    "time": 1000,
    "examples": [
      {
        "input": "3 7\n2 3 5",
        "output": "yes"
      },
      {
        "input": "2 5\n3 9",
        "output": "no"
      },
      {
        "input": "4 10\n3 3 3 3",
        "output": "no"
      }
    ]
  },
  {
    "id": 165,
    "name": "Только вправо или вниз",
    "description": "Игровое  поле N×M заполняется целыми числами, одно неотрицательное целое число в  каждой клетке. Цель игры состоит в том, чтобы пройти по любому разрешенному пути от верхнего левого угла до правого нижнего. Целое число в каждой клетке указывает, какой длины шаг должен быть из текущей клетки. Все шаги могут быть или направо или вниз. Если в результате какого-либо шага игрок покидает пределы поля, такой шаг запрещается.\nOUTPUT.TXT3[Лучшие попытки]\nНа рис. 1 приведен пример игрового поля 3×4, где сплошная окружность показывает положение начала, а пунктирная окружность – цель. Рис. 2 показывает три возможных пути от начала до цели для рассматриваемого примера игрового поля, с удаленными промежуточными числами.\nТребуется написать программу, которая определит число различных вариантов путей от верхнего левого угла до правого нижнего.\nВходные данные\nВходной файл INPUT.TXT содержит в первой строке размеры поля N (1 ≤ N ≤ 70) и M (1 ≤ M ≤ 70). В последующих N строках входного файла, каждая из которых описывает отдельную строку игрового поля, записаны через пробел по M целых чисел от 0 до 100 – длины шагов из клеток данной строки.\nВыходные данные\nВыходной файл OUTPUT.TXT должен содержать одно число - число различных вариантов путей от верхнего левого угла до правого нижнего. Для каждого поля будет менее чем 231 различных путей.",
    "complexity": 32,
    "memory": 16000,
    "time": 1000,
    "examples": [
      {
        "input": "3 4\n\n2 1 1 2\n\n3 2 1 44\n\n3 1 1 0",
        "output": "3"
      }
    ]
  },
  {
    "id": 250,
    "name": "Двоякие числа",
    "description": "Натуральное число называется двояким, если в его десятичной записи встречается не более двух различных цифр. Например, числа 3, 23, 33, 100, 12121 — двоякие, а числа 123 и 9980 — нет. \nOUTPUT.TXT122220122020202011111[Лучшие попытки]\nДля заданного натурального числа N требуется найти ближайшее к нему двоякое число.\n31111111111\nВходные данные\nВо входном файле INPUT.TXT записано одно натуральное число N, не превосходящее 30 000.\nВыходные данные\nВ выходной файл OUTPUT.TXT требуется выдать единственное число —  ближайшее двоякое к числу N. Если таких чисел несколько, то следует вывести наименьшее.",
    "complexity": 27,
    "memory": 16000,
    "time": 1000,
    "examples": [
      {
        "input": "123",
        "output": "122"
      },
      {
        "input": "2012",
        "output": "2020"
      },
      {
        "input": "11111",
        "output": "11111"
      }
    ]
  },
  {
    "id": 277,
    "name": "Школьная алгебра",
    "description": "Трёхчлен a + bx + сy от двух переменных x и y однозначно определяется коэффициентами a, b и c. Написать программу, которая по заданным a, b и c выводит соответствующий трёхчлен, записанный с использованием алгебраических соглашений:\nзнак \"+\" опускается, если он предшествует отрицательному коэффициенту;OUTPUT.TXT2x-y23 0 -23-2y3-2y[Лучшие попытки]\nкоэффициент при члене, содержащем переменную, опускается, если его модуль равен единице;\nчлен, коэффициент при котором равен нулю, опускается (кроме случая, когда все коэффициенты равны нулю, тогда трехчлен состоит из одной цифры 0);\nзнак \"+\" опускается, если он предшествует отрицательному коэффициенту;\nзнак \"+\" опускается, если он стоит в начале выражения (так называемый унарный плюс);\nзнак умножения между коэффициентом и переменной опускается.\nзнак \"+\" опускается, если он стоит в начале выражения (так называемый унарный плюс);\nзнак умножения между коэффициентом и переменной опускается.\nПри этом запрещено менять местами члены.\nВходные данные\nВо входном файле INPUT.TXT через пробел записаны целые коэффициенты a, b и с, каждое из которых не превосходит 30000 по абсолютной величине.\nВыходные данные\nВыходной файл OUTPUT.TXT должен содержать трехчлен, записанный с использованием алгебраических соглашений.",
    "complexity": 27,
    "memory": 16000,
    "time": 1000,
    "examples": [
      {
        "input": "0 2 -1",
        "output": "2x-y"
      },
      {
        "input": "3 0 -2",
        "output": "3-2y"
      }
    ]
  },
  {
    "id": 107,
    "name": "Красивые номера",
    "description": "",
    "complexity": 52,
    "memory": 16000,
    "time": 1000,
    "examples": [
      {
        "input": "2",
        "output": ""
      },
      {
        "input": "2",
        "output": ""
      },
      {
        "input": "2",
        "output": ""
      },
      {
        "input": "3",
        "output": ""
      },
      {
        "input": "2",
        "output": ""
      },
      {
        "input": "3",
        "output": ""
      },
      {
        "input": "3",
        "output": ""
      },
      {
        "input": "4",
        "output": ""
      },
      {
        "input": "3",
        "output": ""
      },
      {
        "input": "5",
        "output": ""
      },
      {
        "input": "8727333",
        "output": "8727-333\n5"
      },
      {
        "input": "8827291",
        "output": "88-272-91\n4"
      }
    ]
  },
  {
    "id": 240,
    "name": "Кубическая гостиница",
    "description": "В связи с проведением межпланетного шашечного турнира было принято решение о строительстве орбитальной гостиницы. Она должна была представлять собой большой куб из N×N×N блоков – маленьких кубиков 1×1×1, и каждый блок должен был быть окрашен снаружи со всех сторон в какой-то один цвет. При этом некоторые блоки могли быть покрашены в один и тот же цвет. \nOUTPUT.TXT1122\nZZ ZZ ZZ ZZ ZZ ZZ\nZZ ZZ ZZ ZZ ZZ ZZ\n88[Лучшие попытки]\nЧерез год были сделаны фотографии гостиницы с каждой из 6 сторон: спереди, слева, сзади, справа, сверху, снизу. За год эксплуатации могло случиться так, что из-за непрочного крепления некоторые блоки, из которых была построена гостиница, оторвались и улетели в открытый космос. Комиссия по восстановлению гостиницы хочет по сделанным снимкам установить максимальное возможное количество оставшихся блоков.\nИтак, вам необходимо по видам гостиницы (куба N×N×N, из которого, возможно, выкинуты некоторые кубики 1×1×1) с 6 сторон определить, из какого максимального количества блоков 1×1×1 она может состоять. Может оказаться так, что гостиница состоит из двух или более не связанных между собой частей.\nВходные данные\nВ первой строке входного файла INPUT.TXT находится число N — размер гостиницы (1≤N≤10). На следующих N строках записаны виды гостиницы с 6 сторон (в следующем порядке: спереди, слева, сзади, справа, сверху, снизу). Каждый такой вид представляет собой таблицу N×N, в которой различными заглавными английскими буквами обозначены различные цвета, а символом «.» (точка) — то, что в этом месте можно будет смотреть прямо сквозь гостиницу. Два последовательных вида отделяются друг от друга ровно одним пробелом в каждой из N строк.\nНижняя граница вида сверху соответствует верхней границе вида спереди, а верхняя граница вида снизу — нижней границе вида спереди. Для видов спереди, сзади и с боков верх и низ вида соответствуют верху и низу гостиницы.\nВходные данные корректны, то есть во входном файле описано состояние, которое может получиться.\nВыходные данные\nВыведите в выходной файл OUTPUT.TXT одно число — искомое максимальное количество оставшихся блоков в гостинице.",
    "complexity": 60,
    "memory": 16000,
    "time": 1000,
    "examples": [
      {
        "input": "3\n\n.R. YYR .Y. RYY .Y. .R.\n\nGRB YGR BYG RBY GYB GRB\n\n.R. YRR .Y. RRY .R. .Y.",
        "output": "11"
      },
      {
        "input": "2\n\nZZ ZZ ZZ ZZ ZZ ZZ\n\nZZ ZZ ZZ ZZ ZZ ZZ",
        "output": "8"
      }
    ]
  },
  {
    "id": 282,
    "name": "Прямоугольники",
    "description": "Найдите количество невырожденных прямоугольников со сторонами, параллельными осям координат, вершины которых лежат в точках с целыми координатами внутри или на границе прямоугольника, противоположные углы которого находятся в точках (0, 0) и (W, Н).\nOUTPUT.TXT122 1339[Лучшие попытки]\nВходные данные32 29\nВходной файл INPUT.TXT содержит два натуральных числа W и Н, не превосходящих 1000.\nВыходные данные\nВ выходной файл OUTPUT.TXT выведите ответ на задачу.",
    "complexity": 32,
    "memory": 16000,
    "time": 1000,
    "examples": [
      {
        "input": "1 1",
        "output": "1"
      },
      {
        "input": "2 1",
        "output": "3"
      },
      {
        "input": "2 2",
        "output": "9"
      }
    ]
  },
  {
    "id": 283,
    "name": "Рунные слова",
    "description": "Руны — это древние магические знаки, которые наши предки использовали как буквы. Говорят, что рунные знаки обладают магическими свойствами, а при сложении рун в слова их магическая сила многократно возрастает. Если кузнец изготовит доспехи и начертит там определенные руны в определенном порядке, то доспехи будут наделены необычайными магическими силами.\nOUTPUT.TXTYes2IoItIsWasteNoNo[Лучшие попытки]\nДля того, чтобы стать обладателем таких доспехов достаточно просто принести кузнецу начертания этих рунных знаков. А вот, чтобы стать обладателем рунного знака приходилось немало потрудиться. Воины добывали начертания рун других языков и наречий в боях или получали их в качестве наград в благодарность за оказанные услуги.\nНо так или иначе и в этом деле развелись жулики. По подозрениям ученых кузнец Игнатус Мошеникус изготавливал благородным воинам фальшивые рунные слова. Из древних преданий ученым стало достоверно известно, что каждая руна записывается из двух, трех или четырех английских букв. Причем первая буква рунного слова всегда записывается как заглавная, а все остальные являются маленькими. Ученые перевели несколько, выкованных этим кузнецом, рунных слов на английский язык и теперь нуждаются в Вашей помощи. Проверьте, является ли приведенное слово рунным.\nВходные данные\nВ единственной строке входного файла INPUT.TXT содержится слово. Оно представляет собой непустую строку, длиной не более 100000 символов, содержащую только большие и маленькие буквы английского алфавита.\nВыходные данные\nВ выходной файл OUTPUT.TXT выведите «Yes», если слово является рунным и  «No» в противном случае.",
    "complexity": 25,
    "memory": 16000,
    "time": 1000,
    "examples": [
      {
        "input": "IoIsTheBest",
        "output": "Yes"
      },
      {
        "input": "IoItIsWaste",
        "output": "No"
      }
    ]
  },
  {
    "id": 242,
    "name": "Раскраска плиток",
    "description": "После того, как к удивлению тётушки Полли, её забор был покрашен, она поручила Тому Сойеру обновить краску на плитках, которыми был вымощен их квадратный двор. Двор был покрыт N×N одинаковыми квадратными плитками, каждая из которых когда-то давно была покрашена в один из K цветов (K \u003c N). Краска на плитках потускнела и Тому Сойеру поручили их покрасить, на этот раз в один любой цвет (из тех же К цветов). Покрасить нужно все плитки, в том числе и те, которые уже были покрашены в этот цвет раньше.\nOUTPUT.TXT4 122 1\n1 1\n1 1\n2 12 1[Лучшие попытки]\nОкунув кисть в ведро с краской один раз, можно перекрасить один горизонтальный или вертикальный ряд плиток. Чтобы разнообразить свою работу, Том придумал, что ряд плиток можно красить только цветом, которым на данный момент уже покрашены (старой или новой краской) по крайней мере две плитки выбранного ряда (вертикального или горизонтального). За один раз Том собирается красить допустимым цветом весь ряд целиком, независимо от того, были ли уже перекрашены какие-либо его плитки ранее. Помогите Тому определить, какое минимальное число раз ему придется обмакнуть кисть, чтобы перекрасить все плитки, следуя придуманным правилам, и в какой цвет окажутся окрашены все плитки.\nВходные данные\nВ первой строке входного файла INPUT.TXT записаны через пробел два числа: N — количество плиток в одном ряду (1 \u003c N ≤ 200) и K (1 ≤ K \u003c N). В каждой из следующих N строк записаны N натуральных чисел, обозначающих номера цветов красок, в которые когда-то были выкрашены соответствующие плитки данного горизонтального ряда. Номера цветов — натуральные числа в диапазоне от 1 до K.\nВыходные данные\nВ выходной файл OUTPUT.TXT выведите два числа: L — какое минимальное число раз придется окунать кисть в ведро с краской, и номер краски С, в которую в результате окажутся перекрашены все плитки двора. Если таких красок может быть несколько, то выведите любую из них. Если перекрасить все плитки, следуя придуманным Томом правилам, нельзя, выведите два раза число 0.",
    "complexity": 66,
    "memory": 16000,
    "time": 1000,
    "examples": [
      {
        "input": "3 2\n\n1 2 1\n\n2 1 1\n\n1 2 2",
        "output": "4 1"
      },
      {
        "input": "2 1\n\n1 1\n\n1 1",
        "output": "2 1"
      }
    ]
  },
  {
    "id": 299,
    "name": "Волейбол",
    "description": "Партия в волейболе выигрывается командой, которая первой набирает 25 очков с преимуществом минимум в два очка. В случае равного счета 24-24, игра продолжается до достижения преимущества в 2 очка (26-24; 27-25).\nOUTPUT.TXT1251677700220:251761039350070176103935007016123801841550[Лучшие попытки]\nДве сыгранные партии, закончившиеся с одинаковым счетом, будем считать разными, если строки, в которых выписан порядок набора очков командами, не равны.\n325:2316123801841550\nКомитет по проведению соревнований по волейболу заинтересовался, количеством различных партий, заканчивающихся счетом 25:23. Их оказалось 16123801841550.\nОпределить, сколько существует различных партий, заканчивающихся заданным счетом.\nВходные данные\nВо входном файле INPUT.TXT указан конечный счет в партии (то есть такой, при котором победа в партии отдаётся одной из команд). Также известно, что ни одна из команд не набрала более 40 очков.\nВыходные данные\nВ выходной файл OUTPUT.TXT выведите количество всевозможных партий, которые заканчиваются данным счетом.",
    "complexity": 56,
    "memory": 16000,
    "time": 1000,
    "examples": [
      {
        "input": "25:12",
        "output": "1251677700"
      },
      {
        "input": "20:25",
        "output": "1761039350070"
      },
      {
        "input": "25:23",
        "output": "16123801841550"
      }
    ]
  },
  {
    "id": 128,
    "name": "Один конь",
    "description": "На шахматной доске N×N в клетке (x1,y1) стоит голодный шахматный конь. Он хочет попасть в клетку (x2,y2), где растет вкусная шахматная трава. Какое наименьшее количество ходов он должен для этого сделать?\nOUTPUT.TXT2[Лучшие попытки]\nВходные данные\nВходной файл INPUT.TXT содержит пять чисел: N, x1, y1, x2, y2 (5 ≤ N ≤ 20, 1 ≤ x1, y1, x2, y2 ≤ N). Левая верхняя клетка доски имеет координаты (1,1), правая нижняя - (N,N).\nВыходные данные\nВ выходной файл OUTPUT.TXT необходимо вывести наименьшее число ходов коня.",
    "complexity": 41,
    "memory": 16000,
    "time": 1000,
    "examples": [
      {
        "input": "5\n\n1 1\n\n3 1",
        "output": "2"
      }
    ]
  },
  {
    "id": 252,
    "name": "Сортировка масс",
    "description": "Как известно, Россия является одним из ведущих экспортеров нефти. Разные страны мира, от достаточно больших до сравнительно маленьких, нуждаются в этой нефти как в воздухе. В ее состав в больших количествах входят ароматические углеводороды, которые обуславливают ее высокое качество. Доставка нефти в пункт назначения осуществляется с помощью нефтепровода. Считается, что количество нефти, отправленное в страну назначения, равно количеству полученной нефти. На самом деле это, конечно, не так. Как и многое другое, нефть воруют некоторые несознательные личности. Причем неофициально считается, что больше нефти воруют в нефтепроводах тех стран, куда нефти посылается больше (может быть, несознательные личности считают, что приносят, таким образом, меньше ущерба, кто знает...). Официальное руководство компании «Русская Нефть» решило узнать, правдивый это слух или нет, чтобы усилить (а может просто установить) охрану на тех нефтепроводах, где больше всего воруют нефть.\n6OUTPUT.TXT32 mg\n234 g\n4576 mp\n2 t\n2 Mg\n[Лучшие попытки]\nДля этого им нужно отсортировать нефтепроводы по количеству нефти, которая протекает в направлении какой-то страны за сутки. У компании «Русская Нефть», как и у любой уважающей себя компании, есть несколько штатных программистов, и руководство предложило им решить эту, в сущности, нетрудную задачу. Но программистов поставило в тупик то, что данные о количестве нефти представлены в разных единицах измерения (начиная от граммов и заканчивая тоннами).\n9\nПоэтому они решили найти человека, который был бы в силах решить эту задачу за них, и обещают взять его на работу в эту перспективную и процветающую компанию. Решите задачу, и, кто знает, может, повезет именно Вам?\n6\nВходные данные\nВ первой строке входного файла INPUT.TXT находится целое число N (1 ≤ N ≤ 1000) — количество нефтепроводов. В каждой из следующих N строк находится количество (точнее — масса) нефти, транспортированной по соответствующему нефтепроводу за сутки, по одному в строке. Масса нефти задана целым числом от 1 до 10000 с указанием соответствующей единицы измерения. Число и единица измерения разделены ровно одним пробелом. Единица измерения задается одной из трех букв: g (граммы), p (пуды), t (тонны), причем перед этой буквой может стоять одна из приставок: m (милли-), k (кило-), M (мега-), G (гига-). Напомним, что эти приставки обозначают умножение единицы измерения на 10–3, 103, 106 и 109 соответственно. 1 пуд = 16380 граммов, 1 тонна = 106 граммов.\nВыходные данные\nВ выходной файл OUTPUT.TXT выведите N строк, в которых должны быть записаны массы нефти в порядке неубывания. Каждая строка должна описывать массу нефти в одном из нефтепроводов. Массы должны быть описаны в том же формате, в котором записаны во входном файле. Приоритет равных масс, записанных в разных форматах должен соответствовать порядку, в котором они следуют во входном файле.",
    "complexity": 44,
    "memory": 16000,
    "time": 1000,
    "examples": [
      {
        "input": "5\n\n234 g\n\n4576 mp\n\n2 t\n\n32 mg\n\n2 Mg",
        "output": "32 mg\n\n234 g\n\n4576 mp\n\n2 t\n\n2 Mg"
      }
    ]
  },
  {
    "id": 220,
    "name": "Мышка с колесиком",
    "description": "Выходные данные\nВ выходной файл OUTPUT.TXT нужно вывести наименьшее возможное количество пересечений курсора мыши с линиями таблицы.",
    "complexity": 54,
    "memory": 16000,
    "time": 1000,
    "examples": [
      {
        "input": "10 3 10 10\n\n4\n\n0 1 6 9",
        "output": "0"
      },
      {
        "input": "10 6 2 21\n\n11\n\n0 2 4 6 8 10 12 14 16 18 20",
        "output": "21"
      }
    ]
  },
  {
    "id": 294,
    "name": "Болты и гайки",
    "description": "Вновь созданная фирма купила заброшенные склады на окраине города. Новому заведующему складами поручили произвести учёт в короткие сроки. Всё шло хорошо, пока случайно не рассыпали контейнеры с болтами и гайками на каждом складе, после чего собрали их в общие (для болтов и гаек) контейнеры, потеряв при этом несколько деталей. \nOUTPUT.TXT3700025000 15 234000 17 225360053600[Лучшие попытки]\nПомогите оценить нанесённый ущерб на каждом складе, приняв во внимание, что, помимо потерянных деталей, болт (или гайка) считается непригодным, если он не имеет соответствующей гайки (или болта).\nВходные данные\nВо входном файле INPUT.TXT описано текущее положение на складе. В первой строке через пробел записаны три целых числа: k1, l1, m1 – начальное число болтов (100 ≤ k1 ≤ 30000, k1 кратно 100), процент потерянных деталей (0 ≤ l1 ≤ 100) и стоимость одного болта (1 ≤ m1 ≤ 100) соответственно. Во второй строке через пробел записаны также три целых числа: k2, l2, m2 – начальное число гаек (100 ≤ k2 ≤ 30000, k2 кратно 100), процент потерянных деталей (0 ≤ l2 ≤ 100) и стоимость одной гайки (1 ≤ m2 ≤ 100) соответственно.\nВыходные данные\nВ выходной OUTPUT.TXT выведите одно целое число – размер ущерба.",
    "complexity": 17,
    "memory": 16000,
    "time": 1000,
    "examples": [
      {
        "input": "1000 10 100\n1200 20 90",
        "output": "37000"
      },
      {
        "input": "5000 15 23\n4000 17 22",
        "output": "53600"
      }
    ]
  },
  {
    "id": 258,
    "name": "Скорая помощь",
    "description": "",
    "complexity": 42,
    "memory": 16000,
    "time": 1000,
    "examples": [
      {
        "input": "89 20 41 1 11",
        "output": "2 3"
      },
      {
        "input": "11 1 1 1 1",
        "output": "0 1"
      },
      {
        "input": "3 2 2 2 1",
        "output": "-1 -1"
      }
    ]
  },
  {
    "id": 292,
    "name": "Простой цифровой корень",
    "description": "Определим простой цифровой корень (ПЦК) натурального числа N следующим образом. Если N - простое число, то ПЦК(N) = N. Если число однозначное, но не простое (то есть 1, 4, 6, 8 или 9), то ПЦК(N) = 0. В остальных случаях ПЦК(N) = ПЦК(S(N)), где S(N) - сумма цифр числа N.\nOUTPUT.TXT0233311[Лучшие попытки]\nВходные данные312811\nВо входном файле INPUT.TXT записано число N (1 ≤ N ≤ 231-1).\nВыходные данные\nЗапишите в файл OUTPUT.TXT простой цифровой корень числа N.",
    "complexity": 31,
    "memory": 16000,
    "time": 1000,
    "examples": [
      {
        "input": "1",
        "output": "0"
      },
      {
        "input": "3",
        "output": "3"
      },
      {
        "input": "128",
        "output": "11"
      }
    ]
  },
  {
    "id": 297,
    "name": "Кругляши",
    "description": "Однажды в просторах рунета появился следующий ребус:\nOUTPUT.TXT322035162241[Лучшие попытки]\n157892 = 3\n     203516 = 2\n     409578 = 4\n     236271 = ?34095784[Решение]\nНикто так и не смог его разгадать. Позже оказалось, что число в правом столбце равно сумме \"кругляшей\", которые есть в цифрах числа, расположенного слева. Ваша задача написать программу, которая определяет, сколько кругляшей в числе.\n42362711\nВходные данные\nВо входном файле INPUT.TXT записано целое число N (0 ≤ N ≤ 10100).\nВыходные данные\nВ выходной файл OUTPUT.TXT выведите одно число – количество кругляшей в числе N.",
    "complexity": 16,
    "memory": 16000,
    "time": 1000,
    "examples": [
      {
        "input": "157892",
        "output": "3"
      },
      {
        "input": "203516",
        "output": "2"
      },
      {
        "input": "409578",
        "output": "4"
      },
      {
        "input": "236271",
        "output": "1"
      }
    ]
  },
  {
    "id": 295,
    "name": "Шифровка",
    "description": "Разведкой был перехвачен ряд шифровок, которые передавал Джеймс Бонд. Известно, что каждое послание зашифровано методом циклического сдвига. Суть которого в том, что каждая буква заменяется на букву, отстоящую в алфавите от первой на определенном расстоянии. Это расстояние называется знаменателем шифра. Так, при знаменателе шифра 2 буква D превратится в F, буква Q – в S, а Z – в B. Известно, что Бонд использует знаменатели от 0 до 25, и составляет послания исключительно из заглавных букв английского алфавита. Знаменатели в шифровках постоянно меняются, так что расшифровать содержимое послания будет не просто. После тщательного анализа удалось примерно определить предмет посланий. Теперь для каждого послания точно известно одно из входящих туда слов.\nOUTPUT.TXTHELLOAMERICA2KHOORDPHULFD\nHELLOAMERICAHELLOAMERICAHELLOAMERICAIMPOSSIBLE[Лучшие попытки]\nВходные данные3KHOORDPHULFD\nKHOORDPHULFCIMPOSSIBLE\nВ первой строке входного файла INPUT.TXT содержится строка с перехваченным посланием, а во второй строке – слово, которое обязательно присутствует в этом послании. Обе строки состоят только из заглавных английских букв и содержат от 1 до 40 символов.\nВыходные данные\nВ выходной файл OUTPUT.TXT выведите расшифрованный текст, либо сообщение «IMPOSSIBLE», если разгадать шифровку невозможно. В тех случаях, когда расшифровка возможна с различными знаменателями, то следует вывести вариант с наименьшим таким значением.",
    "complexity": 29,
    "memory": 16000,
    "time": 1000,
    "examples": [
      {
        "input": "HELLOAMERICA\n\nAMERICA",
        "output": "HELLOAMERICA"
      },
      {
        "input": "KHOORDPHULFD\n\nHELLOAMERICA",
        "output": "HELLOAMERICA"
      },
      {
        "input": "KHOORDPHULFD\n\nKHOORDPHULFC",
        "output": "IMPOSSIBLE"
      }
    ]
  },
  {
    "id": 296,
    "name": "Лиса Алиса и кот Базилио",
    "description": "Лиса Алиса и кот Базилио вырастили денежное дерево. И выросли на нем трехрублевые и пятирублевые золотые монеты. Лиса Алиса себе взяла трехрублевые монеты, а коту Базилио отдала пятирублевые монеты. Посетовав на свою скромность, она предложила впредь рассчитываться за покупки вместе, деньги давать без сдачи и минимальным числом монет. Известно, что они сделали покупку стоимостью N рублей, при этом они рассчитались без сдачи.\nOUTPUT.TXT1 12111 21 23 0[Лучшие попытки]\nВам следует написать программу, которая определяет: сколько монет внес кот Базилио, и сколько монет внесла лиса Алиса.\n3153 0[Решение]\nВходные данные\nВо входном файле INPUT.TXT записано одно натуральное число N – стоимость покупки в рублях (7 \u003c N \u003c 1000).\nВыходные данные\nВ выходной OUTPUT.TXT выведите два целых числа через пробел: число монет, которые отдал кот Базилио и число монет, которые отдала лиса Алиса.",
    "complexity": 22,
    "memory": 16000,
    "time": 1000,
    "examples": [
      {
        "input": "8",
        "output": "1 1"
      },
      {
        "input": "11",
        "output": "1 2"
      },
      {
        "input": "15",
        "output": "3 0"
      }
    ]
  },
  {
    "id": 291,
    "name": "Словарь",
    "description": "Дан некоторый набор букв и словарь. Ваша задача - подсчитать, сколько различных слов из словаря можно составить из этих букв.\nOUTPUT.TXT027\nbee\nfly\ncat\ndog\nant\newe\ngnu\ntancugd\n33[Лучшие попытки]\nВходные данные\nВ первой строке файла INPUT.TXT записано число N - количество слов в словаре (0 ≤ N ≤ 1000). В следующих N строках файла записано по одному слову из словаря. Слова содержат от 1 до 10 маленьких английских букв. Все слова в словаре различны. В последней строке файла записан набор букв (от 1 до 100 букв).\nВыходные данные\nЗапишите в файл OUTPUT.TXT количество различных слов из словаря, которые можно составить из заданного набора букв.",
    "complexity": 31,
    "memory": 16000,
    "time": 1000,
    "examples": [
      {
        "input": "7\n \nant\n\nbee\n\ncat\n\ndog\n\newe\n\nfly\n\ngnu\n\nbew",
        "output": "0"
      },
      {
        "input": "7\n\nbee\n\nfly\n\ncat\n\ndog\n\nant\n\newe\n\ngnu\n\ntancugd",
        "output": "3"
      }
    ]
  },
  {
    "id": 307,
    "name": "Атлеты",
    "description": "Художественная гимнастика – это вид спорта, где всё познаётся в сравнении, здесь нельзя, как в беге или плавании, измерить результат спортсмена с точностью до сотой доли секунды. Поэтому на выступлениях оценки выступлениям дают судьи. При выставлении оценок судьи ориентируются не только на текущее выступление, но, безусловно, сравнивают текущее выступление с выступлениями, показанными ранее. Кроме того, учитывается сложность показанного упражнения и рейтинг спортсмена.\nOUTPUT.TXT322 2 2\n1 1\n2 2\n00[Лучшие попытки]\nКаждый выход спортсмена описывается двумя числами: номер спортсмена в рейтинге (наиболее профессиональные спортсмены имеют наибольший номер), и номер исполненного упражнения (упражнения нумеруются, начиная с самых простых). Судья сравнивает каждый выход спортсмена с каждым из выполненных ранее выходов. Если в результате сравнения получается, что спортсмен с большим номером показал более простое упражнение, чем спортсмен с меньшим номером, судья удивляется. Следует учитывать, что один выход может удивить судью несколько раз. Один спортсмен может выполнить несколько выходов, так же, как и одно упражнение может быть показано несколькими спортсменами – но такие выходы в сравнении судью не удивляют. Спортсмен не исполняет уже показанное упражнение повторно. Требуется подсчитать, сколько раз за время выступлений будет удивлён судья.\nВходные данные\nПервая строка входного файла INPUT.TXT содержит количество спортсменов N (0 \u003c N ≤ 250), количество упражнений M (0 \u003c M ≤ 250) и количество выходов P. Следующие P строк содержат по два числа, описывающие выход спортсмена – номер спортсмена и номер упражнения.\nВыходные данные\nВ выходной файл OUTPUT.TXT выведите, сколько раз был удивлен судья.",
    "complexity": 50,
    "memory": 16000,
    "time": 1000,
    "examples": [
      {
        "input": "3 3 4\n\n3 1\n\n1 2\n\n1 3\n\n3 2",
        "output": "3"
      },
      {
        "input": "2 2 2\n\n1 1\n\n2 2",
        "output": "0"
      }
    ]
  },
  {
    "id": 301,
    "name": "Код",
    "description": "В наши дни в космосе находятся сотни спутников, и все они обмениваются данными. При этом система распознавания сигналов работает по схеме «Свой-Чужой». Один из спутников отправляет запрос другому спутнику в формате двух целых чисел, а второй спутник отвечает первому так же двумя целыми числами. Первые два числа первого спутника представляют собой сумму цифр и количество цифр тех двух чисел, которыми должен ответить второй спутник. При этом в качестве ответа должны получиться числа, представляющие наибольшее и наименьшее возможные значения, которые могут быть сформированы по описанному выше методу.\nOUTPUT.TXT100 10022 3200 101200 1013000 1002[Лучшие попытки]\nВам предстоит написать программу, формирующую ответ для второго спутника по известным числам, полученным от первого спутника.\n33 43000 1002\nВходные данные\nВо входном файле INPUT.TXT записаны 2 натуральных числа S и K, представляющих сумму и количество цифр соответственно (K  ≤ 100). При этом гарантируется, что возможно составить хотя бы одно K-значное число, сумма цифр которого равна S.\nВыходные данные\nВ выходной файл OUTPUT.TXT выведите два числа – ответ второго спутника. При этом следует помнить, что все числа не имеют лидирующих нулей.",
    "complexity": 36,
    "memory": 16000,
    "time": 1000,
    "examples": [
      {
        "input": "1 3",
        "output": "100 100"
      },
      {
        "input": "2 3",
        "output": "200 101"
      },
      {
        "input": "3 4",
        "output": "3000 1002"
      }
    ]
  },
  {
    "id": 303,
    "name": "Цифры",
    "description": "Составить программу, удаляющую одну цифру из N-значного числа, такую, чтобы плюс-минус сумма была наибольшей. Плюс-минус сумма – это сумма с чередованием цифр числа с разными знаками: для числа 764 это +7-6+4. Если удалить цифру 7, то будет +6-4=2, если удалить цифру 6, то будет +7-4=3, если удалить цифру 4, то будет +7-6=1. При этом видно, что максимум достигается при удалении средней цифры 6 и равен 3.\nOUTPUT.TXT3262748611414[Лучшие попытки]\nВходные данные\nВо входном файле INPUT.TXT записано натуральное N-значное число (2 ≤ N ≤ 50).\nВыходные данные\nВ выходной файл OUTPUT.TXT выведите значение наибольшей суммы.",
    "complexity": 27,
    "memory": 16000,
    "time": 1000,
    "examples": [
      {
        "input": "764",
        "output": "3"
      },
      {
        "input": "6274861",
        "output": "14"
      }
    ]
  },
  {
    "id": 261,
    "name": "Лотерея",
    "description": "На одном из телеканалов каждую неделю проводится следующая лотерея. В течение недели участники делают свои ставки. Каждая ставка заключается в назывании какого-либо M-значного числа в системе счисления с основанием K (то есть, по сути, каждый участник называет M цифр, каждая из которых лежит в диапазоне от 0 до K–1). Ведущие нули в числах допускаются.\n3MOUTPUT.TXT621 1 10100000[Лучшие попытки]\nВ некоторый момент прием ставок на текущий розыгрыш завершается, и после этого ведущий в телеэфире называет выигравшее число (это также M-значное число в K-ичной системе счисления). После этого те телезрители, у кого первая цифра их числа совпала с первой цифрой числа, названного ведущим, получают выигрыш в размере A1 рублей. Те, у кого совпали первые две цифры числа — получают A2 рублей (при этом если у игрока совпала вторая цифра, но не совпала первая, он не получает ничего). Аналогично угадавшие первые три цифры получают A3 рублей. И так далее. Угадавшие все число полностью получают AM рублей. При этом если игрок угадал t первых цифр, то он получает At рублей, но не получает призы за угадывание t–1, t–2  и т.д. цифр. Если игрок не угадал первую цифру, он не получает ничего.\nM1\nt\nНапишите программу, которая по известным ставкам, сделанным телезрителями, находит число, которое должна назвать телеведущая, чтобы фирма-организатор розыгрыша выплатила в качестве выигрышей минимальную сумму. Для вашего удобства ставки, сделанные игроками, уже упорядочены по неубыванию.\n2\nВходные данныеM\nВ первой строке входного файла INPUT.TXT задаются числа N (количество телезрителей, сделавших свои ставки, 1 ≤ N ≤ 100000), M (длина чисел 1 ≤ M ≤ 10) и K (основание системы счисления 2 ≤ K ≤ 10). В следующей строке записаны M чисел A1, A2, …, AM, задающих выигрыши в случае совпадения только первой, первых двух,... , всех цифр (1 ≤ A1 ≤ A2 ≤ … ≤ AM ≤ 100000). В каждой из следующих N строк либо в одной строке через пробел записано по одному M-значному K-ичному числу. Числа идут в порядке неубывания.\nВыходные данные\nВ выходной файл OUTPUT.TXT выведите наименьшую сумму, которую придется выплатить в качестве выигрыша.",
    "complexity": 71,
    "memory": 16000,
    "time": 1000,
    "examples": [
      {
        "input": "10 3 2\n1 3 100\n000 000 001 010 100 100 100 100 110 111",
        "output": "6"
      },
      {
        "input": "1 1 10\n100\n0",
        "output": "0"
      }
    ]
  },
  {
    "id": 311,
    "name": "Сумма факториалов",
    "description": "Факториалом натурального числа K называется произведение K!=1×2×3×…×K.  \nOUTPUT.TXT122339[Лучшие попытки]\nТребуется написать программу, которая по заданному числу N вычислит сумму 1!+2!+…+N! .\n339\nВходные данные\nВходной файл INPUT.TXT содержит одно натуральное число N (N ≤ 200).\nВыходные данные\nВыходной файл OUTPUT.TXT должен содержать все десятичные знаки искомой суммы.",
    "complexity": 45,
    "memory": 16000,
    "time": 1000,
    "examples": [
      {
        "input": "1",
        "output": "1"
      },
      {
        "input": "2",
        "output": "3"
      },
      {
        "input": "3",
        "output": "9"
      }
    ]
  },
  {
    "id": 302,
    "name": "Города",
    "description": "Для исследования поверхности Марса ученым необходимо разработать систему оповещения, которая смогла бы передавать информацию по цепному принципу между городами, которые планируется там построить.\nOUTPUT.TXT2.2423\n2 0\n0 2\n4 2\n2.832.83[Лучшие попытки]\nПри этом в каждом городе необходимо построить радиостанцию таким образом, чтобы была связь между всеми городами. При этом все такие станции должны передавать сигнал друг другу на равном расстоянии R. Таким образом, будет возможна передачи информации из одного города в другой только тогда, когда расстояние между ними не более R.\nПо заданным координатам городов, в целях экономии энергии радиостанций, Вам следует определить минимальное значение R, при котором информация сможет быть доставлена из любого города во все остальные.\nВходные данные\nВ первой строке входного файла INPUT.TXT сначала записано натуральное число N – количество городов (N ≤ 1000). Далее идет N строк, содержащих вещественные координаты (Xi, Yi) соответствующего города. (-10000 ≤ Xi, Yi ≤ 10000). Предполагается, что все города находятся на плоскости.\nВыходные данные\nВ выходной файл OUTPUT.TXT выведите одно вещественное число – наименьший радиус радиостанций. Число следует вывести с двумя знаками после запятой, без лидирующих нулей, в формате, приведенном в примерах.",
    "complexity": 55,
    "memory": 16000,
    "time": 1000,
    "examples": [
      {
        "input": "4\n\n0 0\n\n2 0\n\n0 2\n\n2 3",
        "output": "2.24"
      },
      {
        "input": "3\n\n2 0\n\n0 2\n\n4 2",
        "output": "2.83"
      }
    ]
  },
  {
    "id": 298,
    "name": "Стрелок",
    "description": "Стрелок стоит в центре стрельбища. На стрельбище несколько мишеней. Пули стрелка пробивают мишени насквозь, не теряя скорости, и могут поразить все мишени, стоящие на одной линии.\nOUTPUT.TXT426\n2 2\n-2 2\n-2 -2\n2 -2\n1 1\n-1 3\n55[Лучшие попытки]\nБудем считать, что стрелок стоит в начале координат. Известны координаты всех мишеней (для простоты будем считать их геометрические размеры пренебрежимо малыми). Определите минимальное число выстрелов, необходимых стрелку для поражения всех мишеней.\nВходные данные\nПервая строка входного файла INPUT.TXT содержит натуральное число N – количество мишеней (N ≤ 20). Далее идет N строк с информацией о координатах каждой мишени, при этом в каждой строке указывается два целых числа через пробел X и Y (-10 ≤ X, Y ≤ 10).\nВыходные данные\nВ выходной файл OUTPUT.TXT выведите одно целое число – наименьшее количество выстрелов, необходимых для поражения всех мишеней.",
    "complexity": 28,
    "memory": 16000,
    "time": 1000,
    "examples": [
      {
        "input": "4\n\n2 2\n\n-2 2\n\n-2 -2\n\n2 -2",
        "output": "4"
      },
      {
        "input": "6\n\n2 2\n\n-2 2\n\n-2 -2\n\n2 -2\n\n1 1\n\n-1 3",
        "output": "5"
      }
    ]
  },
  {
    "id": 309,
    "name": "К-удивительные числа",
    "description": "Переворотом числа X назовем число, в котором все цифры числа X стоят в обратном порядке. Например, переворотом числа 6372 является число 2736, а числа 7800 - 87. Назовем K-удивительным такое число, которое в сумме со своим переворотом дает число K.\nOUTPUT.TXT22105099[Лучшие попытки]\nНапример, у числа 222 имеется всего два K-удивительных числа: 111 и 210, а у числа 1050 имеется девять K-удивительных числа: 129, 228, 327, 426, 525, 624, 723, 822, 921.\nТребуется написать программу, которая по заданному K определит количество K-удивительных чисел.\nВходные данные\nВходной файл INPUT.TXT содержит одно натуральное число K (1 ≤ K ≤ 106).\nВыходные данные\nВыходной файл OUTPUT.TXT должен содержать одно число - количество K-удивительных чисел.",
    "complexity": 25,
    "memory": 16000,
    "time": 1000,
    "examples": [
      {
        "input": "222",
        "output": "2"
      },
      {
        "input": "1050",
        "output": "9"
      }
    ]
  },
  {
    "id": 310,
    "name": "Рамка из клеток",
    "description": "Прямоугольник состоит из X×Y квадратных клеток одинакового размера. Из него вырезан прямоугольник размером (X-2)×(Y-2) так, что осталась рамка шириной в одну клетку. Определить, можно ли покрыть всю рамку плитками размером A×1. Запас плиток неограничен, плитки не накладываются одна на другую и за пределы рамки не выходят.\nOUTPUT.TXT1223 3 23 3 31010[Лучшие попытки]\nТребуется написать программу, которая решает эту задачу.\nВходные данные\nВходной текстовый файл INPUT.TXT содержит в первой строке натуральное число K – количество тестов (1 ≤ K ≤ 10). В следующих K строках записаны по три натуральных числа: X, Y - размеры рамки, А – размер плитки (3 ≤ X, Y ≤ 2×109, 1 ≤ A ≤ 2×109). Числа разделены пробелами.\nВыходные данные\nВыходной текстовый файл OUTPUT.TXT должен содержать одну строку из K символов 0 или 1 (1 - если покрытие существует, 0 - иначе).",
    "complexity": 33,
    "memory": 16000,
    "time": 1000,
    "examples": [
      {
        "input": "1\n3 3 1",
        "output": "1"
      },
      {
        "input": "2\n3 3 2\n3 3 3",
        "output": "10"
      }
    ]
  },
  {
    "id": 319,
    "name": "Точки отрезка",
    "description": "Концы отрезка на плоскости имеют целочисленные координаты.\nOUTPUT.TXT220 0 -2 -23310[Лучшие попытки]\nТребуется написать программу, которая вычислит, сколько всего точек с целочисленными координатами принадлежат этому отрезку.\n31 1 1 1010\nВходные данные\nВходной  файл INPUT.TXT содержит четыре числа – координаты концов отрезка (x1, y1) и (x2, y2). Каждая из координат не превышает по абсолютной величине значения 109.\nВыходные данные\nВыходной файл OUTPUT.TXT должен содержать одно число – количество точек на заданном отрезке, имеющих целочисленные координаты.",
    "complexity": 42,
    "memory": 16000,
    "time": 1000,
    "examples": [
      {
        "input": "1 1 2 2",
        "output": "2"
      },
      {
        "input": "0 0 -2 -2",
        "output": "3"
      },
      {
        "input": "1 1 1 10",
        "output": "10"
      }
    ]
  },
  {
    "id": 316,
    "name": "Телеграфный перевод",
    "description": "Телеграфный перевод оплачивается по 7 рублей за каждую полную и неполную сотню рублей. Например, за перевод 123 рублей надо заплатить 14 рублей – 7 рублей за полную сотню и 7 рублей за 23 рубля – неполную сотню. Некто попросил переслать ему зарплату в N рублей, взяв деньги за перевод из этой зарплаты.\nOUTPUT.TXT3 72108100 7100 7[Лучшие попытки]\nТребуется написать программу, которая найдет, какую максимальную сумму некто сможет получить, и сколько денег будет стоить перевод.\nВходные данные\nВходной файл INPUT.TXT содержит одно натуральное число N (8 ≤ N ≤ 6∙104).\nВыходные данные\nВыходной файл OUTPUT.TXT должен содержать два натуральных числа – максимальную сумму и стоимость перевода. Числа разделить одним пробелом.",
    "complexity": 29,
    "memory": 16000,
    "time": 1000,
    "examples": [
      {
        "input": "10",
        "output": "3 7"
      },
      {
        "input": "108",
        "output": "100 7"
      }
    ]
  },
  {
    "id": 318,
    "name": "Следующее число",
    "description": "Задано натуральное число N.\nOUTPUT.TXT222445[Лучшие попытки]\nТребуется написать программу, которая найдет следующее за ним число, в двоичном разложении которого столько же единиц, сколько в двоичном разложении числа N.\n335\nВходные данные\nВходной файл INPUT.TXT содержит одно натуральное число N (N ≤ 230).\nВыходные данные\nВыходной файл OUTPUT.TXT должен содержать ответ на задачу.",
    "complexity": 36,
    "memory": 16000,
    "time": 1000,
    "examples": [
      {
        "input": "1",
        "output": "2"
      },
      {
        "input": "2",
        "output": "4"
      },
      {
        "input": "3",
        "output": "5"
      }
    ]
  },
  {
    "id": 312,
    "name": "Арифметическая прогрессия",
    "description": "Заданы первый и второй элементы арифметической прогрессии. Требуется написать программу, которая вычислит элемент прогрессии по ее номеру.\n2OUTPUT.TXT9[Лучшие попытки]\nВходные данные2[Решение]\nПервая строка входного файла INPUT.TXT содержит три целых числа, разделенных пробелами – первый элемент прогрессии A1 (1 ≤ A1 ≤ 1000), второй элемент прогрессии A2 (1 ≤ A2 ≤ 1000), и номер требуемого элемента N (1 ≤ N ≤ 1000).\nВыходные данные\nВыходной файл OUTPUT.TXT должен содержать одно целое число - N-й элемент арифметической прогрессии.",
    "complexity": 15,
    "memory": 16000,
    "time": 1000,
    "examples": [
      {
        "input": "1 5 3",
        "output": "9"
      }
    ]
  },
  {
    "id": 313,
    "name": "Ежеминутные автобусы",
    "description": "На автобусную остановку каждую минуту подходит автобус одного из маршрутов. Диспетчерская служба собрала данные за N минут – номера маршрутов каждого автобуса.\nOUTPUT.TXT42423 23 41 4111[Лучшие попытки]\nТребуется определить максимально возможное время ожидания для пассажира, желающего уехать определенным маршрутом. Т.е. в данной последовательности номеров маршрутов нужно найти два самых удаленных числа, равных между собой, между которыми нет равных им. Например, для последовательности 2, 11, 2, 2, 25, 11, 25, 11 максимальное время ожидания равно 4 (для маршрута номер 11).\nВходные данные\nВходной файл INPUT.TXT содержит в первой строке число N (2 ≤ N ≤ 106). Во второй строке записаны N чисел – номера маршрутов. Все числа натуральные и не превышают 100. Каждый номер маршрута встречается не менее двух раз.\nВыходные данные\nВ выходной файл OUTPUT.TXT выведите ответ на задачу.",
    "complexity": 30,
    "memory": 128000,
    "time": 1000,
    "examples": [
      {
        "input": "8\n2 11 2 2 25 11 25 11",
        "output": "4"
      },
      {
        "input": "4\n23 23 41 41",
        "output": "1"
      }
    ]
  },
  {
    "id": 315,
    "name": "Наименьшая система счисления",
    "description": "Выходные данные\nВыходной файл OUTPUT.TXT должен содержать одно число. Если строка является записью числа в некоторой системе счисления, то нужно вывести минимальное основание такой системы счисления. Иначе вывести -1.",
    "complexity": 26,
    "memory": 16000,
    "time": 1000,
    "examples": [
      {
        "input": "123",
        "output": "4"
      },
      {
        "input": "ABCDEF",
        "output": "16"
      },
      {
        "input": "AD%AF",
        "output": "-1"
      },
      {
        "input": "03025",
        "output": "6"
      },
      {
        "input": "abc",
        "output": "-1"
      }
    ]
  },
  {
    "id": 317,
    "name": "Подарки Деда Мороза",
    "description": "Ириска весит X грамм, мандарин – Y грамм, пряник – Z грамм.\nOUTPUT.TXT3[Лучшие попытки]\nТребуется написать программу, которая определит, сколько различных вариантов подарков весом ровно W грамм может сделать Дед Мороз.\nВходные данные\nВ единственной строке входного файла INPUT.TXT содержится четыре целых числа X, Y, Z и W (1 ≤ X, Y, Z ≤ 100, 1 ≤ W ≤ 1000).\nВыходные данные\nВыходной файл OUTPUT.TXT должен содержать одно целое число – количество вариантов подарков.",
    "complexity": 27,
    "memory": 16000,
    "time": 1000,
    "examples": [
      {
        "input": "10 25 15 40",
        "output": "3"
      }
    ]
  },
  {
    "id": 322,
    "name": "Слово",
    "description": "Числа Фибоначчи строятся следующим образом: первые два равны единице, а каждое следующее равно сумме двух предыдущих. Например, первые десять чисел Фибоначчи равны: 1, 1, 2, 3, 5, 8, 13, 21, 34, 55. В заданном тексте символы нумеруются слева направо, начиная с единицы.\nOUTPUT.TXTa2abcabcabcabceh[Лучшие попытки]\nТребуется написать программу, которая составит слово из символов, номера которых совпадают с числами Фибоначчи.\n3abcdefghijabceh\nВходные данные\nВходной файл INPUT.TXT содержит в единственной строке текст, состоящий из английских строчных букв. В тексте от 1 до 30000 символов.\nВыходные данные\nВыходной файл OUTPUT.TXT должен содержать слово из символов, номера которых совпадают с числами Фибоначчи. Символы слова идут в том же порядке, что и в заданном тексте.",
    "complexity": 20,
    "memory": 16000,
    "time": 1000,
    "examples": [
      {
        "input": "a",
        "output": "a"
      },
      {
        "input": "abc",
        "output": "abc"
      },
      {
        "input": "abcdefghij",
        "output": "abceh"
      }
    ]
  },
  {
    "id": 304,
    "name": "Волейбол - 2",
    "description": "Партия в волейболе, выигрывается командой, которая первой набирает 25 очков с преимуществом минимум в два очка. В случае равного счета 24-24, игра продолжается до достижения преимущества в 2 очка (26-24; 27-25). Исключение составляет лишь пятая партия (когда счет по партиям 2:2), в этом случае счет ведется по такому же принципу, но до 15 очков, а в случае счета 14:14 игра продолжается так же до достижения преимущества в 2 очка.\nOUTPUT.TXT1004310578692710768616627197099892500024 25:23 20:25 26:24 25:18323866095164273521651645790930981230216140667500000323866095164273521651645790930981230216140667500000[Лучшие попытки]\nДве сыгранные партии, закончившиеся с одинаковым счетом, будем считать разными, если строки, в которые вписан порядок набора очков командами, не равны.\nКомитет по проведению соревнований по волейболу заинтересовало, сколько различных партий может быть, заканчивающихся со счетом 25:23, оказывается 16123801841550, далее им стало интересно, сколько же существует различных матчей в которых первая команда победила в 3 партиях со счетом 25:23 25:20 25:18, оказывается 10043105786927107686166271970998925000.\nОпределить, сколько существует различных матчей, заканчивающихся заданным счетом. Два матча закончившиеся одинаковым количеством партий с одинаковым счетом, считаются различными, если есть различно сыгранные партии.\nВходные данные\nВо входном файле INPUT.TXT сначала записано число N - количество партий в матче.  Далее следует N пар чисел, описывающих счет в каждой партии. При этом результаты партий разделяются пробелом, а счет в каждой партии отделяется двоеточием. Гарантируется, что счет в каждой партии соответствует возможному, согласно правилам волейбола, и ни в какой партии, ни одна из команд не набирает более 40 очков.\nВыходные данные\nВ выходной файл OUTPUT.TXT выведите количество различных матчей, которые могут оканчиваться данным счетом.",
    "complexity": 68,
    "memory": 16000,
    "time": 1000,
    "examples": [
      {
        "input": "3 25:23 25:20 25:18",
        "output": "10043105786927107686166271970998925000"
      },
      {
        "input": "4 25:23 20:25 26:24 25:18",
        "output": "323866095164273521651645790930981230216140667500000"
      }
    ]
  },
  {
    "id": 305,
    "name": "Морской бой",
    "description": "Участник игры в морской бой размещает на игровом поле свои корабли. По правилам этой разновидности игры корабли могут быть только прямоугольниками любых размеров, не могут пересекаться и иметь общих граничных точек. Количество уже размещённых кораблей  равно K. Последний корабль он хочет сделать максимально большим.\nOUTPUT.TXT21[Лучшие попытки]\nВходные данные\nВ первой строке входного файла INPUT.TXT записаны три числа N, M и K – количество клеток по вертикали, количество клеток по горизонтали и число уже выстроенных кораблей соответственно (1 ≤ N, M ≤ 100, 1 ≤ K ≤ 10). Следующие K строк содержат координаты K размещённых кораблей – 4 числа в каждой строке. 1-е и 2-е число – вертикальная и горизонтальная  координаты левой верхней угловой клетки корабля, 3-е и 4-е число – вертикальная и  горизонтальная координаты правой нижней угловой клетки корабля.  Клетки поля нумеруются  сверху вниз (от 1 до N) и слева направо (от 1 до M).\nВыходные данные\nВ выходной файл OUTPUT.TXT выведите одно число – количество клеток в последнем корабле.",
    "complexity": 48,
    "memory": 16000,
    "time": 1000,
    "examples": [
      {
        "input": "8 7 3\n\n1 1 2 2\n\n3 5 3 7\n \n4 2 4 3",
        "output": "21"
      }
    ]
  },
  {
    "id": 321,
    "name": "Разные цифры",
    "description": "Требуется написать программу, определяющую, в каких системах счисления с основаниями от 2 до 36 это число не содержит одинаковых цифр.\nOUTPUT.TXT11 12 13 14 15 16 17 18 20 21 22 23 25 26 27 28 29 30 31 32 33 34 35 36[Лучшие попытки]\nВходные данные\nВходной файл INPUT.TXT содержит одно целое число N (1 ≤ N ≤ 109), записанное в десятичной системе счисления.\nВыходные данные\nВыходной файл OUTPUT.TXT должен содержать основания систем счисления в порядке возрастания, разделенные одним пробелом.",
    "complexity": 27,
    "memory": 16000,
    "time": 1000,
    "examples": [
      {
        "input": "100",
        "output": "11 12 13 14 15 16 17 18 20 21 22 23 25 26 27 28 29 30 31 32 33 34 35 36"
      }
    ]
  },
  {
    "id": 332,
    "name": "Минимальная стоимость проезда",
    "description": "На прямой ветке железной дороги расположено несколько станций. Задана стоимость проезда между любыми двумя станциями.\nOUTPUT.TXT12[Лучшие попытки]\nТребуется написать программу нахождения минимальной стоимости проезда между крайними станциями. Двигаться по железной дороге можно только в одном направлении (от станции с меньшим номером до станции с большим номером.).\nВходные данные\nВходной файл INPUT.TXT содержит в первой строке натуральное число N, не большее 250. Всего на дороге расположено N+1 станций, пронумерованных от 0 до N. В следующих строках записано N(N+1)/2 чисел, задающих стоимости проезда между станциями: сначала стоимость проезда от станции 0 до станций 1, 2, 3, …, N, затем от станции 1 до станций 2, 3, …, N, …, от станции N-1 до станции N. Все стоимости проезда – неотрицательные целые числа, не превосходящие 10000.\nВыходные данные\nВыходной файл OUTPUT.TXT должен содержать одно число – минимальную стоимость проезда от станции 0 до станции N с возможными пересадками.",
    "complexity": 40,
    "memory": 16000,
    "time": 1000,
    "examples": [
      {
        "input": "3\n7 10 20\n4 8\n2",
        "output": "12"
      }
    ]
  },
  {
    "id": 346,
    "name": "Сумма двух чисел",
    "description": "Заданы три числа: a, b, c. Необходимо выяснить, можно ли так переставить цифры в числах a и b, чтобы в сумме получилось c.\nOUTPUT.TXTYES12 13212 31 26NONOYES11 2[Лучшие попытки]\nВходные данные3101 2 13YES11 2[Решение]\nВходной файл INPUT.TXT содержит три целых числа: a, b, c (0 ≤ a, b, c \u003c 109). Числа разделены пробелом.\nВыходные данные\nВ выходной файл OUTPUT.TXT следует вывести YES, если искомая перестановка цифр возможна, в противном случае необходимо вывести NO. При положительном ответе во второй строке следует вывести число x, получаемое перестановкой цифр числа a, и число y, получаемое перестановкой цифр числа b, сумма которых равна c. Числа x и y при выводе не должны содержать ведущих нулей. Числа в строке разделены пробелом. Если решений несколько, то следует вывести ту пару, в которой число x минимально.",
    "complexity": 46,
    "memory": 16000,
    "time": 1000,
    "examples": [
      {
        "input": "12 31 25",
        "output": "YES\n12 13"
      },
      {
        "input": "12 31 26",
        "output": "NO"
      },
      {
        "input": "101 2 13",
        "output": "YES\n11 2"
      }
    ]
  },
  {
    "id": 320,
    "name": "Коридор",
    "description": "Прямоугольный коридор длиной N метров и шириной M метров решили застелить N прямоугольными плитками шириной 1 метр и длиной M метров, таким образом, чтобы не было не застеленной поверхности.\nOUTPUT.TXT422 222[Лучшие попытки]\nТребуется написать программу, которая найдет количество способов это сделать. Например, для коридора с размерами 6 на 4 существует четыре способа застелить плитками 1 на 4.\nВходные данные\nВходной файл INPUT.TXT содержит два целых числа – M (длина плитки и ширина коридора) и N (длина коридора). Для этих чисел верны неравенства 2 ≤ M ≤ N ≤ 50.\nВыходные данные\nВыходной файл OUTPUT.TXT должен содержать одно число – количество способов.",
    "complexity": 38,
    "memory": 16000,
    "time": 1000,
    "examples": [
      {
        "input": "4 6",
        "output": "4"
      },
      {
        "input": "2 2",
        "output": "2"
      }
    ]
  },
  {
    "id": 323,
    "name": "Гипотеза Гольдбаха",
    "description": "Известно, что любое чётное число, большее 2, представимо в виде суммы 2 простых чисел, причём таких разложений может быть несколько. Впервые гипотезу о существовании данного разложения сформулировал математик Х. Гольдбах.\nOUTPUT.TXT3 3299273 91973 919[Лучшие попытки]\nТребуется написать программу, производящую согласно утверждению Гольдбаха, разложение заданного чётного числа. Из всех пар простых чисел, сумма которых равна заданному числу, требуется найти пару, содержащую наименьшее простое число.\n[Решение]\nВходные данные\nВходной файл INPUT.TXT содержит чётное число N (4 ≤ N ≤ 998).\nВыходные данные\nВ выходной файл OUTPUT.TXT необходимо вывести два простых числа, сумма которых равна числу N. Первым выводится наименьшее число.",
    "complexity": 30,
    "memory": 16000,
    "time": 1000,
    "examples": [
      {
        "input": "6",
        "output": "3 3"
      },
      {
        "input": "992",
        "output": "73 919"
      }
    ]
  },
  {
    "id": 334,
    "name": "Китайские часы",
    "description": "Русский бизнесмен Иван Петров закупил в Китае большую партию наручных часов, чтобы продать их на родине за полцены (т.е. в 5 раз дороже, чем они стоили в Китае). Иван столкнулся с проблемой: китайские часы оказались некачественными. Мало того, что часы работали на протяжении всего нескольких часов, пока их не стукнешь, так еще и время подводить неудобно: вращать можно не минутную, а только секундную стрелку, причем, что самое ужасное, только в одну сторону в направлении увеличении времени. Например, для того, чтобы подвести часы на секунду назад, необходимо было сделать более 700 полных оборотов секундной стрелки, на что Иван бы потратил более 10 минут.\nOUTPUT.TXT2:05:11[Лучшие попытки]\nЧтобы продать эти часы оптом Ивану необходимо на момент сделки создать видимость того, что часы исправны. Для этого он собирается остановить все часы, установить их на одно и то же время. А перед сделкой ударить по чемодану с часами, чтобы они все дружно пошли.\nПомогите Ивану выяснить: какое время на часах лучше установить для того, чтобы Иван потратил как можно меньше времени для того, чтобы подвести все часы.\nВходные данные\nВ первой строке входного файла INPUT.TXT содержится натуральное число N – количество часов (N ≤ 50000). В последующих N строках располагаются показания всех часов в формате h:mm:ss, где h – показывает который час, mm – минуты, ss - секунды (1 ≤ h ≤ 12, 0 ≤ mm ≤ 59, 0 ≤ ss ≤ 59).\nВыходные данные\nВыходной файл OUTPUT.TXT должен содержать время, которое нужно установить на всех часах, в формате, указанном выше. В случае неоднозначного ответа выведите наименьшее время.",
    "complexity": 41,
    "memory": 16000,
    "time": 1000,
    "examples": [
      {
        "input": "3\n\n8:19:16\n\n2:05:11\n\n12:50:07",
        "output": "2:05:11"
      }
    ]
  },
  {
    "id": 333,
    "name": "Общие цифры",
    "description": "Заданы натуральные числа A, B, C. Требуется написать программу, которая найдет общие цифры в этих числах.\nOUTPUT.TXT0212 13 14111123 4[Лучшие попытки]\nВходные данные31234 2345 345623 4\nВходной файл INPUT.TXT содержит три натуральных числа A, B, C (1 ≤ A, B, C ≤ 1080). Числа разделены одним пробелом.\nВыходные данные\nВыходной файл OUTPUT.TXT должен содержать в первой строке количество общих цифр, а во второй строке в порядке возрастания через один пробел общие цифры.",
    "complexity": 28,
    "memory": 16000,
    "time": 1000,
    "examples": [
      {
        "input": "1 2 3",
        "output": "0"
      },
      {
        "input": "12 13 14",
        "output": "1\n1"
      },
      {
        "input": "1234 2345 3456",
        "output": "2\n3 4"
      }
    ]
  },
  {
    "id": 325,
    "name": "Мы с конем вдвоем по полю пойдем",
    "description": "Заданы две клетки шахматной доски. Требуется определить, возможно ли попасть из одной клетки в другую одним ходом шахматного коня, а если нет, то следует выяснить, возможно ли попасть с помощью двух ходов.\nOUTPUT.TXTNO2a1, b3112[Лучшие попытки]\nВходные данные3a1, d42\nВходной файл INPUT.TXT содержит координаты двух клеток в общепринятом формате: каждая координата записывается как английская строчная буква и цифра, координаты отделены друг от друга запятой и пробелом.\nВыходные данные\nВыходной файл OUTPUT.TXT должен содержать цифру «1», если возможно из одной клетки в другую попасть за 1 ход, либо цифру «2», если попасть можно за 2 хода, либо «NO», если одна клетка недостижима из другой ни за 1 ни за 2 хода.",
    "complexity": 31,
    "memory": 16000,
    "time": 1000,
    "examples": [
      {
        "input": "a1, h8",
        "output": "NO"
      },
      {
        "input": "a1, b3",
        "output": "1"
      },
      {
        "input": "a1, d4",
        "output": "2"
      }
    ]
  },
  {
    "id": 324,
    "name": "Четырехзначный палиндром",
    "description": "Требуется написать программу, определяющую, является ли четырехзначное натуральное число N палиндромом, т.е. числом, которое одинаково читается слева направо и справа налево.\nOUTPUT.TXTYES21231NONO[Лучшие попытки]\nВходные данные[Решение]\nВходной файл INPUT.TXT содержит натуральное число N (1000 ≤ N ≤ 9999).\nВыходные данные\nВ выходной файл OUTPUT.TXT следует вывести слово «YES», если число N является палиндромом, или «NO» – если нет.",
    "complexity": 10,
    "memory": 16000,
    "time": 1000,
    "examples": [
      {
        "input": "6116",
        "output": "YES"
      },
      {
        "input": "1231",
        "output": "NO"
      }
    ]
  },
  {
    "id": 335,
    "name": "Трипростые числа",
    "description": "Будем называть натуральное число трипростым, если в нем любые подряд идущие 3 цифры образуют трехзначное простое число.\nOUTPUT.TXT204[Лучшие попытки]\nТребуется найти количество N-значных трипростых чисел.\nВходные данные\nВходной файл INPUT.TXT содержит натуральное число N (3 ≤ N ≤ 10000).\nВыходные данные\nВыходной файл OUTPUT.TXT должен содержать количество N-значных трипростых чисел, которое следует вывести по модулю 109+9.",
    "complexity": 40,
    "memory": 16000,
    "time": 1000,
    "examples": [
      {
        "input": "4",
        "output": "204"
      }
    ]
  },
  {
    "id": 337,
    "name": "Лампочки",
    "description": "Имеется ряд из N лампочек, которые пронумерованы от 1 до N. Изначально ни одна из лампочек не горит. Далее происходит K последовательных линейных инверсий этого ряда ламп. Под линейной инверсией понимается инверсия каждой P-й лампочки в ряде. Например, если P=3, то произойдет инверсия 3й, 6й, 9й и т.д. лампочек.\niOUTPUT.TXT82172 1019 2 7 13 40 23 16 1 45 99999[Лучшие попытки]\nТребуется определить: сколько горящих лампочек останется после реализации всех заданных линейных инверсий?\nВходные данные\nВ первой строке входного файла INPUT.TXT заданы числа N и K – число лампочек и число линейных инверсий. Вторая строка состоит из K целых чисел Pi, задающих период данных инверсий. (1 ≤ N ≤ 109, 1 ≤ K ≤ 100, 1 ≤ Pi ≤ 50)\nВыходные данные\nВ выходной файл OUTPUT.TXT следует вывести ответ на задачу.",
    "complexity": 94,
    "memory": 16000,
    "time": 1000,
    "examples": [
      {
        "input": "20 3\n2 3 8",
        "output": "8"
      },
      {
        "input": "172 10\n19 2 7 13 40 23 16 1 45 9",
        "output": "99"
      }
    ]
  },
  {
    "id": 375,
    "name": "Системы счисления",
    "description": "Дано целое неотрицательное число в I-ричной системе счисления. Требуется вывести это число в J-ричной системе счисления.\nOUTPUT.TXTHELLO22 1011011313[Лучшие попытки]\nВходные данные\nВходной файл INPUT.TXT в первой строке содержит два числа I и J (в десятичной системе счисления), во второй строке - число для перевода. Ограничения: 2 ≤ I, J ≤ 36, для представления цифр 10...35 используются прописные английские буквы A...Z соответственно, число разрядов исходного числа не превышает 1000.\nВыходные данные\nВ выходной файл OUTPUT.TXT выведите искомое число без лидирующих нулей.",
    "complexity": 53,
    "memory": 16000,
    "time": 1000,
    "examples": [
      {
        "input": "10 36\n29234652",
        "output": "HELLO"
      },
      {
        "input": "2 10\n1101",
        "output": "13"
      }
    ]
  },
  {
    "id": 336,
    "name": "Лифт",
    "description": "В доме Вилли установили скоростной лифт новой экспериментальной модели. В этом лифте кнопки с номерами этажей заменены двумя другими кнопками. При нажатии на первую кнопку лифт поднимается на один этаж вверх, а при нажатии на вторую – опускается на один этаж вниз.\nOUTPUT.TXT3221212226[Лучшие попытки]\nМладшему брату Вилли Дилли очень нравится кататься на новом лифте. Он катается на нём до тех пор, пока не побывает на каждом из этажей хотя бы по одному разу. После этого Дилли довольный возвращается домой.\n312212212212216\nЗная порядок, в котором Дилли нажимал на кнопки лифта, попробуйте определить общее количество этажей в доме Вилли и Дилли.\nВходные данные\nПервая строка входного файла INPUT.TXT содержит последовательность нажатий на кнопки лифта. Символ «1» означает, что была нажата первая кнопка, а символ «2» – что была нажата вторая кнопка. Символы «1» и «2» не разделены пробелами. Количество нажатий от 1 до 100. Гарантируется, что лифт никогда не опускался ниже первого и не поднимался выше последнего этажа.\nВыходные данные\nВ выходной файл OUTPUT.TXT следует вывести одно число – количество этажей в доме Вилли и Дилли.",
    "complexity": 20,
    "memory": 16000,
    "time": 1000,
    "examples": [
      {
        "input": "11",
        "output": "3"
      },
      {
        "input": "21212",
        "output": "2"
      },
      {
        "input": "1221221221221",
        "output": "6"
      }
    ]
  },
  {
    "id": 365,
    "name": "Разложение на слагаемые",
    "description": "Требуется вывести все различные представления натурального числа N в виде суммы натуральных чисел. Представления, отличающиеся друг от друга порядком слагаемых, не являются различными.\nOUTPUT.TXT1+1+1+1\n1+2+1\n1+3\n2+2\n251+1+1+1+1\n1+1+1+2\n1+1+3\n1+2+2\n2+3\n1+4\n1+1+1+1+1\n1+1+1+2\n1+1+3\n1+2+2\n2+3\n1+4\n[Лучшие попытки]\nВходные данные\nВходной файл INPUT.TXT содержит целое число N (2 ≤ N ≤ 40).\nВыходные данные\nВ выходной файл OUTPUT.TXT выведите все различные представления числа N без повторов в виде суммы по одному на отдельной строке. Как слагаемые, так и сами суммы могут следовать в произвольном порядке.",
    "complexity": 54,
    "memory": 16000,
    "time": 1000,
    "examples": [
      {
        "input": "4",
        "output": "1+1+1+1\n\n1+2+1\n\n1+3\n\n2+2"
      },
      {
        "input": "5",
        "output": "1+1+1+1+1\n\n1+1+1+2\n\n1+1+3\n\n1+2+2\n\n2+3\n\n1+4"
      }
    ]
  },
  {
    "id": 331,
    "name": "Время прибытия",
    "description": "Задано время отправления поезда и время в пути до конечной станции. Требуется написать программу, которая найдет время прибытия этого поезда (возможно, в другие сутки).\nOUTPUT.TXT10:10201:024 605:0805:0809:00[Лучшие попытки]\n311:0022 009:00\nВходные данные\nВходной файл INPUT.TXT содержит две строки. В первой строке задано время отправления, а во второй строке – время в пути. Время отправления задается в формате «HH:MM», где HH время в часах, которое принимает значение от 00 до 23, ММ – время в минутах, которое принимает значение от 00 до 59. Время в пути задается двумя неотрицательными целыми числами – количество часов и количество минут. Числа разделяются одним пробелом. Количество часов не превышает 120, минут – 59.\nВыходные данные\nВыходной файл OUTPUT.TXT должен содержать одну строку – время прибытия поезда на конечную станцию. Формат вывода этого времени совпадает с форматом ввода времени отправления.",
    "complexity": 15,
    "memory": 16000,
    "time": 1000,
    "examples": [
      {
        "input": "00:00\n10 10",
        "output": "10:10"
      },
      {
        "input": "01:02\n4 6",
        "output": "05:08"
      },
      {
        "input": "11:00\n22 0",
        "output": "09:00"
      }
    ]
  },
  {
    "id": 338,
    "name": "Лоскутки",
    "description": "Вася Пупкин взял листочек в клетку и начал его резать по определённым линиям. На запасном листке такого же размера он закрасил клетки, по которым проходили линии.  Василий Васильевич так увлёкся этим занятием, что запутался, сколько частей от листа у него осталось. Ваша задача найти это число.\nOUTPUT.TXT2[Лучшие попытки]\nВходные данные\nВо входном файле INPUT.TXT в первой строке записаны N и M (0 \u003c N, M ≤ 100) – размерность матрицы. Далее записана матрица из N строк, каждая из которых содержит M нулей и единиц. 0 обозначает не закрашенную клетку и 1 – закрашенную (линию разреза).\nВыходные данные\nВ выходной файл OUTPUT.TXT следует вывести количество оставшихся частей листа.",
    "complexity": 40,
    "memory": 16000,
    "time": 1000,
    "examples": [
      {
        "input": "4 4\n\n0 0 1 0\n\n0 0 1 0\n\n0 1 0 0\n\n1 0 0 1",
        "output": "2"
      }
    ]
  },
  {
    "id": 326,
    "name": "Преобразование последовательности - 2",
    "description": "Задана последовательность, содержащая n целых чисел. Необходимо найти число, которое встречается в этой последовательности наибольшее количество раз, а если таких чисел несколько, то найти минимальное из них, и после этого переместить все такие числа в конец заданной последовательности. Порядок расположения остальных чисел должен остаться без изменения.\nOUTPUT.TXT1 3 3 1 2 2 2[Лучшие попытки]\nНапример, последовательность 1, 2, 3, 2, 3, 1, 2 после преобразования должна превратиться в последовательность 1, 3, 3, 1, 2, 2, 2.\nТребуется написать программу, которая решает данную задачу.\nВходные данные\nПервая строка входного файла INPUT.TXT содержит число n — количество чисел во входной последовательности (3 ≤ n ≤ 100). Следующая строка содержит входную последовательность, состоящую из n целых чисел, не превышающих по модулю 100. Все числа в строке разделены пробелом.\nВыходные данные\nВ выходной файл OUTPUT.TXT выводится последовательность чисел, которая получается в результате названного преобразования. Все числа в последовательности должны быть разделены пробелом.",
    "complexity": 29,
    "memory": 16000,
    "time": 1000,
    "examples": [
      {
        "input": "7\n1 2 3 2 3 1 2",
        "output": "1 3 3 1 2 2 2"
      }
    ]
  },
  {
    "id": 347,
    "name": "Покер",
    "description": "Имеется 5 целых чисел. Среди них:\nOUTPUT.TXTOne Pair21 5 5 4 4Two PairsTwo PairsStraightNothing[Лучшие попытки]\n• если одинаковы 5, то вывести \"Impossible\", иначе\n• если одинаковы 4, то вывести \"Four of a Kind\", иначе\n• если одинаковы 3 и 2, то вывести \"Full House\", иначе\n• если есть 5 последовательных, то вывести \"Straight\", иначе\n• если одинаковы 3, то вывести \"Three of a Kind\", иначе\n• если одинаковы 2 и 2, то вывести \"Two Pairs\", иначе\n• если одинаковы 2, то вывести \"One Pair\", иначе\n• вывести \"Nothing\".\n31 5 2 4 3Straight\nВходные данные410 11 12 13 1Nothing\nВходной файл INPUT.TXT содержит 5 целых чисел от 1 до 13, разделенных пробелом.\nВыходные данные\nВ выходной файл OUTPUT.TXT следует вывести результат анализа.",
    "complexity": 33,
    "memory": 16000,
    "time": 1000,
    "examples": [
      {
        "input": "1 3 9 3 2",
        "output": "One Pair"
      },
      {
        "input": "1 5 5 4 4",
        "output": "Two Pairs"
      },
      {
        "input": "1 5 2 4 3",
        "output": "Straight"
      },
      {
        "input": "10 11 12 13 1",
        "output": "Nothing"
      }
    ]
  },
  {
    "id": 328,
    "name": "Точки на костях Домино",
    "description": "Для того, чтобы заработать огромный капитал, новым русским необходимо иметь неординарное мышление. Конечно, при такой сложной работе, должны так же присутствовать какие-то особенные механизмы для отдыха и развлечений. В этих целях в казино был придуман специальный набор домино для новых русских. Обычные кости домино представляют собой набор из различных комбинаций сочетаний двух плиток, на каждой из которых отображается от 0 до 6 точек. А этот набор представляет собой подобные сочетания плиток, но количество точек на каждой может быть от нуля до заданного значения, которое зависит от интеллектуального уровня игроков. В таком наборе костей присутствуют всевозможные сочетания плиток, но при этом ни одна из костей не повторяется (даже такие комбинации как 2-5 и 5-2 считаются одинаковыми).\nOUTPUT.TXT12[Лучшие попытки]\nДля изготовления данного набора костей перед изготовителем встала проблема вычисления суммарного количества точек на всех костях домино. Это связано с тем, что домино для новых русских украшается бриллиантами, которые представляют собой точки на плитках и при изготовлении необходимо оценить стоимость.\nПомогите написать программу, которая решит эту задачу.\nВходные данные\nВходной файл INPUT.TXT содержит одно натуральное число N – максимальное количество точек на одной плитке домино. (N ≤ 10000)\nВыходные данные\nВ выходной файл OUTPUT.TXT выведите количество бриллиантовых камней, которые необходимо изготовить для заданного набора костей.",
    "complexity": 25,
    "memory": 16000,
    "time": 1000,
    "examples": [
      {
        "input": "2",
        "output": "12"
      }
    ]
  },
  {
    "id": 327,
    "name": "В одном шаге от счастья",
    "description": "Вова купил билет в трамвае 13-го маршрута и сразу посчитал суммы первых трёх цифр и последних трёх цифр номера билета (номер у билета шестизначный). Оказалось, что суммы отличаются ровно на единицу. «Я в одном шаге от счастья», — подумал Вова, — «или предыдущий или следующий билет точно счастливый». Прав ли он?\nOUTPUT.TXTYes \nNo\nYes\n[Лучшие попытки]\nВходные данные\nВходной файл INPUT.TXT содержит в первой строке число K – количество тестов. В следующих K строках записаны номера билетов. Количество тестов не больше 10. Номер состоит ровно из шести цифр, среди которых могут быть и нули. Гарантируется, что Вова умеет считать, то есть суммы первых трех цифр и последних трех цифр отличаются ровно на единицу.\nВыходные данные\nВыходной  файл OUTPUT.TXT должен содержать K строк, в каждой из которых для соответствующего теста следует указать \"Yes\", если Вова прав, и \"No\", если нет.",
    "complexity": 16,
    "memory": 16000,
    "time": 1000,
    "examples": [
      {
        "input": "3\n715068\n\n445219\n\n012200",
        "output": "Yes\n \nNo\n\nYes"
      }
    ]
  },
  {
    "id": 340,
    "name": "Коробки",
    "description": "На столе лежат коробка размера A1 × B1 × C1 и коробка размера A2 × B2 × C2. Выясните можно ли одну из этих коробок положить в другую, если разрешены повороты коробок вокруг любого ребра на угол 90 градусов.\nOUTPUT.TXTBoxes are equal22 2 33 2 1The first box is larger than the second oneThe first box is larger than the second oneThe first box is smaller than the second oneBoxes are incomparable[Лучшие попытки]\nВходные данные32 2 33 2 3The first box is smaller than the second one\nПервая строка входного файла содержит три целых числа A1, B1 и C1. Вторая строка входного файла содержит три целых числа A2, B2 и C2. Все числа положительны и не превосходят 1000.\n43 4 52 4 6Boxes are incomparable\nВыходные данные\nЕсли коробки одинаковы, выведите \"Boxes are equal\". Если первая коробка может быть положена во вторую, выведите \"The first box is smaller than the second one\". Если вторая коробка может быть положена в первую, выведите \"The first box is larger than the second one\". Иначе, выведите \"Boxes  are  incomparable\".",
    "complexity": 19,
    "memory": 16000,
    "time": 1000,
    "examples": [
      {
        "input": "1 2 3\n3 2 1",
        "output": "Boxes are equal"
      },
      {
        "input": "2 2 3\n3 2 1",
        "output": "The first box is larger than the second one"
      },
      {
        "input": "2 2 3\n3 2 3",
        "output": "The first box is smaller than the second one"
      },
      {
        "input": "3 4 5\n2 4 6",
        "output": "Boxes are incomparable"
      }
    ]
  },
  {
    "id": 348,
    "name": "Пересечение отрезков",
    "description": "Два отрезка на плоскости заданы целочисленными координатами своих концов в декартовой системе координат. Требуется определить, существует ли у них общая точка.\nOUTPUT.TXTYes20 0\n1 0\n0 1\n1 1\nNoNoYes[Лучшие попытки]\nВходные данные30 0\n1 0\n1 0\n1 1\nYes\nВходной файл INPUT.TXT содержит координаты четырех точек, задающих отрезки. В первой строке содержатся координаты первого конца первого отрезка , во второй - второго конца первого отрезка, в третьей и четвёртой - координаты концов второго отрезка. Все координаты – целые числа, не превосходящие 10000 по абсолютной величине.\nВыходные данные\nВ выходной файл OUTPUT.TXT следует вывести слово \"Yes\", если общая точка есть, или слово \"No\" - в противном случае.",
    "complexity": 49,
    "memory": 16000,
    "time": 1000,
    "examples": [
      {
        "input": "0 0\n\n1 1\n\n0 1\n\n1 0",
        "output": "Yes"
      },
      {
        "input": "0 0\n\n1 0\n\n0 1\n\n1 1",
        "output": "No"
      },
      {
        "input": "0 0\n\n1 0\n\n1 0\n\n1 1",
        "output": "Yes"
      }
    ]
  },
  {
    "id": 366,
    "name": "Выражение",
    "description": "Даны N целых чисел X1, X2, …, XN. Требуется расставить между ними знаки «+» и «-» так, чтобы значение получившегося выражения было равно заданному целому S.\nN9OUTPUT.TXT15+25-30=1022 10010 10No solutionNo solution[Лучшие попытки]\nВходные данные9\nВходной файл INPUT.TXT в первой строке содержит числа N и S. В следующей строке располагается N чисел, разделенных пробелом. Ограничения: 2 ≤ N ≤ 24, 0 ≤ Xi ≤ 5*107, -109 ≤ S ≤ 109.\nВыходные данные\nВ выходной файл OUTPUT.TXT выведите «No solution», если такой результат получить невозможно, иначе выведите получившееся равенство. Если решение не единственное, выведите любое.",
    "complexity": 56,
    "memory": 16000,
    "time": 1000,
    "examples": [
      {
        "input": "3 10\n15 25 30",
        "output": "15+25-30=10"
      },
      {
        "input": "2 100\n10 10",
        "output": "No solution"
      }
    ]
  },
  {
    "id": 339,
    "name": "Мероприятие",
    "description": "Мише поручили решить следующую задачу: имеется дата начала и конца некоторого мероприятия; требуется определить его длительность. Он написал программу и попросил Машу её проверить.\nOUTPUT.TXT36201.09.000501.09.000636636630[Лучшие попытки]\nЧерез некоторое время пришла Маша и расстроила Мишу: «Твоя программа работает неправильно. По-моему, ты забыл, что года бывают високосными».\n301.02.200401.03.200430\nУ Миши очень мало свободного времени и он не успевает исправить свою программу. Помогите ему.\nГод является високосным, тогда и только тогда, когда выполнено одно из следующих условий:\nгод делится на 4, но не делится на 100;\n  год делится на 400.\nНапример, года 400, 404, 496, 504, 2000, 2004 являются високосными, а года 100, 200, 300, 503, 1000, 2001, 2005 - нет.\nВходные данные\nПервая строка входного файла INPUT.TXT содержит дату начала мероприятия. Вторая строка входного файла содержит дату конца мероприятия. Гарантируется, что первая дата меньше второй. Даты заданы в формате DD.MM.YYYY.\nВыходные данные\nВ выходной файл OUTPUT.TXT выведите единственное число - длительность мероприятия (в днях).",
    "complexity": 31,
    "memory": 16000,
    "time": 1000,
    "examples": [
      {
        "input": "01.09.2005\n06.10.2005",
        "output": "36"
      },
      {
        "input": "01.09.0005\n01.09.0006",
        "output": "366"
      },
      {
        "input": "01.02.2004\n01.03.2004",
        "output": "30"
      }
    ]
  },
  {
    "id": 369,
    "name": "Гангстеры",
    "description": "N гангстеров собираются в ресторан. i-й гангстер приходит в момент времени Ti и имеет богатство Pi. Дверь ресторана имеет K+1 степень открытости, они обозначаются целыми числами из интервала [0, K]. Степень открытости двери может изменяться на единицу в единицу времени, то есть дверь может открыться на единицу, закрыться на единицу или остаться в том же состоянии. В начальный момент времени дверь закрыта (степень открытости 0). i-й гангстер заходит в ресторан, только если дверь открыта специально для него, то есть когда степень открытости двери соответствует его полноте Si. Если в момент, когда гангстер подходит к ресторану, степень открытости двери не соответствует его полноте, он уходит и больше не возвращается. Ресторан работает в интервале времени [0, T].\niNOUTPUT.TXT2622 17 100\n5 0\n50 33\n6 1\n00[Лучшие попытки]\nТребуется собрать гангстеров с максимальным суммарным богатством в ресторане, открывая и закрывая дверь соответствующим образом.\n1\nВходные данные2\nВ первой строке входного файла INPUT.TXT  находятся числа N, K, T, во второй - T1, T2, ..., TN, в третьей - P1, P2, ..., PN. в четвёртой - S1, S2, ..., SN. Числа в строках разделены пробелами. Ограничения: 1 ≤ N ≤ 100, 1 ≤ K ≤ 100, 1 ≤ T ≤ 30 000, 0 ≤ Ti ≤ T, 1 ≤ Pi ≤ 300, 1 ≤ Si ≤ K .\nN\n1Выходные данные\n2\nВ выходной файл OUTPUT.TXT выведите одно число - максимальное суммарное богатство гангстеров, попавших в ресторан. Если зайти не удалось никому, вывести 0.\nNПримеры\ni\n№INPUT.TXTOUTPUT.TXT\n14 10 20\n10 16 8 16\n10 11 15 1\n10 7 1 8\n26\n22 17 100\n5 0\n50 33\n6 1\n0\ni\niДля отправки решения задачи необходимо зарегистрироваться и авторизоваться!\n[Обсуждение]\n\n  [Все попытки]\n\n  [Лучшие попытки]\nwindow.yaContextCb.push(()=\u003e{\n  Ya.Context.AdvManager.render({\n    renderTo: 'yandex_rtb_R-A-122393-3',\n    blockId: 'R-A-122393-3'\n  })\n})",
    "complexity": 44,
    "memory": 16000,
    "time": 1000,
    "examples": [
      {
        "input": "4 10 20\n\n10 16 8 16\n\n10 11 15 1\n\n10 7 1 8",
        "output": "26"
      },
      {
        "input": "2 17 100\n\n5 0\n\n50 33\n\n6 1",
        "output": "0"
      }
    ]
  },
  {
    "id": 367,
    "name": "Степень - 2",
    "description": "Для натуральных чисел A и N требуется вычислить значение AN.\nOUTPUT.TXT348678440122 16655366553688817841970012523233890533447265625[Лучшие попытки]\nВходные данные35 5088817841970012523233890533447265625[Решение]\nВходной файл INPUT.TXT в первой строке содержит числа A и N, разделенные пробелом. (1 ≤ A ≤ 9, 1 ≤ N ≤ 7000)\nВыходные данные\nВ выходной файл OUTPUT.TXT выведите одно число – результат возведения в степень, без лидирующих нулей.",
    "complexity": 45,
    "memory": 16000,
    "time": 1000,
    "examples": [
      {
        "input": "3 20",
        "output": "3486784401"
      },
      {
        "input": "2 16",
        "output": "65536"
      },
      {
        "input": "5 50",
        "output": "88817841970012523233890533447265625"
      }
    ]
  },
  {
    "id": 342,
    "name": "Вписанная окружность",
    "description": "Очень интересными объектами, которые изучаются в планиметрии, являются вписанные и описанные окружности. Известно, например, что вокруг любого треугольника можно описать окружность и в любой треугольник можно вписать окружность. А что будет, если вместо треугольника задан выпуклый многоугольник?\nOUTPUT.TXTYES0.500 0.500 0.50024\n0 0\n1 0\n1 2\n0 2\nNONO[Лучшие попытки]\nТребуется написать программу, которая определяет, можно ли в заданный выпуклый многоугольник вписать окружность, и, если это можно сделать, то вычисляет координаты ее центра и радиус.\nВходные данные\nПервая строка входного файла INPUT.TXT содержит количество вершин многоугольника n (3 ≤ n ≤ 8). Последующие n строк содержат координаты вершин многоугольника в порядке обхода против часовой стрелки, каждая i-ая из них содержит два целых числа: xi и yi, значения которых не превосходят 1000 по абсолютной величине.\nВыходные данные\nВ первой строке выходного файла OUTPUT.TXT необходимо вывести YES, если окружность, вписанная в заданный многоугольник, существует, в противном случае следует вывести слово NO . В случае положительного ответа во второй строке следует указать координаты центра окружности и ее радиус с точностью, не худшей чем 10-3.",
    "complexity": 68,
    "memory": 16000,
    "time": 1000,
    "examples": [
      {
        "input": "4\n\n0 0\n\n1 0\n\n1 1\n\n0 1",
        "output": "YES\n0.500 0.500 0.500"
      },
      {
        "input": "4\n\n0 0\n\n1 0\n\n1 2\n\n0 2",
        "output": "NO"
      }
    ]
  },
  {
    "id": 341,
    "name": "Числовая последовательность",
    "description": "Выходные данные\nВ выходной файл OUTPUT.TXT выведите искомое число aN.",
    "complexity": 35,
    "memory": 16000,
    "time": 1000,
    "examples": [
      {
        "input": "1",
        "output": "0"
      },
      {
        "input": "28",
        "output": "911"
      }
    ]
  },
  {
    "id": 368,
    "name": "Маршрут",
    "description": "В таблице из N строк и N столбцов клетки заполнены цифрами от 0 до 9. Требуется найти такой путь из клетки (1, 1) в клетку (N, N), чтобы сумма цифр в клетках, через которые он пролегает, была минимальной; из любой клетки ходить можно только вниз или вправо.\nOUTPUT.TXT#..\n###\n..#\n[Лучшие попытки]\nВходные данные\nВ первой строке входного файла INPUT.TXT находится число N. В следующих N строках содержатся по N цифр без пробелов. (2 ≤ N ≤ 250)\nВыходные данные\nВ выходной файл OUTPUT.TXT выведите N строк по N символов. Символ  «#» (решетка) показывает, что маршрут проходит через эту клетку, а «.» (точка) - что не проходит. Если путей с минимальной суммой цифр несколько, можно вывести любой.",
    "complexity": 38,
    "memory": 16000,
    "time": 1000,
    "examples": [
      {
        "input": "3\n\n943\n\n216\n\n091",
        "output": "#..\n\n###\n\n..#"
      }
    ]
  },
  {
    "id": 376,
    "name": "День рождения - 2",
    "description": "Заданы день и месяц рождения, а также текущие день, месяц и год. Определить, сколько дней осталось до дня рождения.\nOUTPUT.TXT0205 0519 04 200216161096[Лучшие попытки]\nПримечание. Високосные годы - это те, номер которых делится на 400, а также те, номер которых делится на 4, но не делится на 100.\n329 0228 02 20011096\nВходные данные\nВ первой строке входного файла INPUT.TXT находятся, разделённые пробелами, день и месяц рождения, во второй - разделённые пробелами текущие день, месяц и год. Ограничения: год от 1920 до 3000, месяц от 1 до 12, день от 1 до числа дней в месяце.\nВыходные данные\nВ выходной файл OUTPUT.TXT выведите число дней, оставшихся до дня рождения.",
    "complexity": 32,
    "memory": 16000,
    "time": 1000,
    "examples": [
      {
        "input": "19 04\n19 04 2002",
        "output": "0"
      },
      {
        "input": "05 05\n19 04 2002",
        "output": "16"
      },
      {
        "input": "29 02\n28 02 2001",
        "output": "1096"
      }
    ]
  },
  {
    "id": 383,
    "name": "Красивые числа - 2",
    "description": "Будем называть число красивым, если сумма его цифр в десятичной системе счисления делится на количество цифр в нем (в десятичной системе счисления).\nOUTPUT.TXT12152020[Лучшие попытки]\nНеобходимо найти N-ое в порядке возрастания красивое число.\nВходные данные\nВходной файл INPUT.TXT содержит целое число N. (1 ≤ N ≤ 100 000)\nВыходные данные\nВ выходной файл OUTPUT.TXT выведите ответ на задачу.",
    "complexity": 26,
    "memory": 16000,
    "time": 1000,
    "examples": [
      {
        "input": "1",
        "output": "1"
      },
      {
        "input": "15",
        "output": "20"
      }
    ]
  },
  {
    "id": 330,
    "name": "Телепортация",
    "description": "Вова попал на космическом корабле на бесконечную плоскую планету в точку с координатами (x1, y1). Вова, управляя кораблем, имеет возможность за одну секунду телепортироваться из точки (x, y) в одну из точек (x+C, y+C), (x+C, y-C), (x-C, y+C), (x-C, y-C), где C - произвольное натуральное число, которое можно изменять на каждом ходу.\n2OUTPUT.TXT2[Лучшие попытки]\nТребуется написать программу, которая определит, через какое минимальное время Вове удастся достичь точки (x2, y2).\n2\nВходные данные6\nВходной файл INPUT.TXT содержит в первой строке числа x1, y1, во второй – x2, y2. Все числа целые от нуля до 106. Точки (x1, y1) и (x2, y2) не совпадают.\n1\n1Выходные данные\n2\nВыходной файл OUTPUT.TXT должен содержать одно число – минимальное время телепортации. Если такая телепортация невозможна, то вывести 0.\n2Пример\n№INPUT.TXTOUTPUT.TXT\n10 00 22\nДля отправки решения задачи необходимо зарегистрироваться и авторизоваться!\n[Обсуждение]\n\n  [Все попытки]\n\n  [Лучшие попытки]\nwindow.yaContextCb.push(()=\u003e{\n  Ya.Context.AdvManager.render({\n    renderTo: 'yandex_rtb_R-A-122393-3',\n    blockId: 'R-A-122393-3'\n  })\n})",
    "complexity": 30,
    "memory": 16000,
    "time": 1000,
    "examples": [
      {
        "input": "0 0\n0 2",
        "output": "2"
      }
    ]
  },
  {
    "id": 377,
    "name": "Закраска прямой",
    "description": "На числовой прямой окрасили N отрезков. Известны координаты левого и правого концов каждого отрезка (Li и Ri). Найти длину окрашенной части числовой прямой.\n9OUTPUT.TXT32110 1000[Лучшие попытки]\nВходные данные\nВходной файл INPUT.TXT в первой строке содержит число N, в следующих N строках - пары Li и Ri. Ограничения: все числа целые, не превышающие 109 по абсолютной величине, 1 ≤ N ≤ 15 000.\nВыходные данные\nВ выходной файл OUTPUT.TXT выведите длину окрашенной части прямой.",
    "complexity": 48,
    "memory": 16000,
    "time": 1000,
    "examples": [
      {
        "input": "2\n1 3\n2 4",
        "output": "3"
      },
      {
        "input": "1\n10 10",
        "output": "0"
      }
    ]
  },
  {
    "id": 379,
    "name": "Игра с датой",
    "description": "Играют двое. Задаётся какая-то дата 2008 года. Каждый игрок на своём ходе называет более позднюю дату, увеличивая на 1 или 2 либо день в месяце, либо месяц, но не то и другое сразу. При этом сочетание дня и месяца должно оставаться датой. Игрок, назвавший 31 декабря, проигрывает. Оба играют наилучшим образом. Исходя из заданной даты вывести, кто выиграет.\nOUTPUT.TXT2229 12112[Лучшие попытки]\nВходные данные329 112\nВ первой строке входного файла INPUT.TXT находятся числа, обозначающие день и месяц. Месяц указывается от 1 до 12, день от 1 до числа дней в месяце, дата «31 декабря» отсутствует во входных данных.\nВыходные данные\nВ выходной файл OUTPUT.TXT выведите 1, если выигрывает первый (начинающий) игрок, или 2 – в противном случае.",
    "complexity": 54,
    "memory": 16000,
    "time": 1000,
    "examples": [
      {
        "input": "30 12",
        "output": "2"
      },
      {
        "input": "29 12",
        "output": "1"
      },
      {
        "input": "29 11",
        "output": "2"
      }
    ]
  },
  {
    "id": 345,
    "name": "Рекурсия",
    "description": "Выходные данные\nВ выходной файл OUTPUT.TXT для каждой процедуры, присутствующей во входных данных, необходимо вывести слово YES, если она является потенциально рекурсивной, и слово NO – в противном случае, в том же порядке, в каком они перечислены во входных данных.",
    "complexity": 46,
    "memory": 16000,
    "time": 1000,
    "examples": [
      {
        "input": "3\n\np1\n\n2\n\np1\n\np2\n\n*****\n\np2\n\n1\n\np1\n\n*****\n\np3\n\n1\n\np1\n\n*****",
        "output": "YES\n\nYES\n\nNO"
      }
    ]
  },
  {
    "id": 344,
    "name": "Ближайшие точки",
    "description": "Антон в школе начал изучать математику. Его внимание привлекло новое для него понятие числовой прямой. Антон быстро научился вычислять расстояния между двумя точками на этой прямой, задавать отрезки и интервалы на ней.\niOUTPUT.TXT14 2[Лучшие попытки]\nГотовясь к контрольной работе, Антон столкнулся со следующей задачей: «На числовой прямой задано n точек. Необходимо найти среди них две ближайшие». Расстояние между двумя точками числовой прямой x и y равно |x - y|.\n9\nТребуется написать программу, которая поможет Антону решить поставленную задачу.\nВходные данные\nПервая строка входного файла INPUT.TXT содержит количество точек n (2 ≤ n ≤ 105). Вторая строка содержит n различных целых чисел xi – координаты заданных точек числовой прямой. Числа в строке разделены пробелом. Значения всех координат xi не превосходят 109 по абсолютной величине.\nВыходные данные\nВ первой строке выходного файла OUTPUT.TXT необходимо вывести минимальное расстояние между двумя точками, заданными во входном файле. Во второй строке выходного файла необходимо вывести номера точек, которым соответствует найденное расстояние. Точки нумеруются натуральными числами от 1 до n в том порядке, в котором они заданы во входном файле. Если ответов несколько, выведите тот из них, в котором точки расположены левее других на числовой прямой. Первым выводится номер левой точки, далее через пробел – номер правой точки.",
    "complexity": 38,
    "memory": 32000,
    "time": 1000,
    "examples": [
      {
        "input": "5\n10 3 6 2 5",
        "output": "1\n4 2"
      }
    ]
  },
  {
    "id": 343,
    "name": "Укладка плиток",
    "description": "OUTPUT.TXT922 3\n2\n2 1 1\n3 1 2666[Лучшие попытки]\nВы являетесь одним из разработчиков нового архитектурного пакета прикладных программ «CadArch». Одной из его функций является проектирование укладки половых плиток. В настоящее время вы занимаетесь программной реализацией модуля, который отвечает за укладку плиток в прямоугольных помещениях.\n33 2\n2\n4 1 1\n1 2 16\nДля простоты будем считать, что пол помещения представляет собой прямоугольник размером n на m метров, разбитый на m∙n квадратиков со стороной по 1 метру. Кроме этого, будем считать, что имеется четыре типа плиток, показанные в таблице. Каждая из плиток представляет собой квадрат размером 2 на 2 метра, из которого вырезан один квадратик размером 1 на 1 метр.\nПроектируемый модуль должен работать следующим образом. На вход модуля подается набор команд, каждая из которых обозначает, в какое место и какого типа плитку необходимо положить. Команда обрабатывается следующим образом: если ни один из квадратиков, который должна занимать текущая плитка, не занят и плитка полностью помещается внутри прямоугольника, то плитка размещается в указанном месте, в противном случае – нет.\nТребуется написать программу, которая определяет, какая площадь в соответствии с заданным набором команд будет покрыта плитками.\nВходные данные\nПервая строка входного файла INPUT.TXT содержит два числа n и m — длина и ширина пола помещения (1 ≤ m, n ≤ 50). Вторая строка содержит число k — количество команд, которые необходимо обработать. Каждая из последующих k строк содержит описание одной команды из набора команд. Описание команды состоит из трех чисел. Первое число определяет тип плитки (число от 1 до 4), а два других - координаты левого верхнего угла квадрата (y,x) размером 2 на 2, в который вписана соответствующая плитка (0 ≤ x, y, k ≤ 1000).\nВыходные данные\nВ выходной файл OUTPUT.TXT необходимо вывести одно число, определяющее площадь, покрытую плитками после выполнения заданной во входном файле последовательности команд.",
    "complexity": 35,
    "memory": 16000,
    "time": 1000,
    "examples": [
      {
        "input": "4 4\n\n4\n\n4 1 1\n\n2 2 2\n\n3 1 1\n\n1 3 3",
        "output": "9"
      },
      {
        "input": "2 3\n\n2\n\n2 1 1\n\n3 1 2",
        "output": "6"
      },
      {
        "input": "3 2\n\n2\n\n4 1 1\n\n1 2 1",
        "output": "6"
      }
    ]
  },
  {
    "id": 329,
    "name": "Лесенка-2",
    "description": "Вова стоит перед лесенкой из N ступеней. На каждой из ступеней написаны произвольные целые числа. Первым шагом Вова может перейти на первую ступень или, перепрыгнув через первую, сразу оказаться на второй. Также он поступает и дальше, пока не достигнет N-ой ступени. Посчитаем сумму всех чисел, написанных на ступенях, через которые прошел Вова.\nOUTPUT.TXT41 2 3231 -1 121 321 3[Лучшие попытки]\nТребуется написать программу, которая определит оптимальный маршрут Вовы, при котором, шагая, он получит наибольшую сумму.\nВходные данные\nВходной файл INPUT.TXT содержит в первой строке натуральное число N – количество ступеней лестницы (2 ≤ N ≤ 1000). Во второй строке через пробел заданы числа, написанные на ступенях лестницы, начиная с первой. Числа, написанные на ступенях, не превосходят по модулю 1000.\nВыходные данные\nВыходной файл OUTPUT.TXT должен содержать в первой строке наибольшее значение суммы. Во второй строке должны быть записаны через пробел номера ступеней по возрастанию, по которым должен шагать Вова. Если существует несколько различных правильных маршрутов, то можно вывести любой из них.",
    "complexity": 37,
    "memory": 16000,
    "time": 1000,
    "examples": [
      {
        "input": "3\n1 2 1",
        "output": "4\n1 2 3"
      },
      {
        "input": "3\n1 -1 1",
        "output": "2\n1 3"
      }
    ]
  },
  {
    "id": 380,
    "name": "Площадь прямоугольников",
    "description": "Дано N прямоугольников со сторонами, параллельными осям координат. Требуется определить площадь фигуры, образованной объединением данных прямоугольников.\n2OUTPUT.TXT36221 1 3 32 2 4 477[Лучшие попытки]\nВходные данные2\nВ первой строке входного файла INPUT.TXT находится число прямоугольников - N. Затем идут N строк, содержащих по 4 числа: x1, y1, x2, y2 - координаты двух противоположных углов прямоугольника. Все координаты – целые числа, не превосходящие по абсолютной величине 10 000. (1 ≤ N  ≤ 100)\nВыходные данные\nВ выходной файл OUTPUT.TXT выведите одно целое число – площадь фигуры.",
    "complexity": 50,
    "memory": 16000,
    "time": 1000,
    "examples": [
      {
        "input": "1\n1 1 7 7",
        "output": "36"
      },
      {
        "input": "2\n1 1 3 3\n2 2 4 4",
        "output": "7"
      }
    ]
  },
  {
    "id": 355,
    "name": "Перестановки - 2",
    "description": "Дана строка, состоящая из N символов. Требуется вывести все перестановки символов данной строки.\nOUTPUT.TXTABBA2122122212221122212221[Лучшие попытки]\nВходные данные\nВходной файл INPUT.TXT содержит строку, состоящую из N символов (1 ≤ N ≤ 8), символы - буквы английского алфавита и цифры.\nВыходные данные\nВ выходной файл OUTPUT.TXT выведите в каждой строке по одной перестановке. Перестановки можно выводить в любом порядке. Повторений и строк, не являющихся перестановками исходной, быть не должно.",
    "complexity": 46,
    "memory": 16000,
    "time": 1000,
    "examples": [
      {
        "input": "AB",
        "output": "AB\nBA"
      },
      {
        "input": "122",
        "output": "122\n212\n221"
      }
    ]
  },
  {
    "id": 300,
    "name": "Радар",
    "description": "Радар подвергается атаке из четырех точек, являющихся вершинами квадрата, в центре которого и стоит радар. Радар укомплектован специальным щитом, позволяющим блокировать удар, но щит может защищать радар только с одной из четырех сторон, и поворот щита требует времени. Изначально щит направлен в сторону той вершины, откуда будет первая атака. Известно время запуска и скорость ракет, ведущих атаку.\nxOUTPUT.TXTALIVE20 10\n10 10\n5 10\n15 10\n5 100\n11[Лучшие попытки]\nТребуется определить, сколько ракет удастся отбить.\nx\nВходные данныеpov\nПервые четыре строки входного файла INPUT.TXT содержат время запуска в секундах Tx  (0 ≤ Tx ≤ 1000) и скорость полета в метрах в секунду Vx x-ой ракеты (0 \u003c Vx ≤ 1000). Ракеты перечисляются по часовой стрелке Далее задано время в секундах, необходимое для поворота щита на 90 градусов Tpov (0 \u003c Tpov ≤ 1000) и половина диагонали квадрата D – расстояние в метрах, предстоящее каждой из ракет (0 \u003c D \u003c 1000). Все числа – целые.\npov\nВыходные данные\nВ выходной файл OUTPUT.TXT выведите «ALIVE», если радар уцелеет при всех выстрелах, в противном случае следует вывести число успешно отраженных ракет. Если несколько ракет подлетают к радару одновременно, и радар может защититься от хотя бы одной из них, то он защищается от одной ракеты, и ее удар считается отраженным.",
    "complexity": 48,
    "memory": 16000,
    "time": 1000,
    "examples": [
      {
        "input": "0 10\n\n5 10\n\n10 10\n\n15 10\n\n5 100",
        "output": "ALIVE"
      },
      {
        "input": "0 10\n\n10 10\n\n5 10\n\n15 10\n\n5 100",
        "output": "1"
      }
    ]
  },
  {
    "id": 353,
    "name": "Треугольники",
    "description": "Дан набор из нескольких отрезков. Необходимо составить треугольник наибольшей площади, используя в качестве сторон три отрезка из заданных.\nOUTPUT.TXT13.998233 4 56.0006.0000[Лучшие попытки]\nТребуется написать программу, которая найдет наибольшую площадь треугольника.\n331 2 50\nВходные данные\nВходной файл INPUT.TXT содержит в первой строке одно целое число N (3 ≤ N ≤ 1000) – количество отрезков. Во второй строке содержатся N целых чисел от 1 до 1000 – длины отрезков. Числа разделены пробелом.\nВыходные данные\nВыходной файл OUTPUT.TXT должен содержать одно число с тремя десятичными знаками после запятой – наибольшую площадь треугольника из заданных отрезков. Если из заданных отрезков нельзя построить ни одного треугольника, то следует вывести 0.",
    "complexity": 41,
    "memory": 16000,
    "time": 1000,
    "examples": [
      {
        "input": "5\n2 4 8 16 7",
        "output": "13.998"
      },
      {
        "input": "3\n3 4 5",
        "output": "6.000"
      },
      {
        "input": "3\n1 2 5",
        "output": "0"
      }
    ]
  },
  {
    "id": 356,
    "name": "Копилка",
    "description": "Задан вес E пустой копилки и вес F копилки с монетами. В копилке могут находиться монеты N видов, для каждого вида известна ценность Pi и вес Wi одной монеты. Найти минимальную и максимальную суммы денег, которые могут находиться в копилке.\niOUTPUT.TXT100 25021000 1010\n2\n6 3\n2 2\n10 1610 16This is impossible.[Лучшие попытки]\nВходные данныеi31000 2000\n1\n10 3\nThis is impossible.\nВ первой строке входного файла INPUT.TXT находятся числа E и F, во второй - число N, в следующих N строках - по два числа, Pi и Wi. (1 ≤ E ≤ F ≤ 10000, 1 ≤ N ≤ 500, 1 ≤ Pi ≤ 50000, 1 ≤ Wi ≤ 10000).\nВыходные данные\nВ выходной файл OUTPUT.TXT выведите два числа через пробел - минимальную и максимальную суммы. Если копилка не может иметь точно заданный вес при условии, что она наполнена монетами заданных видов, следует вывести \"This is impossible.\".",
    "complexity": 49,
    "memory": 16000,
    "time": 1000,
    "examples": [
      {
        "input": "1000 1100\n\n2\n\n1 1\n\n5 2",
        "output": "100 250"
      },
      {
        "input": "1000 1010\n\n2\n\n6 3\n\n2 2",
        "output": "10 16"
      },
      {
        "input": "1000 2000\n\n1\n\n10 3",
        "output": "This is impossible."
      }
    ]
  },
  {
    "id": 382,
    "name": "Покраска лабиринта",
    "description": "Лабиринт представляет собой квадрат, состоящий из N×N сегментов. Каждый из сегментов может быть либо пустым, либо заполненным монолитной каменной стеной. Гарантируется, что левый верхний и правый нижний сегменты пусты. Лабиринт обнесён сверху, снизу, слева и справа стенами, оставляющими свободными только левый верхний и правый нижний углы. Директор лабиринта решил покрасить стены лабиринта, видимые изнутри (см. рисунок). Помогите ему рассчитать количество краски, необходимой для этого.\nOUTPUT.TXT550[Лучшие попытки]\nВходные данные\nВ первой строке входного файла INPUT.TXT находится число N, затем идут N строк по N символов: точка обозначает пустой сегмент, решётка - сегмент со стеной. Размер сегментов – 5х5 метров, высота стен – 5 метров. (3 ≤ N ≤ 50)\nВыходные данные\nВ выходной файл OUTPUT.TXT выведите одно число - площадь видимой части внутренних стен лабиринта в квадратных метрах.",
    "complexity": 46,
    "memory": 16000,
    "time": 1000,
    "examples": [
      {
        "input": "5\n\n.....\n\n...##\n\n..#..\n\n..###\n\n.....",
        "output": "550"
      }
    ]
  },
  {
    "id": 354,
    "name": "Разложение на простые множители",
    "description": "Требуется вывести представление целого числа N в виде произведения простых чисел.\nOUTPUT.TXT52302*3*52*3*5[Лучшие попытки]\nВходные данные[Решение]\nВходной файл INPUT.TXT содержит натуральное число N (2 ≤ N ≤ 231-1).\nВыходные данные\nВ выходной файл OUTPUT.TXT выведите список простых множителей числа N в порядке неубывания, разделенных знаком «*».",
    "complexity": 27,
    "memory": 16000,
    "time": 1000,
    "examples": [
      {
        "input": "5",
        "output": "5"
      },
      {
        "input": "30",
        "output": "2*3*5"
      }
    ]
  },
  {
    "id": 361,
    "name": "Подстроки из одинаковых букв",
    "description": "В заданной строке, состоящей из малых английских букв, необходимо найти пару самых длинных подстрок, состоящих из одних и тех же букв (возможно, в разном порядке). Например, в строке twotwow это будут подстроки wotwo и otwow.\nOUTPUT.TXT02abcdea55[Лучшие попытки]\nВходные данные\nВходной файл INPUT.TXT содержит исходную строку, длиной от 1 до 100 символов.\nВыходные данные\nВыходной файл OUTPUT.TXT должен содержать единственное число – длину подстрок в максимальной паре, или 0, если таких подстрок в строке нет.",
    "complexity": 32,
    "memory": 16000,
    "time": 1000,
    "examples": [
      {
        "input": "abcde",
        "output": "0"
      },
      {
        "input": "abcdea",
        "output": "5"
      }
    ]
  },
  {
    "id": 351,
    "name": "Прыжки по буквам",
    "description": "Дана цепочка из N символов, состоящая из прописных английских букв. Необходимо пройти с первого символа цепочки до последнего символа, прыгая не более чем на K символов. Стоимость прыжка, при котором символ не меняется, равна 0, а стоимость прыжка на другой символ равна 1.\nOUTPUT.TXT2[Лучшие попытки]\nТребуется написать программу, которая вычислит наименьшую стоимость перехода с первого на последний символ.\nВходные данные\nВходной файл INPUT.TXT содержит в первой строке два целых числа: длина цепочки N (2 ≤ N ≤ 105) и максимальная длина прыжка K (1 ≤ K \u003c N). Во второй строке содержится цепочка из N  английских букв.\nВыходные данные\nВыходной файл OUTPUT.TXT должен содержать одно число – минимальную стоимость перехода.",
    "complexity": 56,
    "memory": 16000,
    "time": 1000,
    "examples": [
      {
        "input": "10 2\nABABBCACBC",
        "output": "2"
      }
    ]
  },
  {
    "id": 358,
    "name": "Забор в парке",
    "description": "В бесконечном парке деревья образуют квадратную решетку с шагом один метр. Часть парка было решено оградить забором, который представляет собой треугольник с заданными координатами вершин. Деревья, которые в точности попадают на вершины или стороны треугольника, придется срубить.\nOUTPUT.TXT620 0 -1 -1 -1 033[Лучшие попытки]\nТребуется написать программу, которая найдет количество таких деревьев.\nВходные данные\nВходной файл INPUT.TXT содержит шесть целых чисел – координаты вершин треугольника (абсцисса, ордината). Все числа по абсолютной величине не превышают 109 и разделены пробелами.\nВыходные данные\nВыходной файл OUTPUT.TXT должен содержать одно число – количество деревьев.",
    "complexity": 42,
    "memory": 16000,
    "time": 1000,
    "examples": [
      {
        "input": "0 0 2 0 0 2",
        "output": "6"
      },
      {
        "input": "0 0 -1 -1 -1 0",
        "output": "3"
      }
    ]
  },
  {
    "id": 372,
    "name": "Скобки - 2",
    "description": "Вывести все правильные скобочные выражения длиной N, состоящие из круглых и квадратных скобок.\nOUTPUT.TXT()\n[]\n24(())\n[[]]\n[()]\n()[]\n[]()\n()()\n([])\n[][](())\n[[]]\n[()]\n()[]\n[]()\n()()\n([])\n[][][Лучшие попытки]\nВходные данные\nВходной файл INPUT.TXT содержит единственное четное натуральное число N, не превышающее 14.\nВыходные данные\nВ выходной файл OUTPUT.TXT выведите всевозможные правильные скобочные выражения по одному в каждой строке в произвольном порядке.",
    "complexity": 52,
    "memory": 16000,
    "time": 1000,
    "examples": [
      {
        "input": "2",
        "output": "()\n\n[]"
      },
      {
        "input": "4",
        "output": "(())\n\n[[]]\n\n[()]\n\n()[]\n\n[]()\n\n()()\n\n([])\n\n[][]"
      }
    ]
  },
  {
    "id": 357,
    "name": "Делимость на 11",
    "description": "Для делимости числа на 11 необходимо, чтобы разность между суммой цифр, стоящих на четных местах, и суммой цифр, стоящих на нечетных местах, делилась на 11. \nOUTPUT.TXTYES21211NONO[Лучшие попытки]\nТребуется написать программу, которая проверит делимость заданного числа на 11.\nВходные данные\nВходной файл INPUT.TXT содержит одно натуральное число N, делимость которого надо проверить (1 ≤ N ≤ 1010000).\nВыходные данные\nВ выходной файл OUTPUT.TXT выведите “YES”, если число делится на 11, или “NO” иначе.",
    "complexity": 22,
    "memory": 16000,
    "time": 1000,
    "examples": [
      {
        "input": "121",
        "output": "YES"
      },
      {
        "input": "1211",
        "output": "NO"
      }
    ]
  },
  {
    "id": 306,
    "name": "Танец",
    "description": "На городском празднике танцуют девушки в красных и синих юбках. Они двигаются цепочкой и выполняют сложный рисунок танца. Из цепочки девушки выделяются по одной. Первая становится на левом краю сцены, вторая уходит в конец исходной цепочки, третья – на левый край сцены (справа от первой), четвертая – в конец исходной цепочки и т.д., пока все девушки не выстроятся на краю сцены. \nOUTPUT.TXTBR23BBRBBRBBRR[Лучшие попытки]\nПомогите постановщику танца определить, каким должно быть исходное расположение девушек, если на краю сцены, они выстроены так, что их юбки чередуются по цвету (слева направо): синяя, красная, синяя, красная и т.д.\n34BBRR\nВходные данные\nВо входном файле INPUT.TXT записано натуральное число N – количество танцующих девушек (N ≤ 1000).\nВыходные данные\nВ выходной файл OUTPUT.TXT выведите строку, содержащую цепочку из N символов, состоящую из заглавных букв B и R, соответствующих цветам юбок – синему и красному.",
    "complexity": 45,
    "memory": 16000,
    "time": 1000,
    "examples": [
      {
        "input": "2",
        "output": "BR"
      },
      {
        "input": "3",
        "output": "BBR"
      },
      {
        "input": "4",
        "output": "BBRR"
      }
    ]
  },
  {
    "id": 371,
    "name": "Дружественные числа",
    "description": "Два различных натуральных числа называются дружественными, если первое из них равно сумме делителей второго числа, за исключением самого второго числа, а второе равно сумме делителей первого числа, за исключением самого первого числа. Требуется найти все пары дружественных чисел, оба из которых принадлежат промежутку от M до N.\nOUTPUT.TXT220 2842200 250AbsentAbsent185368 203432196724 202444[Лучшие попытки]\nВходные данные3185000 205000185368 203432196724 202444\nВходной файл INPUT.TXT в первой строке содержит натуральные числа M и N, разделенные пробелом, не превышающие 106.\nВыходные данные\nВ выходной файл OUTPUT.TXT выведите в каждой строке по паре чисел через пробел. Первое число пары должно быть меньше второго. Строки должны быть отсортированы в порядке возрастания первого числа пары. Если пар дружественных чисел в промежутке нет, то следует вывести \"Absent\".",
    "complexity": 58,
    "memory": 16000,
    "time": 1000,
    "examples": [
      {
        "input": "200 300",
        "output": "220 284"
      },
      {
        "input": "200 250",
        "output": "Absent"
      },
      {
        "input": "185000 205000",
        "output": "185368 203432\n196724 202444"
      }
    ]
  },
  {
    "id": 415,
    "name": "Подпись",
    "description": "Марсиане Миша и Маша решили вместе подобрать подарок на день рождения Кати. Когда они наконец нашли то, что хотели, и упаковали предмет в красивую коробку, надо было решить, как подписать подарок. Друзья подумали, что лучшим решением будет составить общую подпись так, чтобы в ней как подстроки содержались их имена.\nOUTPUT.TXTMashaMisha2JulyaLyalyaJuLyalyaJuLyalya[Лучшие попытки]\nУчтите, что на Марсе принято подписываться полными именами, а они у марсиан могут быть достаточно длинными.\n[Решение]\nВходные данные\nВходной файл INPUT.TXT содержит две строки, в которых записаны полные имена друзей. Имена, как ни странно, состоят из букв английского алфавита, из которых только первая – прописная. Длина имен от 1 до 1000 символов.\nВыходные данные\nВ выходной файл OUTPUT.TXT выведите кратчайшую строку, в которой встречаются имена Миши и Маши одновременно. Буквы, с которых имена начинаются в этой строке нужно сделать большими. Если существует несколько решений, выведите то, которое меньше в алфавитном порядке (следует считать, что любая буква в верхнем регистре меньше, чем любая буква в нижнем регистре).",
    "complexity": 44,
    "memory": 16000,
    "time": 1000,
    "examples": [
      {
        "input": "Misha\nMasha",
        "output": "MashaMisha"
      },
      {
        "input": "Julya\nLyalya",
        "output": "JuLyalya"
      }
    ]
  },
  {
    "id": 384,
    "name": "Числа Фибоначчи - 3",
    "description": "Выходные данные\nВ выходной файл OUTPUT.TXT выведите остаток от деления НОД чисел Fi и Fj на 109.",
    "complexity": 52,
    "memory": 16000,
    "time": 1000,
    "examples": [
      {
        "input": "5 10",
        "output": "5"
      },
      {
        "input": "2 4",
        "output": "1"
      }
    ]
  },
  {
    "id": 363,
    "name": "Длинное произведение",
    "description": "Даны целые неотрицательные числа M и N.  Требуется найти произведение этих чисел.\nOUTPUT.TXT35241349378275927843241791256832128324179125683212810108215200126352690[Лучшие попытки]\nВходные данные39876543210102345678910108215200126352690[Решение]\nВходной файл INPUT.TXT содержит в первой строке число M, а во второй строке – число N. (0 ≤ M, N ≤ 102500)\nВыходные данные\nВ выходной файл OUTPUT.TXT выведите произведение чисел M и N.",
    "complexity": 46,
    "memory": 16000,
    "time": 1000,
    "examples": [
      {
        "input": "5\n7",
        "output": "35"
      },
      {
        "input": "4134937827592\n784",
        "output": "3241791256832128"
      },
      {
        "input": "9876543210\n1023456789",
        "output": "10108215200126352690"
      }
    ]
  },
  {
    "id": 431,
    "name": "Путь коня",
    "description": "Дана шахматная доска, состоящая из N×N клеток, несколько из них вырезано. Провести ходом коня через невырезанные клетки путь минимальной длины из одной заданной клетки в другую.\nOUTPUT.TXT...@.\n.@@..\n....@\n.....\n.....\n25\n@..@.\n..##.\n.....\n.....\n.....\n@..@.\n..##.\n.@..@\n..@..\n@....\n@..@.\n..##.\n.@..@\n..@..\n@....\nImpossible[Лучшие попытки]\nВходные данные35\n@....\n..#..\n.#...\n.....\n....@\nImpossible\nВ первой строке входного файла INPUT.TXT задано число N (2 ≤ N ≤ 50). В следующих N строках содержится по N символов. Символом # обозначена вырезанная клетка, точкой - невырезанная клетка, @ - заданные клетки (таких символов два), соответствующие началу и концу пути коня.\nВыходные данные\nЕсли путь построить невозможно, в выходной файл OUTPUT.TXT следует вывести \"Impossible\", в противном случае вывести такую же карту, как и на входе, но пометить все промежуточные положения коня символом @.",
    "complexity": 44,
    "memory": 16000,
    "time": 1000,
    "examples": [
      {
        "input": "5\n\n.....\n\n.@@..\n\n.....\n\n.....\n\n.....",
        "output": "...@.\n\n.@@..\n\n....@\n\n.....\n\n....."
      },
      {
        "input": "5\n\n@..@.\n\n..##.\n\n.....\n\n.....\n\n.....",
        "output": "@..@.\n\n..##.\n\n.@..@\n\n..@..\n\n@...."
      },
      {
        "input": "5\n\n@....\n\n..#..\n\n.#...\n\n.....\n\n....@",
        "output": "Impossible"
      }
    ]
  },
  {
    "id": 362,
    "name": "Открытка и конверт",
    "description": "Даны размеры прямоугольных открытки и конверта. Требуется определить, поместится ли открытка в конверте.\nOUTPUT.TXTPossible210 1515 10PossiblePossibleImpossible[Лучшие попытки]\nВходные данные33 43 3Impossible\nВходной файл INPUT.TXT содержит в первой строке размеры открытки, во второй строке заданы размеры конверта. Все размеры – натуральные числа, не превосходящие 100.\nВыходные данные\nВ выходной файл OUTPUT.TXT выведите «Possible», если открытку можно разместить в конверте и «Impossible» в противном случае.",
    "complexity": 50,
    "memory": 16000,
    "time": 1000,
    "examples": [
      {
        "input": "1 10\n9 9",
        "output": "Possible"
      },
      {
        "input": "10 15\n15 10",
        "output": "Possible"
      },
      {
        "input": "3 4\n3 3",
        "output": "Impossible"
      }
    ]
  },
  {
    "id": 416,
    "name": "Шахматный конь",
    "description": "OUTPUT.TXTc1\nc3\nd4\nf4\ng1\ng3\n2a1b3c2b3c2[Лучшие попытки]\nВася решил научиться играть в шахматы. Он нашел книгу с записями партий и внимательно их изучает. Может быть, когда-нибудь Вася станет великим шахматистом, но пока он еще учится в начальной школе, и ему нелегко дается шахматная нотация. Больше всего трудностей у Васи вызывают ходы шахматного коня. Он попросил вас написать программу, которая сможет сообщить Васе, на какие клетки можно пойти конем с заданной клетки.\nВы, наверное, тоже знаете, что конь в шахматах всегда перемещается либо на две клетки по горизонтали и на одну по вертикали, либо на одну по горизонтали и на две по вертикали. Вертикали обозначаются маленькими английскими буквами от a до h, а горизонтали - цифрами от 1 до 8. Любая клетка на шахматной доске обозначается буквой соответствующей вертикали и цифрой соответствующей горизонтали, например, c6 или e2.\nВходные данные\nВо входном файле INPUT.TXT записано 2 символа – координаты клетки, где стоит конь.\nВыходные данные\nВ выходной файл OUTPUT.TXT в произвольном порядке выведите все координаты клеток, на которые за один ход может попасть конь, находящийся на заданной клетке.",
    "complexity": 25,
    "memory": 16000,
    "time": 1000,
    "examples": [
      {
        "input": "e2",
        "output": "c1\n\nc3\n\nd4\n\nf4\n\ng1\n\ng3"
      },
      {
        "input": "a1",
        "output": "b3\nc2"
      }
    ]
  },
  {
    "id": 359,
    "name": "Змейка - 2",
    "description": "Мальчик Вася на уроке математики, вместо того, чтобы слушать учителя, рисовал числа в тетрадке в клеточку. Да не просто так рисовал, а определенным образом. Сначала он поставил в клетку число 1. Затем справа от нее нарисовал число 2. Затем снизу от числа 2 написал число 3. Затем перешёл на клетку правее и продолжил увлекательное занятие двигаясь по столбцу вверх, пока число в этом столбце не стало выше самого верхнего числа в предыдущем столбце. Затем он перешёл на клетку правее и опять таки продолжил рисование чисел, начиная с 7, но только уже сверху вниз, пока не нарисовал число, которое оказалось на одну клетку ниже самого нижнего числа в предыдущем столбце. И так далее. Вася не любил числа, заканчивающиеся нулем, и пропускал их при рисовании змейки. Первые его шесть заполненных столбцов мы скопировали из его тетрадки и привели здесь на рисунке. Так как Вася очень любопытный, то он очень хочет узнать, какое же число будет у него стоять в N-ом столбце в той строке, где стоит число 1. Первые 6 таких чисел в этой строке видны на рисунке: 1, 2, 5, 8, 14, 19.\nOUTPUT.TXT5251414[Лучшие попытки]\nТребуется написать программу, которая поможет Васе.\nВходные данные\nВходной файл INPUT.TXT содержит одно число N (1 ≤ N ≤ 106) – номер столбца.\nВыходные данные\nВыходной файл OUTPUT.TXT должен содержать N-ое число в строке, где стоит число 1.",
    "complexity": 38,
    "memory": 16000,
    "time": 1000,
    "examples": [
      {
        "input": "3",
        "output": "5"
      },
      {
        "input": "5",
        "output": "14"
      }
    ]
  },
  {
    "id": 360,
    "name": "Максимальная тройка",
    "description": "В данной двумерной целочисленной таблице размером N × N требуется найти три элемента, сумма которых максимальна. При этом первый элемент должен быть соседним по горизонтали или вертикали со вторым, а второй — с третьим.\nOUTPUT.TXT6[Лучшие попытки]\nВходные данные\nВходной файл INPUT.TXT содержит в первой строке число N (1 \u003c N ≤ 2000). В следующих N строках записано по N чисел – элементы таблицы. Элементы матрицы по абсолютной величине не превышают 100.\nВыходные данные\nВыходной файл OUTPUT.TXT должен содержать единственное число — максимальную сумму.",
    "complexity": 33,
    "memory": 16000,
    "time": 1000,
    "examples": [
      {
        "input": "3\n\n1 1 1\n\n2 2 1\n\n2 1 0",
        "output": "6"
      }
    ]
  },
  {
    "id": 417,
    "name": "Даты",
    "description": "При обработке различной информации часто приходится оперировать с данными о датах. В этой задаче вам нужно составить программу, которая сможет вывести число, месяц и день недели, которые наступят через K дней, начиная с первого января 2008 года. Напомним, что это был вторник.\nOUTPUT.TXTTuesday, 01.0125Sunday, 06.01Sunday, 06.01[Лучшие попытки]\nВходные данные\nВходной файл INPUT.TXT содержит одно целое число K (0 ≤ K ≤ 1000) - количество дней, после первого января, через которое наступит (или наступила) интересующая дата.\nВыходные данные\nВ выходной файл OUTPUT.TXT ваша программа должна записать, какие день недели, число и месяц наступят по прошествии заданного времени. Результаты проверяются автоматически, поэтому вам следует придерживаться формата, показанного в примерах.",
    "complexity": 34,
    "memory": 16000,
    "time": 1000,
    "examples": [
      {
        "input": "0",
        "output": "Tuesday, 01.01"
      },
      {
        "input": "5",
        "output": "Sunday, 06.01"
      }
    ]
  },
  {
    "id": 373,
    "name": "Маршрут - 2",
    "description": "Дана матрица N×N, заполненная положительными числами. Путь по матрице начинается в левом верхнем углу. За один ход можно пройти в соседнюю по вертикали или горизонтали клетку (если она существует). Нельзя ходить по диагонали, нельзя оставаться на месте. \nOUTPUT.TXT21[Лучшие попытки]\nТребуется найти максимальную сумму чисел, стоящих в клетках по пути длиной K (клетку можно посещать несколько раз).\nВходные данные\nВходной файл INPUT.TXT в первой строке содержит разделенные пробелом числа N и K. Затем идут N строк по N чисел в каждой – данные таблицы. Элементы матрицы – целые числа от 1 до 9999, 2 ≤ N ≤ 100, 1 ≤ K ≤ 2000.\nВыходные данные\nВ выходной файл OUTPUT.TXT выведите одно число – максимальную сумму.",
    "complexity": 47,
    "memory": 16000,
    "time": 1000,
    "examples": [
      {
        "input": "5 7\n\n1 1 1 1 1\n\n1 1 3 1 9\n\n1 1 6 1 1\n\n1 1 3 1 1\n\n1 1 1 1 1",
        "output": "21"
      }
    ]
  },
  {
    "id": 456,
    "name": "Сундук Билли Бонса",
    "description": "Билли Бонс положил в сундук некоторое количество золотых монет. На второй год он вынул из сундука положительное количество монет. Начиная с третьего года, он добавлял столько монет, сколько было в сундуке два года назад.\nOUTPUT.TXT5 2[Лучшие попытки]\nТребуется написать программу, которая определит, сколько монет было в сундуке в первый и во второй года, если в X-м году там оказалось ровно Y монет.\nВходные данные\nВходной файл INPUT.TXT содержит натуральные числа X и Y (3 ≤ X ≤ 20, 1 ≤ Y ≤ 32767).\nВыходные данные\nВ выходной файл OUTPUT.TXT выведите через пробел количество монет в первый и второй года. Гарантируется, что решение задачи всегда существует.",
    "complexity": 33,
    "memory": 16000,
    "time": 1000,
    "examples": [
      {
        "input": "6 25",
        "output": "5 2"
      }
    ]
  },
  {
    "id": 443,
    "name": "Хеш-функция",
    "description": "В задачах поиска часто используются так называемые хеш-функции. Одним из важнейших классов хеш-функций являются так называемые полиномиальные хеш-функции.\nl(n)(i)OUTPUT.TXT1125 10 100\n1\n2\n3\n4\n5\n00[Лучшие попытки]\nПусть дана строка S = s1s2 … sl, состоящая из цифр от 0 до 9. Тогда значение полиномиальной хеш-функции p(S, x, m) вычисляется следующим образом:\n(i)(n)\n(j)(i)\n(a mod b обозначает остаток от деления числа a на число b). Например, пусть S = 0123, тогда p(S, 2, 5) = (0 • 1 + 1 • 2 + 2 • 4 + 3 • 8) mod 5 = 4.\n(i)\nВам даны множество из n строк (S(1), S(2), … , S(n)), каждая из которых состоит только из цифр от 0 до 9, и числа m и x. Необходимо найти количество таких пар (i, j), где 1 ≤ i, j ≤ n, i \u003c j, что p(S(i), x, m) = p(S(j), x, m).\nВходные данные\nПервая строка входного файла INPUT.TXT содержит три целых числа: n (1 ≤ n ≤ 30000), m (1 ≤ m ≤ 2000), x (1 ≤ x ≤ 100). Далее идут n строк, каждая из которых содержит по одной строке из данного множества: 2-ая строка входного файла содержит S(1), 3-я - S(2), . . . , (i + 1)-ая - S(i), ... , (n + 1)-ая - S(n). Длины S(i) не превосходят 100, S(i) не пусты и состоят только из цифр от 0 до 9.\nВыходные данные\nВ выходной файл OUTPUT.TXT выведите ответ на задачу.",
    "complexity": 37,
    "memory": 16000,
    "time": 1000,
    "examples": [
      {
        "input": "8 3 8\n\n1234\n\n239\n\n366\n\n261\n\n32890\n\n43823490\n\n382390\n\n3043840",
        "output": "11"
      },
      {
        "input": "5 10 100\n\n1\n\n2\n\n3\n\n4\n\n5",
        "output": "0"
      }
    ]
  },
  {
    "id": 432,
    "name": "Грядки",
    "description": "Прямоугольный садовый участок шириной N и длиной M метров разбит на квадраты со стороной 1 метр. На этом участке вскопаны грядки. Грядкой называется совокупность квадратов, удовлетворяющая таким условиям:\nOUTPUT.TXT325 10\n##..#####.\n.#.#.#....\n###..##.#.\n..##.....#\n.###.#####\n55[Лучшие попытки]\nиз любого квадрата этой грядки можно попасть в любой другой квадрат этой же грядки, последовательно переходя по грядке из квадрата в квадрат через их общую сторону;\nникакие две грядки не пересекаются и не касаются друг друга ни по вертикальной, ни по горизонтальной сторонам квадратов (касание грядок углами квадратов допускается).\nПодсчитайте количество грядок на садовом участке.\nВходные данные\nВ первой строке входного файла INPUT.TXT находятся числа N и M через пробел, далее идут N строк по M символов. Символ # обозначает территорию грядки, точка соответствует незанятой территории. Других символов в исходном файле нет. (1 ≤ N, M ≤ 200)\nВыходные данные\nВ выходной файл OUTPUT.TXT выведите количество грядок на садовом участке.",
    "complexity": 40,
    "memory": 16000,
    "time": 1000,
    "examples": [
      {
        "input": "5 10\n\n##......#.\n\n.#..#...#.\n\n.###....#.\n\n..##....#.\n\n........#.",
        "output": "3"
      },
      {
        "input": "5 10\n\n##..#####.\n\n.#.#.#....\n\n###..##.#.\n\n..##.....#\n\n.###.#####",
        "output": "5"
      }
    ]
  },
  {
    "id": 374,
    "name": "Выпуклая оболочка - 2",
    "description": "На плоскости заданы N точек своими декартовыми координатами. Найти минимальный периметр многоугольника, содержащего все эти точки. Гарантируется, что искомый многоугольник имеет ненулевую площадь.\niOUTPUT.TXT5.7[Лучшие попытки]\nВходные данныеi\nВходной файл INPUT.TXT в первой строке содержит число N, далее - N строк с парами координат (xi, yi). Ограничения: 3 ≤ N ≤ 1000, -10 000 ≤ xi, yi ≤ 10 000, все числа целые, все точки различны.\nВыходные данные\nВ выходной файл OUTPUT.TXT выведите одно вещественное число - длину периметра полученного многоугольника с одним знаком после запятой.",
    "complexity": 55,
    "memory": 16000,
    "time": 1000,
    "examples": [
      {
        "input": "5\n\n1 0\n\n0 1\n\n-1 0\n\n0 -1\n\n0 0",
        "output": "5.7"
      }
    ]
  },
  {
    "id": 444,
    "name": "Список",
    "description": "В наше время создатели офисных приложений стараются сделать все для удобства пользователя. Поэтому даже такая мелочь, как представление на экране списков чисел - например, для вывода номеров страниц, - должна быть тщательно проработана. \nOUTPUT.TXT-1, 1, 3, ..., 6[Лучшие попытки]\nВы должны реализовать функцию, которая по заданному набору целых чисел будет формировать строку, являющуюся его самым коротким текстовым представлением. Текстовое представление - строка, состоящая из разделенных запятыми чисел и диапазонов чисел вида \u003c a, ..., b \u003e, которые используются для записи набора всех чисел от a до b. При этом все числа, входящие в строку, должны быть упорядочены по возрастанию в том порядке, в котором они встречаются в строке.\nВходные данные\nВходной файл INPUT.TXT содержит целое число N (1 ≤ N ≤ 1000) - размер набора. Вторая строка содержит N задающих набор целых чисел, по абсолютной величине не превосходящих 10000, разделенные пробелами. Одно число может встречаться в этом описании несколько раз.\nВыходные данные\nВ выходной файл OUTPUT.TXT выведите одно из кратчайших текстовых представлений заданного набора чисел. Следите за правильной расстановкой пробелов. Выходной файл в примере содержит ровно четыре пробела.",
    "complexity": 35,
    "memory": 16000,
    "time": 1000,
    "examples": [
      {
        "input": "7\n\n1 3 5 -1 1 4 6",
        "output": "-1, 1, 3, ..., 6"
      }
    ]
  },
  {
    "id": 308,
    "name": "Вода",
    "description": "Имеется три ведра, емкости которых известны и не равны. Самое большое ведро полное, остальные пусты. Требуется добиться, чтобы в самом большом ведре был заданный объем воды. За один шаг вода переливается из одного ведра в другое до тех пор, пока либо не закончится вода в ведре-источнике, либо не наполнится доверху вода в ведре-получателе.\nOUTPUT.TXT3210 8 4 5IMPOSSIBLEIMPOSSIBLE[Лучшие попытки]\nШкольник Василий, чтобы занять себя, пытается решать эту задачу с разными входными данными, но не всегда находит решение. И даже если решение найдено, он хочет знать, является ли найденное решение оптимальным, а именно, используется ли минимальное количество шагов. Требуется написать программу, которая поможет Василию проверить его решение.\nВходные данные\nВо входном файле INPUT.TXT записаны 4 числа: емкости ведер B1, B2, B3 (1000 ≥ B1 \u003e B2 \u003e B3 \u003e 0) и требуемое количество воды  T в первом ведре (B1 \u003e T \u003e 0).\nВыходные данные\nВ выходной файл OUTPUT.TXT выведите либо минимальное количество переливаний, либо если задача не имеет решения, то слово IMPOSSIBLE.",
    "complexity": 53,
    "memory": 16000,
    "time": 1000,
    "examples": [
      {
        "input": "10 8 4 4",
        "output": "3"
      },
      {
        "input": "10 8 4 5",
        "output": "IMPOSSIBLE"
      }
    ]
  },
  {
    "id": 445,
    "name": "Покупки",
    "description": "Во многих фирмах, занимающихся торговлей, существует должность менеджера по закупкам. Как известно, они занимаются тем, что по торговому плану, представляющему собой список наименований товаров, для каждого из которых указано необходимое количество, закупает указанные в нем товары на оптовых базах. Торговый план при этом составляется руководством компании. Иногда у менеджеров по закупкам возникает желание принести выгоду не только своей фирме, но и себе.\nOUTPUT.TXT2.0000\n0.5000\n0.0000\n0.0000\n[Лучшие попытки]\nТолько что, как раз после подписания очередного торгового плана на заказ n наименований товаров, открылась новая оптовая база. Как это часто бывает сразу после открытия, ее цены на многие товары ниже заложенных в план. Наверное, этим можно воспользоваться.\nНа закупку товаров были выделены деньги из расчета того, что все товары будут закупаться на старой оптовой базе. Менеджер хочет, воспользовавшись возможностью покупать товары на новой базе, потратить как можно меньше денег на закупку требуемого количества товаров (не потраченные деньги он, конечно, сможет забрать себе).\nЧтобы не вызывать сильных подозрений, производить на новой базе закупки, суммарная запланированная стоимость которых была больше, чем d денежных единиц, не следует. Осталось только рассчитать, какие товары и в каком количестве следует закупать на новой базе, чтобы осталось как можно больше не потраченных денег.\nВходные данные\nПервая строка содержит четыре числа: n (1 ≤ n ≤ 1000), d, а так же k1 и k2 (1 ≤ k1, k2 ≤ 1000) - количества наименований товаров, имеющихся на открытых ранее и новой базе соответственно. После этого идут n строк, каждая из которых содержит название товара в плане и его количество (положительное вещественное число). За ними следуют два блока из k1 и k2 строк соответственно, отделенные от предыдущего и разделенные между собой переводом строки - наименования товаров на базах и цены за единицу товара соответственно. Все цены являются положительными числами, даже на новой базе.\nНазвания товаров состоят из не более, чем 100 английских букв и символов подчеркивания, при этом регистр букв не учитывается. Вещественные числа заданы не более чем с двумя знаками после десятичной точки и по величине не превосходят 106. Гарантируется, что все товары из плана можно купить на старой базе. Считайте, что любой товар на любой базе можно покупать в любом дробном количестве, а также что при оплате можно использовать любое дробное количество денежных единиц.\nВыходные данные\nВ выходной файл OUTPUT.TXT выведите n вещественных чисел, по одному на строке, задающих количество соответствующего товара, закупаемого на новой базе. На i-ой строке выведите количество товара, идущего i-ым в плане. Ошибки менее 0.01 будут игнорироваться.",
    "complexity": 56,
    "memory": 16000,
    "time": 1000,
    "examples": [
      {
        "input": "4 11.00 5 4\n\nSalt 3\n\nsuGar 0.5\n\nPowdered_MilK 7\n\nfLoUR 8\n\n\n\nflOuR 1\n\nCINNAmOn 8\n\nsaLt 0.5\n\nSuGAr 20\n\npoWdErED_MILk 3\n\n\n\nFLOur 2\n\nSALT 0.4\n\nliQUID_HydRoGen 10000\n\nsUgAR 10",
        "output": "2.0000\n\n0.5000\n\n0.0000\n\n0.0000"
      }
    ]
  },
  {
    "id": 434,
    "name": "Стеклянный забор",
    "description": "OUTPUT.TXT6\n0 0\n9 0\n9 9\n6 9\n6 6\n0 6\n[Лучшие попытки]\nВ известном городе Санкт-Тверь решили построить новый микрорайон, представляющий в плане прямоугольную область. Границы микрорайона и его улицы по проекту ориентированы строго по сторонам света, причем улицы разбивают микрорайон на кварталы размером 1 км × 1 км.\nВо время привязки исходного проекта к местности выяснилось, что некоторые кварталы по проекту микрорайона оказываются полностью или частично расположенными на топком болоте. Область, занимаемая болотом, связна и со всех сторон окружена подлежащими застройке кварталами микрорайона (область  связна, если из любой ее точки можно добраться в любую другую, не выходя за пределы области).\nДля сохранения экологии местности и обеспечения безопасности жителей занятую болотом область решили оградить стеклянным забором. Забор должен проходить только по границам кварталов проектируемого микрорайона, отделяя болото, и, возможно, некоторые кварталы проекта, не занятые болотом, от остальной части микрорайона.\nДля экономии строительных материалов забор должен иметь минимальную длину. Среди всех заборов минимальной длины нужно выбрать тот, для которого площадь части микрорайона, попадающей внутрь забора, минимальна.\nТребуется написать программу, которая спроектирует забор с заданными выше свойствами.\nВходные данные\nВходной файл INPUT.TXT содержит описание многоугольника — границы области, состоящей только из кварталов c заболоченными участками. Стороны многоугольника параллельны осям координат.\nВ первой строке задано целое число N — количество вершин в многоугольнике (4 ≤ N ≤ 105, N четное). В каждой из следующих N строк заданы два целых числа — координаты очередной вершины при обходе этого многоугольника против часовой стрелки. Все числа не превосходят 109 по абсолютной величине. Никакие три последовательные вершины границы не лежат на одной прямой. Граница многоугольника не содержит самопересечений и самокасаний.\nВыходные данные\nВыходной файл OUTPUT.TXT должен содержать описание многоугольника, определяющего искомый забор. Формат описания многоугольника тот же, что и для входных данных. Никакие три последовательные вершины этого многоугольника не должны лежать на одной прямой.",
    "complexity": 72,
    "memory": 16000,
    "time": 1000,
    "examples": [
      {
        "input": "8\n\n0 0\n\n9 0\n\n9 9\n\n6 9\n\n6 3\n\n3 3\n\n3 6\n\n0 6",
        "output": "6\n\n0 0\n\n9 0\n\n9 9\n\n6 9\n\n6 6\n\n0 6"
      }
    ]
  },
  {
    "id": 420,
    "name": "Химическая формула",
    "description": "Запись химической реакции всегда содержит описания нескольких веществ. В свою очередь, описание одного химического вещества - строка, в которой входящие в него атомы химических элементов перечисляются в определенном порядке. При этом последовательности из двух и более одинаковых атомов, идущих подряд, группируются: записывается сокращенное название химического элемента и количество одинаковых элементов подряд. Например, вместо HH пишут H2. Обозначения химических элементов состоят из одной или двух английских букв, из которых первая - прописная, а вторая - строчная. В этой задаче не будут рассматриваться более сложные правила. Например, не используются скобки. Вы должны проверить, что заданная последовательность символов подходит под данное выше описание формулы химического вещества. При этом не нужно рассматривать корректность заданной строки, исходя из каких-либо других соображений, даже если они продиктованы здравым смыслом.\nOUTPUT.TXTYES2H2OYESYESNOYES[Лучшие попытки]\nВходные данные3HHNO\nВ единственной строке входного файла INPUT.TXT записана непустая последовательность символов, содержащая только цифры и строчные и прописные английские буквы. Гарантируется, что в последовательности перед каждой строчной буквой идет прописная, а все однобуквенные и двухбуквенные подстроки, начинающиеся с прописной буквы - правильные обозначения химических элементов (поэтому здесь даже не приводится их список). Длина последовательности от 1 до 1000 символов.\n4CHCYES\nВыходные данные\nВ выходной файл OUTPUT.TXT выведите одно слово YES, если данная строка подходит под упрощенное описание формулы химического вещества из условия и NO, если не подходит.",
    "complexity": 36,
    "memory": 16000,
    "time": 1000,
    "examples": [
      {
        "input": "OHNaOHNa",
        "output": "YES"
      },
      {
        "input": "H2O",
        "output": "YES"
      },
      {
        "input": "HH",
        "output": "NO"
      },
      {
        "input": "CHC",
        "output": "YES"
      }
    ]
  },
  {
    "id": 433,
    "name": "Школа танцев",
    "description": "В школу бальных танцев профессора Падеграса записались n учеников — мальчиков и девочек. Профессор построил их в один ряд, и хочет отобрать из них для первого занятия группу стоящих подряд учеников, в которой количество мальчиков и девочек одинаково. Сколько вариантов выбора есть у профессора?\nOUTPUT.TXT228abbababa1313[Лучшие попытки]\nВходные данные\nВ первой строке входного файла INPUT.TXT задано число n (1 ≤ N ≤ 106). Во второй строке задается описание построенного ряда из мальчиков и девочек — строка из n символов a и b (символ a соответствует девочке, а символ b — мальчику).\nВыходные данные\nВ единственной строке выходного файла OUTPUT.TXT должно содержаться единственное число — количество вариантов выбора требуемой группы.",
    "complexity": 52,
    "memory": 64000,
    "time": 1000,
    "examples": [
      {
        "input": "3\nbab",
        "output": "2"
      },
      {
        "input": "8\nabbababa",
        "output": "13"
      }
    ]
  },
  {
    "id": 419,
    "name": "Палиндром",
    "description": "Одно из известных развлечений со словами - составление палиндромов. Палиндромом называется предложение, которое, после удаления из него всех пробелов и знаков препинания, читается одинаково справа налево и слева направо. Создатели одного известного текстового редактора пишут новую версию модуля для проверки орфографии. Они хотят реализовать возможность вывода подсказки для пользователя на тот случай, если он допустил опечатку при наборе какого-нибудь палиндрома. Конечно же, они решили обратиться именно к вам.\nOUTPUT.TXTYESNeVErODDoREVen2Eat it!NONOYESSums are not set as a test on Erasmus.[Лучшие попытки]\nБолее точно, по заданной строке нужно определить, может ли она быть результатом замены, удаления или добавления не более чем \nодного символа в некотором палиндроме. При этом строчные и прописные английские буквы не различаются, а все остальные символы должны игнорироваться.\n3Mums are not set as a test on Erasmus.YESSums are not set as a test on Erasmus.\nВходные данные\nВо входном файле INPUT.TXT содержится заданная строка. Гарантируется, что она содержит хотя бы одну букву. Длина строки не превосходит 105.\nВыходные данные\nВ первой строке выходного файла OUTPUT.TXT выведите YES, если строка может быть получена каким-нибудь из описанных выше преобразований из некоторого палиндрома, и NO в противном случае. В случае положительного ответа во второй строке выведите какой-нибудь из палиндромов, в которых мог допустить опечатку пользователь.",
    "complexity": 41,
    "memory": 16000,
    "time": 1000,
    "examples": [
      {
        "input": "Never odd or even",
        "output": "YES\nNeVErODDoREVen"
      },
      {
        "input": "Eat it!",
        "output": "NO"
      },
      {
        "input": "Mums are not set as a test on Erasmus.",
        "output": "YES\nSums are not set as a test on Erasmus."
      }
    ]
  },
  {
    "id": 421,
    "name": "Треугольники - 2",
    "description": "Когда Вова зашел в класс математики, на школьной доске было в беспорядке нарисовано некоторое количество треугольников. Вове очень понравилась идея разрисовывания доски треугольниками, и он принялся изучать ситуацию более внимательно. Вова подумал, что наиболее простой и быстрый способ ровно нарисовать такое количество треугольников - вырезать из какого-нибудь материала шаблон и обводить его на доске мелом. Кроме того Вова предположил, что тот, кто рисовал треугольники, должно быть, очень спешил, и потому перемещал шаблон, не отрывая никакую его часть от доски.\nOUTPUT.TXTYES22\n1 1 4 1 2 2\n1 1 4 1 3 2\nNONO[Лучшие попытки]\nПомогите Вове проверить его гипотезу, если он готов сообщить вам тщательно измеренные координаты вершин треугольников.\nВходные данные\nВ первой строке входного файла INPUT.TXT записано одно целое число - количество треугольников N (2 ≤ N ≤ 100). Последующие N строк описывают треугольники, строка i+1 содержит 3 пары положительных целых чисел, не превосходящих 10000 - координаты вершин треугольника номер i.\nВыходные данные\nВ выходной файл OUTPUT.TXT выведите ответ на задачу: YES, если все треугольники можно было нарисовать, обводя один шаблон и не отрывая этот шаблон от доски, и NO в противном случае.",
    "complexity": 47,
    "memory": 16000,
    "time": 1000,
    "examples": [
      {
        "input": "3\n\n1 1 1 2 2 1\n\n2 1 2 2 1 2\n\n1 1 2 1 2 2",
        "output": "YES"
      },
      {
        "input": "2\n\n1 1 4 1 2 2\n\n1 1 4 1 3 2",
        "output": "NO"
      }
    ]
  },
  {
    "id": 424,
    "name": "Игра умножения",
    "description": "Слава и Оля играют в игру умножения: умножают целое число P на одно из чисел от 2 до 9. Слава всегда начинает с P = 1, делает умножение, затем число умножает Оля, затем Слава и т.д. Перед началом игры им задают случайное число N, и победителем считается тот, кто первым получит P ≥ N.\nOUTPUT.TXTStan wins.217Ollie wins.Ollie wins.Stan wins.[Лучшие попытки]\nТребуется определить, кто выиграет при заданном числе N, если известно, что Слава и Оля играют наилучшим образом.\n334012226Stan wins.\nВходные данные\nВходной файл INPUT.TXT содержит целое N. (2 ≤ N ≤ 4 294 967 295)\nВыходные данные\nВ выходной файл OUTPUT.TXT выведите «Stan wins.», если победит Слава, или «Ollie wins.», если победит Оля.",
    "complexity": 52,
    "memory": 16000,
    "time": 1000,
    "examples": [
      {
        "input": "162",
        "output": "Stan wins."
      },
      {
        "input": "17",
        "output": "Ollie wins."
      },
      {
        "input": "34012226",
        "output": "Stan wins."
      }
    ]
  },
  {
    "id": 436,
    "name": "Счастливые цифры",
    "description": "Школьнику Васе нравятся числа, которые заканчиваются счастливыми для него цифрами K. Поэтому каждый раз, когда он видит какое-нибудь натуральное число N, он сразу пытается подобрать такое D (D ≥ 2), что число N в системе счисления с основанием D заканчивается как можно большим количеством цифр K.\nOUTPUT.TXT3 227 53 0Ни в одной системе счисления 7 не заканчивается на цифру 53 0[Лучшие попытки]\nТребуется написать программу, которая по заданным числам N и K найдет такое D, чтобы число N в системе счисления с основанием D заканчивалось как можно большим количеством цифр K.\nКомментарий4910 = 12113Ни в одной системе счисления 7 не заканчивается на цифру 5\nВходные данные\nВходной файл INPUT.TXT содержит два целых десятичных числа N и K (1 ≤ N ≤ 1011; 0 ≤ K ≤ 9).\nВыходные данные\nВ выходной файл OUTPUT.TXT выведите два числа: D – искомое основание системы счисления и L – количество цифр K, которым заканчивается запись числа N в этой системе счисления. Если искомых D несколько, выведите любое из них, не превосходящее 1012 (такое всегда существует).",
    "complexity": 60,
    "memory": 16000,
    "time": 1000,
    "examples": [
      {
        "input": "49 1",
        "output": "3 2"
      },
      {
        "input": "7 5",
        "output": "3 0"
      }
    ]
  },
  {
    "id": 435,
    "name": "Несчастливые номера",
    "description": "Обычно автобусный билет с номером, состоящим из 6 цифр, считается счастливым, если сумма первых трех цифр его номера была равна сумме трех последних. Школьник Вася очень любил получать счастливые билеты, однако это случалось не так часто. Поэтому для себя он изменил определение счастливого билета. \nOUTPUT.TXT724 316416450184219171[Лучшие попытки]\nСчастливым он считал тот номер, сумма некоторых цифр которого равнялась сумме оставшихся цифр. В его представлении билет с номером 561743 счастливый, так как 5+1+4+3=6+7.\n311 950184219171\nВася вырос, но по привычке в номерах различных документов пытается найти признаки счастливого номера .  Для этого он расширил свое определение счастливого номера на N значные номера лицевых счетов и других документов, состоящих из цифр от 0 до K.  Номер документа он называет счастливым, если сумма некоторых цифр этого номера равняется сумме оставшихся. Остальные номера для него несчастливые. К сожалению, несмотря на расширенное понимание “счастья”, несчастливых номеров остается еще много...\nВам предлагается определить количество несчастливых N-значных номеров, которые можно составить, используя цифры от 0 до K.  В номерах допускается любое количество ведущих нулей.\nВходные данные\nВходной файл INPUT.TXT содержит описание вида номеров в виде двух чисел N и K, разделенных пробелом. (1 ≤ N ≤ 100, 1 ≤ K ≤ 9, N*K ≤ 300)\nВыходные данные\nВ выходной файл OUTPUT.TXT выведите количество несчастливых номеров для заданных N и K.",
    "complexity": 88,
    "memory": 16000,
    "time": 1000,
    "examples": [
      {
        "input": "1 7",
        "output": "7"
      },
      {
        "input": "4 3",
        "output": "164"
      },
      {
        "input": "11 9",
        "output": "50184219171"
      }
    ]
  },
  {
    "id": 422,
    "name": "Упорядоченные дроби",
    "description": "Требуется вывести в порядке возрастания все несократимые дроби, заключённые между 0 и 1, знаменатели которых не превышают N.\nOUTPUT.TXT1/31/22/3251/51/41/32/51/23/52/33/44/51/51/41/32/51/23/52/33/44/5[Лучшие попытки]\nВходные данные\nВходной файл INPUT.TXT содержит натуральное число N. (2 ≤ N ≤ 255)\nВыходные данные\nВ выходной файл OUTPUT.TXT выведите в каждой строке по дроби – элементу искомой последовательности в таком же формате, как в примерах.",
    "complexity": 38,
    "memory": 16000,
    "time": 1000,
    "examples": [
      {
        "input": "3",
        "output": "1/3\n1/2\n2/3"
      },
      {
        "input": "5",
        "output": "1/5\n1/4\n1/3\n2/5\n1/2\n3/5\n2/3\n3/4\n4/5"
      }
    ]
  },
  {
    "id": 423,
    "name": "Сообщение",
    "description": "В сообщении, состоящем из заглавных русских букв и пробелов, каждую букву заменили её порядковым номером в русском алфавите (А - 1, Б - 2, ..., Я - 33), а пробел - нулем. \nOUTPUT.TXT4221705338[Лучшие попытки]\nТребуется по заданной последовательности цифр найти количество исходных сообщений, из которых она могла получиться.\n3332228\nВходные данные\nВходной файл INPUT.TXT содержит последовательность цифр, состоящую не более чем из 100 цифр.\nВыходные данные\nВ выходной файл OUTPUT.TXT выведите ответ на задачу.",
    "complexity": 46,
    "memory": 16000,
    "time": 1000,
    "examples": [
      {
        "input": "1025",
        "output": "4"
      },
      {
        "input": "21705",
        "output": "3"
      },
      {
        "input": "33222",
        "output": "8"
      }
    ]
  },
  {
    "id": 472,
    "name": "Подарки",
    "description": "Приближался Новый год и отец купил своим детям по подарку. Оказалось, что в них разное количество конфет. Тогда отец купил еще конфет и стал их раскладывать по подаркам следующим образом: брал один из подарков с наименьшим количеством конфет и добавлял в него одну конфету.\nOUTPUT.TXT3[Лучшие попытки]\nТребуется написать программу, которая найдет наименьшее количество конфет, оказавшихся в одном из подарков после завершения раскладывания всех конфет.\nВходные данные\nВходной текстовый файл INPUT.TXT содержит в первой строке N – количество детей и M – количество купленных конфет. Числа записаны через пробел, 1 ≤ N ≤ 10 000, 1 ≤ M ≤ 1 000 000. Далее в N строках записаны числа в диапазоне от 1 до 30000 – количество конфет в подарках.\nВыходные данные\nВыходной файл OUTPUT.TXT должен содержать одно найденное число.",
    "complexity": 39,
    "memory": 16000,
    "time": 1000,
    "examples": [
      {
        "input": "2 4\n\n1\n\n2",
        "output": "3"
      }
    ]
  },
  {
    "id": 457,
    "name": "Постоянная Капрекара",
    "description": "Возьмем четырехзначное число, в котором не все цифры одинаковы, например 6264. Расположим цифры сначала в порядке убывания - 6642; затем, переставив их в обратном порядке, получим 2466. Вычтем последнее число из 6642. На следующем шаге с полученной разностью проделаем проделаем то же самое. Если в результате промежуточных вычислений получилось число из менее чем\nчетырёх цифр - дополним его лидирующими нулями до четырёхзначного и используем в вычислениях как четырёхзначное. Через несколько таких действий получится число, переходящее само в себя и называемое постоянной Капрекара.\nOUTPUT.TXT61743[Лучшие попытки]\nТребуется написать программу, которая находит эту постоянную и количество шагов для ее получения из заданного четырехзначного числа.\nВходные данные\nВходной файл INPUT.TXT содержит одну строку, в которой записано четырехзначное число.\nВыходные данные\nВ выходной файл OUTPUT.TXT записываются: в первой строке постоянная Капрекара, во второй – количество шагов для ее получения.",
    "complexity": 22,
    "memory": 16000,
    "time": 1000,
    "examples": [
      {
        "input": "1234",
        "output": "6174\n3"
      }
    ]
  },
  {
    "id": 459,
    "name": "Нить Ариадны",
    "description": "Тезею из лабиринта Минотавра помог выйти клубок ниток. Вы можете вместо клубка использовать персональный компьютер.\nOUTPUT.TXTNWW[Лучшие попытки]\nТребуется написать программу, которая вводит маршрут Тезея в лабиринте и находит кратчайший обратный путь, по которому Тезей сможет выйти из лабиринта, не заходя в тупики и не делая петель.\nВходные данные\nВходной файл INPUT.TXT содержит маршрут Тезея, который представлен строкой, состоящей из букв: N, S, W, E и длиной от 1 до 200.\nБуквы означают:\nN - один \"шаг\" на север,\nS - один \"шаг\" на юг,\nW - один \"шаг\" на запад,\nE - один \"шаг\" на восток.\nВыходные данные\nВ выходной файл OUTPUT.TXT записывается аналогично входному файлу найденный обратный путь. Если маршрут неоднозначен, то следует выбирать согласно следующему приоритету: N, E, S, W.",
    "complexity": 49,
    "memory": 32000,
    "time": 1000,
    "examples": [
      {
        "input": "EENNESWSSWE",
        "output": "NWW"
      }
    ]
  },
  {
    "id": 385,
    "name": "Развлечения с измерителем",
    "description": "Дима обнаружил у папы на столе специальный чертежный прибор, похожий на циркуль-измеритель. Измеритель отличается от обычного циркуля тем, что в обеих его ножках находятся иголки (у обычного циркуля в одной ножке находится иголка, а в другой – грифель).\nOUTPUT.TXT2\n1.0\n1.414213562373[Лучшие попытки]\nКроме измерителя Дима нашел на столе клетчатый лист бумаги, в углах некоторых клеток которого были нарисованы точки. Так как измеритель служит для измерения расстояний, то Дима решил измерить все попарные расстояния между всеми точками на листе бумаги.\nВаша задача - написать программу, которая по координатам точек определит, сколько различных расстояний встречается среди расстояний, которые измерил Дима.\nВходные данные\nПервая строка входного файла INPUT.TXT содержит число n – количество точек (2 ≤ n ≤ 50). Следующие n строк содержат по два целых числа – координаты точек. Координаты не превышают 104 по абсолютной величине.\nВыходные данные\nНа первой строке выходного файла OUTPUT.TXT выведите k – количество различных расстояний, которые измерил Дима. Следующие k строк должны содержать по одному вещественному числу – сами расстояния. Расстояния должны быть выведены в возрастающем порядке. Каждое число должно быть выведено с точностью не менее чем 10-9.",
    "complexity": 28,
    "memory": 16000,
    "time": 1000,
    "examples": [
      {
        "input": "4\n\n0 0\n\n1 1\n\n1 0\n\n0 1",
        "output": "2\n\n1.0\n\n1.414213562373"
      }
    ]
  },
  {
    "id": 458,
    "name": "Шифровка - 2",
    "description": "Для кодирования сообщения используют следующие действия: сообщение записывают, опуская пробелы, в прямоугольник заданной высоты по столбцам, а затем прочитывают строки в заданном порядке.\nOUTPUT.TXTПРОГРАММИРОВАНИЕ22\n2 1\nииафзкфизикафизика[Лучшие попытки]\n1 П Р И А\n2 Р А Р Н\n3 О М О И\n4 Г М В Е\nа затем, если выбрать порядок строк 3, 1, 2, 4, получают закодированное сообщение ОМОИПРИАРАРНГМВЕ.\nТребуется написать программу, которая по заданным высоте прямоугольника и порядке прочтения строк при кодировке декодирует заданное сообщение.\nВходные данные\nВходной файл INPUT.TXT содержит: в первой строке высоту прямоугольника H (2 ≤ H ≤ 10), во второй – порядок прочтения строк (числа записаны через пробел), в третьей – закодированное сообщение, длина которого составляет от 1 до 200 символов. Закодированное сообщение состоит из заглавных и строчных русских букв в DOS-кодировке (CP 866) и цифр.\nВыходные данные\nВ выходной файл OUTPUT.TXT записывается декодированное сообщение.",
    "complexity": 35,
    "memory": 16000,
    "time": 1000,
    "examples": [
      {
        "input": "4\n\n3 1 2 4\n\nОМОИПРИАРАРНГМВЕ",
        "output": "ПРОГРАММИРОВАНИЕ"
      },
      {
        "input": "2\n\n2 1\n\nииафзк",
        "output": "физика"
      }
    ]
  },
  {
    "id": 460,
    "name": "Пятерки",
    "description": "Задано натуральное N. Требуется написать программу, которая определит количество цифр 5 в записи всех натуральных чисел от 1 до N включительно.\nOUTPUT.TXT321202222[Лучшие попытки]\nВходные данные\nВо входном файле INPUT.TXT в единственной строке задается число N ≤ 1018.\nВыходные данные\nВ выходной файл OUTPUT.TXT записывается найденное число – количество пятерок.",
    "complexity": 57,
    "memory": 16000,
    "time": 1000,
    "examples": [
      {
        "input": "27",
        "output": "3"
      },
      {
        "input": "120",
        "output": "22"
      }
    ]
  },
  {
    "id": 387,
    "name": "Левая рекурсия",
    "description": "В теории формальных грамматик и автоматов (ТФГиА) важную роль играют так называемые контекстно-свободные грамматики (КС-грамматики). КС-грамматикой будем называть четверку, состоящую из множества N нетерминальных символов, множества T терминальных символов, множества P правил (продукций) и начального символа S, принадлежащего множеству N.\nOUTPUT.TXT2[Лучшие попытки]\nКаждая продукция p из P имеет форму A –\u003e a, где A нетерминальный символ (A из N), а a – строка, состоящая из терминальных и нетерминальных символов. Процесс вывода слова начинается со строки, содержащей только начальный символ S. После этого на каждом шаге один из нетерминальных символов, входящих в текущую строку, заменяется на правую часть одной из продукций, в которой он является левой частью. Если после такой операции получается строка, содержащая только терминальные символы, то процесс вывода заканчивается.\nВо многих теоретических задачах удобно рассматривать так называемые нормальные формы грамматик. Процесс приведения грамматики к нормальной форме часто начинается с устранения левой рекурсии. В этой задаче мы будем рассматривать только ее частный случай, называемый непосредственной левой рекурсией. Говорят, что правило вывода A –\u003e R содержит непосредственную левую рекурсию, если первым символом строки R является A.\nЗадана КС-грамматика. Требуется найти количество правил, содержащих непосредственную левую рекурсию.\nВходные данные\nПервая строка входного файла INPUT.TXT содержит количество n (1 ≤ n ≤ 1000) правил в грамматике. Каждая из последующих n строк содержит по одному правилу. Нетерминальные символы обозначаются заглавными буквами английского алфавита, терминальные - строчными. Левая часть продукции отделяется от правой символами –\u003e. Правая часть продукции имеет длину от 1 до 30 символов.\nВыходные данные\nВ выходной файл OUTPUT.TXT выведите ответ на задачу.",
    "complexity": 20,
    "memory": 16000,
    "time": 1000,
    "examples": [
      {
        "input": "3\n\nS-\u0026gt;Sabc\n\nS-\u0026gt;A\n\nA-\u0026gt;AA",
        "output": "2"
      }
    ]
  },
  {
    "id": 386,
    "name": "Генерация тестов",
    "description": "При подготовке задач для олимпиад по информатике и программированию часто возникает необходимость подготовки тестов. Поскольку зачастую количество тестов достаточно велико, и каждый из них может содержать множество данных, то генерацию тестов разумно автоматизировать.\nOUTPUT.TXTYES0 024YES\n0 0\n0 1\n1 0\n1 1\nYES\n0 0\n0 1\n1 0\n1 1\n[Лучшие попытки]\nВ геометрических задачах часто требуется сгенерировать n точек на плоскости так, чтобы никакие три из них не лежали на одной прямой. В этом и состоит ваша задача. Напишите программу, которая по числу N построит множество из N точек, обладающее указанным свойством.\nВходные данные\nВходной файл INPUT.TXT содержит целое число N (1 ≤ N ≤ 300).\nВыходные данные\nЕсли искомое множество точек можно построить, то выведите в выходной файл OUTPUT.TXT в первой строке слово YES, а далее N строк, каждая из которых должна содержать два числа – координаты соответствующей точки. Среди точек не должно быть совпадающих. Все координаты должны быть целыми числами, не превосходящими 10000 по абсолютному значению. Если искомое множество точек нельзя построить, выведите в выходной файл строку NO.",
    "complexity": 37,
    "memory": 16000,
    "time": 1000,
    "examples": [
      {
        "input": "1",
        "output": "YES\n0 0"
      },
      {
        "input": "4",
        "output": "YES\n\n0 0\n\n0 1\n\n1 0\n\n1 1"
      }
    ]
  },
  {
    "id": 446,
    "name": "Табло",
    "description": "Выходные данные\nВ выходной файл OUTPUT.TXT выведите YES, если на табло возможно отобразить заставку и NO - в противном случае.",
    "complexity": 20,
    "memory": 16000,
    "time": 1000,
    "examples": [
      {
        "input": "3 3\n\n.GB\n\nR.B\n\nRG.\n\n0 1 2 \n\n3 4 5\n\n6 7 0",
        "output": "NO"
      },
      {
        "input": "2 3 \n\nRGB\n\n.G.\n\n7 7 7 \n\n7 7 7",
        "output": "YES"
      }
    ]
  },
  {
    "id": 447,
    "name": "Последняя цифра N!",
    "description": "Требуется найти последнюю ненулевую цифру числа N! = 1*2*3*…*N.\nOUTPUT.TXT12522[Лучшие попытки]\nВходные данные\nВходной файл INPUT.TXT содержит единственное натуральное число N (N ≤ 9999).\nВыходные данные\nВ выходной файл OUTPUT.TXT выведите ответ на задачу.",
    "complexity": 39,
    "memory": 16000,
    "time": 1000,
    "examples": [
      {
        "input": "1",
        "output": "1"
      },
      {
        "input": "5",
        "output": "2"
      }
    ]
  },
  {
    "id": 448,
    "name": "Простые гири",
    "description": "Имеются гири с массами: 1 г, 2 г, …, N г .Требуется написать программу, распределяющую эти гири на максимально возможное количество пар так, чтобы суммарный вес гирь в каждой паре выражался простым числом.\nOUTPUT.TXT1 6\n7 4\n5 2\n[Лучшие попытки]\nВходные данные\nВходной файл INPUT.TXT содержит единственное натуральное число N, не превосходящее 500 000.\nВыходные данные\nВ выходной файл OUTPUT.TXT выведите список найденных пар. Каждая пара выводится в одной строке через пробел.",
    "complexity": 54,
    "memory": 16000,
    "time": 1000,
    "examples": [
      {
        "input": "7",
        "output": "1 6\n\n7 4\n\n5 2"
      }
    ]
  },
  {
    "id": 437,
    "name": "Тапкодер",
    "description": "Ассоциация Тапкодер организует Всемирное парное соревнование сильнейших программистов. К участию в соревновании допущены первые 2K зарегистрировавшихся участников, которым присвоены номера от 1 до 2K.\nOUTPUT.TXT2 2 223 1 13 113Если четвертый участник выиграет у третьего, то договорная встреча первого и третьего не состоится, что благоприятно для первого33 1 2 3[Лучшие попытки]\nСоревнование будет проходить по олимпийской системе. В первом туре первый участник встречается со вторым, третий с четвертым и так далее. В каждой паре победителем становится участник, первым решивший предложенную задачу, при этом ничьих не бывает. Все победители очередного тура и только они являются участниками следующего тура. В каждом туре пары составляются из участников в порядке возрастания присвоенных им номеров. Соревнование продолжается до тех пор, пока не останется один победитель.\nКомментарийУ каждого из участников есть возможность выйти в финал, так как договорных матчей нетЕсли четвертый участник выиграет у третьего, то договорная встреча первого и третьего не состоится, что благоприятно для первого33 3 4\n1 2\n1 3\n4 1\n1 2 3 4\n3 1 2 3Первому участнику благоприятно во втором туре играть с третьим, а не с четвертым, в свою очередь, четвертый может выиграть у третьего и также выйти в финалПервому участнику благоприятно во втором туре играть с третьим, а не с четвертым, в свою очередь, четвертый может выиграть у третьего и также выйти в финал\nОрганизаторам стало известно, что некоторые пары участников заранее договорились о результате встречи между собой, если такая встреча состоится. Для всех остальных встреч, кроме N договорных, возможен любой исход.\nНекоторые M участников соревнования представили свои резюме в ассоциацию Тапкодер с целью поступления на работу. Организаторов интересует, до какого тура может дойти каждый из претендентов при наиболее благоприятном для него стечении обстоятельств. При этом для каждого участника в отдельности считается, что все недоговорные встречи, в том числе те, в которых он не участвует, закончатся так, как ему выгодно, а все состоявшиеся договорные встречи закончатся в соответствии с имеющимися договоренностями.\nТребуется написать программу, которая для каждого из претендентов определяет максимальный номер тура, в котором он может участвовать.\nВходные данные\nВ первой строке входного файла INPUT.TXT заданы три целых числа K (1 ≤ K ≤ 60), N (0 ≤ N ≤ 100 000) и M (1 ≤ M ≤ 100 000). В следующих N строках описаны N пар участников, которые договорились между собой о том, что первый из двух участников пары выиграет встречу, если она состоится. Гарантируется, что каждая пара участников присутствует во входных данных не более одного раза, при этом, если задана пара X Y, то пары Y X быть не может, кроме того, X ≠ Y. В последней строке файла перечислены номера участников, желающих работать в Тапкодере, в порядке возрастания их номеров. Все номера претендентов на работу различны.\nВыходные данные\nВыходной файл OUTPUT.TXT должен содержать M целых чисел — максимальные номера туров, до которых могут дойти соответствующие претенденты на работу. Туры нумеруются от 1 до K.",
    "complexity": 78,
    "memory": 16000,
    "time": 1000,
    "examples": [
      {
        "input": "2 0 3\n1 3 4",
        "output": "2 2 2"
      },
      {
        "input": "3 1 1\n3 1\n1",
        "output": "3"
      },
      {
        "input": "3 3 4\n\n1 2\n\n1 3\n\n4 1\n\n1 2 3 4",
        "output": "3 1 2 3"
      }
    ]
  },
  {
    "id": 449,
    "name": "Плавающие числа",
    "description": "Дано N целых чисел. Каждое из них можно один раз изменить не более чем на целую величину L как в сторону увеличения, так и в сторону уменьшения или оставить без изменения. Если после такой операции некоторые из чисел оказываются равными, то они засчитываются за одно. С данными числами произвели указанную операцию таким образом, что осталось минимально возможное количество чисел. Требуется написать программу для определения этого количества.\nOUTPUT.TXT125 3\n6 10 27\n22[Лучшие попытки]\nВходные данные\nВходной файл INPUT.TXT содержит в первой строке натуральные числа L и N (N ≤ 100, L ≤ 3200), во второй строке N чисел (в диапазоне от -32768 до 32767), записанных через пробел.\nВыходные данные\nВ выходной файл OUTPUT.TXT выведите единственное число – ответ на задачу.",
    "complexity": 41,
    "memory": 16000,
    "time": 1000,
    "examples": [
      {
        "input": "10 3\n\n11 21 27",
        "output": "1"
      },
      {
        "input": "5 3\n\n6 10 27",
        "output": "2"
      }
    ]
  },
  {
    "id": 388,
    "name": "Седловые точки",
    "description": "Задана матрица, содержащая N строк и M столбцов. Седловой точкой этой матрицы назовем элемент, который одновременно является минимумом в своей строке и максимумом в своем столбце.\nOUTPUT.TXT422 21 23 411[Лучшие попытки]\nНайдите количество седловых точек заданной матрицы.\nВходные данные\nВходной файл INPUT.TXT в первой строке содержит целые числа N и M (1 ≤ N, M ≤ 750). Далее следуют N строк по M чисел в каждой. Элементы матрицы - целые числа, не превосходящие 1000 по абсолютной величине. Числа могут быть разделены несколькими пробелами.\nВыходные данные\nВ выходной файл OUTPUT.TXT выведите ответ на задачу.",
    "complexity": 28,
    "memory": 64000,
    "time": 1000,
    "examples": [
      {
        "input": "2 2\n0 0\n0 0",
        "output": "4"
      },
      {
        "input": "2 2\n1 2\n3 4",
        "output": "1"
      }
    ]
  },
  {
    "id": 440,
    "name": "Биатлон",
    "description": "На Зимних Олимпийских Играх традиционно проводятся соревнования по биатлону. Как известно, этот вид спорта содержит лыжные гонки и стрельбу по мишеням из винтовки. На каждом огневом рубеже расположены 5 мишеней. Каждая из них имеет форму круга радиусом 10 см, а расстояния между центрами соседних мишеней одинаковы и равны 25 см. Центры мишеней при этом расположены на одной горизонтали.\nOUTPUT.TXT520 0\n0 0\n0 0\n75 0\n100 0\n33[Лучшие попытки]\nВведем прямоугольную систему координат так, что начало координат расположено в центре самой левой мишени, ось Ox направлена вправо, а ось Oy - вверх. Таким образом, центры мишеней имеют координаты (0, 0), (25, 0), (50, 0), (75, 0) и (100, 0).\nДля информационного обеспечения проведения соревнований было решено разработать систему подсчета количества пораженных мишеней. Эта система по точкам, в которые попали пули после выстрелов спортсмена, должна определять количество пораженных мишеней. Мишень считается пораженной, если в нее попала хотя бы одна пуля (при этом, разумеется, если в мишень попали две или больше пуль, то попадание считается только один раз).\nНа спринтерской гонке на каждом огневом рубеже у спортсмена есть 5 пуль. Вам даны координаты точек, в которые попали пули после выстрелов спортсмена. Определите количество пораженных мишеней.\nВходные данные\nВходной файл INPUT.TXT содержит ровно пять строк: i-ая из них содержит два целых числа xi и yi - координаты точки, в которую попала пуля после i-ого выстрела спортсмена. Все числа во входном файле не превосходят 1000 по модулю.\nВыходные данные\nВ выходной файл OUTPUT.TXT выведите единственное число – число пораженных мишеней.",
    "complexity": 24,
    "memory": 16000,
    "time": 1000,
    "examples": [
      {
        "input": "0 0\n\n25 0\n\n50 0\n\n75 0\n\n100 0",
        "output": "5"
      },
      {
        "input": "0 0\n\n0 0\n\n0 0\n\n75 0\n\n100 0",
        "output": "3"
      }
    ]
  },
  {
    "id": 438,
    "name": "Сочи-2014",
    "description": "К предстоящей олимпиаде в Сочи требуется возвести N олимпийских объектов. Процесс строительства каждого объекта определяется освоением выделяемых на него денежных средств.\n33OUTPUT.TXT8.800\n0 1 1\n0 2 2\n6.4000000 1 2\n6.4000000 2 1\n23\n100 100 100\n4\n5 5 10 10\n12.00000\n0 1 3\n0 2 4\n0 3 1\n4 2 2\n4 3 4\n8 1 1\n8 3 4\n8 2 3\n12.00000\n0 1 3\n0 2 4\n0 3 1\n4 2 2\n4 3 4\n8 1 1\n8 3 4\n8 2 3\n[Лучшие попытки]\nВ строительстве объектов готовы участвовать K фирм. Фирмы имеют разные строительные мощности, выраженные в количестве денежных средств, которые фирма может осваивать в единицу времени.\nNK\nВ каждый момент времени фирма может осуществлять работы только на одном объекте. В строительстве одного объекта не могут одновременно участвовать несколько фирм. В любой момент времени любой объект может быть передан для продолжения строительства любой фирме.\nij\nАдминистрация строительства олимпийских объектов заинтересована в скорейшем освоении денежных средств, поэтому хочет составить такой график работ, при следовании которому строительство будет завершено в кратчайшие сроки. В графике будет указано время, в течение которого тот или иной объект будет строиться какой-то фирмой.\nНапишите программу, результаты работы которой позволят администрации построить требуемый график.\nВходные данные\nПервая строка входного файла INPUT.TXT содержит целое число N — количество объектов (1 ≤ N ≤ 50). Во второй строке содержатся разделенные пробелами целочисленные значения S1, S2, S3, …, SN объемов денежных средств, выделяемых для строительства каждого из объектов. Числа Si выражены в тысячах рублей, положительные и не превышают 1000.\nВ третьей строке находится целое число K — количество строительных фирм (1 ≤ K ≤ 50). Четвертая строка содержит разделенные пробелами целочисленные значения мощностей каждой из фирм V1, V2, V3, …, VK в тыс. руб / час. Числа Vj положительные и не превышают 1000.\nВыходные данные\nПервая строка выходного файла OUTPUT.TXT содержит действительное число T — время в часах окончания всех работ, считая с начала строительства, выведенное не менее чем с тремя точными знаками после запятой. Далее в каждой строке выходного файла содержатся разделенные пробелами три числа: t, i, j, где действительное число t — время от начала строительства в часах, в которое j-я фирма приступает к строительным работам на i-м объекте.\nЗначения времен необходимо выводить с максимально возможной точностью.\nСтроки должны быть отсортированы по неубыванию t.",
    "complexity": 90,
    "memory": 16000,
    "time": 1000,
    "examples": [
      {
        "input": "2\n\n24 20\n\n2\n\n3 2",
        "output": "8.800\n\n0 1 1\n\n0 2 2\n\n6.4000000 1 2\n\n6.4000000 2 1"
      },
      {
        "input": "3\n\n100 100 100\n\n4\n\n5 5 10 10",
        "output": "12.00000\n\n0 1 3\n\n0 2 4\n\n0 3 1\n\n4 2 2\n\n4 3 4\n\n8 1 1\n\n8 3 4\n\n8 2 3"
      }
    ]
  },
  {
    "id": 439,
    "name": "Закон Амдала",
    "description": "Параллельное программирование изучает методы построения программ, которые будут выполняться на нескольких процессорах. В результате решения одной из первых задач этого раздела информатики появился закон Амдала.\nOUTPUT.TXT1.818181818210 253.0769230773.0769230771.000000000[Лучшие попытки]\nЗадача Амдала формулировалась так. Имеется n процессоров и p процентов вычислений не могут выполняться параллельно. Во сколько раз быстрее можно выполнить вычисления по сравнению с одним процессором?\n31000 1001.000000000\nНапример, если n = 10, p = 50, а на одном процессоре все вычисления выполняются за время t. Тогда первая половина вычислений (50%) будет выполнена за время t/(2•10) , а вторая - за время t/2. Общее время вычислений в этом случае составит t/2 + t/20 = 11•t/20, а ускорение по сравнению с одним процессором составит 20/11 раза.\nЕсли же n = 10, p = 25, и на одном процессоре все вычисления выполняются за время t. Тогда 75% вычислений будут выполнены за время 3•t/(4•10) , а оставшиеся 25% - за время t/4 . Общее время вычислений в этом случае составит t/4 + 3•t/40 = 13•t/40, а ускорение по сравнению с одним процессором составит 40/13 раза.\nДаны числа n и p. Напишите программу, решающую задачу Амдала.\nВходные данные\nВходной файл INPUT.TXT содержит 2 целых числа n и p. (1 ≤ n ≤ 1000, 0 ≤ p ≤ 100).\nВыходные данные\nВ выходной файл OUTPUT.TXT выведите ответ на задачу с точностью, не меньшей 10-6.",
    "complexity": 23,
    "memory": 16000,
    "time": 1000,
    "examples": [
      {
        "input": "10 50",
        "output": "1.818181818"
      },
      {
        "input": "10 25",
        "output": "3.076923077"
      },
      {
        "input": "1000 100",
        "output": "1.000000000"
      }
    ]
  },
  {
    "id": 418,
    "name": "Редактор",
    "description": "Немногие знают, что первые версии текстового редактора из предыдущей задачи были написаны в России программистом Колей. Для этого он несколько месяцев почти не выходил из подвала, где стояли только диван и компьютер.\nOUTPUT.TXT152Hello, World?\\This is^\u003c!!!| a sample.1717[Лучшие попытки]\nВот одна из проблем, с которыми столкнулся Коля в те времена. Во время работы пользователь набирает какой-то текст, а так же может его редактировать. При этом, даже если итоговый результат полностью помещается на экран, в процессе работы отдельные строки могут иметь слишком большую длину. Мы не будем просить вас повторить Колин подвиг и заново написать редактор. Определите, какой максимальной длины строка получалась в течение набора текста, если вам известно, какие клавиши и в каком порядке нажимал пользователь.\nВходные данные\nВо входном файле INPUT.TXT записана строка из различных символов - последовательность кнопок на клавиатуре, которые нажимал пользователь. Переводы строк заменены на символ '\\'. Первые версии редактора поддерживали три управляющие команды, которые закодированы следующим образом:\n'\u003c' - удаление предыдущего символа (если курсор находится в начале строки, и эта строка не первая, то удаляется предшествующий перевод строки); \n'^' - перемещение в конец предыдущей строки (игнорируется, если курсор находится на первой строке); \n'|' - перемещение в конец следующей строки (игнорируется, если курсор находится на последней строке).\nВсе остальные символы, содержащиеся в файле, имеют коды от 32 (пробел) и выше и должны пониматься как есть. Число нажатий клавиш не превосходит 105.\nВыходные данные\nВ выходной файл OUTPUT.TXT выведите одно целое число - максимальную длину строки, которая была достигнута в течение работы редактора.",
    "complexity": 39,
    "memory": 16000,
    "time": 1000,
    "examples": [
      {
        "input": "Hello, World???\u0026lt;\u0026lt;\u0026lt;!",
        "output": "15"
      },
      {
        "input": "Hello, World?\\This is^\u0026lt;!!!| a sample.",
        "output": "17"
      }
    ]
  },
  {
    "id": 425,
    "name": "Прямая и квадраты",
    "description": "В прямоугольной декартовой системе координат прямая задана двумя принадлежащими ей точками (0, W) и (100•N, E). Также заданы N2 квадратов со сторонами, параллельными осям координат. Квадрат Si,j имеет координаты углов (100•i, 100•j) и (100•i - 100, 100•j - 100), i, j = 1, 2, ..., N.\nOUTPUT.TXT422 110 12022[Лучшие попытки]\nТребуется найти количество квадратов, имеющих общую точку с прямой.\nВходные данные\nВходной файл INPUT.TXT содержит в одной строке числа N, W и E, разделенные пробелами. (1 ≤ N ≤ 100, 0 ≤ W, E ≤ 100•N)\nВыходные данные\nВ выходной файл OUTPUT.TXT выведите количество квадратов, имеющих общую точку с заданной прямой.",
    "complexity": 49,
    "memory": 16000,
    "time": 1000,
    "examples": [
      {
        "input": "3 150 50",
        "output": "4"
      },
      {
        "input": "2 110 120",
        "output": "2"
      }
    ]
  },
  {
    "id": 441,
    "name": "Карточки - 2",
    "description": "Вася и Петя играют в следующую игру. Вася кладет на стол два ряда карточек. Первый ряд состоит из N карточек, на каждой из которых написано некоторое число ai. Второй ряд состоит из N карточек, на каждой из которых написано некоторое число bi.\niOUTPUT.TXT728\n1 2 1 2 1 2 1 2\n2 1 2 1 2 1 2 2\n-1-1[Лучшие попытки]\nПете требуется переупорядочить карточки первого ряда так, чтобы на столе получилось два одинаковых ряда карточек. За одну секунду Петя может поменять местами i-ую и (i+1)-ую (1 ≤ i ≤ N-1) карточки первого ряда.\n6\nПомогите Пете переупорядочить карточки, затратив на это минимальное время.\nВходные данные\nПервая строка входного файла INPUT.TXT содержит целое число N (1 ≤ N ≤ 105). Вторая строка содержит N целых чисел ai. Третья строка содержит N целых чисел bi. Все числа по абсолютной величине не превосходят 106.\nВыходные данные\nВ выходной файл OUTPUT.TXT выведите количество секунд, за которые Петя сможет переупорядочить карточки требуемым образом. Если переупорядочить карточки требуемым образом невозможно, выведите единственное число -1.",
    "complexity": 73,
    "memory": 128000,
    "time": 1000,
    "examples": [
      {
        "input": "5\n\n3 2 3 4 5\n\n5 4 3 2 3",
        "output": "7"
      },
      {
        "input": "8\n\n1 2 1 2 1 2 1 2\n\n2 1 2 1 2 1 2 2",
        "output": "-1"
      }
    ]
  },
  {
    "id": 427,
    "name": "Несоставляемое число",
    "description": "Дано N натуральных чисел. Требуется найти минимальное натуральное число, не представимое суммой никаких из этих чисел, если в эту сумму каждое исходное число может входить не более одного раза.\nOUTPUT.TXT42412481616[Лучшие попытки]\nВходные данные\nВходной файл INPUT.TXT в первой строке содержит натуральное число N, не превосходящее 104, далее следуют N строк, в каждой из которых записано по одному натуральному числу, каждое из которых не превосходит 109.\nВыходные данные\nВ выходной файл OUTPUT.TXT выведите ответ на задачу.",
    "complexity": 48,
    "memory": 16000,
    "time": 1000,
    "examples": [
      {
        "input": "4\n1\n1\n1\n5",
        "output": "4"
      },
      {
        "input": "4\n1\n2\n4\n8",
        "output": "16"
      }
    ]
  },
  {
    "id": 442,
    "name": "Шрифты",
    "description": "Третий за неделю чек по заправке картриджа для принтера в бухгалтерии приняли без особого удовольствия. Судя по всему, надо серьезно подойти к вопросу экономного использования тонера - на учет должна быть поставлена каждая буква. Вам поручена реализация утилиты, которая будет обрабатывать HTML-документы старых версий и подсчитывать в них количество символов каждого размера. HTML-документ состоит из обычного текста и тегов - управляющих элементов, заключенных в угловые скобки. Для управления размером шрифта используется тег font с атрибутом size: \u003cfont size=\"x\"\u003e. Если x - натуральное число, то размер шрифта устанавливается равным x. Кроме того, x может иметь вид +y или -y, где y - целое положительное число. В этом случае размер шрифта соответственно увеличивается или уменьшается на y. Действие тега заканчивается с появлением соответствующего закрывающего тега \u003c/font\u003e. Все остальные теги вы не должны обрабатывать. Можете считать, что теги не содержат лишних пробельных символов. По умолчанию размер шрифта равен 10, и изменения не будут выводить его из интервала от 1 до 50.\nOUTPUT.TXT2 4\n7 12\n10 20\n11 6\n15 10[Лучшие попытки]\nВходные данные\nВходной файл INPUT.TXT содержит описание HTML-документа, по длине не превосходящее 5000 символов.\nВыходные данные\nВ выходной файл OUTPUT.TXT выведите для каждого шрифта, которым был написан хотя бы один непробельный символ, на отдельной строке через пробел его размер и количество соответствующих ему непробельных (с ASCII кодами не равными 9, 10, 13 и 32) символов в порядке возрастания размера.",
    "complexity": 45,
    "memory": 16000,
    "time": 1000,
    "examples": [
      {
        "input": "\u0026lt;HTML\u0026gt;\n\n\u0026lt;BODY\u0026gt;\n\n\u0026lt;b\u0026gt; Fonts: normal \u0026lt;font size=\u0026#34;2\u0026#34;\u0026gt; tiny \u0026lt;font size=\u0026#34;+9\u0026#34;\u0026gt; bigger\n\n\u0026lt;p\u0026gt;\n\n\u0026lt;/font\u0026gt;\u0026lt;/font\u0026gt; as before \n\n\u0026lt;/b\u0026gt;\n\n\u0026lt;font size=\u0026#34;+5\u0026#34;\u0026gt;\n\nvery big\n\n\u0026lt;font size=\u0026#34;-8\u0026#34;\u0026gt;\n\nsmaller again\n\n\u0026lt;/font\u0026gt; \u0026lt;a href=\u0026#34;...\u0026#34;\u0026gt;...\u0026lt;/a\u0026gt;\u0026lt;/font\u0026gt;\n\n\u0026lt;/BODY\u0026gt;\n\n\u0026lt;/HTML\u0026gt;",
        "output": "2 4\n\n7 12\n\n10 20\n\n11 6\n\n15 10"
      }
    ]
  },
  {
    "id": 426,
    "name": "Lines - 2",
    "description": "В таблице из N строк и N столбцов некоторые клетки заняты шариками, другие свободны. Выбран шарик, который нужно переместить, и место, куда его нужно переместить. Выбранный шарик за один шаг перемещается в соседнюю по горизонтали или вертикали свободную клетку. Требуется выяснить, возможно ли переместить шарик из начальной клетки в заданную, и, если возможно, то найти путь из наименьшего количества шагов.\nOUTPUT.TXTY\n+++++\n+OOOO\n+++++\nOOOO+\n@++++\n25\n..X..\n.....\nOOOOO\n.....\n..@..\nNNY\n..++.\n.++..\nO+OOO\n.++++\n....@[Лучшие попытки]\nВходные данные35\n...X.\n.....\nO.OOO\n.....\n....@Y\n..++.\n.++..\nO+OOO\n.++++\n....@\nВ первой строке входного файла INPUT.TXT находится число N, в следующих N строках - по N символов. Символом точки обозначена свободная клетка, английской заглавной O - шарик, @ - исходное положение шарика, который должен двигаться, английской заглавной X - конечное положение шарика. (2 ≤ N ≤ 250)\nВыходные данные\nВ выходной файл OUTPUT.TXT выведите  в первой строке «Y», если движение возможно, или «N», если нет. Если движение возможно, то далее следует вывести N строк по N символов - как и на вводе, но буква X, а также все точки по пути следует заменить плюсами. Если решений несколько, выведите любое.",
    "complexity": 48,
    "memory": 16000,
    "time": 1000,
    "examples": [
      {
        "input": "5\n\n....X\n\n.OOOO\n\n.....\n\nOOOO.\n\n@....",
        "output": "Y\n\n+++++\n\n+OOOO\n\n+++++\n\nOOOO+\n\n@++++"
      },
      {
        "input": "5\n\n..X..\n\n.....\n\nOOOOO\n\n.....\n\n..@..",
        "output": "N"
      },
      {
        "input": "5\n\n...X.\n\n.....\n\nO.OOO\n\n.....\n\n....@",
        "output": "Y\n\n..++.\n\n.++..\n\nO+OOO\n\n.++++\n\n....@"
      }
    ]
  },
  {
    "id": 402,
    "name": "Коттеджный поселок",
    "description": "Поблизости от столицы Флатландии одна компания решила построить коттеджный поселок. Строительная компания, которая занимается возведением коттеджей, решила раскрасить некоторые коттеджи в розовый цвет, а остальные – в голубой. Но они не могут решить, какой коттедж раскрасить в какой цвет.\n4OUTPUT.TXT12[Лучшие попытки]\nДиректор компании утверждает, что раскраска симпатичная, если есть хотя бы один розовый коттедж, хотя бы один голубой коттедж, и можно провести такую прямую, что все розовые коттеджи окажутся с одной стороны от нее, а все голубые – с другой стороны (при этом на самой прямой коттеджей быть не должно). На это главный дизайнер возразил, что есть несколько способов сделать симпатичную раскраску.\ni\nПомогите им определить, сколько существует различных симпатичных раскрасок.\ni\nВходные данные4\nПервая строка входного файла INPUT.TXT содержит число N – количество коттеджей (1 ≤ N ≤ 300). Следующие N строк содержат координаты коттеджей, каждая строка содержит два целых числа xi и yi (-104 ≤ xi, yi ≤ 104).\nВыходные данные\nВ выходной файл OUTPUT.TXT выведите одно число – ответ на задачу.",
    "complexity": 75,
    "memory": 16000,
    "time": 1000,
    "examples": [
      {
        "input": "4\n\n0 0\n\n1 0\n\n1 1\n\n0 1",
        "output": "12"
      }
    ]
  },
  {
    "id": 391,
    "name": "Взлом хеш-функции",
    "description": "В некоторых задачах защиты информации используются так называемые хеш-функции. Одним из важнейших классов хеш-функций являются так называемые полиномиальные хеш-функции. \nlOUTPUT.TXT0422207956[Лучшие попытки]\nПусть дана строка S = s1s2 ... sl, состоящая из цифр от 0 до 9. Тогда значение полиномиальной хеш-функции p(S, x, m) вычисляется следующим образом:\n(a mod b обозначает остаток от деления числа a на число b). Например, пусть S = 0123, тогда p(S, 2, 5) = (0 ∙ 1 + 1 ∙ 2 + 2 ∙ 4 + 3 ∙ 8) mod 5 = 4.\nОдним из способов применения хеш-функций является хранение паролей. Часто бывает так, что пароли приходится хранить в незащищенной таблице базы данных, поэтому вместо них хранят хеш-функции от них. При проверке пароля вычисляется хеш-функция от введенной строки и сравнивается со значением, хранящимся в таблице.\nВаша задача состоит в том, чтобы по заданным числам x, m, L и v найти строку S из цифр от 0 до 9 длины L, значение полиномиальной хеш-функции p(S, x, m) равно v.\nВходные данные\nВходной файл INPUT.TXT содержит четыре целых числа: x (x – простое число, 5 ≤ x ≤ 100), m (m является степенью двойки, 1 ≤ m ≤ 256), L (10 ≤ L ≤ 100) и v (0 ≤ v ≤ m-1).\nВыходные данные\nВ выходной файл OUTPUT.TXT выведите искомую строку или NO SOLUTION, если такой строки не существует. Если решений несколько, выведите любое.",
    "complexity": 35,
    "memory": 16000,
    "time": 1000,
    "examples": [
      {
        "input": "5 16 10 9",
        "output": "0422207956"
      }
    ]
  },
  {
    "id": 428,
    "name": "SMS",
    "description": "OUTPUT.TXT122WWW220[Лучшие попытки]\nСообщения SMS сотового телефона MOBILA составлены из прописных английских букв. Если буква первая на кнопке, нужно нажать эту кнопку один раз, чтобы добавить букву в сообщение. Если буква вторая - нужно нажать кнопку дважды и т.д. Так, чтобы набрать слово \"SMS\", нужно нажать \n380QUARTERFINAL0\n(PQRS)(PQRS)(PQRS)(PQRS)(MNO)(PQRS)(PQRS)(PQRS)(PQRS)\nЧтобы ввести две буквы, находящиеся на одной кнопке, нужно между нажатиями клавиши сделать паузу. Например, чтобы ввести сообщение \"AA\", нужно нажать\n(ABC)(пауза)(ABC)\nЕсли на кнопке три буквы, то, как только такая кнопка нажата три раза, последняя буква добавляется в сообщение немедленно, а следующие нажатия той же кнопки относятся к следующей букве сообщения. Аналогично, если на кнопке четыре буквы, то после четырёх нажатий в сообщение будет добавлена последняя буква. То есть последовательность нажатий\n(ABC)(ABC)(ABC)(ABC)(пауза)(ABC)\nсоответствует сообщению \"CAA\". К сожалению, сотовые телефоны этой модели давно не производятся, и остался только один такой телефон. Он может произвольно вставлять и игнорировать паузы во время ввода сообщения, что может привести к некоторым изменениям в сообщениях. Например, введя MOSCOWQUARTERFINAL, можно получить вместо этого OMSCMNWQTTARTERDEINAL. Вы получили SMS-сообщение и знаете, что оригинальное сообщение содержало N букв. Чтобы определить вероятность угадывания оригинального сообщения, найдите число возможных сообщений, которые могли превратиться в то, которое Вы получили.\nВходные данные\nВходной файл INPUT.TXT в первой строке содержит длину оригинального сообщения N (1 ≤ N ≤ 80). Вторая строка содержит полученное SMS-сообщение, состоящее только из прописных английских букв длиной от 1 до 80.\nВыходные данные\nВ выходной файл OUTPUT.TXT выведите число сообщений из N букв, которые будучи набранными на этом телефоне, могут превратиться в данное сообщение.",
    "complexity": 74,
    "memory": 16000,
    "time": 1000,
    "examples": [
      {
        "input": "4\nMAMA",
        "output": "1"
      },
      {
        "input": "2\nWWW",
        "output": "2"
      },
      {
        "input": "80\nQUARTERFINAL",
        "output": "0"
      }
    ]
  },
  {
    "id": 390,
    "name": "Треугольная область",
    "description": "",
    "complexity": 41,
    "memory": 16000,
    "time": 1000,
    "examples": [
      {
        "input": "0 0 1 2 2 0\n1 1",
        "output": "0.4472135"
      },
      {
        "input": "0 0 0 3 3 0\n1 1",
        "output": "0.7071067"
      }
    ]
  },
  {
    "id": 452,
    "name": "Система счисления Фибоначчи",
    "description": "Числа Фибоначчи F1, F2, … определяются начальными значениями и соотношением:\nnOUTPUT.TXT100010[Лучшие попытки]\nF1=1; F2=2; Fn=Fn-1+Fn-2.\nn-1\nn-2\nРассмотрим систему счисления с двумя цифрами 0 и 1, в которой, в отличие от двоичной системы, весами являются не степени двойки 1, 2, 4, 8, 16, …, а числа Фибоначчи 1, 2, 3, 5, 8, 13, …. В этой системе счисления каждое положительное целое число единственном способом представляется в виде строки из нулей и единиц, которая начинается с 1 и в которой нет двух единиц, стоящих рядом.\nТребуется написать программу, которая по двум заданным строкам, представляющим числа A и B в системе счисления Фибоначчи, находила строку, представляющую число A+B также в этой системе счисления.\nНапример, исходные строки 10101 и 100 представляют числа 1*8+0*5+1*3+0*2+1*1=8+3+1=12 и 1*3+0*2+0*1=3. Ответом является строка 100010, представляющая число 1*13+0*8+0*5+0*3+1*2+0*1=13+2=15=12+3.\nВходные данные\nВходной файл INPUT.TXT в первой строке содержит число A и B во второй. Длина записи чисел A, B и их суммы A+B в системе счисления Фибоначчи не превышает 255 знаков.\nВыходные данные\nВ выходной файл OUTPUT.TXT выведите значение суммы A+B в системе счисления Фибоначчи.",
    "complexity": 51,
    "memory": 16000,
    "time": 1000,
    "examples": [
      {
        "input": "10101\n100",
        "output": "100010"
      }
    ]
  },
  {
    "id": 450,
    "name": "Бутылки - 2",
    "description": "В цех вторичной переработки поступают бутылки N видов: A, B, C, … (первые N заглавных букв английского алфавита). Бутылки поступают на переработку партиями из N контейнеров, причем в каждом контейнере могут находиться бутылки различных видов. Перед вторичной переработкой бутылок рабочие сортируют их по видам таким образом, чтобы после сортировки в каждом из поступивших контейнеров остались бутылки не более чем одного вида и каждый вид бутылок оказался не более чем в одном контейнере. В каждом из контейнеров может помещаться неограниченное количество бутылок.\nOUTPUT.TXTABCD\n102\n[Лучшие попытки]\nТребуется написать программу, которая определяет минимальное количество перемещений бутылок, обеспечивающих их сортировку по видам, причем за каждое перемещение можно переместить только одну бутылку из одного контейнера в другой.\nВходные данные\nВходной файл INPUT.TXT состоит из N+1 строк. В первой строке записано число N (1 ≤ N ≤ 8). Во второй строке располагаются разделенные пробелами N целых числа, соответствующие количеству бутылок вида A, B, C, … в первом контейнере. В последующих строках содержится аналогичная информация для второго, третьего, …, N-го контейнеров соответственно. Известно, что количество бутылок в каждом из контейнеров не превосходит 32767.\nВыходные данные\nВыходной файл OUTPUT.TXT должен состоять из двух строк. В первой располагается перестановка первых N прописных букв английского алфавита, которая определяет, какого вида бутылки могут находиться после сортировки в 1-м, 2-м, …, N-м контейнерах. Во второй строке располагается число, определяющее искомое количество перемещений бутылок. Если возможно несколько вариантов ответа, то необходимо выдать любой из них.",
    "complexity": 51,
    "memory": 16000,
    "time": 1000,
    "examples": [
      {
        "input": "4\n\n1 2 3 4\n\n5 6 7 8\n\n9 10 11 12\n\n13 14 15 16",
        "output": "ABCD\n\n102"
      }
    ]
  },
  {
    "id": 392,
    "name": "Сдвиг перестановки",
    "description": "",
    "complexity": 24,
    "memory": 32000,
    "time": 1000,
    "examples": [
      {
        "input": "3\n3 2 1",
        "output": "1 3 2"
      }
    ]
  },
  {
    "id": 451,
    "name": "Арифметическое выражение",
    "description": "Требуется вычислить значение арифметического выражения, в записи которого могут использоваться вещественные числа, круглые скобки, пробелы, бинарные операции «+», «-», «*» и «/», а так же функции cos(x) и sin(x). Вычисление следует проводить согласно синтаксису языка Delphi.\nOUTPUT.TXT527*8 - 120/6 + 4404010.52Error6120.02Error12.656987[Лучшие попытки]\nВходные данные310/(6-2)+810.5[Решение]\nВходной файл INPUT.TXT содержит единственную строку, в которой находится запись арифметического выражения. Длина строки не превышает 200 символов. В строке могут содержаться любые символы. Гарантируется, что при корректном вычислении выражения не будет возникать переполнения 6-байтного вещественного типа и деления на ноль.\n4sin(3.14/2)+cos(2-6/3)2\nВыходные данные5three plus fiveError\nВ выходной файл OUTPUT.TXT выведите значение заданного арифметического выражения с точностью, не меньше 10-3. В том случае, когда в выражении присутствуют синтаксические ошибки, следует вывести «Error».\n66.12e3+2e-26120.02",
    "complexity": 71,
    "memory": 16000,
    "time": 1000,
    "examples": [
      {
        "input": "2+3",
        "output": "5"
      },
      {
        "input": "7*8 - 120/6 + 4",
        "output": "40"
      },
      {
        "input": "10/(6-2)+8",
        "output": "10.5"
      },
      {
        "input": "sin(3.14/2)+cos(2-6/3)",
        "output": "2"
      },
      {
        "input": "three plus five",
        "output": "Error"
      },
      {
        "input": "6.12e3+2e-2",
        "output": "6120.02"
      },
      {
        "input": "-1",
        "output": "Error"
      },
      {
        "input": "12. + Sin(7)",
        "output": "12.656987"
      }
    ]
  },
  {
    "id": 394,
    "name": "Апельсины",
    "description": "Катя решила пригласить к себе в гости n друзей. Так как ее друзья очень любят фрукты, то в качестве угощения для них она купила m одинаковых апельсинов.\nOUTPUT.TXT222 411[Лучшие попытки]\nОна хочет разрезать каждый апельсин на одинаковое число равных долек так, чтобы их можно было распределить между гостями (сама Катя апельсины есть не будет), и всем гостям досталось поровну долек.\nНапишите программу, которая вычисляет минимальное количество долек, на которое необходимо разрезать каждый апельсин, чтобы были выполнены указанные выше условия.\nВходные данные\nВходной файл INPUT.TXT содержит два положительных целых числа n и m (1 ≤ n, m ≤ 109).\nВыходные данные\nВ выходной файл OUTPUT.TXT выведите ответ на задачу.",
    "complexity": 26,
    "memory": 16000,
    "time": 1000,
    "examples": [
      {
        "input": "2 5",
        "output": "2"
      },
      {
        "input": "2 4",
        "output": "1"
      }
    ]
  },
  {
    "id": 393,
    "name": "Плейлист",
    "description": "Антон – большой любитель музыки. Но в разные моменты ему нравится разная музыка. Однажды он решил составить рейтинг своих песен, причем считать его так – если песня дослушана до конца, то ее рейтинг увеличивается на единицу, если же он так и не дослушал ее, переключив на следующую, то уменьшается на единицу. Отметим, что вследствие этого рейтинг может стать отрицательным.\nOUTPUT.TXT1 0[Лучшие попытки]\nОн попросил Вас написать ему программу, которая подсчитывала бы такой рейтинг. Для этого он записал в каком порядке прослушивались песни и в какие моменты времени он переключал песню на следующую. Изначально рейтинги всех песен равны нулю.\nВходные данные\nПервая строка входного файла INPUT.TXT содержит одно число n (1 ≤ n ≤ 1000) – количество песен у Антона. В следующих n строках следуют описания песен – название песни, состоящее не более, чем из 50 маленьких английских букв, и длина песни в секундах, разделенные пробелом. Каждая песня длится положительное число секунд и не более 30 минут. (n + 2)-я строка содержит два числа m, k (0 ≤ k ≤ m ≤ 1000) – количество прослушанных песен и количество переключений на следующую. В следующих m строках следуют названия прослушанных песен в порядке их прослушивания (все эти песни из списка). И, наконец, в последней строке – k целых неотрицательных чисел – последовательные (в неубывающем порядке) времена переключения на следующую песню (гарантируется, что она всегда существует), отсчитываемые в секундах от начала прослушивания первой. Считается, что если Антон переключил песню в момент окончания какой-нибудь, то он пропускает уже следующую.\nВыходные данные\nВ выходной файл OUTPUT.TXT выведите n чисел – рейтинги песен в том порядке, в котором они даны во входном файле.",
    "complexity": 48,
    "memory": 16000,
    "time": 1000,
    "examples": [
      {
        "input": "2\n\nsonga 10\n\nsongb 20\n\n5 2\n\nsonga\n\nsongb\n\nsongb\n\nsonga\n\nsonga\n\n40 55",
        "output": "1 0"
      }
    ]
  },
  {
    "id": 453,
    "name": "Раз-два, раз-два",
    "description": "Для заданного натурального числа N требуется найти число, состоящее только из цифр 1 и 2, которое делилось бы на 2N.\nOUTPUT.TXT2221212[Лучшие попытки]\nВходные данные[Решение]\nВходной файл INPUT.TXT содержит натуральное число N, не превосходящее 300.\nВыходные данные\nВ выходной файл OUTPUT.TXT выведите искомое число, состоящее не более чем из 10 000 цифр.",
    "complexity": 49,
    "memory": 16000,
    "time": 1000,
    "examples": [
      {
        "input": "1",
        "output": "2"
      },
      {
        "input": "2",
        "output": "12"
      }
    ]
  },
  {
    "id": 314,
    "name": "Лексикографический порядок чисел",
    "description": "Натуральные числа от 1 до N упорядочены лексикографически. Например, для N=25 результат этого упорядочения будет таким: 1, 10, 11, 12, 13, 14, 15, 16, 17, 18, 19, 2, 20, 21, 22, 23, 24, 25, 3, 4, 5, 6, 7, 8, 9.\nOUTPUT.TXT9[Лучшие попытки]\nТребуется написать программу, которая определит, на каком месте оказалось число K.\nВходные данные\nВходной файл INPUT.TXT содержит два натуральных числа N и K, записанных через пробел (1 ≤ K ≤ N ≤ 104).\nВыходные данные\nВыходной файл OUTPUT.TXT должен содержать одно натуральное число – номер места, на котором оказалось число K.",
    "complexity": 31,
    "memory": 16000,
    "time": 1000,
    "examples": [
      {
        "input": "25 17",
        "output": "9"
      }
    ]
  },
  {
    "id": 429,
    "name": "Дерево игры",
    "description": "OUTPUT.TXT+127\nN 1\nN 1\nL 2 -1\nL 2 +1\nL 3 +1\nL 3 0\n00+1[Лучшие попытки]\nИгра для двух игроков определяется её деревом. Соперники делают ходы по очереди. Первый игрок начинает игру. Игра кончается или вничью, или победой одного из игроков. Листья дерева этой игры могут иметь значения, равные одному из трёх чисел: +1 - победа первого игрока, -1 - победа второго игрока, 0 - ничья. Ваша задача - определить, кто выиграет, если оба противника следуют правильной стратегии.\n318\nN 1\nN 1\nN 2\nL 2 +1\nN 3\nL 3 +1\nL 3 +1\nL 4 -1\nL 4 +1\nN 4\nN 6\nL 6 -1\nL 6 -1\nL 11 -1\nL 11 +1\nL 12 +1\nL 12 -1\n+1\nВходные данные\nУзлы дерева пронумерованы последовательными целыми числами. Корень дерева всегда имеет номер 1. Первая строка входного файла INPUT.TXT содержит натуральное N - число узлов в дереве игры (2 ≤ N ≤ 1000). Следующая N - 1 строка описывает узлы - одна строка для каждого узла (за исключением первого). Вторая строка содержит описание второго узла дерева, третья - третьего узла и т.д. Если узел является листом, первый символ строки - L, затем идёт пробел, затем номер родительского узла, ещё пробел и результат игры (+1 - победа первого игрока, -1 - победа второго, 0 - ничья). Если узел внутренний, то строка содержит N - первый символ, затем пробел и номер родительского узла.\nВыходные данные\nВ выходной файл OUTPUT.TXT выведите +1, если выигрывает первый игрок, -1, если второй, и 0 - в случае ничейного исхода.",
    "complexity": 56,
    "memory": 16000,
    "time": 1000,
    "examples": [
      {
        "input": "7\n\nN 1\n\nN 1\n\nL 2 -1\n\nL 2 +1\n\nL 3 +1\n\nL 3 +1",
        "output": "+1"
      },
      {
        "input": "7\n\nN 1\n\nN 1\n\nL 2 -1\n\nL 2 +1\n\nL 3 +1\n\nL 3 0",
        "output": "0"
      },
      {
        "input": "18\n\nN 1\n\nN 1\n\nN 2\n\nL 2 +1\n\nN 3\n\nL 3 +1\n\nL 3 +1\n\nL 4 -1\n\nL 4 +1\n\nN 4\n\nN 6\n\nL 6 -1\n\nL 6 -1\n\nL 11 -1\n\nL 11 +1\n\nL 12 +1\n\nL 12 -1",
        "output": "+1"
      }
    ]
  },
  {
    "id": 409,
    "name": "Железная дорога",
    "description": "При строительстве новой железной дороги возникли проблемы. Дорога пролегает по холмистой местности, однако сами пути должны идти строго горизонтально. Поэтому руководство строительной компании приняло решение выровнять поверхность земли на этом участке. Главная проблема состоит в том, что привозить или вывозить землю на стройку стоит 10000$ за кубический метр. Поскольку бюджет железной дороги невелик, этого нельзя себе позволить.\nOUTPUT.TXT0.666666666725\n2 2 2 2 2\n2.00000000002.0000000000[Лучшие попытки]\nПоэтому главный инженер принял решение выровнять поверхность, используя только землю, из которой состоят холмы. Теперь самая сложная задача состоит в том, чтобы выяснить высоту над уровнем моря, на которой будет пролегать дорога. Это ответственное задание было поручено Вам.\nЧерез каждый метр от начала участка была измерена высота над уровнем моря. Напишите программу, которая по данным измерений рассчитывает искомую высоту.\nВходные данные\nПервая строка входного файла INPUT.TXT содержит количество N (1 \u003c N ≤ 30000) точек, в которых была замерена высота. Вторая строка содержит результаты замеров – i-ое число строки содержит высоту над уровнем моря точки, находящейся на расстоянии (i-1) метр от начала участка. Все высоты – целые неотрицательные числа, не превосходящие 10000. Считайте, что между соседними точками измерений земная поверхность строго прямолинейна.\nВыходные данные\nВ выходной файл OUTPUT.TXT выведите ответ на задачу с точностью, не меньшей 10-5.",
    "complexity": 26,
    "memory": 16000,
    "time": 1000,
    "examples": [
      {
        "input": "4\n\n0 1 1 0",
        "output": "0.6666666667"
      },
      {
        "input": "5\n\n2 2 2 2 2",
        "output": "2.0000000000"
      }
    ]
  },
  {
    "id": 430,
    "name": "Дуга на сфере",
    "description": "На поверхности планеты, являющейся шаром радиусом R, заданы две точки своими широтой и долготой. Требуется найти минимальную длину пути по поверхности этой планеты из одной точки в другую.\nOUTPUT.TXT3141.5923437.541.766666 -50.23333341.236388 -51.1552.0452.04[Лучшие попытки]\nВходные данные\nВ первой строке входного файла INPUT.TXT находится число R, во второй строке заданы широта и долгота первой точки, в третьей строке - широта и долгота второй точки. Широта измеряется в градусах от -90 до 90, долгота – в градусах от -180 до 180. Радиус R меняется в пределах от 100 до 10000. Все числа вещественные.\nВыходные данные\nВ выходной файл OUTPUT.TXT выведите длину пути с двумя знаками после запятой.",
    "complexity": 51,
    "memory": 16000,
    "time": 1000,
    "examples": [
      {
        "input": "4000\n45 120\n0 120",
        "output": "3141.59"
      },
      {
        "input": "3437.5\n41.766666 -50.233333\n41.236388 -51.15",
        "output": "52.04"
      }
    ]
  },
  {
    "id": 454,
    "name": "Оставшееся число",
    "description": "Задан ряд последовательных натуральных чисел от M до N (M \u003c N), из которого удаляют сначала все числа, стоящие на нечетных местах. Затем, из оставшегося ряда удаляют все числа, стоящие в нем на четных местах. Эти действия повторяют до тех пор, пока не останется одно число.\nOUTPUT.TXT222977[Лучшие попытки]\nТребуется написать программу, которая находит оставшееся число.\nВходные данные\nВходной файл INPUT.TXT содержит число M в первой строке и число N во второй (M \u003c N \u003c 109).\nВыходные данные\nВ выходной файл OUTPUT.TXT выведите оставшееся число.",
    "complexity": 45,
    "memory": 16000,
    "time": 1000,
    "examples": [
      {
        "input": "1\n4",
        "output": "2"
      },
      {
        "input": "2\n9",
        "output": "7"
      }
    ]
  },
  {
    "id": 408,
    "name": "Письмо",
    "description": "Вася хочет отправить Пете письмо на листе шириной K. Он хочет распечатать на нем текст, состоящий из N строк. Необходимо изменить количество ведущих и концевых пробелов так, чтобы строки оказались посередине листа, и их длина стала равна K. Вася считает, что строка находится посередине листа, если количество ведущих пробелов не превосходит количества концевых пробелов и, если при сдвиге строки на один символ вправо (т.е. при переносе одного пробела из конца строки в её начало), указанное свойство нарушается.\nOUTPUT.TXT++++++Привет!+++++++\n++++Напиши+мне.+++++\n++++++Пока+=)+++++++\n25 1\nПривет.\nImpossible.Impossible.[Лучшие попытки]\nВходные данные\nПервая строка входного файла INPUT.TXT содержит два целых числа K и N (1 ≤ K ≤ 100, 1 ≤ N ≤ 1000). Следующие N строк содержат текст Васиного письма в однобайтовой кодировке (символы с кодами от 32 до 255). Каждая строка письма содержит хотя бы один символ, отличный от пробела. Длина каждой строки во входном файле не превосходит 100.\nВыходные данные\nЕсли Вася сможет написать письмо, удовлетворяющее всем его требованиям, то в выходной файл OUTPUT.TXT выведите отформатированный текст письма в той же кодировке, иначе, выведите фразу “Impossible.” (без кавычек).",
    "complexity": 31,
    "memory": 16000,
    "time": 1000,
    "examples": [
      {
        "input": "20 3\n\n++Привет!++\n\n+Напиши+мне.++\n\n++++Пока+=)+",
        "output": "++++++Привет!+++++++\n\n++++Напиши+мне.+++++\n\n++++++Пока+=)+++++++"
      },
      {
        "input": "5 1\n\nПривет.",
        "output": "Impossible."
      }
    ]
  },
  {
    "id": 411,
    "name": "Квадратное уравнение",
    "description": "Сложно найти человека, который любит решать однообразные задачки по математике. В последнее время школьникам стало легче, ведь с появлением компьютеров почти в каждой квартире стало существенно проще проверять себя.\nOUTPUT.TXT21.0000002.00000020 -1 616.00000016.000000[Лучшие попытки]\nНо программы, в которых решение уравнений является стандартной функцией, установлены не везде. Напишите программу, которая сможет решить уравнение\nax2 + bx + c = 0\nВходные данные\nЕдинственная строка входного файла INPUT.TXT содержит три целых числа a, b и c, каждое из которых не превосходит по модулю 30000. Числа разделяются пробелами.\nВыходные данные\nНа первой строке выходного файла OUTPUT.TXT выведите число различных действительных корней заданного уравнения. Затем выведите сами корни по одному на строке с ошибкой, не превосходящей 10-4. Если для заданных коэффициентов корней бесконечно много, на единственной строке выходного файла выведите -1.",
    "complexity": 28,
    "memory": 16000,
    "time": 1000,
    "examples": [
      {
        "input": "1 -3 2",
        "output": "2\n1.000000\n2.000000"
      },
      {
        "input": "0 -1 6",
        "output": "1\n6.000000"
      }
    ]
  },
  {
    "id": 410,
    "name": "Цифровое колдовство",
    "description": "В современном мире все становится цифровым. Шаманы в одной сказочной северной стране тоже стараются не отставать от жизни. Последние изыскания показали, что в качестве материальных компонентов для колдовства с большой эффективностью можно использовать длинные веревки, сплетенные из моржовых усов. Каждая веревка кодирует магическое целое число следующим образом: сначала она определенным образом делится на части, соответствующие цифрам магического числа, в каждой из которых можно завязать от нуля до девяти узелков (глобализация вынуждает шаманов использовать обычную десятичную систему счисления). Конечно, при этом для задания очень больших чисел могут понадобиться длинные веревки. Можно надеяться, что вводная часть вам ясна. Шаман племени X наслал порчу на племя Y.\nOUTPUT.TXT1126 152424[Лучшие попытки]\nШаману племени Y удалось выяснить, какое магическое число N было использовано при проведении страшного ритуала. Теперь ему нужно создать веревку с таким числом K, чтобы N + K делилось на фундаментальную магическую константу M. Необходимо сделать это как можно быстрее, поэтому он хочет выполнить задачу, завязав наименьшее число узелков, даже если для этого придется взять самую длинную веревку из потайного хранилища.\nПоможете ли вы спасти племя Y (а в след за ним, может быть, и весь мир) от ужасного шамана племени X?\nВходные данные\nВо входном файле INPUT.TXT записаны два целых числа – N и M. Ограничения: 0 ≤ N ≤ 1000, 1 \u003c M ≤ 1000.\nВыходные данные\nВ выходной файл OUTPUT.TXT выведите целое неотрицательное число K – ответ на задачу.",
    "complexity": 75,
    "memory": 16000,
    "time": 1000,
    "examples": [
      {
        "input": "5 8",
        "output": "11"
      },
      {
        "input": "6 15",
        "output": "24"
      }
    ]
  },
  {
    "id": 455,
    "name": "Умножение дроби",
    "description": "Задана некоторая правильная периодическая дробь Q и натуральное число N.\nOUTPUT.TXT0.5212.(3)224.(6)24.(6)[Лучшие попытки]\nТребуется написать программу, которая определяет результат умножения Q на N, то есть непериодическую часть и минимальный период числа Q×N. В случае получения результата умножения в виде конечной дроби скобки опускаются.\nВходные данные\nВходной файл INPUT.TXT в первой строке содержит число Q, во второй строке записано число N. В записи числа Q используется не более 100 цифр. При изображении дроби Q периодическая часть заключается в круглые скобки. N – натуральное число, не превосходящее 1000.\nВыходные данные\nВ выходной файл OUTPUT.TXT выведите  результат умножения Q на N.",
    "complexity": 64,
    "memory": 16000,
    "time": 1000,
    "examples": [
      {
        "input": "0.1(6)\n3",
        "output": "0.5"
      },
      {
        "input": "12.(3)\n2",
        "output": "24.(6)"
      }
    ]
  },
  {
    "id": 492,
    "name": "Сближение с целью",
    "description": "Вы являетесь одним из разработчиков программного обеспечения боевой информационной системы для ракетного крейсера нового поколения РК-2000. Один из компонентов этой системы отвечает за решение задач тактического маневрирования. В настоящее время вы занимаетесь решением задачи о сближении с целью.\nx0OUTPUT.TXTNO21 11 11 1 2YESYES[Лучшие попытки]\nЗаданы координаты x0 и y0 цели в начальный момент времени, а также вектор (Vx; Vy) ее скорости. Считается, что цель движется равномерно и прямолинейно. В начальный момент времени РК-2000 находится в начале координат. Его максимальная скорость равна V.\ny9\nНеобходимо выяснить, может ли РК-2000 через заданное время t оказаться ровно на заданном расстоянии d от цели. Для простоты считайте, что РК-2000 может мгновенно изменять свою скорость.\n0\nВходные данные9\nПервая строка входного файла INPUT.TXT содержит два целых числа x0 и y0 (|x0| ≤ 109, |y0| ≤ 109). Вторая строка входного файла содержит два целых числа Vx и Vy (|Vx| ≤ 106, |Vy| ≤ 106). Третья строка входного файла содержит три целых числа: V , t, d (1 ≤ V ≤ 106, 1 ≤ t ≤ 103, 1 ≤ d ≤ 109).\nx\nyВыходные данные\nx\nВ выходной файл OUTPUT.TXT выведите YES, если РК-2000 может через заданное время t оказаться ровно на заданном расстоянии d от цели, и NO –  в противном случае.\n6Примеры\ny\n№INPUT.TXTOUTPUT.TXT\n11 11 11 1 1NO\n21 11 11 1 2YES\n6\n6Для отправки решения задачи необходимо зарегистрироваться и авторизоваться!\n3\n\n  [Обсуждение]\n\n  [Все попытки]\n\n  [Лучшие попытки]\n9\nwindow.yaContextCb.push(()=\u003e{\n  Ya.Context.AdvManager.render({\n    renderTo: 'yandex_rtb_R-A-122393-3',\n    blockId: 'R-A-122393-3'\n  })\n})",
    "complexity": 37,
    "memory": 16000,
    "time": 1000,
    "examples": [
      {
        "input": "1 1\n1 1\n1 1 1",
        "output": "NO"
      },
      {
        "input": "1 1\n1 1\n1 1 2",
        "output": "YES"
      }
    ]
  },
  {
    "id": 395,
    "name": "Произведение цифр - 2",
    "description": "Найдите количество целых чисел из отрезка [L, R], которые делятся на произведение своих цифр.\nOUTPUT.TXT11[Лучшие попытки]\nВходные данные\nВходной файл INPUT.TXT содержит два целых числа L и R. (1 ≤ L ≤ R ≤ 109, |R-L| ≤ 105)\nВыходные данные\nВ выходной файл OUTPUT.TXT выведите ответ на задачу.",
    "complexity": 28,
    "memory": 16000,
    "time": 1000,
    "examples": [
      {
        "input": "1 12",
        "output": "11"
      }
    ]
  },
  {
    "id": 475,
    "name": "Арифметическая прогрессия - 2",
    "description": "Задана последовательность натуральных чисел из диапазона [1, 2147483647]. Необходимо определить: можно ли выстроить эти числа в отрезок арифметической прогрессии. При необходимости порядок чисел в последовательности можно изменять.\nOUTPUT.TXTYes21 2 3 5NoNo[Лучшие попытки]\nТребуется написать программу для решения этой задачи.\nВходные данные\nВходной файл INPUT.TXT содержит последовательность натуральных чисел. Количество чисел в последовательности может быть от 2 до 100 000. Числа в файле разделены пробелами или символами перехода на новую строку.\nВыходные данные\nВыходной файл OUTPUT.TXT должен содержать либо «Yes» в случае положительного ответа, либо «No» в противоположном случае.",
    "complexity": 38,
    "memory": 16000,
    "time": 1000,
    "examples": [
      {
        "input": "80 50 10 30 70 40 20 60 90",
        "output": "Yes"
      },
      {
        "input": "1 2 3 5",
        "output": "No"
      }
    ]
  },
  {
    "id": 473,
    "name": "Автомобильные пробки",
    "description": "Автомобильные пробки случаются везде, даже в нашем небольшом городе. Дороги у нас имеют по две полосы в одном направлении, а автомобили только двух видов: легковые (в пробке занимают квадратное место 1×1 от ширины одной полосы) и грузовые (занимают прямоугольное место 1×2). Автомобилисты очень дисциплинированы: не становятся поперек полосы, не занимают чужую площадь, но и не оставляют свободных мест.\nOUTPUT.TXT42399[Лучшие попытки]\nТребуется написать программу, которая определит количество различных автомобильных пробок длины N.\nВходные данные\nВходной файл INPUT.TXT содержит одно  натуральное число N (N ≤ 1000).\nВыходные данные\nВыходной файл OUTPUT.TXT должен содержать найденное количество автомобильных пробок.",
    "complexity": 48,
    "memory": 16000,
    "time": 1000,
    "examples": [
      {
        "input": "2",
        "output": "4"
      },
      {
        "input": "3",
        "output": "9"
      }
    ]
  },
  {
    "id": 476,
    "name": "Ферзя в угол!",
    "description": "OUTPUT.TXT226 711[Лучшие попытки]\nРассмотрим бесконечную вправо и вверх шахматную доску, на которой стоит ферзь. Двое по очереди двигают этого ферзя. Разрешается двигать ферзя только вниз, влево или по диагонали вниз влево на любое положительное количество клеток в выбранном направлении. Цель игры – задвинуть ферзя в угол, то есть клетку с координатами (1, 1). На рисунке показаны разрешенные движения ферзя.\nТребуется написать программу, которая найдет номер игрока, который выиграет при правильной игре.\nВходные данные\nВходной файл INPUT.TXT содержит координаты ферзя перед первым ходом - два числа M и N, записанные через пробел (1 ≤ M, N ≤ 250). Гарантируется, что ферзь изначально не находится в клетке с координатами (1,1).\nВыходные данные\nВыходной файл OUTPUT.TXT должен содержать найденный номер победителя.",
    "complexity": 43,
    "memory": 16000,
    "time": 1000,
    "examples": [
      {
        "input": "3 2",
        "output": "2"
      },
      {
        "input": "6 7",
        "output": "1"
      }
    ]
  },
  {
    "id": 474,
    "name": "Последовательность Кеане",
    "description": "Бесконечная последовательность битов, предложенная Кеане, равна 001001110001001110110110001… и формируется следующим алгоритмом: вначале записывается 0, потом 001, далее 001001110, то есть, для получения следующего члена, предыдущий записывается дважды, а справа приписывается его отрицание. Элементы этого ряда являются начальными подпоследовательностями Кеане.\nOUTPUT.TXT121800[Лучшие попытки]\nТребуется написать программу, которая по заданному n определит N-й бит этой последовательности.\nВходные данные\nВходной файл INPUT.TXT содержит число N (N ≤ 10200).\nВыходные данные\nВ выходной файл OUTPUT.TXT должен содержать найденный бит.",
    "complexity": 57,
    "memory": 16000,
    "time": 1000,
    "examples": [
      {
        "input": "3",
        "output": "1"
      },
      {
        "input": "18",
        "output": "0"
      }
    ]
  },
  {
    "id": 396,
    "name": "Точки и отрезки",
    "description": "Дано N отрезков на числовой прямой и M точек на этой же прямой. Для каждой из данных точек определите, скольким отрезкам она принадлежит. Точка x считается принадлежащей отрезку с концами a и b, если выполняется двойное неравенство min(a, b) ≤ x ≤ max(a, b).\niOUTPUT.TXT2 021 3\n-10 10\n-100 100 0\n0 0 10 0 1[Лучшие попытки]\nВходные данные9\nПервая строка входного файла INPUT.TXT содержит два целых числа N – число отрезков и M – число точек (1 ≤ N, M ≤ 105). В следующих N строках по два целых числа ai и bi – координаты концов соответствующего отрезка. В последней строке M целых чисел – координаты точек. Все числа во входном файле не превосходят по модулю 109.\nВыходные данные\nВ выходной файл OUTPUT.TXT выведите M чисел – для каждой точки количество отрезков, в которых она содержится.",
    "complexity": 62,
    "memory": 16000,
    "time": 1000,
    "examples": [
      {
        "input": "3 2\n\n0 5\n\n-3 2\n\n7 10\n\n1 6",
        "output": "2 0"
      },
      {
        "input": "1 3\n\n-10 10\n\n-100 100 0",
        "output": "0 0 1"
      }
    ]
  },
  {
    "id": 397,
    "name": "Качество строки",
    "description": "Назовем качеством строки разность между максимальным и минимальным номерами в алфавите букв, входящих в строку. Например, качество строки ab равно 2 - 1 = 1, а строки abcz равно 26 - 1 = 25.\nOUTPUT.TXTab2zzzzz[Лучшие попытки]\nДана строка S. Необходимо найти непустую подстроку этой строки, обладающую максимальным качеством, а из всех таких – минимальную по длине.\nВходные данные\nВходной файл INPUT.TXT содержит непустую строку S, состоящую из строчных букв английского алфавита. Ее длина не превосходит 2∙105 символов.\nВыходные данные\nВ выходной файл OUTPUT.TXT выведите искомую подстроку. Если вариантов ответа несколько, выведите любой.",
    "complexity": 52,
    "memory": 16000,
    "time": 1000,
    "examples": [
      {
        "input": "aba",
        "output": "ab"
      },
      {
        "input": "zzz",
        "output": "z"
      }
    ]
  },
  {
    "id": 478,
    "name": "Коррозия металла",
    "description": "Для хранения двух агрессивных жидкостей A и B используется емкость с многослойной перегородкой, которая изготавливается из имеющихся N листов. Для каждого листа i (i = 1, …, N) известно время его растворения жидкостью A — ai  и жидкостью B — bi. Растворение перегородки каждой из жидкостей происходит последовательно лист за листом, с постоянной скоростью по толщине листа.\n-4OUTPUT.TXT6.000\n4 2 1 3\n[Лучшие попытки]\nТребуется написать программу проектирования такой перегородки, время растворения которой было бы максимальным.\ni\nВходные данныеi\nВ первой строке входного файла INPUT.TXT записано число N (1 ≤ N ≤ 256). В каждой из последующих N строк содержатся два положительных вещественных числа ai и bi, разделенные пробелом (10-4 ≤ ai,  bi ≤ 106, все числа содержат не более 11 значащих цифр).\n6\nВыходные данные\nВ первую строку выходного файла OUTPUT.TXT записать время растворения перегородки с точностью, не меньшей 10-3. В следующую строку файла записать номера листов в порядке их расположения от жидкости A к жидкости B, разделяя числа пробелами.",
    "complexity": 55,
    "memory": 16000,
    "time": 1000,
    "examples": [
      {
        "input": "4\n\n1 2\n\n1 2\n\n0.5 1.5\n\n7 3.5",
        "output": "6.000\n\n4 2 1 3"
      }
    ]
  },
  {
    "id": 480,
    "name": "Игра с монетами",
    "description": "Гриша и Дима играют в следующую игру: они разложили однокопеечные монетки в стопки (в разных стопках может быть различное количество монет), а стопки расположили на столе перед собой в ряд слева направо. Затем Гриша и Дима по очереди делают ходы. На каждом ходе один из игроков берет слева несколько стопок, не меньше одной, но и не больше, чем перед этим взял его соперник. Первый игрок своим первым ходом берет не более K стопок. Игра заканчивается, когда стопок не остается. \nOUTPUT.TXT1424  1 2 2 7  35518[Лучшие попытки]\nТребуется написать программу, позволяющую вычислить, какое максимальное число монет может получить первый участник после окончания игры, если второй –  тоже старается ходить так, чтобы получить как можно больше монет.\n35  3 4 8 1 7  218[Решение]\nВходные данные\nВходной файл INPUT.TXT состоит из одной строки, в которой записаны: число стопок N (1 ≤ N ≤ 180), за ним идут N чисел, задающих количество монет в стопках слева направо (количество монет в стопке – не менее 1 и не более 20000), а затем число K, ограничивающее количество стопок, которые первый игрок может взять на первом ходе (1 ≤ K ≤ 80). Все числа в строке разделены пробелом.\nВыходные данные\nВ выходной файл OUTPUT.TXT необходимо вывести одно число – максимальное количество монет, которое заведомо может получить первый игрок, как бы ни играл второй.",
    "complexity": 47,
    "memory": 16000,
    "time": 1000,
    "examples": [
      {
        "input": "3  4 9 1  3",
        "output": "14"
      },
      {
        "input": "4  1 2 2 7  3",
        "output": "5"
      },
      {
        "input": "5  3 4 8 1 7  2",
        "output": "18"
      }
    ]
  },
  {
    "id": 398,
    "name": "Сумма - 2",
    "description": "Задано натуральное число x. Найдите число способов представить его в виде суммы четырех натуральных чисел: x = a + b + c + d, где a ≤ b ≤ c ≤ d.\nOUTPUT.TXT02511[Лучшие попытки]\nВходные данные\nВходной файл INPUT.TXT содержит целое число x (1 ≤ x ≤ 1500).\nВыходные данные\nВ выходной файл OUTPUT.TXT выведите ответ на задачу.",
    "complexity": 30,
    "memory": 16000,
    "time": 1000,
    "examples": [
      {
        "input": "3",
        "output": "0"
      },
      {
        "input": "5",
        "output": "1"
      }
    ]
  },
  {
    "id": 477,
    "name": "Простая игра",
    "description": "Дед Мазай и заяц играют в очень простую игру. Перед ними – огромная куча из N одинаковых морковок. Каждый из них во время своего хода может взять из этой кучи любое количество морковок, равное неотрицательной степени числа 2, т.е. 1, 2, 4, 8,… . Начинает игру либо дед Мазай, либо заяц. Затем игроки ходят по очереди. Тот, кто возьмет последнюю морковку, тот и выигрывает.\nOUTPUT.TXT2281212[Лучшие попытки]\nТребуется написать программу, которая при заданных исходных данных определяет победителя в этой игре. При этом следует учитывать, что игроки играют оптимально.\nВходные данные\nВходной файл INPUT.TXT содержит единственное целое положительное число N (N ≤ 10250), задающее число морковок в начале игры.\nВыходные данные\nВыходной файл OUTPUT.TXT должен содержать в первой строке цифру «1», если выиграет тот, кто ходит первым, или цифру «2» – в противном случае. Если игру выиграл тот, кто ходил первым, то во второй строке этого файла должно содержаться минимальное число морковок, которое должен взять игрок, выполнявший ход первым, чтобы гарантировать свою победу.",
    "complexity": 50,
    "memory": 16000,
    "time": 1000,
    "examples": [
      {
        "input": "3",
        "output": "2"
      },
      {
        "input": "8",
        "output": "1\n2"
      }
    ]
  },
  {
    "id": 412,
    "name": "Ферзь и король",
    "description": "Вася продолжает заниматься шахматами, и теперь он изучает различные окончания. Оказалось, что компьютер очень удобно использовать для анализа позиций. Теперь Вася просит вас написать программу, которая сможет определить, что черный король находится под шахом.\n\n\nДля начала Васе подойдет программа, которая анализирует игровую ситуацию с тем предположением, что на доске находятся три фигуры - белые король и ферзь и черный король. Черный король находится под шахом, если белый ферзь может за один ход попасть на занимаемую им клетку. Шахматный ферзь может перемещаться по вертикали, горизонтали или диагонали, но, в отличие от коня, не может “перепрыгивать” через другие фигуры.\n\n\nВходные данные\n\n\nВ единственной строке входного файла INPUT.TXT записаны обозначения трех клеток шахматной доски, разделенные пробелами: положения белого короля, белого ферзя и черного короля соответственно. При этом гарантируется, что черный и белый короли не находятся на соседних клетках.\n\n\nВыходные данные\n\n\nВ выходной файл OUTPUT.TXT выведите слово YES, если черный король находится под шахом и NO, если шаха нет.\n\n\nДля начала Васе подойдет программа, которая анализирует игровую ситуацию с тем предположением, что на доске находятся три фигуры - белые король и ферзь и черный король. Черный король находится под шахом, если белый ферзь может за один ход попасть на занимаемую им клетку. Шахматный ферзь может перемещаться по вертикали, горизонтали или диагонали, но, в отличие от коня, не может “перепрыгивать” через другие фигуры.\nOUTPUT.TXTYES2a1 a8 b3NONO[Лучшие попытки]\nВходные данныеПримеры\nВ единственной строке входного файла INPUT.TXT записаны обозначения трех клеток шахматной доски, разделенные пробелами: положения белого короля, белого ферзя и черного короля соответственно. При этом гарантируется, что черный и белый короли не находятся на соседних клетках.\n\n№INPUT.TXTOUTPUT.TXT\n1d3 d5 d8YES\n2a1 a8 b3NO\nВыходные данные\nВ выходной файл OUTPUT.TXT выведите слово YES, если черный король находится под шахом и NO, если шаха нет.\nДля отправки решения задачи необходимо зарегистрироваться и авторизоваться!\n[Обсуждение]\n\n  [Все попытки]\n\n  [Лучшие попытки]\nwindow.yaContextCb.push(()=\u003e{\n  Ya.Context.AdvManager.render({\n    renderTo: 'yandex_rtb_R-A-122393-3',\n    blockId: 'R-A-122393-3'\n  })\n})",
    "complexity": 32,
    "memory": 16000,
    "time": 1000,
    "examples": [
      {
        "input": "d3 d5 d8",
        "output": "YES"
      },
      {
        "input": "a1 a8 b3",
        "output": "NO"
      }
    ]
  },
  {
    "id": 389,
    "name": "К коду Грея",
    "description": "",
    "complexity": 50,
    "memory": 16000,
    "time": 1000,
    "examples": [
      {
        "input": "2\n\n0 1 3 2\n\n2\n\n1 2\n\n2 1",
        "output": "No\nYes"
      }
    ]
  },
  {
    "id": 413,
    "name": "Военная база",
    "description": "Со спутника-шпиона получено изображение в некотором волновом диапазоне сверхсекретной военной базы предполагаемого противника. База расположена на Антарктиде, все постройки на ней высечены из кубов льда и имеют на фотографии квадратную форму и не имеют общих фрагментов стен ненулевой длины (по всей видимости, это сделано в целях маскировки от локаторов, работающих в инфракрасном спектре). Благодаря мастерству операторов оказалось, что стены разных построек параллельны границам фотографии.\nOUTPUT.TXT2[Лучшие попытки]\nДля того, чтобы составить сверхсрочный отчет для командования, необходимо узнать, сколько зданий находятся на базе. Напишите программу, которая это сделает.\nВходные данные\nВ первой строке входного файла INPUT.TXT записаны числа N и M (1 ≤ M, N ≤ 500) – размеры фотографии в пикселях по вертикали и по горизонтали. Следующие N строк содержат по M символов каждая: символ '.' соответствует пустому месту, '#' – элементу постройки.\nВыходные данные\nВ выходной файл OUTPUT.TXT выведите единственное число – количество построек на базе.",
    "complexity": 32,
    "memory": 16000,
    "time": 1000,
    "examples": [
      {
        "input": "8 6\n\n......\n\n...##.\n\n...##.\n\n......\n\n.###..\n\n.###..\n\n.###..\n\n......",
        "output": "2"
      }
    ]
  },
  {
    "id": 479,
    "name": "Муравей и дерево",
    "description": "Муравей находится в лесу с плоской поверхностью почвы в точке с координатами (x1, y1) и направляется в точку (x2, y2). В лесу растет дерево, основание ствола которого имеет форму круга с центром в точке (x, y) и радиусом r. Дерево, возможно, помешает муравью дойти до цели по прямой. В таком случае ему придется обойти дерево вокруг ствола.\n22OUTPUT.TXT6.014[Лучшие попытки]\n2\nТребуется написать программу, которая определит длину кратчайшего пути муравья.\n2\nВходные данные\nВходной файл INPUT.TXT содержит вещественные числа x1, y1, x2, y2, x, y, r. Числа записаны через пробел и находятся в диапазоне от 0 до 1000, r\u003e0. Начальная и конечная точки пути муравья не могут находиться внутри круга.\nВыходные данные\nВыходной файл OUTPUT.TXT должен содержать единственное вещественное число – длину кратчайшего пути. Ответ следует выводить с точностью не менее трех знаков после запятой.",
    "complexity": 63,
    "memory": 16000,
    "time": 1000,
    "examples": [
      {
        "input": "0 0 4 4 2 2 1",
        "output": "6.014"
      }
    ]
  },
  {
    "id": 481,
    "name": "Количество палиндромов",
    "description": "Непустая строка, содержащая некоторое слово, называется палиндромом, если это слово одинаково читается как слева направо, так и справа налево. Пусть задана строка, в которой записано слово S, состоящее из N букв английского алфавита. Путем вычеркивания из этого слова некоторого набора символов, можно получить строку, которая будет палиндромом.\nOUTPUT.TXT72BAOBAB2222[Лучшие попытки]\nТребуется написать программу, с помощью которой можно определить, сколько существует способов вычеркивания из заданного слова некоторого (возможно пустого) набора символов, чтобы образованная таким образом строка была палиндромом. Способы, отличающиеся порядком вычеркивания символов, считаются одинаковыми.\nВходные данные\nВ первой и  единственной строке входного файла INPUT.TXT записано слово S, состоящее из N символов (1 ≤ N ≤ 30).\nВыходные данные\nВ выходной файл OUTPUT.TXT выведите найденное число способов.",
    "complexity": 49,
    "memory": 16000,
    "time": 1000,
    "examples": [
      {
        "input": "AAA",
        "output": "7"
      },
      {
        "input": "BAOBAB",
        "output": "22"
      }
    ]
  },
  {
    "id": 484,
    "name": "Трубопровод",
    "description": "В некоторой корпорации при производстве различных химических веществ используется сложная система трубопроводов для слива отходов. При монтаже трубопровода использовались стандартные элементы, состоящие из двух задвижек, двух входов и одного выхода (рис. 1).\nOUTPUT.TXT8 4 2 1255 2 15 2 16 3 110 6 3 1[Лучшие попытки]\nТакие элементы объединяются вместе, как показано на рисунке 2, где изображен трубопровод до 4 уровня. Здесь обозначение Layer – указывает на слой (уровень) задвижек. \n366 3 1\n41010 6 3 1\nВ последующем ограничимся рассмотрением трубопровода до сорокового слоя включительно. Все задвижки в трубопроводе пронумерованы от первого до сорокового слоя. Внутри каждого слоя задвижки пронумерованы слева направо (см. рис. 2).\nНапишите программу, которая по заданному порядковому номеру S начальной задвижки определяет и выводит в выходной файл номера всех тех задвижек, которые следует открыть, чтобы осуществить сброс отходов.\nВходные данные\nВходной файл INPUT.TXT содержит одно целое число S – номер начальной задвижки (1 ≤ S ≤ 433494435).\nВыходные данные\nВыходной файл OUTPUT.TXT должен содержать последовательность номеров задвижек. Последовательность должна начинаться с числа S и заканчиваться числом 1. Элементы последовательности идут в порядке убывания, разделяются пробелами и (или) символами конца строк.",
    "complexity": 60,
    "memory": 16000,
    "time": 1000,
    "examples": [
      {
        "input": "8",
        "output": "8 4 2 1"
      },
      {
        "input": "5",
        "output": "5 2 1"
      },
      {
        "input": "6",
        "output": "6 3 1"
      },
      {
        "input": "10",
        "output": "10 6 3 1"
      }
    ]
  },
  {
    "id": 483,
    "name": "Двоичная машина",
    "description": "Выходные данные\nВ выходной файл OUTPUT.TXT выведите ответ – результат преобразования в двоичном виде без ведущих нулей.",
    "complexity": 53,
    "memory": 16000,
    "time": 1000,
    "examples": [
      {
        "input": "4\n1001",
        "output": "10"
      },
      {
        "input": "7\n1101101",
        "output": "101"
      }
    ]
  },
  {
    "id": 485,
    "name": "Рыбаки",
    "description": "Говорят, что однажды Дираку предложили решить следующую задачу.\nOUTPUT.TXT2524 3247247[Лучшие попытки]\nТрое рыбаков отправились на рыбалку. Наловив рыбы, они устроились на ночлег. Проснувшись, один из рыбаков решил взять свою долю (третью часть) и отправиться домой. Пересчитав рыбу, он заметил, что на троих выловленная рыба не делится – остается одна лишняя. Недолго думая, первый рыбак выкинул лишнюю рыбу в море, взял свою долю и отправился домой.\nЗатем проснулся второй рыбак. Не заметив, что один из его товарищей уже уехал, он тоже стал делить оставшуюся рыбу на троих, и у него тоже получилась одна лишняя рыба. Поступив с лишней рыбой, также как и первый рыбак, он забрал долю, которую считал своей и поехал домой.\nТретий рыбак также не обнаружил исчезновения своих товарищей и тоже стал делить рыбу на троих. И у него получилась одна лишняя рыба, которую он выкинул, после чего забрал третью часть и отбыл домой.\nВопрос, заданный Дираку, звучал так: сколько рыбы поймали рыбаки?\nОбобщим данную задачу следующим образом.\nОднажды N рыбаков отправились на рыбалку, где поймали X рыб. После этого рыбаки легли спать. Утром, просыпаясь друг за другом, каждый из них делил выловленную рыбу на N частей. Каждый раз в остатке оставалось ровно K рыб (0 \u003c K \u003c N). Эти K рыб выбрасывались обратно в море. Рыбак забирал свою часть улова и отбывал домой, не зная ничего о том, поступал ли уже кто-либо из остальных рыбаков таким же образом.\nВаша задача – определите при заданных N и K минимально возможное целое положительное значение X – число рыб, удовлетворяющее условию задачи.\nВходные данные\nВходной файл INPUT.TXT содержит два целых числа N и K, разделенные пробелом (2 ≤ N ≤ 8, 0 \u003c K \u003c N).\nВыходные данные\nВыходной файл OUTPUT.TXT должен содержать одно целое положительное число X – наименьшее возможное количество выловленной рыбаками рыбы.",
    "complexity": 29,
    "memory": 16000,
    "time": 1000,
    "examples": [
      {
        "input": "3 1",
        "output": "25"
      },
      {
        "input": "4 3",
        "output": "247"
      }
    ]
  },
  {
    "id": 482,
    "name": "Короткая последовательность",
    "description": "Дано целое число N. Рассмотрим последовательность S1S2S3...Sk..., где каждая группа цифр Sk состоит из записанных одно за другим чисел от 1 до k. Например, первые 75 цифр последовательности выглядят так: \n3OUTPUT.TXT222055[Лучшие попытки]\nk\n112123123412345123456123456712345678123456789123456789101234567891011123456.\nk\nТребуется написать программу, которая определит: какая цифра находится на N-ой позиции в построенной последовательности.\nВходные данные\nВходной файл INPUT.TXT содержит одно число N (0 \u003c N \u003c 32768).\nВыходные данные\nВ выходной файл OUTPUT.TXT выведите цифру, которая стоит на N-ой позиции в последовательности.",
    "complexity": 23,
    "memory": 16000,
    "time": 1000,
    "examples": [
      {
        "input": "3",
        "output": "2"
      },
      {
        "input": "20",
        "output": "5"
      }
    ]
  },
  {
    "id": 414,
    "name": "Расследование",
    "description": "В городском управлении полиции одного прибрежного города ведется расследование крупного дела, в котором могут быть замешаны сотрудники полиции. Было принято решение о тайной установке оборудования для просмотра информации, поступающей через Интернет. Под подозрение попадают два отдела, но добиться выделения денег на покупку двух комплектов оборудования не удалось. К счастью, внутренняя сеть управления имеет древовидную структуру, то есть каждый отдел имеет выход в Интернет через какой-либо другой отдел. Исключение составляет отдел по борьбе с компьютерными преступлениями, который имеет непосредственный доступ в Интернет по модемной линии.\nOUTPUT.TXT328\n3 6\n1 1 2 4 5 1 1\n11[Лучшие попытки]\nМожно было бы установить оборудование для слежения прямо в этом отделе, но для предотвращения злоупотреблений лучше найти такое расположение, чтобы нарушалась секретность как можно меньшего количества лишних отделов.\nКак наиболее опытному в подобных вопросах сотруднику, решение этой задачи поручили вам. Подчиненные уже пронумеровали все отделы натуральными числами, начиная с 1, первый номер присвоен отделу по борьбе с компьютерными преступлениями.\nВходные данные\nПервая строка входного файла INPUT.TXT содержит натуральное число N \n(N ≤ 30000) – количество отделов. Во второй строке записаны номера двух отделов, за которыми необходимо установить слежение. На третьей строке находятся n-1 натуральных чисел, i-е из них не больше i и задает номер отдела, к которому подсоединен отдел i + 1.\nВыходные данные\nВ выходной файл OUTPUT.TXT выведите одно число – номер отдела, в котором следует установить следящее оборудование.",
    "complexity": 40,
    "memory": 16000,
    "time": 1000,
    "examples": [
      {
        "input": "4\n\n3 4\n\n1 1 3",
        "output": "3"
      },
      {
        "input": "8\n\n3 6\n\n1 1 2 4 5 1 1",
        "output": "1"
      }
    ]
  },
  {
    "id": 352,
    "name": "Дробь",
    "description": "Вася учится в третьем классе и сейчас он проходит тему «Простые дроби с натуральными числителем и знаменателем». Оказывается, что дробь называется правильной, если ее числитель меньше знаменателя, и несократимой, если числитель и знаменатель являются взаимно простыми. Вася очень любит математику и поэтому дома он решает много задач. В данный момент Вася ищет наибольшую правильную несократимую дробь, у которой сумма числителя и знаменателя равна N.\nOUTPUT.TXT1 22103 73 7[Лучшие попытки]\nТребуется написать программу, которая поможет Васе решить эту задачу.\nВходные данные\nВходной файл INPUT.TXT содержит одно целое число N (3 ≤ N ≤ 2∙109).\nВыходные данные\nВыходной файл OUTPUT.TXT должен содержать два числа – числитель и знаменатель найденной дроби, разделенные пробелом.",
    "complexity": 39,
    "memory": 16000,
    "time": 1000,
    "examples": [
      {
        "input": "3",
        "output": "1 2"
      },
      {
        "input": "10",
        "output": "3 7"
      }
    ]
  },
  {
    "id": 514,
    "name": "Лестница",
    "description": "OUTPUT.TXT124223[Лучшие попытки]\nМальчик Петя строит из кубиков лестницу. Лестница представляет собой несколько строящихся рядом башенок из кубиков, каждая из которых ровно на один кубик выше предыдущей. Требуется по имеющемуся у мальчика Пети числу кубиков определить, какой в кубиках будет высота последней ступеньки.\n363\nВходные данные\nВходной файл INPUT.TXT содержит число К – количество кубиков у мальчика Пети (1 ≤ K ≤ 106).\nВыходные данные\nВ выходной файл OUTPUT.TXT выведите количество кубиков в последней ступеньке у максимально высокой лестницы, которую можно построить из K кубиков.",
    "complexity": 14,
    "memory": 16000,
    "time": 1000,
    "examples": [
      {
        "input": "1",
        "output": "1"
      },
      {
        "input": "4",
        "output": "2"
      },
      {
        "input": "6",
        "output": "3"
      }
    ]
  },
  {
    "id": 399,
    "name": "Жук",
    "description": "Петя нашел в Интернете по адресу http://buglab.ru игру-головоломку \"Жук\", в которой от участников требуется построить для жука лабиринт таким образом, чтобы жук как можно дольше искал выход.\nOUTPUT.TXT2028 30\n@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@\n@   @    @ @@@@ @  @ @@@@ @@ @\n@ @ @@ @  @ @     @ @ @      @\n@   @  @ @ @@  @@        @@ @@\n@             @           @ @@\n@ @  @@ @ @   @@@  @  @   @  @\n@     @   @  @    @   @ @@   @\n@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@\n630630-1[Лучшие попытки]\nЖук всегда начинает свое движение с левого верхнего угла, а выход всегда находится в правом нижнем. Жук движется не оптимально, а следующим образом: он идет туда, где еще не был, либо был там реже. Т.е. проходя каждую клетку лабиринта, жук запоминает: сколько раз он был в этой клетке и при обдумывании направления своего движения в какой то конкретный момент он смотрит: сколько раз он был в клетке снизу, сколько справа, сколько слева и сколько сверху и движется туда, где он был меньше раз. Если таких направлений несколько и одно из них совпадает с текущим направлением движения, то он не меняет направления, иначе он движется согласно следующим приоритетам: вниз, направо, вверх, налево. Т.е. если минимальное число посещений сразу справа и слева (а двигался он при этом вверх или вниз), то жук идет направо, т.к. у \"направо\" приоритет выше. Следует заметить, что двигаясь по данному алгоритму жук всегда достигнет выхода в том случае, когда выход существует.\n34 4\n@@@@\n@ @@\n@@ @\n@@@@\n-1[Решение]\nИзучив алгоритм движения жука Петя хочет написать программу, которая по заданному лабиринту определит количество перемещений жука прежде, чем он достигнет выхода. Помогите Пете с реализацией данной программы!\nvar map=\"111111111000000110100101100000011111000110100101100001111011000110000101110100011010011111010001111100011100001111001101100101011101010110000001101000111100010110100001110000011110011111000001110000111001001111011101110000011001100111111111\"\nvar xxx\nxxx = newImage(\"/images/bug/bug_u.gif\")\nxxx = newImage(\"/images/bug/bug_l.gif\")\nxxx = newImage(\"/images/bug/bug_r.gif\")\nКонструктор лабиринта\n- кнопка запуска жука\n  \n\n  Ходы: 0\nВходные данные\nВходной файл INPUT.TXT в первой строке содержит разделенные пробелом целые числа N и M - количество строк и столбцов в лабиринте (4 ≤ N, M ≤ 100). Далее следует N строк, содержащих данные лабиринта построчно. Каждая строка содержит M символов - клетки лабиринта текущей строки, где символ \"@\" обозначает присутствие стены, а символ пробела - пустое пространство. Гарантируется, что граница лабиринта окружена стеной. Предполагается, что жук начинает свое движение из координаты (2, 2) и заканчивает в координате (M-1, N-1), подразумевается, что в этих координатах нет стен. Гарантируется, что если выход из лабиринта существует, то жук сможет выйти из него, сделав не более 107 шагов.\nВыходные данные\nВ выходной файл OUTPUT.TXT выведите количество движений жука, если спасительный маршрут для жука существует, и -1 в противном случае.",
    "complexity": 30,
    "memory": 16000,
    "time": 1000,
    "examples": [
      {
        "input": "6 6\n\n@@@@@@\n\n@    @\n\n@    @\n\n@ @ @@\n\n@ @  @\n\n@@@@@@",
        "output": "20"
      },
      {
        "input": "8 30\n\n@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@\n\n@   @    @ @@@@ @  @ @@@@ @@ @\n\n@ @ @@ @  @ @     @ @ @      @\n\n@   @  @ @ @@  @@        @@ @@\n\n@             @           @ @@\n\n@ @  @@ @ @   @@@  @  @   @  @\n\n@     @   @  @    @   @ @@   @\n\n@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@",
        "output": "630"
      },
      {
        "input": "4 4\n\n@@@@\n\n@ @@\n\n@@ @\n\n@@@@",
        "output": "-1"
      }
    ]
  },
  {
    "id": 549,
    "name": "Факториальная система",
    "description": "Известно, что любую рациональную дробь вида p/q можно представить в виде (0 \u003c p \u003c q):\nnOUTPUT.TXT50104[Лучшие попытки]\nгде 0 ≤ ai \u003c i, i=2, 3, ..., n для некоторого конечного n. Такое представление называется факториальным.\nТребуется написать программу, которая по заданной рациональной дроби находит ее факториальное представление.\nВходные данные\nВо входном файле INPUT.TXT записаны через пробел два натуральных числа p и q (p \u003c q \u003c1000).\nВыходные данные\nВ выходной файл OUTPUT.TXT нужно в первой строке вывести число n - количество значащих разрядов плюс 1 в факториальном представлении дроби. В следующих строках располагаются неотрицательные целые числа a2, a3, ..., an. Известно, что n \u003c 1000.",
    "complexity": 58,
    "memory": 16000,
    "time": 1000,
    "examples": [
      {
        "input": "1 5",
        "output": "5\n0\n1\n0\n4"
      }
    ]
  },
  {
    "id": 513,
    "name": "Салаты",
    "description": "Как-то раз, придя домой со школы, Света обнаружила записку от мамы, в которой она просила сделать салат. Света знала, что салат – это смесь двух или более ингредиентов, поэтому ей не составило труда выполнить мамину просьбу.\nOUTPUT.TXT4241111[Лучшие попытки]\nНо Света хочет стать математиком, поэтому, для тренировки, решила посчитать, сколько различных салатов она сможет сделать из имеющихся продуктов (майонез, огурцы, помидоры). После небольших расчетов она получила ответ: 4.\nЗная, что вы любите интересные задачки, и хотите стать программистами, Света попросила вас написать программу, которая определяет количество различных салатов для произвольного числа ингредиентов.\nВходные данные\nВходной файл INPUT.TXT содержит натуральное число N – количество имеющихся ингредиентов (N \u003c 32).\nВыходные данные\nВ выходной файл OUTPUT.TXT выведите количество различных салатов.",
    "complexity": 26,
    "memory": 16000,
    "time": 1000,
    "examples": [
      {
        "input": "3",
        "output": "4"
      },
      {
        "input": "4",
        "output": "11"
      }
    ]
  },
  {
    "id": 400,
    "name": "Коробка",
    "description": "Иван работает на заводе, который производит тяжелую технику. Его работа очень проста – он собирает коробки и упаковывает в них технику для заказчиков. Каждая такая коробка представляет собой параллелепипед. Для сборки коробки Иван использует шесть прямоугольных деревянных плиток. Каждая плита представляет собой одну из сторон коробки.\nOUTPUT.TXTPOSSIBLE21234 4567\n1234 4567\n4567 4321\n4322 4567\n4321 1234\n4321 1234\nIMPOSSIBLEIMPOSSIBLE[Лучшие попытки]\n[Решение]\nПетр подбирает плитки для Ивана. Петр недостаточно умен и поэтому часто допускает ошибки – он приносит Ивану такие плитки, из которых невозможно собрать коробку. Но Иван не доверяет Петру. Поэтому он всегда тратит массу времени на то, чтобы объяснить Петру то, где он допустил ошибку.\nК счастью, Петр обожает все, что связано с компьютерами и верит в то, что компьютеры никогда не ошибаются. Иван решил, что можно использовать это в их работе. Иван попросил Вас написать программу, которая по заданным размерам шести плиток скажет: возможно ли построить из них коробку.\nВходные данные\nВходной файл INPUT.TXT содержит шесть строк, каждая из которых содержит два натуральных числа w и h (1 ≤ w, h ≤ 10 000) – ширина и высота плиты в миллиметрах.\nВыходные данные\nВ выходной файл OUTPUT.TXT выведите «POSSIBLE», если возможно собрать коробку из данных плит, и «IMPOSSIBLE» в противном случае.",
    "complexity": 37,
    "memory": 16000,
    "time": 1000,
    "examples": [
      {
        "input": "1345 2584\n\n2584 683\n\n2584 1345\n\n683 1345\n\n683 1345\n\n2584 683",
        "output": "POSSIBLE"
      },
      {
        "input": "1234 4567\n\n1234 4567\n\n4567 4321\n\n4322 4567\n\n4321 1234\n\n4321 1234",
        "output": "IMPOSSIBLE"
      }
    ]
  },
  {
    "id": 516,
    "name": "2-простое число",
    "description": "Число называется 2-простым, если являются простыми числа, составленные из цифр этого числа в возрастающем и убывающем порядках.\nOUTPUT.TXTYes223NoNo[Лучшие попытки]\nТребуется написать программу, которая по заданному числу определит его 2-простоту.\nВходные данные\nВходной файл INPUT.TXT содержит натуральное число N (10 \u003c N \u003c 109).\nВыходные данные\nВ выходной файл OUTPUT.TXT выведите сообщение «Yes», если число N является 2-простым и «No» - иначе.",
    "complexity": 28,
    "memory": 16000,
    "time": 1000,
    "examples": [
      {
        "input": "13",
        "output": "Yes"
      },
      {
        "input": "23",
        "output": "No"
      }
    ]
  },
  {
    "id": 401,
    "name": "Шары и коробки",
    "description": "У вас имеется N выстроенных в ряд коробок, A красных и B синих шаров. Все красные шары (аналогично и синие) идентичны. Вы можете класть шары в коробки. Разрешается размещать в коробках шары как одного, так и двух видов одновременно. Так же разрешается оставлять некоторые из коробок пустыми. Не обязательно класть все шары в коробки.\nOUTPUT.TXT422 1 199[Лучшие попытки]\nТребуется написать программу, которая определяет количество различных способов, которыми возможно заполнить коробки шарами.\nВходные данные\nВходной файл INPUT.TXT содержит целые числа N, A, B. (1 ≤ N ≤ 20, 0 ≤ A, B ≤ 20)\nВыходные данные\nВ выходной файл OUTPUT.TXT выведите ответ на задачу.",
    "complexity": 52,
    "memory": 16000,
    "time": 1000,
    "examples": [
      {
        "input": "1 1 1",
        "output": "4"
      },
      {
        "input": "2 1 1",
        "output": "9"
      }
    ]
  },
  {
    "id": 489,
    "name": "Монеты",
    "description": "На столе лежат произвольным образом N сказочных монет: M1, M2, …, Mn. Ученик Паша проводит следующий эксперимент. Он K раз выполняет следующие действия: берет некоторую монету, переворачивает ее, кладет ее в произвольное свободное место на столе и записывает номинал этой монеты в протокол. \nnпротокол переворачиваний.OUTPUT.TXT1[Лучшие попытки]\nПосле этого Паша закрывает одну монету (любую) и предлагает Маше угадать номинал и верхнюю сторону закрытой монеты.\nМаше доступны следующие исходные данные:\nначальный набор монет, \nнабор монет на столе после эксперимента,\nпротокол переворачиваний.\nПусть Паша положил на стол монеты (N=8): 10, –5, 1, 50, 1, 100, –1, 9. Здесь абсолютная величина числа соответствует номиналу монеты, а знаком \n«–» помечены монеты, положенные орлом вверх.\nПусть в протоколе записано 7 ходов (K=7): 10, 10, 5, 10, 50, 100, 1 (здесь номиналы указываются без знака).\nПосле того, как Паша закрыл одну монету, на столе остались монеты (перечисляются в произвольном порядке): –100, –10, –50, 1, 5, 1, 9.\nПодумав некоторое время, Маша сказала, что закрыта монета номиналом 1 решкой вверх.\nНапишите программу, которая по известным N и K определяет закрытую монету и ее верхнюю сторону. Если вам потребуется, можно дополнительно использовать протокол переворачиваний, который также будет задан во входном файле.\nВходные данные\nВ первой строке входного файла INPUT.TXT записаны два целых числа: N и K – количество монет на столе и количество переворачиваний (1 ≤ N ≤ 10000, 1 ≤ K ≤100000). Во второй строке записаны N целых чисел (монеты в начале эксперимента). В третьей строке записано N-1 целое число (монеты в конце эксперимента). Последующие одна или несколько строк содержат K целых положительных чисел (номиналы тех монет, которые переворачиваются), разделенных пробелами или признаком конца строки. Условные номиналы монет заданы целыми числами в диапазоне от 1 до 1000.\nВыходные данные\nВ выходном файле OUTPUT.TXT должно быть записано одно целое число – номинал закрытой монеты либо без знака (если монета лежит решкой вверх), либо со знаком «–», если монета лежит орлом вверх.",
    "complexity": 40,
    "memory": 16000,
    "time": 1000,
    "examples": [
      {
        "input": "8 7\n\n10 -5 1 50 1 100 -1 9\t\n\n-100 -10 -50 1 5 1 9\n\t\n10 10 5 10 50 100 1",
        "output": "1"
      }
    ]
  },
  {
    "id": 487,
    "name": "Игра \"Баше\"",
    "description": "Студент и профессор играют в игру «Баше» по следующим правилам. \nOUTPUT.TXTF\nF\nT\n[Лучшие попытки]\nНа столе лежат N экзаменационных билетов. Игроки делают ходы поочередно, и в свой ход каждый из игроков может взять от 1 до K билетов. Выигрывает тот игрок, который возьмет билет, оставшийся последним. Т.е. если его возьмет студент, то он получит «зачет», иначе он получит «незачет».\nБудем называть сделанный ход ошибочным, если в этой ситуации можно было сходить иначе, гарантируя себе в дальнейшем выигрыш независимо от игры соперника. Будем называть ход правильным (или допустимым), если он не является ошибочным.\nВаша задача – проанализировать уже сыгранную партию и указать для каждого хода, был ли он правильным или ошибочным.\nВходные данные\nВ первой строке входного файла INPUT.TXT записаны три целых числа: N, K, P (2 ≤ N  ≤ 10000, 2 ≤ K ≤ 100, 2 ≤ P). Здесь P – количество ходов, которые сделали студент и профессор. В последующих P строках записаны числа (по одному числу на строке) в диапазоне от 1 до K.\nВыходные данные\nВыходной файл OUTPUT.TXT должен содержать P строк по одному символу на строке:  «T» (правильный или допустимый ход – от слова True) или «F» (неверный ход – от слова False).",
    "complexity": 49,
    "memory": 16000,
    "time": 1000,
    "examples": [
      {
        "input": "10 5 3\n\n3\n\n3\n\n4",
        "output": "F\n\nF\n\nT"
      }
    ]
  },
  {
    "id": 486,
    "name": "Рыбаки - 2",
    "description": "Однажды N рыбаков отправились на рыбалку, где поймали X рыб. После этого рыбаки легли спать. Утром, просыпаясь друг за другом, каждый из них делил выловленную рыбу на N частей. Каждый раз в остатке оставалось ровно K рыб (0 \u003c K \u003c N). Эти K рыб выбрасывались обратно в море. Рыбак забирал свою часть улова и отбывал домой, не зная ничего о том, поступал ли уже кто-либо из остальных рыбаков таким же образом.\nOUTPUT.TXT2524 3247247[Лучшие попытки]\nВаша задача – определите при заданных N и K минимально возможное целое положительное значение X – число рыб, удовлетворяющее условию задачи.\nВходные данные\nВходной файл INPUT.TXT содержит два целых числа N и K, разделенные пробелом (2 ≤ N ≤ 15, 0 \u003c K \u003c N).\nВыходные данные\nВыходной файл OUTPUT.TXT должен содержать одно целое положительное число X – наименьшее возможное количество выловленной рыбаками рыбы.",
    "complexity": 53,
    "memory": 16000,
    "time": 1000,
    "examples": [
      {
        "input": "3 1",
        "output": "25"
      },
      {
        "input": "4 3",
        "output": "247"
      }
    ]
  },
  {
    "id": 518,
    "name": "Количество путей в лабиринте",
    "description": "Карта лабиринта представляет собой квадратное поле размером N×N. Некоторые квадраты этого поля запрещены для прохождения. Шаг в лабиринте – перемещение из одной разрешенной клетки к другой разрешенной клетке, смежной с первой по стороне. Путь – это некоторая последовательность таких шагов. При этом каждую клетку, включая начальную и конечную, можно посещать несколько раз.\nOUTPUT.TXT522 8\n01\n1000[Лучшие попытки]\nТребуется написать программу, которая подсчитает количество различных путей из клетки (1, 1) в клетку (N, N) ровно за K шагов (то есть оказаться в клетке (N, N) после K-го шага).\n[Решение]\nВходные данные\nВходной файл INPUT.TXT содержит в первой строке числа N и K, разделенные пробелом (1 \u003c N ≤ 15, 0 \u003c K ≤ 30). Следующие N строк, по N символов в каждой, содержат карту лабиринта, начиная с клетки (1, 1). Символ «0» означает не запрещенную для прохождения клетку, а символ «1» - запрещенную. Начальная и конечная клетки всегда разрешены для прохождения.\nВыходные данные\nВыходной файл OUTPUT.TXT должен содержать количество возможных различных путей длины K. Во всех тестах это значение не будет превышать 2147483647.",
    "complexity": 38,
    "memory": 16000,
    "time": 1000,
    "examples": [
      {
        "input": "3 6\n\n000\n\n101\n\n100",
        "output": "5"
      },
      {
        "input": "2 8\n\n01\n\n10",
        "output": "0"
      }
    ]
  },
  {
    "id": 517,
    "name": "Боулинг",
    "description": "Цель при игре в боулинг – сбить шаром максимальное количество кеглей. Партия в этой игре состоит из 10 туров. Задача игрока – сбить все 10 кеглей в каждом туре. Для этого игрок может совершить 2 броска шара, за исключением:\nOUTPUT.TXT300220\n0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 000173[Лучшие попытки]\nесли 10 кеглей сбиты первым броском, то второй бросок не совершается;\nесли 10 кеглей сбиты первым броском в десятом туре, то игроку предоставляются два призовых броска, а если двумя бросками – один. Призовые броски являются частью десятого тура.\n315\n10 10 10 8 2 10 3 4 8 2 4 5 10 4 5173[Решение]\nКоличество очков в каждом туре равно количеству сбитых кеглей, кроме двух бросков, называемых «Strike» и «Spare».\nStrike: игрок сбивает 10 кеглей первым броском, очки в этом туре начисляются из расчета – 10 + сумма очков за два последующих броска.\nSpare: игрок сбивает 10 кеглей двумя бросками, очки в этом туре начисляются из расчета – 10 + сумма очков за один последующий бросок.\nРезультат партии складывается из результатов всех 10 туров.\nТребуется написать программу, которая определит количество набранных игроком очков.\nВходные данные\nВходной файл INPUT.TXT содержит в первой строке одно натуральное число, определяющее количество совершенных бросков. Вторая строка содержит натуральные числа (разделенные пробелом), обозначающие количество сбитых кеглей за каждый совершенный бросок.\nВыходные данные\nВыходной файл OUTPUT.TXT должен содержать одно целое число – количество набранных игроком очков.",
    "complexity": 29,
    "memory": 16000,
    "time": 1000,
    "examples": [
      {
        "input": "12\n\n10 10 10 10 10 10 10 10 10 10 10 10",
        "output": "300"
      },
      {
        "input": "20\n\n0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0",
        "output": "0"
      },
      {
        "input": "15\n\n10 10 10 8 2 10 3 4 8 2 4 5 10 4 5",
        "output": "173"
      }
    ]
  },
  {
    "id": 515,
    "name": "Ловушки",
    "description": "Далеко не все в Тентуре имеют право носить малиновые штаны, и конечно, не все владеют пепелацем с гравицапой, зато один предприимчивый чатланин поставил несколько ловушек, захватывающих отваливающиеся детали с пролетающих мимо инопланетных кораблей. Каждое утро он их обходит, в надежде, что рано или поздно из этих запчастей ему удастся собрать какое-нибудь транспортное средство. Путь свой чатланин планирует по карте, на которой аккуратно отмечены ловушки, отсчитывая начало координат от собственного дома. Начинается обход от дома, и в нем же и заканчивается. \nOUTPUT.TXT2.000221 01 13.4143.4144.000[Лучшие попытки]\nТребуется определить, какое расстояние проходит  чатланин за день.\n331 01 10 14.000\nВходные данные\nВ первой строке входного файла INPUT.TXT находится натуральное число N – количество ловушек, установленных чатланином (N ≤ 10), далее следуют N строк формата «X Y», описывающих координаты ловушек в порядке их обхода (-10 ≤ X,Y ≤ 10; X,Y – целые числа).\nВыходные данные\nВ выходной файл OUTPUT.TXT выведите общее расстояние, которое пройдет чатланин, обойдя все ловушки в приведенном порядке и вернувшись в начало координат от последней ловушки, с точностью до трех знаков после запятой.",
    "complexity": 24,
    "memory": 16000,
    "time": 1000,
    "examples": [
      {
        "input": "1\n1 0",
        "output": "2.000"
      },
      {
        "input": "2\n1 0\n1 1",
        "output": "3.414"
      },
      {
        "input": "3\n1 0\n1 1\n0 1",
        "output": "4.000"
      }
    ]
  },
  {
    "id": 491,
    "name": "Антипалиндром",
    "description": "Палиндромом называют строку, читающуюся одинаково с обеих сторон. Задана строка s. Найдите ее наибольшую по длине подстроку, не являющуюся палиндромом.\nOUTPUT.TXTabb2abcabcabcNO SOLUTION[Лучшие попытки]\nВходные данные3aaaaaNO SOLUTION\nВходной файл INPUT.TXT содержит строку s. Она состоит только из строчных букв английского алфавита, не пуста, а ее длина не превышает 100 000 символов.\nВыходные данные\nВ выходной файл OUTPUT.TXT выведите ответ на задачу. Если все подстроки s являются палиндромами, выведите в выходной файл NO SOLUTION.",
    "complexity": 28,
    "memory": 16000,
    "time": 1000,
    "examples": [
      {
        "input": "abba",
        "output": "abb"
      },
      {
        "input": "abc",
        "output": "abc"
      },
      {
        "input": "aaaaa",
        "output": "NO SOLUTION"
      }
    ]
  },
  {
    "id": 488,
    "name": "Праздничный торт",
    "description": "На дне рождения Пети на стол подали круглый торт, украшенный разноцветными розочками. Причем, на торте было ровно по две небольших розочки каждого цвета, а различных цветов было ровно K. Тем самым, общее число розочек было равно 2*K.\n2OUTPUT.TXT225 31 4 1 -3-3.5 0 4 1.5-3 3 0 -466[Лучшие попытки]\nОдноклассник Пети Вася, славящийся своими математическими способностями, разрезал торт прямолинейными разрезами так, что каждый разрез прошел через две розочки одинакового цвета. (Понятно, что таких разрезов оказалось ровно K.)\n2\nПри этом оказалось, что:\nникакие три разреза не прошли через одну точку, \nникакие два разреза не совпали и не оказались параллельными.\nНапишите программу, которая по заданному радиусу торта, и координатам розочек определяет, на сколько частей был разделен торт.\nВходные данные\nВ первой строке входного файла INPUT.TXT содержатся два числа: действительное число R (радиус торта) и целое число K – количество различных цветов (1 ≤ K ≤ 100). В каждой из последующих K строк записано по четыре числа, разделенных пробелами: X1, Y1, X2, Y2 – координаты двух розочек каждого цвета. Центр торта находится в начале координат. Радиус торта и координаты розочек – действительные числа, не превышающие по абсолютной величине 100 и содержащие не более 6 цифр после запятой.\nВыходные данные\nВ выходной файл OUTPUT.TXT выведите целое число – количество частей, на которые был разрезан торт.",
    "complexity": 58,
    "memory": 16000,
    "time": 1000,
    "examples": [
      {
        "input": "3 1\n-1 -1 1 1",
        "output": "2"
      },
      {
        "input": "5 3\n1 4 1 -3\n-3.5 0 4 1.5\n-3 3 0 -4",
        "output": "6"
      }
    ]
  },
  {
    "id": 490,
    "name": "Дни рождения",
    "description": "Два одноклассника Петя и Вася родились не ранее 1993 и не позднее 1994 года, причем, Петя старше Васи.\nOUTPUT.TXT1205.02.9405.03.942828[Лучшие попытки]\nНапишите программу, которая по заданным дням рождения определяет: на сколько дней Петя старше Васи.\nЗаметим, что 1993 и 1994 года не являются високосными, т.е. в феврале в них ровно 28 дней.\nВходные данные\nВходной файл INPUT.TXT содержит дату рождения Пети в первой строке и дату рождения Васи во второй. Даты заданы в формате «ДД.ММ.ГГ», например, строка 06.02.93 означает дату рождения 6 февраля 1993 года.\nВыходные данные\nВ выходной файл OUTPUT.TXT выведите единственное число – искомое количество дней.",
    "complexity": 27,
    "memory": 16000,
    "time": 1000,
    "examples": [
      {
        "input": "01.01.93\n02.01.93",
        "output": "1"
      },
      {
        "input": "05.02.94\n05.03.94",
        "output": "28"
      }
    ]
  },
  {
    "id": 466,
    "name": "Функция",
    "description": "Функция f(n) определена следующим образом: \nOUTPUT.TXT12533[Лучшие попытки]\nf(0)=0, f(1)=1, f(2n)=f(n), f(2n+1)=f(n)+f(n+1).\nТребуется написать программу, которая по заданному натуральному числу N определяет значение функции f(N).\nВходные данные\nВходной файл INPUT.TXT содержит число N (1 ≤ N ≤ 2147483647).\nВыходные данные\nВ выходной файл OUTPUT.TXT выведите значение f(N).",
    "complexity": 42,
    "memory": 16000,
    "time": 1000,
    "examples": [
      {
        "input": "2",
        "output": "1"
      },
      {
        "input": "5",
        "output": "3"
      }
    ]
  },
  {
    "id": 463,
    "name": "Остаток",
    "description": "Дано натуральное число n в k-ичной системе счисления. \nOUTPUT.TXT1216 357DF992323[Лучшие попытки]\nТребуется написать программу, которая находит остаток от деления этого числа на заданное натуральное число m.\nВходные данные\nВходной файл INPUT.TXT содержит в первой строке натуральные числа k и m  (2 ≤ k ≤ 36, m ≤ 32767), записанные через пробел. Во второй строке задается натуральное число n в k-ой системе счисления, состоящее не более чем из 10000 цифр. Числа k и m записываются в десятичной системе счисления. Для записи цифр числа в системе счисления с основанием, большим 10, используются английские заглавные буквы (10 – A, 11 – B, …, 35 – Z).\nВыходные данные\nВ выходной файл OUTPUT.TXT выведите искомое число, записанное в десятичной системе счисления.",
    "complexity": 44,
    "memory": 16000,
    "time": 1000,
    "examples": [
      {
        "input": "10 2\n17",
        "output": "1"
      },
      {
        "input": "16 35\n7DF99",
        "output": "23"
      }
    ]
  },
  {
    "id": 584,
    "name": "Спираль - 2",
    "description": "OUTPUT.TXT31\nf 6\nr\nf 7\nr\nf 6\nr\nf 5\nr\nf 4\nr\nf 3\nr\nf 2\nr\nf 1\nr\nf 1\nl\nf 1\nl\nf 2\nl\nf 3\nl\nf 4\nl\nf 5\nl\nf 5\nr\nf 1[Лучшие попытки]\nПри обучении школьников младших классов программированию часто используется язык «Лого», позволяющий рисовать на экране картинки хвостом виртуальной черепашки.\nРассмотрим упрощенную версию этого языка, в которой разрешается подавать черепашке следующие команды: переместиться вперед на некоторое количество сантиметров, рисуя за собой линию, повернуть налево на 90 градусов и повернуть направо на 90 градусов.\nВам предлагается написать на этом языке программу, изображающую контур спирали.\nСпираль - это множество клеток, которое строится по следующим правилам. Рассмотрим прямоугольник, состоящий из m×n единичных клеток. Закрасим некоторые из его клеток в следующей последовательности.\nНачнем красить левый столбец снизу вверх. Когда продвижение невозможно, то есть либо следующая клетка лежит вне прямоугольника, либо соприкасается с закрашенной ранее, направление движения поворачивается по часовой стрелке на 90 градусов. Если и после этого поворота дальнейшее движение невозможно, процесс заканчивается. Множество закрашенных таким образом клеток и образует спираль.\nВходные данные\nВходной файл INPUT.TXT содержит два целых числа m и n (1 ≤ m, n ≤ 20 000).\nВыходные данные\nВ выходной файл OUTPUT.TXT выведите последовательность команд, в результате выполнения которой будет нарисован контур ломаной. Напомним формат, в котором следует выводить результат. Первая строка должна содержать k - количество команд. Последующие k строк задают либо длину отрезка d, который надо провести, в формате f d, либо направление поворота - l для поворота налево и r для поворота направо. Команды рисования отрезка и поворота должны чередоваться, начинаясь и заканчиваясь командой рисования отрезка. Считайте, что начало первого отрезка совпадает с левым нижним углом прямоугольника. При этом контур должен быть выведен в направлении обхода по часовой стрелке, и никакая его часть ненулевой длины не должна быть нарисована дважды.",
    "complexity": 59,
    "memory": 16000,
    "time": 1000,
    "examples": [
      {
        "input": "6 7",
        "output": "31\n\nf 6\n\nr\n\nf 7\n\nr\n\nf 6\n\nr\n\nf 5\n\nr\n\nf 4\n\nr\n\nf 3\n\nr\n\nf 2\n\nr\n\nf 1\n\nr\n\nf 1\n\nl\n\nf 1\n\nl\n\nf 2\n\nl\n\nf 3\n\nl\n\nf 4\n\nl\n\nf 5\n\nl\n\nf 5\n\nr\n\nf 1"
      }
    ]
  },
  {
    "id": 364,
    "name": "Совершенные числа",
    "description": "Число называется совершенным, если оно равно сумме всех своих делителей, меньших его самого. Требуется найти все совершенные числа от M до N.\nOUTPUT.TXT624 5AbsentAbsent628[Лучшие попытки]\nВходные данные35 30628\nВходной файл INPUT.TXT содержит числа M и N, разделенные пробелом. (1 ≤ M ≤ N ≤ 5*1018)\nВыходные данные\nВ выходной файл OUTPUT.TXT выведите по одному числу в строке в порядке возрастания все совершенные числа, находящихся на отрезке [M, N]. В том случае, когда таких чисел нет следует вывести «Absent».",
    "complexity": 51,
    "memory": 16000,
    "time": 1000,
    "examples": [
      {
        "input": "6 6",
        "output": "6"
      },
      {
        "input": "4 5",
        "output": "Absent"
      },
      {
        "input": "5 30",
        "output": "6\n28"
      }
    ]
  },
  {
    "id": 462,
    "name": "Числа",
    "description": "Задано натуральное число N. Требуется написать программу, которая находит количество натуральных чисел, не превышающих N и не делящихся ни на одно из чисел 2, 3, 5.\nOUTPUT.TXT222066[Лучшие попытки]\nВходные данные\nВходной файл INPUT.TXT содержит число N (1 ≤ N ≤ 109).\nВыходные данные\nВ выходной файл OUTPUT.TXT выведите ответ на задачу.",
    "complexity": 36,
    "memory": 16000,
    "time": 1000,
    "examples": [
      {
        "input": "10",
        "output": "2"
      },
      {
        "input": "20",
        "output": "6"
      }
    ]
  },
  {
    "id": 465,
    "name": "Последовательности из 0 и 1",
    "description": "Рассмотрим последовательности длины N, состоящие из 0 и 1. Требуется написать программу, которая по заданному натуральному числу N определяет количество тех из них, в которых никакие две единицы не стоят рядом.\nOUTPUT.TXT32355[Лучшие попытки]\nВходные данные\nВходной файл INPUT.TXT содержит число N (1 ≤ N ≤ 1000).\nВыходные данные\nВ выходной файл OUTPUT.TXT выведите ответ на задачу.",
    "complexity": 47,
    "memory": 16000,
    "time": 1000,
    "examples": [
      {
        "input": "2",
        "output": "3"
      },
      {
        "input": "3",
        "output": "5"
      }
    ]
  },
  {
    "id": 464,
    "name": "Число в последовательности",
    "description": "Последовательность 011212201220200112… строится следующим образом: сначала пишется 0, затем повторяется следующее действие: уже написанную часть приписывают справа с заменой 0 на 1, 1 на 2, 2 на 0, и т.д.\nOUTPUT.TXT021022[Лучшие попытки]\nТребуется написать программу, которая по заданному натуральному числу N определяет, какое число стоит на N-ом месте.\nВходные данные\nВходной файл INPUT.TXT содержит число N (1 ≤ N ≤ 2147483647).\nВыходные данные\nВыходной файл OUTPUT.TXT должен содержать одно искомое число.",
    "complexity": 35,
    "memory": 16000,
    "time": 1000,
    "examples": [
      {
        "input": "1",
        "output": "0"
      },
      {
        "input": "10",
        "output": "2"
      }
    ]
  },
  {
    "id": 551,
    "name": "Заяц и дерево",
    "description": "OUTPUT.TXTYES[Лучшие попытки]\nПосле строительства на выбранной поляне частокола для обороны от хищников Заяц обнаружил, что внутри ограды оказалось огромное засохшее дерево, которое может помешать строительству домика. Зайцу хочется спилить это дерево “под самый корешок” таким образом, чтобы дерево при падении не повредило ограду.\nЗаяц обрубил все ветки, и от дерева остался цилиндр высотой h и радиусом r. Ограда имеет форму окружности с радиусом R и по высоте больше диаметра дерева. Центр дерева находится на расстоянии b от центра ограды. Заяц может повалить дерево в любую нужную ему сторону. После падения нижний край поваленного дерева касается (как касательная) окружности основания дерева, как показано на рисунке.\nТребуется написать программу, которая определит, сможет ли заяц повалить спиленное дерево, не повредив ограду.\nВходные данные\nВ единственной строке входного файла INPUT.TXT записано четыре целых числа через один пробел: R, r, h и b (r+b \u003c R, 1 ≤ r ≤ R ≤ 100, 1 ≤ h ≤ 1000).\nВыходные данные\nВ выходной файл OUTPUT.TXT нужно вывести слово YES, если существует направление падения дерева, при котором ограда останется неповрежденной, и NO в противном случае.",
    "complexity": 29,
    "memory": 16000,
    "time": 1000,
    "examples": [
      {
        "input": "90 3 50 10",
        "output": "YES"
      }
    ]
  },
  {
    "id": 550,
    "name": "День программиста",
    "description": "День программиста отмечается в 255-й день года (при этом 1 января считается нулевым днем).\nТребуется написать программу, которая определит дату (месяц и число григорианского календаря), на которую приходится День программиста в заданном году.\nOUTPUT.TXT12/09/20002200913/09/200913/09/2009[Лучшие попытки]\nВ григорианском календаре високосным является:\n[Решение]\nгод, номер которого делится нацело на 400\nгод, номер которого делится на 4, но не делится на 100\nВходные данные\nВ единственной строке входного файла INPUT.TXT записано целое число от 1 до 9999 включительно, которое обозначает номер года нашей эры.\nВыходные данные\nВ единственную строку выходного файла OUTPUT.TXT нужно вывести дату Дня программиста в формате DD/MM/YYYY, где DD — число, MM — номер месяца (01 — январь, 02 — февраль, ..., 12 — декабрь), YYYY — год в десятичной записи.",
    "complexity": 13,
    "memory": 16000,
    "time": 1000,
    "examples": [
      {
        "input": "2000",
        "output": "12/09/2000"
      },
      {
        "input": "2009",
        "output": "13/09/2009"
      }
    ]
  },
  {
    "id": 502,
    "name": "Лягушонок",
    "description": "Многие, вероятно, слышали песни про приключения лягушонка Crazy Frog. На этот раз неугомонное милое создание решило подкрепиться, но даже такое простое действие решило выполнить в виде игры. Итак, в каждой клетке квадратного игрового поля, разбитого на N×N (N ≤ 50) клеток, находится один комар весом aij (вес комара – натуральное число ≤ 50), i - номер строки, j - номер столбца. Лягушонок, прыгая с клетки на клетку, ест комаров. Правила игры таковы - в каждом столбце можно съесть не более одного комара. Всякий раз при съедании комара запоминаем номер строки, откуда съеден комар, и сумма номеров строк, в которых были съедены комары, в конце игры должна быть в точности равна N. Учтите, если из какой-то строки съедено несколько комаров, то номер данной строки участвует в суммировании более одного раза.\nOUTPUT.TXT1425\n8 2 1 2 3\n1 2 6 2 4\n2 7 2 3 4\n1 3 2 4 4\n1 3 4 3 1\n1919[Лучшие попытки]\nОпределите максимальный вес комаров, который можно съесть при следовании приведённым правилам.\nВходные данные\nПервая строка входного файла INPUT.TXT содержит число N. Следующие N строк содержат по N чисел aij, разделенных пробелами.\nВыходные данные\nВ выходной файл OUTPUT.TXT выведите целое число – вес съеденных комаров.",
    "complexity": 39,
    "memory": 16000,
    "time": 1000,
    "examples": [
      {
        "input": "3\n8 2 1\n1 2 6\n2 7 2",
        "output": "14"
      },
      {
        "input": "5\n\n8 2 1 2 3\n\n1 2 6 2 4\n\n2 7 2 3 4\n\n1 3 2 4 4\n\n1 3 4 3 1",
        "output": "19"
      }
    ]
  },
  {
    "id": 552,
    "name": "Зоопарк",
    "description": "Выходные данные\nВыходной текстовый файл OUTPUT.TXT должен содержать одно число – количество способов выбрать трех животных для международной выставки.",
    "complexity": 45,
    "memory": 16000,
    "time": 1000,
    "examples": [
      {
        "input": "4\n2 1 1 1",
        "output": "7"
      },
      {
        "input": "3\n100 100 100",
        "output": "1000000"
      }
    ]
  },
  {
    "id": 553,
    "name": "Объединение блоков",
    "description": "",
    "complexity": 46,
    "memory": 16000,
    "time": 1000,
    "examples": [
      {
        "input": "3\n34 29\n29 4\n4 15",
        "output": "646"
      }
    ]
  },
  {
    "id": 494,
    "name": "Отрезок и окружности",
    "description": "На плоскости задана система концентрических окружностей, центры которых находятся в начале координат, а радиусы равны 1, 2, 3, . . .  . Также на плоскости задан отрезок, концы которого находятся в точках (x1, y1) и (x2, y2).\nOUTPUT.TXT121 2 2 100[Лучшие попытки]\nНеобходимо найти число общих точек этого отрезка и указанной системы окружностей.\n[Решение]\nВходные данные\nВходной файл INPUT.TXT содержит четыре целых числа: x1, y1, x2 и y2. Эти числа не превосходят 103 по абсолютной величине. Заданный отрезок имеет ненулевую длину.\nВыходные данные\nВ выходной файл OUTPUT.TXT выведите одно целое число – количество общих точек.",
    "complexity": 58,
    "memory": 16000,
    "time": 1000,
    "examples": [
      {
        "input": "1 1 2 1",
        "output": "1"
      },
      {
        "input": "1 2 2 1",
        "output": "0"
      }
    ]
  },
  {
    "id": 493,
    "name": "Морской бой - 2",
    "description": "«Морской бой» - игра для двух участников, в которой игроки по очереди называют координаты на неизвестной им карте соперника. Если у соперника по этим координатам имеется корабль, то корабль или его часть «топится», а попавший получает право сделать еще один ход. Цель игрока - первым поразить все корабли противника.\nOUTPUT.TXT424 3\n***\n...\n...\n***\n00[Лучшие попытки]\n«Морской бой» очень популярен среди учеников одной физико-математической школы. Ребята очень любят в него играть на переменах. Вот и сейчас ученики Иннокентий и Емельян начали новую партию.\nПравила, по которым ребята расставляют корабли перед началом партии, несколько отличаются от классических. Во-первых, игра происходит на поле размером N×M, а не 10×10. Во-вторых, число кораблей, их размер и форма выбираются ребятами перед партией - так играть намного интереснее.\nЕмельян уже расставил все свои корабли, кроме одного однопалубного. Такой корабль занимает ровно одну клетку.\nЗадана расстановка кораблей Емельяна. Найдите число способов поставить оставшийся однопалубный корабль. При этом учитывайте, что по правилам его можно ставить только в ту клетку, все соседние с которой не заняты. В этой задаче соседними считаются клетки, имеющие общую сторону.\nВходные данные\nПервая строка входного файла INPUT.TXT содержит два числа: N и M (1 ≤ N, M ≤ 100). Последующие N строк описывают игровое поле - каждая из них содержит M символов. Символом «.» (точка) обозначена свободная клетка, символом «*» (звездочка) - занятая кораблем.\nВыходные данные\nВ выходной файл OUTPUT.TXT выведите ответ на задачу.",
    "complexity": 21,
    "memory": 16000,
    "time": 1000,
    "examples": [
      {
        "input": "4 4\n\n****\n\n**..\n\n*...\n\n*...",
        "output": "4"
      },
      {
        "input": "4 3\n\n***\n\n...\n\n...\n\n***",
        "output": "0"
      }
    ]
  },
  {
    "id": 519,
    "name": "Наименьшее и наибольшее числа из тех же цифр",
    "description": "Требуется написать программу, которая найдет наименьшее и наибольшее числа, состоящие из тех же цифр, что и заданное натуральное число N.\nOUTPUT.TXT1057 75102851158 851158 851[Лучшие попытки]\nВходные данные\nВходной файл INPUT.TXT содержит натуральное число N (N ≤ 2×109).\nВыходные данные\nВыходной файл OUTPUT.TXT должен содержать в одной строке наименьшее, а через пробел – наибольшее числа.",
    "complexity": 23,
    "memory": 16000,
    "time": 1000,
    "examples": [
      {
        "input": "7051",
        "output": "1057 7510"
      },
      {
        "input": "851",
        "output": "158 851"
      }
    ]
  },
  {
    "id": 522,
    "name": "Похожие массивы",
    "description": "Два массива называются похожими, если совпадают множества чисел, встречающихся в этих массивах.\nOUTPUT.TXT122 3\n1 2\n2 3 100[Лучшие попытки]\nТребуется написать программу, которая определит: похожи ли два заданных массива.\nВходные данные\nВходной файл INPUT.TXT содержит в первой строке два числа M и N - длины массивов (1 ≤ M, N ≤ 16000). Во второй строке записаны M чисел – элементы первого массива. В третьей строке записаны N чисел – элементы второго массива. Числа в строках разделены пробелами, элементы массивов - целые числа, не превышающие 32000 по абсолютной величине.\nВыходные данные\nВыходной файл OUTPUT.TXT должен содержать 1, если массивы похожи и 0 иначе.",
    "complexity": 25,
    "memory": 16000,
    "time": 1000,
    "examples": [
      {
        "input": "4 3\n\n1 2 3 2\n\n1 2 3",
        "output": "1"
      },
      {
        "input": "2 3\n\n1 2\n\n2 3 1",
        "output": "0"
      }
    ]
  },
  {
    "id": 495,
    "name": "Двойственная ломаная",
    "description": "Пусть задана некоторая замкнутая ломаная P. Двойственной для P ломаной называется ломаная, вершины которой находятся в серединах звеньев P.\niOUTPUT.TXT424\n0 0\n1 0\n1 1\n0 1\n1\n2.82842712472.8284271247[Лучшие попытки]\nОпределим понятие двойственной для P ломаной k-ого порядка dual(P, K) следующим образом:\ni\nдвойственной ломаной нулевого порядка является сама ломаная P (dual(P, 0) = P);\n  если K \u003e 0, то двойственной ломаной K-ого порядка является ломаная, двойственная для dual(P, K - 1).\n5\nЗадана замкнутая ломаная P и число K. Найдите длину двойственной для P ломаной k-ого порядка dual(P, K).\nВходные данные\nВходной файл INPUT.TXT содержит число звеньев исходной ломаной N (3 ≤ N ≤ 100). Каждая из последующих N строк содержит по два целых числа xi и yi - координаты i-ой вершины ломаной. Все xi и yi не превосходят 105 по абсолютной величине. Последняя строка входного файла содержит целое число K (0 ≤ K ≤ 10).\nВыходные данные\nВ выходной файл OUTPUT.TXT выведите искомую длину с точностью не хуже, чем 10-4.",
    "complexity": 35,
    "memory": 16000,
    "time": 1000,
    "examples": [
      {
        "input": "4\n\n0 0\n\n1 0\n\n1 1\n\n0 1\n\n0",
        "output": "4"
      },
      {
        "input": "4\n\n0 0\n\n1 0\n\n1 1\n\n0 1\n\n1",
        "output": "2.8284271247"
      }
    ]
  },
  {
    "id": 520,
    "name": "Оптовая покупка",
    "description": "Пара носков стоит 10 руб. 50 коп., связка (12 пар) стоит 102 руб. 50 коп., а коробка (12 связок) стоит 1140 руб.\nOUTPUT.TXT0 1 025003 5 83 5 8[Лучшие попытки]\nТребуется написать программу, которая по числу пар носков, которые хочет купить покупатель, вычисляет количества коробок, связок и пар носков, которые ему следует купить с наибольшей выгодой.\nВходные данные\nВходной файл INPUT.TXT содержит натуральное число N (N ≤ 109) – число пар носков, которые желает купить покупатель.\nВыходные данные\nВыходной файл OUTPUT.TXT должен содержать три числа (первое – количество коробок, второе – связок, третье – пар носков), разделенные пробелами.",
    "complexity": 27,
    "memory": 16000,
    "time": 1000,
    "examples": [
      {
        "input": "11",
        "output": "0 1 0"
      },
      {
        "input": "500",
        "output": "3 5 8"
      }
    ]
  },
  {
    "id": 521,
    "name": "Пасьянс старухи Шапокляк",
    "description": "На столе лежат колоды игральных карт. В самой тоненькой колоде – p карт, во второй – p+1, в третьей – p+2, …, в последней – k карт. Старуха Шапокляк раскладывает пасьянс. Беря в руки любую из колод, она, если число карт в ней четное, на место возвращает колоду, наполовину уменьшив число карт в ней (лишние убирает в ящик), а если количество карт в колоде нечетное, то утраивает их количество и добавляет еще одну карту, а уже тогда кладет колоду на стол (карт у нее в ящике для этой операции достаточно). Если в какой-то колоде остается две карты, она больше ее не трогает. Пасьянс сходится, если во всех колодах остается по две карты.\nOUTPUT.TXT625 82828[Лучшие попытки]\nТребуется написать программу, которая определит сходится ли пасьянс, и если сходится – сколько раз должна старуха Шапокляк брать со стола карты.\nВходные данные\nВходной файл INPUT.TXT содержит 2 числа, записанные через пробел (2 ≤ p \u003c k \u003c 1000).\nВыходные данные\nВыходной файл OUTPUT.TXT должен содержать 0, если пасьянс не сходится, и, если сходится, количество «ходов» старухи Шапокляк.",
    "complexity": 25,
    "memory": 16000,
    "time": 1000,
    "examples": [
      {
        "input": "2 3",
        "output": "6"
      },
      {
        "input": "5 8",
        "output": "28"
      }
    ]
  },
  {
    "id": 554,
    "name": "Пицца",
    "description": "Пицца – любимое лакомство Васи, он постоянно покупает и с удовольствием употребляет различные сорта этого великолепного блюда. Однажды, в очередной раз, разрезая круглую пиццу на несколько частей, Вася задумался: на какое максимальное количество частей можно разрезать пиццу за N прямых разрезов?\nOUTPUT.TXT42377[Лучшие попытки]\nПомогите Васе решить эту задачу, определив максимальное число не обязательно равных кусков, которые может получить Вася, разрезая пиццу таким образом.\n[Решение]\nВходные данные\nВходной файл INPUT.TXT содержит натуральное число N – число прямых разрезов пиццы (N ≤ 1000).\nВыходные данные\nВ выходной файл OUTPUT.TXT выведите ответ на задачу.",
    "complexity": 20,
    "memory": 16000,
    "time": 1000,
    "examples": [
      {
        "input": "2",
        "output": "4"
      },
      {
        "input": "3",
        "output": "7"
      }
    ]
  },
  {
    "id": 555,
    "name": "Вычисление сложности программы",
    "description": "Аня решила стать чемпионкой мира по программированию. Для этого ей, кроме всего прочего, потребовалось научиться вычислять время работы программ. Во многих программах основное время работы занимают вложенные циклы. Поэтому Аня хочет научиться узнавать, сколько операций будет выполнено внутри последовательности вложенных циклов.\niOUTPUT.TXT5050224 6-1 30003567587328[Лучшие попытки]\nПока Аня еще только учится, поэтому все программы выглядят как последовательность вложенных циклов, причем все циклы выполняются от некоторого числа или переменной до некоторого другого числа. Ей требуется найти, сколько раз будет выполнена операция внутри самого вложенного цикла. Для этого она создала счетчик, проинициализировала его нулем, и увеличивает его на единицу каждый раз, входя в самый вложенный цикл.\ni341 2561 2561 2561 2560\nЗаметьте, что Аня пока не знает, что в качестве верхней границы в цикле может служить переменная. В качестве нижней границы может выступать как переменная, так и фиксированное значение. Если в каком-то цикле левая граница больше, чем правая, то цикл не будет выполняться вообще.\ni441 10001 10001 10001 10003567587328\nТак как программы у Ани иногда работают очень долго, то она попросила своего друга узнать ответ, когда же и он не смог этого посчитать, она попросила об этом вас. Помогите ей.\ni\nНапишите программу, которая находит, какое значение будет в счетчике в конце работы Аниной программы, если счетчик хранился в переменной целого 32-битного беззнакового типа.\ni\nВходные данные\nВ первой строке входного файла INPUT.TXT находится число 1 ≤ N ≤ 3 000 - количество циклов. Далее в N строках написано по два целых числа в каждой. В (i+1)-й строке входного файла записаны левая и правая граница i-го цикла: Li и Ri (1-i ≤ Li ≤ 3 000, 0 ≤ Ri ≤ 3 000). При этом если Li \u003c 0, то это обозначает, что цикл начинается со значения переменной (-Li)-го цикла, в противном случае цикл начинается со значения Li.\nВыходные данные\nВ выходной файл OUTPUT.TXT выведите значение, которое будет в счетчике в конце работы программы.",
    "complexity": 76,
    "memory": 64000,
    "time": 1000,
    "examples": [
      {
        "input": "2\n1 100\n-1 100",
        "output": "5050"
      },
      {
        "input": "2\n4 6\n-1 3",
        "output": "0"
      },
      {
        "input": "4\n1 256\n1 256\n1 256\n1 256",
        "output": "0"
      },
      {
        "input": "4\n1 1000\n1 1000\n1 1000\n1 1000",
        "output": "3567587328"
      }
    ]
  },
  {
    "id": 349,
    "name": "Простые числа",
    "description": "Необходимо вывести все простые числа от M до N включительно.\nOUTPUT.TXT23524 4AbsentAbsent[Лучшие попытки]\nВходные данные[Решение]\nВходной файл INPUT.TXT содержит два натуральных числа M и N, разделенных пробелом (2 ≤ M ≤ N ≤ 106)\nВыходные данные\nВ выходной файл OUTPUT.TXT выведите все простые числа от M до N в порядке возрастания, по одному в строке. Если таковых чисел нет, то следует вывести «Absent».",
    "complexity": 28,
    "memory": 64000,
    "time": 1000,
    "examples": [
      {
        "input": "2 5",
        "output": "2\n3\n5"
      },
      {
        "input": "4 4",
        "output": "Absent"
      }
    ]
  },
  {
    "id": 556,
    "name": "Есть ли жизнь на Марсе?",
    "description": "- Ты врешь, Коля! На Марсе жизни нет! Кто тебе такую чушь сказал?\ni23nOUTPUT.TXT0.18[Лучшие попытки]\n- Петя. А ему сказал Саша.\ni31i\n- Да от Пети я в жизни правдивого слова не слышал! Ему что ни скажут, он все переврет. Да и Саше откуда знать?\n12\n- А Саше рассказал про это Владимир Алексеевич, наш учитель биологии.\n23\n- Ну, Владимиру Алексеевичу-то можно верить... Только вряд ли он так сказал, это либо Саша, либо Петя придумал. А может, это ты меня разыгрываешь?..\n31\n- Минуточку, ребята, - вмешался подошедший к спорящим учитель математики, Глеб Тимофеевич, - давайте подойдем к проблеме формально. Допустим, что все диалоги - Владимира Алексеевича с Сашей, Саши с Петей и Пети с Колей - действительно имели место. Пронумеруем ребят числами 1, 2 и 3. Предположим также, что каждый из ребят независимо друг от друга передал полученную информацию относительно жизни на Марсе верно с вероятностью pi, а соврал с вероятностью qi = 1 - pi для i = 1, 2, 3. Вероятности – это вещественные числа от нуля до единицы; событие, имеющее вероятность 0, никогда не произойдет, событие же с вероятностью 1 произойдет без всякого сомнения. Зная, что Коля после этого объявил, что жизнь на Марсе все-таки есть, найдите по данным pi вероятность того, что так действительно сказал Владимир Алексеевич.\n2\n- А как искать эту вероятность? И что значит независимо друг от друга? – растерялись ребята.\n3\n- Независимость означает, что действие одного из ребят никак не отражается на том, как поступят другие. К примеру, Пете неважно, соврал ли Саша - в любом случае он передаст сказанное Сашей правильно с вероятностью ровно p2.\nЗадача несложная, и можно рассмотреть все восемь возможных случаев. Первый случай - все ребята говорили правду, и вероятность этого случая равна p1∙p2∙p3. В этом случае жизнь на Марсе, без сомнения, есть - Владимиру Алексеевичу мы верим, а ребята передали его слова правильно. Второй случай, когда соврал только Саша, имеет место с вероятностью q1∙p2∙p3, и в этом случае жизни на Марсе нет. Далее переберем остальные шесть случаев, каждый раз перемножая соответствующие вероятности, а потом просуммируем вероятности тех случаев, в которых слова учителя переданы правильно. То, что вероятности для отдельных ребят в каждом случае надо перемножить - это и есть формальное определение независимости. Ну, в скольких случаях будет передано именно то, что говорил Владимир Алексеевич?\n1\n- В одном …\n2\n- А вот и нет. Например, если Петя и Коля соврали, а Саша сказал правду, то истина, дважды исказившись, дойдет до нас в неизменном виде. И вообще, четное количество отрицаний, примененных к утверждению, дает само утверждение. В нашей задаче случаев с четным количеством отрицаний - четыре, и итоговая вероятность равна p1∙p2∙p3+q1∙q2∙p3+q1∙p2∙q3+p1∙q2∙q3.\n3\n- То есть если Петя и Коля точно соврут, а Саша точно скажет правду, то от Коли мы услышим в точности то, что говорил учитель?\n- Совершенно верно. А теперь решите-ка задачу для общего случая, когда ребят не трое, а n. Первому, кто решит - пятерка на следующей контрольной!\nВходные данные\nВходной файл INPUT.TXT содержит целое число n (1 ≤ n ≤ 100). Во второй строке через пробел записаны n вещественных чисел - это числа p1, p2, ..., pn (0 ≤ pi ≤ 1). Числа даны с не более чем шестью десятичными знаками после запятой.\nВыходные данные\nВ выходной файл OUTPUT.TXT выведите одно вещественное число, округленное до шести знаков после запятой - вероятность существования жизни на Марсе.",
    "complexity": 37,
    "memory": 16000,
    "time": 1000,
    "examples": [
      {
        "input": "3\n1 0.1 0.9",
        "output": "0.18"
      }
    ]
  },
  {
    "id": 507,
    "name": "Адронный коллайдер",
    "description": "Внутри адронного коллайдера образовалось N разновидностей новых частиц в количестве A1, … ,AN единиц каждая. Большая часть новых частиц, однако, успевает прореагировать между собой раньше, чем эти частицы сможет уловить детектор, поэтому физикам очень важно предсказать конечный итог реакции между частицами.\nijOUTPUT.TXT3\n0 1 0\n0 0 1\n1 0 0\n21\n2\n0\n1212[Лучшие попытки]\nДля простоты будем считать, что в реакции участвуют 2 частицы, с одним из следующих результатов, в зависимости от типа:\nij\nПервая частица уничтожает вторую\nЧастицы отскакивают друг от друга без какого-либо вреда\nji\nНеобходимо определить все возможные исходы эксперимента.\nВходные данные\nВ первой строке входного файла INPUT.TXT задано количество видов частиц N (1 ≤ N ≤ 4). В следующей строке записаны N чисел, определяющие начальное количество частиц каждого типа Ai (1 ≤ Ai ≤ 2). Следующие N строк  формируют матрицу B[N][N] из чисел 0 и 1. Ненулевое значение ячейки Bij указывает, что частица типа i при столкновении уничтожает частицу типа j. Если Bij не ноль и Bji не ноль, то в результате взаимодействия уничтожается либо частица i, либо частица j, но не обе сразу.\nВыходные данные\nВ первой строке выходного файла OUTPUT.TXT следует вывести количество возможных исходов K. В каждой из последующих K строк должно содержаться описание исхода эксперимента в формате исходного файла.",
    "complexity": 54,
    "memory": 16000,
    "time": 1000,
    "examples": [
      {
        "input": "3\n\n1 1 2\n\n0 0 1\n\n1 0 0\n\n1 1 1",
        "output": "3\n\n0 1 0\n\n0 0 1\n\n1 0 0"
      },
      {
        "input": "1\n\n2\n\n0",
        "output": "1\n2"
      }
    ]
  },
  {
    "id": 504,
    "name": "Цветочки",
    "description": "В рождественский вечер на окошке стояло три цветочка, слева направо: герань, крокус и фиалка. Каждое утро Маша вытирала окошко и меняла местами стоящий справа цветок с центральным цветком. А Таня каждый вечер поливала цветочки и меняла местами левый и центральный цветок. Требуется определить порядок цветов ночью по прошествии K дней.\nOUTPUT.TXTVGC25CVGCVG[Лучшие попытки]\nВходные данные[Решение]\nВо входном файле INPUT.TXT содержится натуральное число K – число дней (K  ≤ 1000).\nВыходные данные\nВ выходной файл OUTPUT.TXT требуется вывести три английских буквы: «G», «C» и «V» (заглавные буквы без пробелов), описывающие порядок цветов на окошке по истечении K дней (слева направо). Обозначения: G – герань, C – крокус, V – фиалка.",
    "complexity": 12,
    "memory": 16000,
    "time": 1000,
    "examples": [
      {
        "input": "1",
        "output": "VGC"
      },
      {
        "input": "5",
        "output": "CVG"
      }
    ]
  },
  {
    "id": 503,
    "name": "Бюро путешествий",
    "description": "Далеко не все в Тентуре имеют право носить малиновые штаны, и конечно, не все владеют пепелацем с гравицапой, поэтому для большинства жителей проблема перемещения между планетами была неразрешимой. Но с некоторых пор один предприимчивый чатланин с планеты Плюк вышел на рынок пассажирских перевозок, и за немного чатлов, готов перевозить желающих с планеты на планету. Рейс начинается с планеты Плюк, включает нескольких других планет, и завершается там же, на планете Плюк. Однако при подготовке рейса возникли неожиданные проблемы. Например, если чатланин с планеты Плюк хочет попасть на планету, которая является в рейсе предпоследней – ему невольно придётся посетить все планеты, которые находятся в рейсе между планетой Плюк и его точкой назначения. Очевидно, что часть планет в этом списке могут оказаться пацакскими. Но каждый чатланин обязан носить цак на пацакской планете и, наоборот, каждый пацак должен носить цак на чатланской планете. (Цак — колокольчик для носа, знак отличия для относительно низшей касты на данной планете). А процедура ношения цака унизительна во всех смыслах этого слова…\nOUTPUT.TXT5 0 2 1 024\nC 3 0 0 0\nC 3 0 0 1\nC 3 0 0 1\nC 3 0 0 1\n3 0 1 2 3 4 03 0 1 2 3 4 0[Лучшие попытки]\nПоскольку данное бюро путешествий пока не имеет представительств на других планетах, перевозка осуществляется только с планеты Плюк на какую-либо другую, либо с другой планеты на Плюк. Задача планирования рейса упрощается – можно посещать планеты в произвольном порядке (но нельзя посещать одну и ту же планету дважды – в пути может закончиться луц). Необходимо вычислить такой порядок посещения планет, при котором надевать цак на промежуточных планетах придётся минимальное количество раз.\nВходные данные\nПервая строка входного файла INPUT.TXT содержит натуральное число N ≤ 22 – количество планет, обслуживаемых данным рейсом (не считая планеты Плюк). N следующих строк содержат информацию о планетах, в следующем виде: тип планеты (английская заглавная буква С – чатланская, P – пацакская), количество чатлан, следующих до этой планеты с Плюка, количество пацаков, следующих до этой планеты с Плюка, количество чатлан, с данной планеты на Плюк, количество пацаков, с данной планеты на Плюк. Всего пассажиров ≤ 1000.\nВыходные данные\nВ выходной файл OUTPUT.TXT выводится, сколько раз придётся надевать цак при оптимальном маршруте, затем порядок посещения планет через пробел. Планеты, перечисленные во входном файле, нумеруются начиная с единицы, планета Плюк имеет номер ноль и всегда указывается в последовательности дважды – в начале и в конце последовательности. Если существуют несколько оптимальных маршрутов – то следует выбрать тот, где планета с меньшим номером посещается раньше.",
    "complexity": 80,
    "memory": 32000,
    "time": 1000,
    "examples": [
      {
        "input": "2\n\nC 1 4 5 2\n\nP 2 5 1 4",
        "output": "5 0 2 1 0"
      },
      {
        "input": "4\n\nC 3 0 0 0\n\nC 3 0 0 1\n\nC 3 0 0 1\n\nC 3 0 0 1",
        "output": "3 0 1 2 3 4 0"
      }
    ]
  },
  {
    "id": 557,
    "name": "Матрицы",
    "description": "Аня недавно узнала, что такое квадратная матрица размерности n. Это таблица n×n с целыми числами в ячейках. Число, стоящее на пересечении i-ой строки и j-ого столбца матрицы A, кратко обозначается A[i, j]. Матрицы можно умножать, и Аня быстро освоила, как запрограммировать эту операцию с помощью циклов. Результатом умножения двух матриц A и B будет матрица C, элементы которой определяются следующим образом:\nOUTPUT.TXT20[Лучшие попытки]\nМатрицы ей понадобились для конкретной задачи, в которой надо узнать определенный элемент произведения нескольких матриц. Это уже достаточно сложная задача для Ани, но она усложняется тем, что все вычисления ведутся по модулю некоторого простого числа p, то есть если при арифметических операциях получается число, большее, либо равное p, оно заменяется на остаток при делении на p.\nПомогите Ане вычислить нужный ей элемент.\nВходные данные\nВ первой строчке входного файла INPUT.TXT стоят два числа: m - количество матриц, n - размер каждой из матриц (1 ≤ m ≤ 130, 1 ≤ n ≤ 130). В следующей строчке содержатся номер строки и столбца, интересующего Аню элемента 1 ≤ a ≤ n, 1 ≤ b ≤ n. В третьей строке содержится простое число p ≤ 1000. Далее следует описание m матриц. Описание каждой матрицы состоит из n строк. В каждой из строк содержится n неотрицательных целых чисел, меньших p. Соседние числа в строке разделены пробелом, а перед каждой матрицей пропущена строка.\nВыходные данные\nВ выходной файл OUTPUT.TXT выведите нужный Ане элемент произведения матриц.",
    "complexity": 42,
    "memory": 16000,
    "time": 1000,
    "examples": [
      {
        "input": "3 2\n\n1 2\n\n239\n\n\n\n1 2\n\n3 4\n\n\n\n4 2\n\n1 3\n\n\n\n1 2\n\n2 1",
        "output": "20"
      }
    ]
  },
  {
    "id": 499,
    "name": "Турист",
    "description": "",
    "complexity": 22,
    "memory": 16000,
    "time": 1000,
    "examples": [
      {
        "input": "10 10\n5 5 6 6 4 5",
        "output": "YES"
      },
      {
        "input": "10 10\n5 5 6 6 7 7",
        "output": "NO"
      }
    ]
  },
  {
    "id": 497,
    "name": "Индикатор",
    "description": "Недавно Вася приобрел настольный калькулятор с жидкокристаллическим индикатором. Этот индикатор отображает N цифр с помощью N одинаковых элементов.\nOUTPUT.TXT1011797111210 1NO SOLUTIONNO SOLUTION[Лучшие попытки]\nОтметим, что каждый элемент содержит семь полосок, каждая из которых может быть либо белой, либо черной. В частности, при отображении цифры «1» черными являются две полоски.\nВася – очень любознательный мальчик, поэтому он хочет узнать, какое максимальное и минимальное N-значное число могут быть отображены на индикаторе его нового калькулятора так, чтобы черными были ровно K полосок.\nНапишите программу, которая найдет ответ на Васин вопрос. Учитывайте при этом, что числа не могут содержать ведущие нули.\nВходные данные\nВходной файл INPUT.TXT содержит два натуральных числа N и K (1 ≤ N ≤ 100, 1 ≤ K ≤ 700).\nВыходные данные\nВ первой строке выходного файла OUTPUT.TXT выведите минимальное число, во второй строке выходного файла выведите максимальное число. Если указанным образом не может быть представлено ни одно число, выходной файл должен содержать одну строку NO SOLUTION.",
    "complexity": 52,
    "memory": 16000,
    "time": 1000,
    "examples": [
      {
        "input": "5 15",
        "output": "10117\n97111"
      },
      {
        "input": "10 1",
        "output": "NO SOLUTION"
      }
    ]
  },
  {
    "id": 558,
    "name": "Упаковка",
    "description": "",
    "complexity": 65,
    "memory": 16000,
    "time": 1000,
    "examples": [
      {
        "input": "5\n2 1 5 10 20",
        "output": "1"
      }
    ]
  },
  {
    "id": 505,
    "name": "Забор",
    "description": "OUTPUT.TXT1\n2\n-\n1\nOK=3 BAD=1\n23 3 4\n1 55 11 12\n3 33 1 2\n2 14 15 2\n55 11 12\n14 15 2\n33 1 2\n14 15 2\n1\n2\n3\n2\nOK=4 BAD=0\n1\n2\n3\n2\nOK=4 BAD=0\n[Лучшие попытки]\nДля парка культуры и отдыха было решено изготовить забор. Чтобы забор не портил своим невзрачным видом облик города, архитекторы решили сделать забор фигурным, и разработали несколько различных шаблонов для изготовления секций забора. Шаблон представляет собой многоугольник, где три стороны всегда одинаковы, а четвертая сторона (верхняя часть забора) представляет ломаную линию. Проекции вершин этой ломаной линии на основание забора следуют равномерно, и таким образом шаблон описывается как последовательность высот точек. Высота точек указывается в целых миллиметрах и варьируется от 0 до 2047.\nКоличество точек в шаблоне равняется L . Архитекторы разработали M шаблонов, и завод изготовил по шаблонам N секций. Пример секции с L = 7 изображен на рисунке.\nПри транспортировке секций забора до парка произошла авария, и готовые секции забора рассыпались и перемешались. При разборе завалов были выполнены измерения секций, и теперь, зная высоты, необходимо определить, к какому шаблону принадлежит каждая секция забора. Кроме того, при падении секции забора могли быть повреждены (например, могли обломаться зубья забора), поэтому необходимо также посчитать случаи, когда извлечённая из завала секция не совпадает ни с одним шаблоном.\nВпрочем, дело несколько упрощается – внутренняя (обращённая в парк) сторона секции отличается по цвету от внешней стороны, поэтому можно сказать с уверенностью, что измерения высот секции проделаны в том же порядке, что и в шаблоне.\nВходные данные\nВходной файла INPUT.TXT содержит целые значения L – число точек в шаблоне и секции, M – число различных шаблонов, N – число найденных секций (1 ≤ L, M ≤ 1000, N ≤ 1000). Далее M строчек содержат информацию о шаблоне: номер шаблона (натуральное число не более 1000) и L точек шаблона. Далее N строчек содержат информацию о секциях забора, в каждой строке содержится L точек одной секции забора (высота секции от 0 до 8191).\nВыходные данные\nВ выходной файл OUTPUT.TXT следует вывести N строк, каждая строка содержит номер шаблона, с которым совпала секция, либо, если подходящего шаблона не найдено, то выводится символ дефиса '-'. В последней строке теста выводится слово ”OK=” (без кавычек) и число секций, сопоставленных с шаблонами, через пробел символы ”BAD=” и число испорченных секций.",
    "complexity": 46,
    "memory": 16000,
    "time": 1000,
    "examples": [
      {
        "input": "4 2 4\n\n1 250 123 0 66\n\n2 22 31 120 100\n\n250 123 0 66\n\n22 31 120 100\n\n25 31 120 100\n\n250 123 0 66",
        "output": "1\n\n2\n\n-\n\n1\n\nOK=3 BAD=1"
      },
      {
        "input": "3 3 4\n\n1 55 11 12\n\n3 33 1 2\n\n2 14 15 2\n\n55 11 12\n\n14 15 2\n\n33 1 2\n\n14 15 2",
        "output": "1\n\n2\n\n3\n\n2\n\nOK=4 BAD=0"
      }
    ]
  },
  {
    "id": 560,
    "name": "Остановки",
    "description": "Представьте себе, что вы - один из проектировщиков железной дороги. Вам нужно построить N остановок, размеры которых довольно велики, но все равны между собой и равны некоторому числу w. Стоимость постройки меняется в зависимости от рода поверхности, по которой предстоит строить платформу. При этом остановки не должны располагаться от границ дороги и друг от друга дальше, чем на R метров, иначе каким-то жителям области придется далеко ходить. Также остановки не должны располагаться от границ дороги и друг к другу ближе, чем на r метров, иначе электрички не будут успевать разгоняться между остановками, и будут медленно ездить. Руководство хочет потратить на постройку остановок минимальное количество денег. Вам известны стоимости постройки метра платформы на каждом из L метров всей дороги. Стоимость i-го метра - ai (при 1 ≤ i ≤ L). Вычислите минимально возможную стоимость расстановки всех остановок.\nOUTPUT.TXT622 3 9\n1 2\n8 1 2 3 7 4 3 1 11\n1414No solution.[Лучшие попытки]\nВходные данные31 1 1\n10 10\n239\nNo solution.\nВ первой строке входного файла INPUT.TXT содержатся целые числа N, w и L (1 ≤ N ≤ 100, 1 ≤ w ≤ 100, 1 ≤ L ≤ 20 000). Во второй строке содержится два целых числа: r и R (0 ≤ r ≤ R ≤ 1000). В третьей строке содержится L целых чисел ai, разделенных пробелами (1 ≤ ai ≤ 10000).\nВыходные данные\nВ выходной файл OUTPUT.TXT выведите целое число - искомый ответ. Если решения не существует, то следует вывести «No solution.» .",
    "complexity": 64,
    "memory": 16000,
    "time": 1000,
    "examples": [
      {
        "input": "3 1 5\n\n0 1\n\n3 7 1 5 2",
        "output": "6"
      },
      {
        "input": "2 3 9\n\n1 2\n\n8 1 2 3 7 4 3 1 11",
        "output": "14"
      },
      {
        "input": "1 1 1\n\n10 10\n\n239",
        "output": "No solution."
      }
    ]
  },
  {
    "id": 506,
    "name": "Игра - 3",
    "description": "Петя и Вася увлеклись азартной игрой на деньги. Игра состоит из множества раундов, в каждом из которых бросается монетка и если выпадает «Решка», то побеждает Петя и получает очко, в противном случае очко присуждается Васе. Набранные очки в разных раундах суммируются и тот, кто первым наберет N очков, выигрывает.\nOUTPUT.TXT4 1224 1 1 21 11 12 30[Лучшие попытки]\nВдруг, посреди игры прозвенел звонок, и ребятам пришлось закончить игру. Помогите Пете и Васе справедливо поделить поставленные на кон монеты между собой в соответствии с математическим ожиданием выигрыша.\n35 1 4 322 30\nВходные данные\nВходной файл INPUT.TXT содержит в одной строке 4 целых числа N, K1, K2 и S. Все числа разделены пробелами. N – количество очков, которые необходимо набрать для победы. K1 и K2 – текущие очки Пети (K1) и Васи (K2). S – число монет, которые на кону и которые необходимо поделить между игроками.\nОграничения: 1 ≤  N  ≤ 50, 0 ≤ K1, K2 \u003c N, 1 \u003c S \u003c 10100.\nВыходные данные\nВ выходной файл OUTPUT.TXT через пробел выведите два целых числа: количество монет, которые должны получить Петя и Вася. Не забудьте, что сумма этих чисел в точности должна быть равна S. Гарантируется, что однозначный ответ в целых числах существует.",
    "complexity": 55,
    "memory": 16000,
    "time": 1000,
    "examples": [
      {
        "input": "3 1 2 16",
        "output": "4 12"
      },
      {
        "input": "4 1 1 2",
        "output": "1 1"
      },
      {
        "input": "5 1 4 32",
        "output": "2 30"
      }
    ]
  },
  {
    "id": 559,
    "name": "Сосиска в тесте",
    "description": "Аня еще учится в школе, однако она уже много слышала о трудностях студенческой жизни. Ее это очень волнует, так как она задумывается о своем будущем и понимает, что после окончания школы ей придется учиться в ВУЗе. Из многочисленных рассказов она узнала, что излюбленной пищей студентов являются сосиски. А так как студенты часто испытывают недостатки в средствах, сосиски часто приходится делить. Однако никто не доверяет делению «на глаз», всегда найдется кто-нибудь, утверждающий, что его обделили.\nOUTPUT.TXT1.50000021 140.856810\n1.500000\n2.1431900.856810\n1.500000\n2.143190[Лучшие попытки]\nСосиска представляет собой практически плоскую фигуру (таковы уж студенческие столовые), которую можно описать следующим образом. Рассмотрим некоторый горизонтальный отрезок на плоскости, а также некоторый круг. Тогда, если центр круга провести по всем точкам отрезка от начальной до конечной, то любая точка, лежавшая, хотя бы в какой-то момент в круге, принадлежит сосиске. Можно описать сосиску и другим способом. Рассмотрим тот же отрезок и два круга одинакового радиуса с центрами в его крайних точках. Тогда точка принадлежит сосиске ровно в том случае, если она лежит на некотором отрезке, у которого каждый из концов лежит в одном из кругов.\nПодумав, Аня понимает, что при наличии линейки можно легко отмерить нужное расстояние от левого края сосиски и вертикально отрезать необходимую часть. Но если при этом отмерять одинаковые расстояния, то те, кому достанутся крайние куски, получат меньше. Помогите Ане разместить разрезы в нужных местах сосиски, чтобы все получили поровну.\nВходные данные\nВходной файл INPUT.TXT содержит в первой строке два числа: d - расстояние между центрами крайних кругов и r - радиус каждого из них. Оба числа вещественные, положительные и не превосходят 10 000 и располагаются на первой строке входного файла. На второй строке находится n – количество студентов, претендующих на сосиску (2 ≤ n ≤ 1000).\nВыходные данные\nВ выходном файле OUTPUT.TXT должно содержаться n-1 строка. В i-ой строке должно содержаться расстояние от левого края сосиски до правого края i куска (куски нумеруются слева направо). Все числа должны быть вычислены с точностью до 6 десятичных знаков после запятой.",
    "complexity": 48,
    "memory": 16000,
    "time": 1000,
    "examples": [
      {
        "input": "1 1\n2",
        "output": "1.500000"
      },
      {
        "input": "1 1\n4",
        "output": "0.856810\n\n1.500000\n\n2.143190"
      }
    ]
  },
  {
    "id": 562,
    "name": "Слабая K-связность",
    "description": "Ане, как будущей чемпионке мира по программированию, поручили очень ответственное задание. Правительство вручает ей план постройки дорог между N городами. По плану все дороги односторонние, но между двумя городами может быть больше одной дороги, возможно, в разных направлениях. Ане необходимо вычислить минимальное такое K, что данный ей план является слабо K-связным.\nOUTPUT.TXT124 4\n2 4\n1 3\n4 1\n3 2\n00[Лучшие попытки]\nПравительство называет план слабо K-связным, если выполнено следующее условие: для любых двух различных городов можно проехать от одного до другого, нарушая правила движения не более K раз. Нарушение правил - это проезд по существующей дороге в обратном направлении. Гарантируется, что между любыми двумя городами можно проехать, возможно, несколько раз нарушив правила.\nВходные данные\nВ первой строке входного файла INPUT.TXT записаны два числа 2 ≤ N ≤ 300 и 1 ≤ M ≤ 105 - количество городов и дорог в плане. В последующих M строках даны по два числа - номера городов, в которых начинается и заканчивается соответствующая дорога.\nВыходные данные\nВ выходной файл OUTPUT.TXT выведите минимальное K, такое, что данный во входном файле план является слабо K-связным.",
    "complexity": 47,
    "memory": 16000,
    "time": 1000,
    "examples": [
      {
        "input": "3 2\n\n1 2\n\n1 3",
        "output": "1"
      },
      {
        "input": "4 4\n\n2 4\n\n1 3\n\n4 1\n\n3 2",
        "output": "0"
      }
    ]
  },
  {
    "id": 561,
    "name": "Башни",
    "description": "Выходные данные\nВ выходной файл OUTPUT.TXT выведите перестановку номеров башен b1, b2, ... , bN в таком порядке, что если взять сначала башню с номером b1, потом с номером b2, и т.д., то они окажутся расположенными в порядке возрастания.",
    "complexity": 95,
    "memory": 16000,
    "time": 1000,
    "examples": [
      {
        "input": "10\n\n4 2 2 2 2 2\n\n1 2 2\n\n1 3 2\n\n1 2 3\n\n3 2 2 2 2\n\n2 2 2 2\n\n1 3 3\n\n3 3 3 3 3\n\n2 4 3 3\n\n2 2 3 4",
        "output": "2 4 3 6 7 5 9 10 1 8"
      }
    ]
  },
  {
    "id": 563,
    "name": "Задача про XOR",
    "description": "В рамках подготовки к чемпионату мира Кирилл придумал Ане задачу. Он написал N знаковых 32-битных чисел и попросил вычислить значение некоторого выражения S. Пусть a1, …, aN - все эти числа. Тогда выражение это\nni+1OUTPUT.TXT12211-1-16[Лучшие попытки]\nS = (a1 xor a2 xor … xor an) xor (b1 xor b2 xor … xor bn-1), \n1i331246\n2\nгде\ni+2\nn-1\nbi = F(ai, ai+1) xor F(ai, ai+2) xor … xor F(ai, an).\ni\nn\nВ этой формуле под знаком xor понимается побитовое «исключающее или», а F(a, b) = x - 1, где x - максимальная степень двойки, на которую делится нацело a-b, если a ≠ b, и F(a, b) = -1, если a = b. Все операции xor выполняются слева направо, если скобки не указывают иной порядок.\nАня, как большая специалистка в области циклов, быстро написала требуемую программу, однако программа работала слишком долго. Чтобы лучше разобраться в этом вопросе, она попросила вас написать программу, которая бы укладывалась в отведенное время. Помогите ей это сделать.\nВходные данные\nВ первой строке входного файла INPUT.TXT содержится число N (1 ≤ N ≤ 105). В следующих N строках содержится N 32-битных знаковых целых чисел ai по одному на строке.\nВыходные данные\nВ выходной файл OUTPUT.TXT выведите значение выражения.",
    "complexity": 69,
    "memory": 16000,
    "time": 1000,
    "examples": [
      {
        "input": "3\n1\n2\n3",
        "output": "1"
      },
      {
        "input": "2\n1\n1",
        "output": "-1"
      },
      {
        "input": "3\n1\n2\n4",
        "output": "6"
      }
    ]
  },
  {
    "id": 564,
    "name": "Забор - 2",
    "description": "Времена Советского Союза уже давно стали историей. И к рассказам о событиях, происходивших тогда, только в России могут относиться не как к анекдотам. Попробуйте мысленно перенестись в те времена.\nOUTPUT.TXT0.43301270189221931 2 3241 2 4 7-1-1[Лучшие попытки]\nОднажды новому управлению строительного комбината выделили землю для дачных участков. Земли было выделено много, но тут возникла следующая проблема. На складах комбината хранилось некоторое количество секций для возведения заборов. Фрагменты имели достаточно большую длину, но их явно не хватало, чтобы огородить выделенную землю и поделить ее на участки (а попытавшись приобрести новую часть забора подходящей длины, любой сотрудник управления явно привлек бы внимание соответствующих органов). К тому же фрагменты были выполнены таким образом, что собрать каждый из них можно было только в один прямой отрезок.\n[Решение]\nПоэтому было решено, что каждый из членов управления может выбрать для себя три фрагмента забора и с помощью них огородить себе участок. Директор комбината (который, конечно же, делает выбор первым) поручил вам помочь ему выбрать такие фрагменты забора, чтобы его участок имел максимально возможную площадь.\nВходные данные\nВ первой строке входного файла INPUT.TXT записано натуральное число n, количество фрагментов на складе (n ≤ 100). На второй строке содержатся n натуральных чисел, не превосходящих 1000 - длины фрагментов забора.\nВыходные данные\nВ выходной файл OUTPUT.TXT выведите максимальное значение площади участка, который может соорудить директор и номера фрагментов, из которых может получиться максимальный участок в произвольном порядке. Ответ следует выводить с точностью, не меньшей, чем 6 знаков после запятой. В случае, если создать участок ненулевой площади нельзя, выведите -1.",
    "complexity": 29,
    "memory": 16000,
    "time": 1000,
    "examples": [
      {
        "input": "3\n1 1 1",
        "output": "0.4330127018922193\n1 2 3"
      },
      {
        "input": "4\n1 2 4 7",
        "output": "-1"
      }
    ]
  },
  {
    "id": 405,
    "name": "Туристическое агентство",
    "description": "Антон работает в межгалактическом туристическом агентстве. Довольно часто ему приходится прокладывать путь с одной планеты на другую с использованием существующих рейсов космических кораблей. К сожалению, количество рейсов невелико, поэтому пассажирам часто приходится пересаживаться на промежуточных планетах.\nOUTPUT.TXT18\n6\n6\n6\n6\n6\n6\n[Лучшие попытки]\nАнтон заметил, что некоторые планеты используются в качестве промежуточных чаще, чем другие. Он решил провести исследование – для каждой планеты A он хотел бы узнать, сколько существует пар различных планет (B,C), таких что любой путь с планеты B на планету C проходит через планету A.\nПомогите Антону!\nВходные данные\nПервая строка входного файла INPUT.TXT содержит два целых числа: N и M – количество планет и количество рейсов космических кораблей, соответственно (2 ≤ N ≤ 20 000, 1 ≤ M ≤ 200 000). Следующие M строк описывают рейсы космических кораблей. Каждый рейс связывает две планеты, и им можно воспользоваться в любом из двух направлений. С любой планеты можно добраться до любой другой.\nВыходные данные\nВ выходной файл OUTPUT.TXT выведите N целых чисел – для каждой планеты A выведите количество пар различных планет, таких что любой путь с одной планеты на другую проходит через A.",
    "complexity": 80,
    "memory": 32000,
    "time": 1000,
    "examples": [
      {
        "input": "7 9\n\n1 2\n\n1 3\n\n1 4\n\n1 5\n\n1 6\n\n1 7\n\n2 3\n\n4 5\n\n6 7",
        "output": "18\n\n6\n\n6\n\n6\n\n6\n\n6\n\n6"
      }
    ]
  },
  {
    "id": 370,
    "name": "Площадь многоугольника",
    "description": "Многоугольник на плоскости задан целочисленными координатами своих N вершин в декартовой системе координат. Требуется найти площадь многоугольника. Стороны многоугольника не соприкасаются (за исключением соседних - в вершинах) и не пересекаются.\nOUTPUT.TXT50.024\n0 4\n0 0\n3 0\n1 1\n3.53.5[Лучшие попытки]\nВходные данные\nВ первой строке входного файла INPUT.TXT находится число N. В следующих N строках находятся пары чисел (Xi,Yi) - координаты точек. Если соединить точки в данном порядке, а также первую и последнюю точки, получится заданный многоугольник. (3 ≤ N ≤ 50 000,  -20 000 ≤ Xi,Yi ≤ 20 000)\nВыходные данные\nВ выходной файл OUTPUT.TXT выведите одно число - площадь многоугольника. Его следует округлить до ближайшего числа с одной цифрой после запятой.",
    "complexity": 48,
    "memory": 16000,
    "time": 1000,
    "examples": [
      {
        "input": "4\n\n5 0\n\n0 5\n\n-5 0\n\n0 -5",
        "output": "50.0"
      },
      {
        "input": "4\n\n0 4\n\n0 0\n\n3 0\n\n1 1",
        "output": "3.5"
      }
    ]
  },
  {
    "id": 469,
    "name": "Химическая тревога",
    "description": "Произошло радиоактивное заражение местности. Составлена карта зараженности. Она представляет собой прямоугольную таблицу N×M, в клетках которой записана зараженность соответствующего участка.\nOUTPUT.TXT9[Лучшие попытки]\nТребуется написать программу, которая найдет путь из левой верхней клетки таблицы в правую нижнюю клетку с минимальной суммарной дозой радиации.\nВходные данные\nВходной файл INPUT.TXT содержит в первой строке числа N и M, а в следующих N строках – по M чисел – карта зараженности местности. Числа в строках разделяются одним пробелом. 1 ≤ N ≤ 30, 1 ≤ M ≤ 30, зараженность участка – целое число от 0 до 100.\nВыходные данные\nВыходной файл OUTPUT.TXT должен содержать одно число – суммарную долю радиации.",
    "complexity": 50,
    "memory": 16000,
    "time": 1000,
    "examples": [
      {
        "input": "3 5\n\n2 100 0 100 100\n\n1 100 0 0 0\n\n1 0 3 100 2",
        "output": "9"
      }
    ]
  },
  {
    "id": 508,
    "name": "Клеверный лист",
    "description": "OUTPUT.TXT2 425\nB 0 0 9 9\nB 0 0 0 0\nL 3 3 0 0\nB 0 0 0 0\nB 8 4 0 0\n9 18 -1 12 89 18 -1 12 8[Лучшие попытки]\nВ одном крупном городе строится объездная автодорога. Она не является кольцевой, то есть имеет западное и восточное окончание. Наиболее интересными инженерными объектами на дороге, являются, конечно же, мосты. Очевидно, что железобетонный мост слишком дорогой для участка с одним автомобилем в день, а деревянный мост не способен обслуживать шоссе с десятком машин в минуту. Поэтому для оправданного проектирования мостов необходимо знать, сколько автомобилей проезжает через мост.\nНа дороге будут использоваться преимущественно развязки \"клеверный лист\", схема такой развязки изображена на рисунке. Согласно этой схеме, автомобиль, поворачивающий направо - не едет через мост, автомобиль, поворачивающий налево (по этой развязке он поворачивает на 270 градусов направо и пересекает свой путь на другом уровне) - всегда едет через мост, и автомобиль, проезжающий прямо - может ехать, а может не ехать через мост, тут всё зависит от направления движения.\nИсследован поток автомобилей, которые едут по дорогам, пересекающим объездную дорогу. Необходимо посчитать поток автомобилей, которые поедут через мосты объездной дороги. Следует помнить, что для некоторых перекрёстков объездная дорога проходит по земле, а мост содержит поперечная дорога - считать такие мосты не требуется. Хоть дорога двусторонняя, один тест исследует только одно направление объездной дороги (например, с запада на восток).\nВходные данные\nПервая строка входного файла INPUT.TXT содержит число N ≤ 100 – количество перекрёстков, перекрёстки перечислены с запада на восток. Следующие N строк содержат информацию о типе пересечения, затем о потоке поперечной дороги. Тип пересечения - английская буква L, означает что объездная дорога проходит по земле, а поперечная проходит через мост, буква B означает что поперечная дорога проходит по земле, а объездная через мост. Далее указаны 2 числа, показывающее количество автомобилей, покинувших объездную дорогу, первое число - с поворотом налево, второе - с поворотом направо. Далее указаны 2 числа, показывающее количество автомобилей, выехавших на объездную дорогу, первое число - с поворотом налево, второе - с поворотом направо. Количество машин по любой из поперечных дорог не превышает 109.\nГарантируется корректность входных данных (изначально на трассе машин нет, покинуло трассу столько же машин, сколько и заехало на трассу, точка перекрёсток схода находится позднее перекрёстка захода).\nВыходные данные\nВ выходной файл OUTPUT.TXT выводится одна строка, содержащая N чисел - потоки машин на мост объездной дороги. Если объездная дорога проходит по земле, а мост - над ней, то выводится -1.",
    "complexity": 36,
    "memory": 16000,
    "time": 1000,
    "examples": [
      {
        "input": "2\n\nB 0 0 2 3\n\nB 4 1 0 0",
        "output": "2 4"
      },
      {
        "input": "5\n\nB 0 0 9 9\n\nB 0 0 0 0\n\nL 3 3 0 0\n\nB 0 0 0 0\n\nB 8 4 0 0",
        "output": "9 18 -1 12 8"
      }
    ]
  },
  {
    "id": 404,
    "name": "Игра с камнями",
    "description": "Правила игры: исходно на столе располагается кучка, содержащая N камней. Два игрока по очереди берут камни из кучки. Если перед ходом игрока кучка содержит K камней, игрок может взять из нее от 1 до [sqrt(K)] (целую часть от квадратного корня из K) камней, включительно. Например, если в кучке 10 камней, разрешается взять 1, 2 или 3 камня. Если в кучке не осталось камней, то игрок, который должен сделать ход, проигрывает.\nOUTPUT.TXTWIN25LOSELOSE[Лучшие попытки]\nТребуется определить: сможет ли первый игрок выиграть, если оба игрока будут придерживаться оптимальной стратегии.\nВходные данные\nВходной файл INPUT.TXT содержит натуральное число N – число камней в кучке (N ≤ 1012).\nВыходные данные\nВ выходной файл OUTPUT.TXT выведите WIN, если первый игрок может выиграть вне зависимости от действий второго игрока, либо LOSE, если второй игрок может заставить первого игрока проиграть.",
    "complexity": 63,
    "memory": 16000,
    "time": 1000,
    "examples": [
      {
        "input": "3",
        "output": "WIN"
      },
      {
        "input": "5",
        "output": "LOSE"
      }
    ]
  },
  {
    "id": 565,
    "name": "Сушка",
    "description": "Тетя Люба только что постирала все белье и теперь перед ней стоит непростая задача - как его высушить, чтобы ни одна вещь не успела испортиться. Сразу после стирки, i-я постиранная вещь имеет влажность wi. Если она сушится на веревке, то за минуту ее влажность уменьшается на 1, а если на батарее - то на r (если влажность была меньше r, то она становится равной 0). Причем веревок у тети Любы много (хватает для одновременной сушки всех вещей), а батарея только одна, причем такая маленькая, что на ней нельзя сушить две вещи одновременно. i-я вещь испортится, если не высохнет за время di. Помогите тете Любе составить план, когда какую вещь повесить на батарею.\niOUTPUT.TXT0 3\n500 1\n1000 323 3\n2000 1000\n2000 1000\n2000 1000ImpossibleImpossible[Лучшие попытки]\nВходные данныеi\nПервая строка входного файла INPUT.TXT содержит целые числа n (1 ≤ n ≤ 105) - количество мокрых вещей, и r (1 ≤ r ≤ 109). Следующие n строк содержат описания постиранных вещей – пары чисел wi и di (1 ≤  wi, di ≤ 109).\ni\niВыходные данные\n9\nВ выходной файл OUTPUT.TXT выведите план сушки в виде пар целых чисел ti и ki, где ti - время в минутах от начала сушки, а ki - номер вещи, которую нужно повесить на батарею в этот момент. Выводите пары в порядке увеличения ti. Пар не должно быть больше 105. Не выводите числа больше 109. Если высушить все вещи невозможно, выведите слово «Impossible».",
    "complexity": 59,
    "memory": 16000,
    "time": 1000,
    "examples": [
      {
        "input": "3 3\n\n2000 1000\n\n2000 2000\n\n2500 1500",
        "output": "0 3\n\n500 1\n\n1000 3"
      },
      {
        "input": "3 3\n\n2000 1000\n\n2000 1000\n\n2000 1000",
        "output": "Impossible"
      }
    ]
  },
  {
    "id": 509,
    "name": "Игра Jammed",
    "description": "Всем известна игра «Пятнашки», где надо выстроить изначально неупорядоченную последовательность чисел, перемещая фишки с нанесёнными числами от 1 до 15 в квадрате 4×4. На основе данной игры была разработана другая – поле в ней лишь 4×2 клетки, на поле 7 фишек, но на фишках изображены буквы английского алфавита и арабские цифры (на каждой фишке – один символ, но на разных фишках могут быть одинаковые символы). Цель игры прежняя – упорядочить в соответствии с образцом стартовую расстановку фишек за минимальное количество ходов.\nOUTPUT.TXT172rogp\nmar#\nprog\nram#\n2626[Лучшие попытки]\nСвободная клетка обозначается специальным символом «#» и используется для перемещения фишек по полю. Перемещать фишки на свободную клетку разрешается из соседних клеток, имеющих общую грань со свободной. Например, на рисунке более правый символ «0» можно переместить вниз на свободную клетку, тогда «0» будет в нижней клетке, а пустой станет верхняя клетка, либо в свободную клетку переместить букву «C» или цифру «2».\nВходные данные\nВходной файл INPUT.TXT содержит четыре строки: две первые строки содержат стартовую комбинацию символов, следующие две - образец. Каждая строка содержит 4 символа (английский алфавит и арабские цифры), пустая клетка обозначается символом «#» (решетка).\nВыходные данные\nВ выходной файл OUTPUT.TXT выведите минимальное количество перемещений, необходимых для получения искомой комбинации. Если нужную комбинацию получить нельзя, выведите число -1.",
    "complexity": 58,
    "memory": 16000,
    "time": 1000,
    "examples": [
      {
        "input": "ACM8\n\n002#\n\nACM#\n\n2008",
        "output": "17"
      },
      {
        "input": "rogp\n\nmar#\n\nprog\n\nram#",
        "output": "26"
      }
    ]
  },
  {
    "id": 467,
    "name": "Закраска прямой - 2",
    "description": "Определение. Интервал прямой с целочисленными координатами [a, b) содержит левую границу – точку a и не содержит правую границу – точку b.\nOUTPUT.TXT15[Лучшие попытки]\nИнтервал от 0 до 109 выкрасили в белый цвет. Затем было выполнено N  операций перекрашивания. При каждой операции цвета в интервале, границы которого задаются, меняются на противоположный (белый на черный, черный на белый).\nТребуется написать программу, которая найдет самый длинный интервал белого цвета после заданной последовательности операций перекрашивания.\nВходные данные\nВходной файл INPUT.TXT содержит в первой строке число N (1 ≤ N ≤ 500) и затем N строк с границами интервалов (числа в диапазоне от 0 до 109).\nВыходные данные\nВ выходной файл OUTPUT.TXT выведите одно число – длину самого большого белого интервала.",
    "complexity": 61,
    "memory": 16000,
    "time": 1000,
    "examples": [
      {
        "input": "4\n\n20 50\n\n10 35\n\n40 90\n\n100 1000000000",
        "output": "15"
      }
    ]
  },
  {
    "id": 566,
    "name": "Халява",
    "description": "Гриша очень любит газировку PupsiCola. Однажды он узнал, что, собрав несколько крышек со звездочками, можно получить футболку. Гриша нашел A крышек с одной звездочкой, B крышек с двумя звездочками и C крышек с тремя звездочками. На футболку можно обменять набор крышек, общее количество звездочек на которых не меньше K.\nOUTPUT.TXT320 0 4 422[Лучшие попытки]\nПомогите Грише узнать, сколько футболок он может получить.\nВходные данные\nВходной файл INPUT.TXT содержит целые числа A, B, C и K (0 ≤ A, B, C ≤ 100, 1 ≤ K ≤ 1000).\nВыходные данные\nВ выходной файл OUTPUT.TXT выведите максимальное количество футболок, которые может получить Гриша.",
    "complexity": 61,
    "memory": 16000,
    "time": 1000,
    "examples": [
      {
        "input": "2 2 2 4",
        "output": "3"
      },
      {
        "input": "0 0 4 4",
        "output": "2"
      }
    ]
  },
  {
    "id": 468,
    "name": "Числовая последовательность - 2",
    "description": "Дана последовательность  натуральных чисел 7, 11, 13, 14, 19, 21, 22, 25, ….\nOUTPUT.TXT7262121[Лучшие попытки]\nТребуется написать программу, которая по заданному N находит N-ый член этой последовательности.\nВходные данные\nВходной файл INPUT.TXT содержит число N (1 ≤ N ≤ 2147483647).\nВыходные данные\nВ выходной файл OUTPUT.TXT выведите N-ый член последовательности.",
    "complexity": 66,
    "memory": 16000,
    "time": 1000,
    "examples": [
      {
        "input": "1",
        "output": "7"
      },
      {
        "input": "6",
        "output": "21"
      }
    ]
  },
  {
    "id": 567,
    "name": "Упаковка подарка",
    "description": "Для упаковки подарка Роме нужно сделать из фольги конус с нижним основанием радиуса r и длиной образующей l.\nOUTPUT.TXT4[Лучшие попытки]\nДля этого ему нужен кусок фольги такой формы:\nУ Ромы есть рулон фольги шириной d, от которого он может отрезать кусок произвольной длины. Помогите ему узнать минимальную длину куска, из которого можно вырезать нужную фигуру.\nВходные данные\nВо входном файле INPUT.TXT содержатся три целых числа: r, l и d (все числа не превосходят 106, l \u003e r). Гарантируется, что существует способ вырезать нужную фигуру.\nВыходные данные\nВ выходной файл OUTPUT.TXT выведите минимально возможную длину куска фольги, из которого Рома сможет сделать нужную упаковку. Выведите не менее 6 знаков после точки.",
    "complexity": 83,
    "memory": 16000,
    "time": 1000,
    "examples": [
      {
        "input": "1 2 2",
        "output": "4"
      }
    ]
  },
  {
    "id": 569,
    "name": "Зарплата - 2",
    "description": "В одном государственном учреждении работают n сотрудников. Их фактические зарплаты равны di, но по закону всем сотрудникам положено платить одинаково, поэтому им всем официально выплачивают среднюю зарплату d, такую, чтобы общая сумма оставалась такой же, а потом сотрудники сами перераспределяют полученные деньги.\niiOUTPUT.TXT2 100\n0 0\n0 023 200\n10\n300\n2903 190\n0 0\n2 1003 190\n0 0\n2 100[Лучшие попытки]\nКороче, творится полный бардак. И чтобы этот бардак уменьшить, Самый Главный Начальник решил использовать недавно принятый закон «о материальной помощи», который позволяет любому сотруднику часть своей зарплаты (целое число рублей от 1 до d-1) передавать другому сотруднику в виде материальной поддержки. Однако по закону сотрудник, таким образом, может «помогать» только одному «малоимущему».\nii\nНапример, если Петя и Вася получают по 100 рублей и Петя напишет заявление на передачу 30% своей зарплаты Васе, то Петя будет получать 70 рублей, а Вася - 130.\n9i\nТеперь Самый Главный Начальник хочет узнать: кто, кому и сколько должен передавать, чтобы в результате все получали ровно столько, сколько нужно. Помогите ему это сделать.\nii\nВходные данные\nВходной файл INPUT.TXT содержит целые числа n и d (1 ≤  n ≤ 105, 1 ≤  d ≤ 109), и далее n целых чисел di (1 ≤  di ≤ 109). Сумма всех di равна n∙d.\nВыходные данные\nВ выходной файл OUTPUT.TXT выведите n пар целых чисел ai и bi, означающих, что сотрудник i передает сотруднику ai часть своей зарплаты в размере bi рублей. Если сотрудник i ничего никому не передает, выведите вместо ai и bi два нуля.",
    "complexity": 43,
    "memory": 16000,
    "time": 1000,
    "examples": [
      {
        "input": "3 200\n\n100\n\n300\n\n200",
        "output": "2 100\n\n0 0\n\n0 0"
      },
      {
        "input": "3 200\n\n10\n\n300\n\n290",
        "output": "3 190\n\n0 0\n\n2 100"
      }
    ]
  },
  {
    "id": 568,
    "name": "Дороги - 2",
    "description": "Мэр города Гадюкино решил проверить состояние дорог после только что проведенного капитального ремонта. Для этого он хочет проехать по каждой дороге в обоих направлениях. Помогите мэру составить кратчайший маршрут, проходящий по каждой дороге в каждом направлении хотя бы один раз.\niOUTPUT.TXT61 2 3 1 3 2 1[Лучшие попытки]\nВ городе Гадюкино n перекрестков и m дорог, каждая из которых соединяет два различных перекрестка. Между двумя перекрестками может быть не более одной дороги. Известно, что по дорогам от каждого перекрестка можно доехать до любого другого.\ni\nВходные данные\nВходной файл INPUT.TXT содержит целые числа n и m (1 ≤  n ≤ 104, 1 ≤  m ≤ 105), и далее m пар целых чисел ai и bi - номера перекрестков, которые соединяет i-я дорога.\nВыходные данные\nВ выходной файл OUTPUT.TXT выведите число s - минимальную длину пути и далее s+1 число - номера перекрестков в том порядке, в котором их нужно проезжать.",
    "complexity": 53,
    "memory": 32000,
    "time": 1000,
    "examples": [
      {
        "input": "3 3\n\n1 2\n\n2 3\n\n1 3",
        "output": "6\n1 2 3 1 3 2 1"
      }
    ]
  },
  {
    "id": 542,
    "name": "Бит-реверс",
    "description": "Целое положительное число m записывается в двоичной системе счисления, разряды (в этой записи) переставляются в обратном порядке и число переводится в десятичную систему счисления. Получившееся число принимается за значение функции B(m).\nOUTPUT.TXT12633[Лучшие попытки]\nТребуется написать программу, которая для заданного m вычислит B(m).\nВходные данные\nВходной файл INPUT.TXT содержит натуральное число m (m ≤ 109).\nВыходные данные\nВ выходной файл OUTPUT.TXT выведите значение B(m).",
    "complexity": 25,
    "memory": 16000,
    "time": 1000,
    "examples": [
      {
        "input": "4",
        "output": "1"
      },
      {
        "input": "6",
        "output": "3"
      }
    ]
  },
  {
    "id": 537,
    "name": "Перестановки - 3",
    "description": "",
    "complexity": 74,
    "memory": 16000,
    "time": 1000,
    "examples": [
      {
        "input": "4 1 2\n6 8 3 9",
        "output": "3 9 6 8"
      },
      {
        "input": "4 4 2\n6 8 3 9",
        "output": "9 3 6 8"
      },
      {
        "input": "4 5 2\n6 8 3 9",
        "output": "-1"
      }
    ]
  },
  {
    "id": 538,
    "name": "Радио",
    "description": "Как известно, при распространении радиоволн возникает интерференция, поэтому если рядом расположены две радиопередающие станции, вещающие на одной и той же частоте, то качество радиопередач резко снижается.\nOUTPUT.TXT0.707106781186547521 2 2 1[Лучшие попытки]\nРадиостанция «Радио Информатика» планирует транслировать свои программы в стране Флатландия. Министерство связи Флатландии выдало радиостанции лицензию на вещание на двух различных частотах.\nВладельцы радиостанции имеют возможность транслировать свои радиопрограммы с использованием n радиовышек, расположенных в различных точках страны. Для осуществления трансляции на каждой радиовышке требуется установить специальный передатчик – трансмиттер. Каждый передатчик можно настроить на одну из двух частот, выделенных радиостанции. Кроме частоты вещания, передатчик характеризуется также своей мощностью. Чем мощнее передатчик, тем на большее расстояние он распространяет радиоволны. Для простоты, предположим, что передатчик мощности R распространяет радиоволны на расстояние, равное R километрам.\nВсе передатчики, установленные на вышках, должны, согласно инструкции министерства, иметь одну и ту же мощность. Чтобы программы радиостанции могли приниматься на как можно большей территории, мощность передатчиков должна быть как можно большей. С другой стороны, необходимо, чтобы прием передач был качественным на всей территории Флатландии. Прием передач считается качественным, если не существует такого участка ненулевой площади, на который радиоволны радиостанции «Радио Информатика» приходят на одной частоте одновременно с двух вышек.\nТребуется написать программу, которая определяет, какую максимальную мощность можно было установить на всех передатчиках, позволяющую выбрать на каждом передатчике такую одну из двух частот передачи, чтобы прием был качественным на всей территории Флатландии.\nВходные данные\nПервая строка входного файла INPUT.TXT содержит число N – количество вышек (3 ≤ N ≤ 1200). Последующие N строк содержат по два целых числа — координаты вышек. Координаты заданы в километрах и не превышают 104 по модулю. Все точки, в которых расположены вышки, различны. Все числа в строках разделены пробелом.\nВыходные данные\nВ первой строке выходного файла OUTPUT.TXT выводится вещественное число — искомая мощность передатчиков. Во второй строке выводятся N чисел, где i-е число должно быть равно 1, если соответствующий передатчик должен вещать на первой частоте, и 2, если на второй. Ответ должен быть выведен с точностью, не меньшей 10–8.",
    "complexity": 62,
    "memory": 16000,
    "time": 1000,
    "examples": [
      {
        "input": "4\n0 0\n0 1\n1 0\n1 1",
        "output": "0.70710678118654752\n1 2 2 1"
      }
    ]
  },
  {
    "id": 498,
    "name": "K-перестановки",
    "description": "Назовем перестановку из N чисел 1…N K-перестановкой, если любые два соседних в ней элемента отличаются не более, чем на K.\nOUTPUT.TXT224 21212[Лучшие попытки]\nТребуется найти число K-перестановок из N чисел от 1 до N.\nВходные данные\nВходной файл INPUT.TXT содержит натуральные числа N и K (K ≤ N ≤ 9).\nВыходные данные\nВ выходной файл OUTPUT.TXT выведите целое число - ответ на задачу.",
    "complexity": 44,
    "memory": 16000,
    "time": 1000,
    "examples": [
      {
        "input": "3 1",
        "output": "2"
      },
      {
        "input": "4 2",
        "output": "12"
      }
    ]
  },
  {
    "id": 525,
    "name": "Сумма степеней двойки",
    "description": "Любое натуральное число можно представить в виде суммы натуральных слагаемых, каждое из которых является степенью числа 2. Суммы, различающиеся лишь порядком слагаемых, считаются одинаковыми. Например, для числа 7 таких представлений 6 (4+2+1, 4+1+1+1, 2+2+2+1, 2+2+1+1+1, 2+1+1+1+1+1, 1+1+1+1+1+1+1).\nOUTPUT.TXT42766[Лучшие попытки]\nТребуется написать программу, которая найдет количество способов такого представления заданного числа N.\nВходные данные\nВходной файл INPUT.TXT содержит число N (1 ≤ N ≤ 1000).\nВыходные данные\nВ выходной файл OUTPUT.TXT выведите одно число – найденное количество способов представления числа N.",
    "complexity": 43,
    "memory": 16000,
    "time": 1000,
    "examples": [
      {
        "input": "4",
        "output": "4"
      },
      {
        "input": "7",
        "output": "6"
      }
    ]
  },
  {
    "id": 524,
    "name": "Слон",
    "description": "На шахматной доске 8*8 клеток стоит слон (фигура, которая ходит по диагонали). \nOUTPUT.TXT22 221 1 3 3110[Лучшие попытки]\nТребуется написать программу, которая определит: сможет ли слон дойти до заданной клетки (x, y). Если сможет, то указать за какое наименьшее количество ходов. Если количество ходов больше одного, то указать через какие промежуточные клетки он должен пройти. Если таких маршрутов несколько, то указать любой из них.\n31 1 4 10\nВходные данные\nВходной файл INPUT.TXT содержит четыре числа m, n, x, y. (m, n) – координаты клетки, на которой находится слон, (x, y) – координаты клетки, на которую надо попасть. Числа m, n, x, y задаются в диапазоне от 1 до 8 и записываются через пробел.\nВыходные данные\nВыходной файл OUTPUT.TXT должен содержать в первой строке k – минимальное количество ходов, а далее в k-1 строках по 2 числа через пробел – координаты посещенных клеток. Если слон не может попасть на заданную клетку, то вывести 0.",
    "complexity": 34,
    "memory": 16000,
    "time": 1000,
    "examples": [
      {
        "input": "1 1 3 1",
        "output": "2\n2 2"
      },
      {
        "input": "1 1 3 3",
        "output": "1"
      },
      {
        "input": "1 1 4 1",
        "output": "0"
      }
    ]
  },
  {
    "id": 526,
    "name": "Уравнение по основанию",
    "description": "Запись AX обозначает, что A есть запись числа в системе счисления по основанию X. Если X\u003e10, то для записи числа используются кроме цифр от 0 до 9 заглавные английские буквы от A до Z. При этом условии X не может быть больше 36.\nOUTPUT.TXT1622012600[Лучшие попытки]\nТребуется написать программу, которая по заданным A и B найдет решение уравнения AX = B, либо сообщит об отсутствии у него решений.\nВходные данные\nВходной файл INPUT.TXT содержит в первой строке число A (непустую последовательность цифр от 0 до 9 и заглавных английских букв от A до Z без ведущих нулей), во второй число B (1 ≤ B ≤ 107).\nВыходные данные\nВ выходной файл OUTPUT.TXT выведите либо наименьшее основание системы счисления, удовлетворяющее уравнению, либо 0, если уравнение не имеет решений.",
    "complexity": 35,
    "memory": 16000,
    "time": 1000,
    "examples": [
      {
        "input": "A1\n161",
        "output": "16"
      },
      {
        "input": "201\n26",
        "output": "0"
      }
    ]
  },
  {
    "id": 536,
    "name": "Числа - 2",
    "description": "Решая задачу по информатике, Вова в очередной раз допустил ошибку. Он снова вывел в выходной файл числа, забыв разделить их пробелами. Увидев полученный результат, Вова сначала огорчился, а потом задумался над следующим вопросом: сколько существует различных последовательностей неотрицательных целых чисел, таких что, если выписать их без пробелов, то получится тот же результат, что и у него. Он вспомнил также, что его программа смогла вывести не произвольные числа, а только те, что не превосходят C и не имеют ведущих нулей. OUTPUT.TXT3219 9 10123456789876543210110[Лучшие попытки]\nЧтобы ответить на поставленный вопрос, Вова решил написать программу, которая позволит ему найти число различных последовательностей неотрицательных целых чисел, в каждой из которых любое число не превосходит C. Он понимал, что такое число могло быть достаточно большим, поэтому ограничился поиском только последних K цифр этого числа.31 8 390[Решение]\nТребуется написать программу, которая покажет Вове, как можно правильно решить поставленную им задачу.\nВходные данные\nПервая строка входного файла INPUT.TXT содержит три целых числа – N, C и K (1 ≤ N ≤ 50000, 1 ≤ C ≤ 108, 1 ≤ K ≤ 18). Во второй строке этого файла содержится результат работы Вовиной программы, состоящий из N цифр.\nВыходные данные\nВ выходной файл OUTPUT.TXT выведите последние K цифр искомого количества последовательностей без ведущих нулей.",
    "complexity": 45,
    "memory": 16000,
    "time": 1000,
    "examples": [
      {
        "input": "3 11 2\n111",
        "output": "3"
      },
      {
        "input": "19 9 1\n0123456789876543210",
        "output": "1"
      },
      {
        "input": "1 8 3\n9",
        "output": "0"
      }
    ]
  },
  {
    "id": 572,
    "name": "Технология программирования",
    "description": "Толик придумал новую технологию программирования. Он хочет уговорить друзей использовать ее. Однако все не так просто. i-й друг согласится использовать технологию Толика, если его авторитет будет не меньше ai (авторитет выражается целым числом). Как только он начнет ее использовать, к авторитету Толика прибавится число bi (попадаются люди, у которых bi \u003c 0). Помогите Толику наставить на путь истинный как можно больше своих друзей.\ni6OUTPUT.TXT4\n1 4 3 5[Лучшие попытки]\nВходные данные\nНа первой строке входного файла INPUT.TXT содержатся два числа: n (1 ≤  n ≤ 1000) – количество друзей у Толика, и первоначальный авторитет Толика . Следующие n строк содержат пары чисел ai и bi. Все числа целые, по модулю не больше 106.\nВыходные данные\nВ выходной файл OUTPUT.TXT выведите число m - максимальное число друзей, которых может увлечь Толик, и затем m чисел - номера друзей в том порядке, в котором их нужно агитировать.",
    "complexity": 60,
    "memory": 16000,
    "time": 1000,
    "examples": [
      {
        "input": "5 1\n\n1 3\n\n6 -5\n\n6 -4\n\n2 2\n\n2 -1",
        "output": "4\n\n1 4 3 5"
      }
    ]
  },
  {
    "id": 570,
    "name": "Квадрат",
    "description": "На сайте сотового оператора BeepLine сделали защиту от роботов, рассылающих SMS-сообщения: прежде, чем отправить SMS, пользователь должен написать, какую фигуру он видит в специальном окошке: квадрат или круг. Причем, для усиления защиты, в рисунок внесены небольшие помехи.\nOUTPUT.TXTSQUARE210 10\n..........\n..........\n..........\n....*.....\n..*****...\n..******..\n.******...\n..*****...\n..*.*.*...\n...*......SQUARESQUARECIRCLECIRCLE[Лучшие попытки]\nКоле срочно нужно разослать всем друзьям сообщение, поэтому он просит Вас написать программу, распознающую изображение.\n310 10\n..........\n..........\n..****....\n.******...\n******.**.\n********..\n********..\n.******...\n..****....\n....*.....CIRCLE\nЭкспериментально установлено, что система рисует квадрат с помехами следующим образом: сначала на белом фоне рисуется черный квадрат k×k клеток (k ≥ 3), затем некоторые клетки на границе квадрата (на рисунке обозначены цифрой 1) закрашиваются белым, а некоторые клетки (если таковые существуют), граничащие с квадратом (на рисунке обозначены цифрой 2), закрашиваются черным.\n43 3\n...\n...\n...CIRCLE\nНапример, квадрат 4×4 после нанесения помех может выглядеть так:\nВходные данные\nПервая строка входного файла INPUT.TXT содержит целые числа n и m - размеры экрана (1 ≤  n,m ≤ 1000). Следующие n строк, по m символов в каждой, содержат описание картинки. Черные клетки обозначены символом «*», а белые - символом «.».\nВыходные данные\nВ выходной файл OUTPUT.TXT выведите «SQUARE», если заданная картинка может быть квадратом после преобразований, описанных в условии, иначе выведите слово «CIRCLE».",
    "complexity": 43,
    "memory": 16000,
    "time": 1000,
    "examples": [
      {
        "input": "10 10\n\n..........\n\n..........\n\n..........\n\n..........\n\n..***.....\n\n..***.....\n\n..***.....\n\n..........\n\n..........\n\n..........",
        "output": "SQUARE"
      },
      {
        "input": "10 10\n\n..........\n\n..........\n\n..........\n\n....*.....\n\n..*****...\n\n..******..\n\n.******...\n\n..*****...\n\n..*.*.*...\n\n...*......",
        "output": "SQUARE"
      },
      {
        "input": "10 10\n\n..........\n\n..........\n\n..****....\n\n.******...\n\n******.**.\n\n********..\n\n********..\n\n.******...\n\n..****....\n\n....*.....",
        "output": "CIRCLE"
      },
      {
        "input": "3 3\n\n...\n\n...\n\n...",
        "output": "CIRCLE"
      }
    ]
  },
  {
    "id": 523,
    "name": "Роман в томах",
    "description": "В романе N глав. В i-той главе ai страниц. Требуется издать роман в K томах так, чтобы объем самого «толстого» тома был минимален. В каждом томе главы располагаются по порядку своих номеров.\nOUTPUT.TXT324\n1 2 1 1\n322[Лучшие попытки]\nТребуется написать программу, которая найдет количество страниц в самом «толстом» томе.\nВходные данные\nВходной текстовый файл INPUT.TXT содержит в первой строке число N (1 ≤ N ≤ 100). Во второй строке через пробел записаны N чисел – количество страниц в каждой главе. Количество страниц в романе не превышает 32767. В третьей строке записано число K (1 ≤ K ≤ N).\nВыходные данные\nВыходной файл OUTPUT.TXT должен содержать количество страниц в самом «толстом» томе.",
    "complexity": 41,
    "memory": 16000,
    "time": 1000,
    "examples": [
      {
        "input": "3\n\n1 2 1\n\n2",
        "output": "3"
      },
      {
        "input": "4\n\n1 2 1 1\n\n3",
        "output": "2"
      }
    ]
  },
  {
    "id": 571,
    "name": "Треугольники - 4",
    "description": "У Сени есть шоколадка, составленная из нескольких прилегающих друг к другу плиточек в форме правильных треугольников. Его брат Женя нашел эту шоколадку и решил сделать ее треугольной, съев все лишнее (ведь треугольные шоколадки намного вкуснее). Сколькими способами он может это сделать?\nOUTPUT.TXT8[Лучшие попытки]\nНапример, из такой шоколадки:\nможно сделать треугольную шоколадку со стороной 1 шестью способами или шоколадку со стороной 2 двумя способами. Итого восемь способов.\nВходные данные\nФорма шоколадки задается ее границей в порядке обхода по часовой стрелке. Первая строка входного файла INPUT.TXT содержит число n - количество отрезков на границе (1 ≤ n ≤ 5000). Далее n чисел от 1 до 6, задающих направление движения по границе (см. рисунок).\nВыходные данные\nВ выходной файл OUTPUT.TXT выведите одно число - количество способов.",
    "complexity": 86,
    "memory": 64000,
    "time": 1000,
    "examples": [
      {
        "input": "8\n1 1 3 2 4 4 6 5",
        "output": "8"
      }
    ]
  },
  {
    "id": 545,
    "name": "Задача Пифагора",
    "description": "Пифагор заказал ремесленнику изготовить несколько прямоугольных треугольников из ценных пород дерева для использования на занятиях по геометрии, но ремесленник перепутал размеры, и треугольники получились не прямоугольные. Чтобы не выбрасывать испорченный ценный материал, ремесленник решил переделать получившиеся треугольники в прямоугольные, постаравшись максимизировать их площади.\nOUTPUT.TXT25.00000[Лучшие попытки]\nТребуется написать программу, которая по размерам сторон треугольника находит максимальную площадь прямоугольного треугольника, который можно вырезать из этого треугольника.\nВходные данные\nВходной файл INPUT.TXT содержит в первой строке три числа, разделенных пробелами – длины сторон треугольника. Все числа вещественные, больше 0 и меньше 1000.\nВыходные данные\nВ выходной файл OUTPUT.TXT выведите максимальную площадь прямоугольного треугольника, получаемого из заданного треугольника, с точностью не хуже, чем 10-5.",
    "complexity": 48,
    "memory": 16000,
    "time": 1000,
    "examples": [
      {
        "input": "10.0 10.0 10.0",
        "output": "25.00000"
      }
    ]
  },
  {
    "id": 573,
    "name": "НЛО",
    "description": "В маленьком городке М начала действовать служба контроля за незаконными полетами НЛО. Первая задача службы - выяснить, сколько НЛО действует в окрестности города.\nOUTPUT.TXT2[Лучшие попытки]\nАгенты службы опросили множество свидетелей и составили список случаев встречи с НЛО, произошедших за одни сутки, с указанием места и времени наблюдения.\nТеперь аналитики хотят понять, сколько же на самом деле было НЛО. Из данных разведки известна максимальная скорость, с которой может лететь НЛО. Аналитики просят вас узнать, какое минимальное количество НЛО могли наблюдать свидетели.\nВходные данные\nНа первой строке входного файла INPUT.TXT содержатся целые числа n и v - количество случаев наблюдения и максимальная скорость НЛО (1 ≤ n ≤ 100, 1 ≤ v ≤ 10000). Следующие n строк содержат описания случаев встречи с НЛО в формате «ЧЧ:ММ x y», где ЧЧ:ММ – время встречи, x и y - координаты места, в котором наблюдался НЛО (для простоты будем считать, что все встречи происходили на плоскости). Координаты целые и по модулю не превышают 1000. Скорость выражена в км/ч, координаты - в км. Гарантируется, что во входных данных нет совпадающих записей.\nВыходные данные\nВ выходной файл OUTPUT.TXT выведите одно число - минимальное возможное количество НЛО.",
    "complexity": 77,
    "memory": 16000,
    "time": 1000,
    "examples": [
      {
        "input": "4 1\n\n12:00 0 0\n\n13:10 0 1\n\n14:00 1 0\n\n15:00 1 1",
        "output": "2"
      }
    ]
  },
  {
    "id": 543,
    "name": "Монеты - 2",
    "description": "В N корзинах находятся золотые монеты. Корзины пронумерованы числами от 1 до N. Во всех корзинах, кроме одной, монеты весят по w граммов. В одной корзине монеты фальшивые и весят w–d граммов. Волшебник берет 1 монету из первой корзины, 2 монеты из второй корзины, и так далее, и, наконец, N-1 монету из (N-1)-й корзины. Из N-й корзины он не берет ничего. Он взвешивает взятые монеты и сразу указывает на корзину с фальшивыми монетами.\nOUTPUT.TXT2210 25 8 1125101050[Лучшие попытки]\nТребуется написать программу, которая выполняет это волшебство.\n38000 30 12 95987940050[Решение]\nВходные данные\nВходной файл INPUT.TXT содержит четыре целых числа: N, w, d и P – суммарного веса отобранных монет (2 ≤ N ≤ 8000, 1 ≤ d \u003c w ≤ 30).\nВыходные данные\nВ выходной файл OUTPUT.TXT выведите номер корзины с фальшивыми монетами.",
    "complexity": 26,
    "memory": 16000,
    "time": 1000,
    "examples": [
      {
        "input": "10 25 8 1109",
        "output": "2"
      },
      {
        "input": "10 25 8 1125",
        "output": "10"
      },
      {
        "input": "8000 30 12 959879400",
        "output": "50"
      }
    ]
  },
  {
    "id": 548,
    "name": "Минимальное число",
    "description": "Требуется написать программу, которая из цифр двух натуральных чисел создает наименьшее возможное число, сохраняя при этом порядок следования цифр в этих числах.\nOUTPUT.TXT12345[Лучшие попытки]\nВходные данные\nВходной файл INPUT.TXT содержит два натуральных числа, записанных в двух строках. Числа больше нуля и меньше 10255.\nВыходные данные\nВ единственную строку выходного файла OUTPUT.TXT нужно вывести наименьшее возможное число, удовлетворяющее условию задачи.",
    "complexity": 35,
    "memory": 16000,
    "time": 1000,
    "examples": [
      {
        "input": "125\n34",
        "output": "12345"
      }
    ]
  },
  {
    "id": 544,
    "name": "Мячик на лестнице",
    "description": "На вершине лесенки, содержащей N ступенек, находится мячик, который начинает прыгать по ним вниз, к основанию. Мячик может прыгнуть на следующую ступеньку, на ступеньку через одну или через две. То есть, если мячик лежит на 8-ой ступеньке, то он может переместиться на 5-ую, 6-ую или 7-ую.\nOUTPUT.TXT12477[Лучшие попытки]\nТребуется написать программу, которая определит число всевозможных \"маршрутов\" мячика с вершины на землю.\nВходные данные\nВходной файл INPUT.TXT содержит число N (0 \u003c N ≤ 70).\nВыходные данные\nВыходной файл OUTPUT.TXT должен содержать искомое число.",
    "complexity": 42,
    "memory": 16000,
    "time": 1000,
    "examples": [
      {
        "input": "1",
        "output": "1"
      },
      {
        "input": "4",
        "output": "7"
      }
    ]
  },
  {
    "id": 547,
    "name": "Период дроби",
    "description": "Рассмотрим дробь 1/n, n\u003e1. Как известно, цифры в её десятичной записи начиная с некоторого места повторяются. Минимальную по длине повторяющуюся (без промежутков) часть называют периодом. Минимальную по длине часть после запятой, которая не входит ни в один период, называют предпериодом. Например:\nOUTPUT.TXT0 1251 11 12 6[Лучшие попытки]\nn=3: 1/3=0,(3), предпериод пустой '', его длина 0, период '3', его длина 1; \n3282 6\nn=5: 1/5=0,2(0), предпериод '2', длина 1, период '0', длина 1;\nn=28: 1/28=0,03(571428), предпериод '03', длина 2, период '571428', длина 6.\nТребуется написать программу, которая по заданному n найдет длину предпериода и длину периода у дроби 1/n.\nВходные данные\nВходной файл INPUT.TXT содержит одно натуральное число n (2 ≤ n ≤ 106).\nВыходные данные\nВыходной файл OUTPUT.TXT должен содержать два числа – сначала длина предпериода, потом длина периода дроби 1/n. Числа отделить друг от друга пробелом.",
    "complexity": 35,
    "memory": 16000,
    "time": 1000,
    "examples": [
      {
        "input": "3",
        "output": "0 1"
      },
      {
        "input": "5",
        "output": "1 1"
      },
      {
        "input": "28",
        "output": "2 6"
      }
    ]
  },
  {
    "id": 546,
    "name": "Печать буклета",
    "description": "Когда происходит печать документа, обычно первая страница печатается первой, вторая - второй, третья - третьей и так далее до конца. Но иногда при создании буклета на одном листе печатаются четыре страницы: две - на лицевой стороне и две - на обратной. Когда вы сложите все листы по порядку и согнете их пополам, страницы будут идти в правильном порядке, как у обычной книги. Например, 4-страничный буклет должен быть напечатан на одном листе бумаги: лицевая сторона должна содержать сначала страницу 4, потом - 1, обратная - 2 и 3.\nOUTPUT.TXT1 1 4 1\n1 2 2 3[Лучшие попытки]\nЕсли в буклете число страниц не кратно четырем, то в конце можно добавить несколько пустых страниц, но так, чтобы количество листов бумаги при этом было минимально возможным.\nТребуется написать программу, которая по заданному числу страниц в буклете генерирует порядок его печати.\nВходные данные\nВо входном файле INPUT.TXT записано количество страниц в буклете - натуральное число, не превышающее 500.\nВыходные данные\nВ выходной файл OUTPUT.TXT необходимо выдать порядок печати данного буклета - последовательность команд, каждая из которых располагается в отдельной строке и состоит из четырех чисел. Числа разделяются пробелом и обозначают следующее: номер листа, на котором происходит печать, сторону: 1 - если печать происходит на лицевой стороне, и 2 - если на обратной, два оставшихся числа - номера страниц буклета, которые должны быть напечатаны с левой и правой сторон.\nПустая страница задается числом 0. Если целая сторона должна быть оставлена пустой, команду для ее печати выводить не обязательно.",
    "complexity": 29,
    "memory": 16000,
    "time": 1000,
    "examples": [
      {
        "input": "4",
        "output": "1 1 4 1\n\n1 2 2 3"
      }
    ]
  },
  {
    "id": 500,
    "name": "Агент",
    "description": "Агент Джеймс Бонд пошел на пенсию, но неугомонный характер требовал новых впечатлений. Поэтому Джеймс Бонд с удовольствием согласился провести мастер-класс в некоторых группах школы «Молодого агента». Тема одного из занятий – работа агента с напарником. В таком опасном деле, как разведка, важно иметь очень надёжного напарника, поэтому напарниками могут стать только агенты, которые максимально близки по возрасту (т.е. два агента не могут стать напарниками, если в группе существует третий агент, который старше одного и младше другого). \nOUTPUT.TXT5255005 1 5004 2 5003 3 5002 4 5001 577[Лучшие попытки]\nЗадание Бонда состоит в том, чтобы агенты нашли друг другу напарников таким образом, чтобы у каждого агента был хотя бы один напарник (всего у агента может быть 2 напарника – один младше, и один старше него, но эти двое не считаются напарниками между собой). Очевидно, что группа из 4 и более агентов может поделиться несколькими способами.\nПосле нескольких занятий Бонд узнал способности групп, обучающихся в школе «Молодого агента», и оценил риск раскрытия каждого агента в отдельности. Но специфика работы с напарником такова, что в паре риску подвергается только старший из двух агентов, поэтому группу надо распределить так, чтобы суммарный риск был минимален.\nВходные данные\nВ первой строке входного файла INPUT.TXT находится одно целое число N – количество агентов в группе (2 ≤ N ≤ 10000). Во второй строке находятся N пар целых положительных чисел, разделенных пробелом. Первое число в паре – это возраст агента (в днях) из диапазона [5000, 16000], второе – риск раскрытия агента, число в диапазоне [1, 1000]. Известно, что в любой группе все агенты разного возраста.\nВыходные данные\nВ выходной файл OUTPUT.TXT выведите единственное число – минимальное значение суммарного риска раскрытия группы.",
    "complexity": 34,
    "memory": 16000,
    "time": 1000,
    "examples": [
      {
        "input": "3\n6000 2 5500 3 5000 4",
        "output": "5"
      },
      {
        "input": "5\n5005 1 5004 2 5003 3 5002 4 5001 5",
        "output": "7"
      }
    ]
  },
  {
    "id": 579,
    "name": "Модуль суммы",
    "description": "Дана последовательность целых чисел. Требуется найти подпоследовательность заданной последовательности с максимальным модулем суммы входящих в нее чисел. Напомним, что модуль целого числа x равняется x, если x ≥ 0 и -x, если x \u003c 0.\nOUTPUT.TXT22 4[Лучшие попытки]\nВходные данные\nПервая строка входного файла INPUT.TXT содержит натуральное число n (1 ≤  n ≤ 10000) - длину последовательности. Во второй строке записаны n целых чисел, по модулю не превосходящих 10000.\nВыходные данные\nВ первой строке выходного файла OUTPUT.TXT выведите длину k выбранной вами подпоследовательности. Во второй строке должны быть записаны k различных чисел, разделенных пробелами - номера выбранных членов последовательности.",
    "complexity": 25,
    "memory": 16000,
    "time": 1000,
    "examples": [
      {
        "input": "5\n-1 4 -1 6 -7",
        "output": "2\n2 4"
      }
    ]
  },
  {
    "id": 575,
    "name": "Строительство",
    "description": "OUTPUT.TXT4.56[Лучшие попытки]\nФирма, в которой вы работаете, исполняет проект строительства суперсовременного бизнес-центра. И вот, когда заказ на склад строительных материалов почти готов к подписанию директором, оказывается, что туда забыли включить некоторые товары. Конкретно, в нем не были предусмотрены материалы, необходимые для возведения стен между отдельными секциями в подвальных помещениях. Необходимо срочно написать программу, которая сможет рассчитать необходимое количество материалов.\nНа плане подвальный этаж имеет вид прямоугольника, стороны которого лежат на линиях сетки с квадратными клетками. Сетка имеет такой масштаб, что сторона клетки соответствует одному метру стены подвального этажа. Каждая клетка на плане целиком принадлежит одному из помещений. Для каждой пары соседних по стороне клеток, отнесенных к разным помещениям, вдоль всей их общей стороны должна быть возведена стена толщиной 20 сантиметров и высотой три метра. Материалы для постройки всех внешних стен подвального этажа уже включены в заказ.\nВходные данные\nПервая строка входного файла INPUT.TXT содержит два целых числа N и M (1 ≤  N, M ≤ 100), разделенных пробелами - размеры подвала на плане. Каждая из N последующих строк содержит по M натуральных чисел, не превосходящих M x N, задающих номер помещения, к которому относится данная клетка. Эти числа разделены пробелами.\nВыходные данные\nВ выходной файл OUTPUT.TXT выведите одно вещественное число с точностью не менее 0.001 - общий объем возводимых стен в кубических метрах.",
    "complexity": 41,
    "memory": 16000,
    "time": 1000,
    "examples": [
      {
        "input": "3 4\n\n1 1 3 3\n\n1 2 2 3\n\n2 2 3 3",
        "output": "4.56"
      }
    ]
  },
  {
    "id": 576,
    "name": "Гадание - 2",
    "description": "Маша недавно прочитала в книге «Теория чисел и предсказание будущего» о новом способе гадания. Способ заключается в следующем: надо выбрать целое положительное число N и посчитать количество чисел, меньших N и взаимно простых с ним. Это количество и будет результатом гадания.\nOUTPUT.TXT122622[Лучшие попытки]\nПоскольку гадать приходится достаточно часто, а процесс гадания достаточно трудоемок, Маша попросила вас написать программу, считающую результат гадания.\nДва числа называются взаимно простыми, если их наибольший общий делитель равен 1. Наибольшим общим делителем двух чисел a и b называется наибольшее целое положительное число, на которое делятся и a, и b.\nВходные данные\nВходной файл INPUT.TXT содержит целое положительное число N (1 ≤ N ≤ 105).\nВыходные данные\nВ выходной файл OUTPUT.TXT выведите одно число – результат гадания.",
    "complexity": 20,
    "memory": 16000,
    "time": 1000,
    "examples": [
      {
        "input": "13",
        "output": "12"
      },
      {
        "input": "6",
        "output": "2"
      }
    ]
  },
  {
    "id": 510,
    "name": "Шоколадка",
    "description": "Саша, не сделал домашнюю работу, зато купил шоколадку. И, по глупости, начал распечатывать ее прямо на уроке... Шелест золотинки услышала учительница. Она хотела вызвать в школу родителей, но Саша уговорил ее не вызывать их, а дать дополнительное задание.\nOUTPUT.TXT3241111[Лучшие попытки]\nУчительница внимательно посмотрела на шоколадку (она была размером 3х4 плиток), разделила на кусочки по две плитки и угостила всех, кто сделал домашнюю работу. А Сашу попросила написать программу, которая определяет, сколько существует способов деления шоколадки размером 3×N плиток на кусочки по две плитки.\nДля выполнения задания Саше нужна помощь.\nВходные данные\nВходной файл INPUT.TXT содержит натуральное число N – размер плитки, (N \u003c 33).\nВыходные данные\nВ выходной файл OUTPUT.TXT выведите одно целое число – количество возможных способов.",
    "complexity": 40,
    "memory": 16000,
    "time": 1000,
    "examples": [
      {
        "input": "2",
        "output": "3"
      },
      {
        "input": "4",
        "output": "11"
      }
    ]
  },
  {
    "id": 577,
    "name": "Таблица умножения",
    "description": "Большой любитель математики Вова решил повесить у себя в комнате таблицу умножения. После некоторых раздумий он обнаружил, что обычная таблица умножения 10 на 10 уже не популярна в наши дни. Он решил повесить у себя в комнате таблицу N на M. Представив себе эту таблицу, Вова задался вопросом - сколько раз в ней встречается каждая из цифр от 0 до 9?\nOUTPUT.TXT28242715\n2315178156[Лучшие попытки]\nИ прежде чем нарисовать эту таблицу Вова попросил вас написать программу, которая даст ответ на его вопрос.\n[Решение]\nКак известно, в таблице умножения на пересечении строки i и столбца j записано число i∙j.\nВходные данные\nВходной файл INPUT.TXT состоит из единственной строки, на которой через пробел записаны два натуральных числа N и M (1 ≤  N, M ≤ 1000).\nВыходные данные\nВыходной файл OUTPUT.TXT должен состоять из десяти строк. На строке i выведите количество раз, которое Вове придется нарисовать цифру i - 1.",
    "complexity": 20,
    "memory": 16000,
    "time": 1000,
    "examples": [
      {
        "input": "10 10",
        "output": "28\n24\n27\n15\n\n23\n15\n17\n8\n15\n6"
      }
    ]
  },
  {
    "id": 581,
    "name": "Атака летающих тарелок",
    "description": "Вы работаете в фирме, занимающейся разработкой компьютерных игр. Сейчас вы занимаетесь разработкой новой компьютерной игры \"Атака летающих тарелок\". По сюжету игры на планету Зумла приземляются летающие тарелки, и их надо уничтожать. Игрок управляет лазерной пушкой. Для того, чтобы произвести выстрел он указывает две точки на поверхности Зумлы (которая в игре считается плоской), через которые должен проходить лазерный луч (который является прямой). \n2OUTPUT.TXT21 2[Лучшие попытки]\nВы должны написать программу, определяющую, какие летающие тарелки были уничтожены выстрелом.\n2\nВходные данныеi\nПервая строка входного файла INPUT.TXT содержит целое число n (1 ≤ n ≤ 30000) - число приземлившихся летающих тарелок. Вторая строка содержит числа xp1, yp1, xp2, yp2 - координаты точек, через которые проходит лазерный луч. Далее идут n строк, каждая из которых содержит описание одной летающей тарелки в формате xi yi ri, где xi, yi - координаты центра, ri - радиус тарелки. Все числа целые и не превосходят по модулю 10000. Радиусы летающих тарелок - целые и положительные. Летающие тарелки могут касаться и пересекаться.\ni\niВыходные данные\ni\nВ первую строку выходного файла OUTPUT.TXT выведите количество уничтоженных летающих тарелок. Во вторую строку выведите номера уничтоженных летающих тарелок в возрастающем порядке. Тарелка считается уничтоженной, если она имеет, хотя бы одну общую точку с лазерным лучом.\niПример\ni\n№INPUT.TXTOUTPUT.TXT\n12\n0 0 1 1\n2 2 100\n1000 1000 121 2\nДля отправки решения задачи необходимо зарегистрироваться и авторизоваться!\n[Обсуждение]\n\n  [Все попытки]\n\n  [Лучшие попытки]\nwindow.yaContextCb.push(()=\u003e{\n  Ya.Context.AdvManager.render({\n    renderTo: 'yandex_rtb_R-A-122393-3',\n    blockId: 'R-A-122393-3'\n  })\n})",
    "complexity": 36,
    "memory": 16000,
    "time": 1000,
    "examples": [
      {
        "input": "2\n\n0 0 1 1\n\n2 2 100\n\n1000 1000 1",
        "output": "2\n1 2"
      }
    ]
  },
  {
    "id": 580,
    "name": "Поднос",
    "description": "Школьная столовая хочет заказать новые треугольные подносы. Естественно, был организован тендер. Основным критерием отбора предложений является условие того, что имеющиеся в столовой круглые тарелки должны помещаться на новые подносы.\nOUTPUT.TXTNO23 4 51YESYES[Лучшие попытки]\nДиректор школы дал вам задание написать программу, проверяющую, помещается ли тарелка данного размера на поднос с данными длинами сторон.\nВходные данные\nВ первой строке входного файла INPUT.TXT находятся 3 целых положительных числа - длины сторон подноса. Гарантируется, что поднос с такими сторонами существует. Во второй строке входного файла содержится радиус тарелки - целое положительное число. Все числа во входном файле не превосходят 100. Радиус тарелки и стороны подноса указаны в одних и тех же единицах измерения.\nВыходные данные\nВыведите в выходной файл OUTPUT.TXT сообщение YES, если тарелка помещается на поднос, и NO - в противном случае.",
    "complexity": 34,
    "memory": 16000,
    "time": 1000,
    "examples": [
      {
        "input": "1 1 1\n1",
        "output": "NO"
      },
      {
        "input": "3 4 5\n1",
        "output": "YES"
      }
    ]
  },
  {
    "id": 578,
    "name": "Система счисления",
    "description": "Вчера на уроке математики Саша узнал о том, что иногда полезно использовать вместо десятичной системы счисления какую-нибудь другую.\nOUTPUT.TXT21222211211[Лучшие попытки]\nОднако, учительница не объяснила, почему в системе счисления по основанию b в качестве цифр выбирают числа от 0 до b - 1.\nНемного подумав, Саша понял, что можно выбирать и другие наборы цифр. Например, вместо троичной системы счисления можно рассмотреть систему счисления, где вместо обычных цифр 0, 1, 2 есть цифры 1, 2 и 3.\nСаша заинтересовался вопросом, а как перевести число n в эту систему счисления? Например, число 7 в этой системе записывается как 21, так как 7 = 2∙3+1, а число 22 записывается как 211, так как 22 = 2 ∙ 9 + 1 ∙ 3 + 1.\nВходные данные\nВходной файл INPUT.TXT содержит натуральное число n, 1 ≤ n ≤ 2•109.\nВыходные данные\nВ выходной файл OUTPUT.TXT выведите число n записанное в указанной системе счисления.",
    "complexity": 37,
    "memory": 16000,
    "time": 1000,
    "examples": [
      {
        "input": "7",
        "output": "21"
      },
      {
        "input": "22",
        "output": "211"
      }
    ]
  },
  {
    "id": 574,
    "name": "Анаграммы",
    "description": "Cтрока S1 называется анаграммой строки S2, если она получается из S2 перестановкой символов. Даны строки S1 и S2. Напишите программу, которая проверяет, является ли S1 анаграммой S2.\nOUTPUT.TXTNO2ABBABABAYESYES[Лучшие попытки]\nВходные данные\nПервая строка входного файла INPUT.TXT содержит строку S1, вторая - S2. Обе строки состоят только из прописных букв английского алфавита. Строки не пусты и имеют длину не больше 100000 символов.\nВыходные данные\nВ выходной файл OUTPUT.TXT выведите YES, если S1 является анаграммой S2, и NO - в противном случае.",
    "complexity": 26,
    "memory": 16000,
    "time": 1000,
    "examples": [
      {
        "input": "ABAA\nABBA",
        "output": "NO"
      },
      {
        "input": "ABBA\nBABA",
        "output": "YES"
      }
    ]
  },
  {
    "id": 582,
    "name": "Кубик",
    "description": "Все мы в детстве играли в кубики. Были у нас и кубики с цифрами, и кубики с буквами. Были также и разноцветные кубики. Маленький Андрюша тоже любит играть в кубики. У него есть несколько наборов кубиков, причем все кубики из одного набора раскрашены одинаково, а кубики из разных наборов - по-разному.\nOUTPUT.TXTYES21 2 3 4 5 61 1 1 1 1 1NONOYES[Лучшие попытки]\nНа столе у Андрюши лежат два кубика. Помогите ему определить, принадлежат они одному набору или нет. Стол у Андрюши стеклянный, поэтому он видит цвета всех граней кубика. Кубики принадлежат одному набору, если один из них можно комбинацией поворотов вокруг осей, проходящих через середины противоположных граней, перевести в другой.\n31 2 3 4 5 65 6 3 4 2 1YES\nВходные данные\nПервая строка входного файла INPUT.TXT содержит описание первого кубика в формате: цвет передней грани, цвет задней грани, цвет верхней грани, цвет нижней грани, цвет левой грани, цвет правой грани. Во второй строке находится описание второго кубика в таком же формате. Цвета граней кодируются числами. Все числа во входном файле - целые, положительные и не превосходят 100.\nВыходные данные\nВ выходной файл OUTPUT.TXT выведите «YES», если первый и второй кубики принадлежат одному набору, и «NO» - в противном случае.",
    "complexity": 47,
    "memory": 16000,
    "time": 1000,
    "examples": [
      {
        "input": "1 2 3 4 5 6\n1 2 3 4 5 6",
        "output": "YES"
      },
      {
        "input": "1 2 3 4 5 6\n1 1 1 1 1 1",
        "output": "NO"
      },
      {
        "input": "1 2 3 4 5 6\n5 6 3 4 2 1",
        "output": "YES"
      }
    ]
  },
  {
    "id": 531,
    "name": "Газон",
    "description": "OUTPUT.TXT14[Лучшие попытки]\nФермер Иван с юности следит за своим газоном. Газон можно считать плоскостью, на которой в каждой точке с целыми координатами растет один пучок травы.\n[Решение]\nВ одно из воскресений Иван воспользовался газонокосилкой и постриг некоторый прямоугольный участок газона. Стороны этого участка параллельны осям координат, а две противоположные вершины расположены в точках (x1, y1) и (x2, y2). Следует отметить, что пучки травы, находящиеся на границе этого прямоугольника, также были пострижены.\nДовольный результатом Иван купил и установил на газоне дождевальную установку. Она была размещена в точке с координатами (x3, y3) и имела радиус действия струи r. Таким образом, установка начала поливать все пучки, расстояние от которых до точки (x3, y3) не превышало r.\nВсе было хорошо, но Ивана заинтересовал следующий вопрос: сколько пучков травы оказалось и пострижено, и полито в это воскресенье?\nТребуется написать программу, которая позволит дать ответ на вопрос Ивана.\nВходные данные\nПервая строка входного файла INPUT.TXT содержит четыре целых числа x1, y1, x2, y2 (−100 000 ≤ x1 \u003c x2 ≤ 100 000; −100 000 ≤ y1 \u003c y2 ≤ 100 000). Во второй строке записаны три целых числа x3, y3, r (−100 000 ≤ x3, y3 ≤ 100 000; 1 ≤ r ≤ 100 000)\nВыходные данные\nВ выходной файл OUTPUT.TXT необходимо вывести одно целое число – число пучков травы, которые были и пострижены, и политы.",
    "complexity": 36,
    "memory": 16000,
    "time": 1000,
    "examples": [
      {
        "input": "0 0 5 4\n4 0 3",
        "output": "14"
      }
    ]
  },
  {
    "id": 529,
    "name": "Длина отрезка",
    "description": "2OUTPUT.TXT5[Лучшие попытки]\nОтрезок задан координатами своих концевых точек. Требуется вычислить длину этого отрезка. \n2[Решение]\nВходные данные\nПервая строка входного файла INPUT.TXT содержит координаты концов отрезка в формате X1 Y1 X2 Y2 . Все координаты – целые числа, не превышающие 1000 по абсолютной величине.\nВыходные данные\nВ выходной файл OUTPUT.TXT выведите длину отрезка с точностью 10-5.",
    "complexity": 12,
    "memory": 16000,
    "time": 1000,
    "examples": [
      {
        "input": "3 4 8 4",
        "output": "5"
      }
    ]
  },
  {
    "id": 501,
    "name": "Строение",
    "description": "Администрация города подбирает площадку для строительства новых спортивных сооружений. На рассмотрении несколько проектов, каждый проект требует выделения  некоторого прямоугольного участка земли. Некоторые участки оказались частично или полностью в пользовании частными лицами, а в случае утверждения проекта администрация будет вынуждена выкупить этот участок, поэтому для определения стоимости очень важно знать площадь пересечения участков. Участки частников также прямоугольной формы (рис. 1) и стороны всех участков параллельны координатным осям. Для каждого проекта был построен план, включающий подобранный участок и его окружение. В приведенном примере показано пересечение участков частников (тонкая линия) с участком, подобранным для строительства (толстая линия). Помогите определить суммарную площадь пересечения участков частников с участком, выбранным для строительства. При этом следует учесть, что выкупаемая земля может принадлежать сразу нескольким участникам и в этом случае необходимо выкупать землю многократно (одна и та же площадь земли может быть посчитана несколько раз).\n2OUTPUT.TXT2522\n15 15 25 25\n5  5  12 12\n10 10 20 202929[Лучшие попытки]\n2\nВходные данные\nВ первой строке входного файла INPUT.TXT содержится число N - количество участков частников, отображенных на плане. Затем следуют N строк с координатами двух вершин этих прямоугольных участков. В последней строке плана координаты участка, подобранного для строительства. Координаты противоположных вершин одного прямоугольника описываются в формате X1 Y1 X2 Y2. Координатами вершин являются целые, неотрицательные числа, не больше 100. Количество исходных прямоугольников не больше 20.\nВыходные данные\nВ единственную строку выходного файла OUTPUT.TXT следует вывести одно целое число – искомую суммарную площадь пересечения прямоугольников.",
    "complexity": 25,
    "memory": 16000,
    "time": 1000,
    "examples": [
      {
        "input": "1\n\n15 15 25 25\n\n10 10 20 20",
        "output": "25"
      },
      {
        "input": "2\n\n15 15 25 25\n\n5  5  12 12\n\n10 10 20 20",
        "output": "29"
      }
    ]
  },
  {
    "id": 528,
    "name": "Замок",
    "description": "OUTPUT.TXT28[Лучшие попытки]\nЗамок состоит из K уровней. Каждый уровень - это правильный N-угольник, угол которого совпадает с углом предыдущего. На сторонах первого уровня находится по две комнаты (в углах), на сторонах каждого следующего - на одну больше. Сколько в замке комнат?\n[Решение]\nВходные данные\nВ первой строке входного файла INPUT.TXT указаны два целых числа N и K \n(3 ≤ N ≤ 106; 1 ≤ K ≤ 106).\nВыходные данные\nВ выходной файл OUTPUT.TXT выведите целое число - количество комнат в замке.",
    "complexity": 29,
    "memory": 16000,
    "time": 1000,
    "examples": [
      {
        "input": "6 3",
        "output": "28"
      }
    ]
  },
  {
    "id": 583,
    "name": "Рисование",
    "description": "При обучении школьников младших классов программированию часто используется язык «Лого», позволяющий рисовать на экране картинки хвостом виртуальной черепашки.\n\"r\" - повернуть направо.OUTPUT.TXTTRUE[Лучшие попытки]\nРассмотрим упрощенную версию этого языка, в которой разрешается подавать черепашке следующие команды: переместиться вперед на некоторое количество сантиметров, рисуя за собой линию, повернуть налево на 90 градусов и повернуть направо на 90 градусов.\nРассмотрим замкнутую фигуру, нарисованную таким образом. Требуется проверить, верно ли, что любой вертикальный и любой горизонтальный отрезок, соединяющий две точки фигуры, полностью содержится внутри этой фигуры.\nВходные данные\nПервая строка входного файла INPUT.TXT содержит число n - количество команд черепашки, использованных для рисования фигуры (7 ≤ n ≤ 40 000). Следующие n строк содержат команды. Команды задаются следующим образом:\n\"f x\" - переместиться вперед на x сантиметров (x - натуральное число);\n\"l\" - повернуть налево;\n\"r\" - повернуть направо.\nИзвестно, что последовательность команд начинается с команды перемещения, не выполняется подряд две команды поворота или две команды перемещения, последняя команда также является командой перемещения.\nГарантируется, что ломаную можно поместить в некоторый прямоугольник, длины сторон которого не превосходят 109.\nВыходные данные\nВ выходной файл OUTPUT.TXT выведите «TRUE», если нарисованная фигура удовлетворяет описанному выше свойству и «FALSE», если не удовлетворяет.",
    "complexity": 65,
    "memory": 16000,
    "time": 1000,
    "examples": [
      {
        "input": "11\n\nf 1\n\nr\n\nf 2\n\nr\n\nf 2\n\nr\n\nf 1\n\nr\n\nf 1\n\nl\n\nf 1",
        "output": "TRUE"
      }
    ]
  },
  {
    "id": 534,
    "name": "Клавиатура - 2",
    "description": "Всем известно, что со временем клавиатура изнашивается, и клавиши на ней начинают залипать. Конечно, некоторое время такую клавиатуру еще можно использовать, но для нажатий клавиш приходиться использовать большую силу. \nNOUTPUT.TXTyes\nno\nno\nno\nyes\n[Лучшие попытки]\nПри изготовлении клавиатуры изначально для каждой клавиши задается количество нажатий, которое она должна выдерживать. Если знать эти величины для используемой клавиатуры, то для определенной последовательности нажатых клавиш можно определить, какие клавиши в процессе их использования сломаются, а какие – нет. \ni[Решение]\nТребуется написать программу, определяющую, какие клавиши сломаются в процессе заданного варианта эксплуатации клавиатуры.\ni\nВходные данныеj\nПервая строка входного файла INPUT.TXT содержит целое число N (1 ≤ N ≤ 100) – количество клавиш на клавиатуре. Вторая строка содержит N целых чисел – с1, с2, … , сN, где сi (1 ≤ сi ≤ 100000) – количество нажатий, выдерживаемых i-ой клавишей. Третья строка содержит целое число K (1 ≤ K ≤ 100000) – общее количество нажатий клавиш, и последняя строка содержит K целых чисел pj (1 ≤ pj ≤ N) – последовательность нажатых клавиш.\nj\nВыходные данные\nВ выходной файл OUTPUT.TXT необходимо вывести N строк, содержащих информацию об исправности клавиш. Если i-ая клавиша сломалась, то i-ая строка должна содержать слово \"yes\" (без кавычек), если же клавиша работоспособна – слово \"no\".",
    "complexity": 25,
    "memory": 16000,
    "time": 1000,
    "examples": [
      {
        "input": "5\n\n1 50 3 4 3\n\n16\n\n1 2 3 4 5 1 3 3 4 5 5 5 5 5 4 5",
        "output": "yes\n\nno\n\nno\n\nno\n\nyes"
      }
    ]
  },
  {
    "id": 527,
    "name": "Алгоритм Евклида",
    "description": "Дима недавно начал изучать информатику. Одним из первых алгоритмов, который он изучил, был алгоритм Евклида для нахождения наибольшего общего делителя (НОД) двух чисел. Напомним, что наибольшим общим делителем двух чисел a и b называется наибольшее натуральное число x, такое, что и число a, и число b делится на него без остатка.\nЕсли b \u003e a, то необходимо поменять местами числа a и b.OUTPUT.TXTYESNO[Лучшие попытки]\nАлгоритм Евклида заключается в следующем:\nПрисвоить числу a значение a – b.[Решение]\nПусть a, b – числа, НОД которых надо найти.\nЕсли b = 0, то число a – искомый НОД.\nЕсли b \u003e a, то необходимо поменять местами числа a и b.\nПрисвоить числу a значение a – b.\nВернуться к шагу 2.\nВернуться к шагу 2.\nДима достаточно быстро освоил алгоритм Евклида и вычислил с его помощью много наибольших общих делителей. Поняв, что надо дальше совершенствоваться, ему пришла идея решить новую задачу. Пусть заданы числа a, b, c и d. Требуется узнать, наступит ли в процессе реализации алгоритма Евклида для заданной пары чисел (a, b) такой момент, когда число a будет равно c, а число b будет равно d.\nТребуется написать программу, которая решает эту задачу.\nВходные данные\nПервая строка входного файла INPUT.TXT содержит количество наборов входных данных k (1 ≤ k ≤ 100). Далее идут описания этих наборов. Каждое описание состоит из двух строк. Первая из них содержит два целых числа: a, b (1 ≤ a, b ≤ 1018). Вторая строка – два целых числа: c, d (1 ≤ c, d ≤ 1018).\nВыходные данные\nДля каждого набора входных данных выведите в отдельной строке выходного файла OUTPUT.TXT слово «YES», если в процессе применения алгоритма Евклида к паре чисел (a, b) в какой-то момент получается пара (c, d), или слово «NO» – в противном случае.",
    "complexity": 40,
    "memory": 16000,
    "time": 1000,
    "examples": [
      {
        "input": "2\n20 10\n10 10\n10 7\n2 4",
        "output": "YES\nNO"
      }
    ]
  },
  {
    "id": 533,
    "name": "Треугольники - 3",
    "description": "Петя достаточно давно занимается в математическом кружке, поэтому он уже успел освоить не только правила выполнения простейших операций, но и такое достаточно сложное понятие как симметрия. Для того, чтобы получше изучить симметрию Петя решил начать с наиболее простых геометрических фигур – треугольников. Он скоро понял, что осевой симметрией обладают так называемые равнобедренные треугольники. Поэтому теперь Петя ищет везде такие треугольники.9OUTPUT.TXT124\n0 0\n1 1\n1 0\n0 1\n44[Лучшие попытки]\nНапомним, что треугольник называется равнобедренным, если его площадь положительна, и у него есть хотя бы две равные стороны.\nНедавно Петя, зайдя в класс, увидел, что на доске нарисовано n точек. Разумеется, он сразу задумался, сколько существует троек из этих точек, которые являются вершинами равнобедренных треугольников.\nТребуется написать программу, решающую указанную задачу.\nВходные данные\nВходной файл INPUT.TXT содержит целое число N (3 ≤ N ≤ 1500). Каждая из последующих строк содержит по два целых числа – xi и yi – координаты i-ой точки. Координаты точек не превосходят 109 по абсолютной величине. Среди заданных точек нет совпадающих.\nВыходные данные\nВ выходной файл OUTPUT.TXT выведите ответ на задачу.",
    "complexity": 66,
    "memory": 16000,
    "time": 1000,
    "examples": [
      {
        "input": "3\n\n0 0\n\n2 2\n\n-2 2",
        "output": "1"
      },
      {
        "input": "4\n\n0 0\n\n1 1\n\n1 0\n\n0 1",
        "output": "4"
      }
    ]
  },
  {
    "id": 530,
    "name": "Черно-белая графика",
    "description": "Одна из базовых задач компьютерной графики – обработка черно-белых изображений. Изображения можно представить в виде прямоугольников шириной w и высотой h, разбитых на w×h единичных квадратов, каждый из которых имеет либо белый, либо черный цвет. Такие единичные квадраты называются пикселами. В памяти компьютера сами изображения хранятся в виде прямоугольных таблиц, содержащих нули и единицы.\nРезультат0011110OUTPUT.TXT11110\n11100\n11110\n[Лучшие попытки]\nВо многих областях очень часто возникает задача комбинации изображений. Одним из простейших методов комбинации, который используется при работе с черно-белыми изображениями, является попиксельное применение некоторой логической операции. Это означает, что значение пиксела результата получается применением этой логической операции к соответствующим пикселам аргументов. Логическая операция от двух аргументов обычно задается таблицей истинности, которая содержит значения операции для всех возможных комбинаций аргументов. 101[Решение]\nНапример, для операции «исключающее ИЛИ» эта таблица выглядит так:\n110\nПервый аргументВторой аргументРезультат\n000\n011\n101\n110\nТребуется написать программу, которая вычислит результат попиксельного применения заданной логической операции к двум черно-белым изображениям одинакового размера.\nВходные данные\nПервая строка входного файла INPUT.TXT содержит два целых числа w и h (1 ≤ w, h ≤ 100). Последующие h строк описывают первое изображение и каждая из этих строк содержит w символов, каждый из которых равен нулю или единице. Далее следует описание второго изображения в аналогичном формате. Последняя строка входного файла содержит описание логической операции в виде четырех чисел, каждое из которых – ноль или единица. Первое из них есть результат применения логической операции в случае, если оба аргумента – нули, второе – результат в случае, если первый аргумент – ноль, второй – единица, третье – результат в случае, если первый аргумент – единица, второй – ноль, а четвертый – в случае, если оба аргумента – единицы.\nВыходные данные\nВ выходной файл OUTPUT.TXT необходимо вывести результат применения заданной логической операции к изображениям в том же формате, в котором изображения заданы во входном файле.",
    "complexity": 26,
    "memory": 16000,
    "time": 1000,
    "examples": [
      {
        "input": "5 3\n\n01000\n\n11110\n\n01000\n\n10110\n\n00010\n\n10110\n\n0110",
        "output": "11110\n\n11100\n\n11110"
      }
    ]
  },
  {
    "id": 535,
    "name": "Неправильное сложение",
    "description": "Володя написал программу, которая складывает в столбик два числа. К сожалению, он не разобрался, как правильно переносить единицу из одного разряда в следующий. Поэтому программа стала выполняться следующим образом. Сначала она складывает последние цифры обоих чисел и записывает результат, как в случае, если он однозначный, так и в случае, если он двузначный. Затем программа складывает предпоследние цифры обоих чисел и результат сложения приписывает слева к результату предыдущего сложения. Далее процесс повторяется для всех разрядов. Если в одном числе цифр меньше, чем в другом, то программа размещает нули в соответствующих разрядах более короткого числа.\nOUTPUT.TXTYES\n7945\n71215\n2643 733 553NO18129NO18129[Лучшие попытки]\nФедя хочет доказать Володе, что его способ сложения не обладает свойством ассоциативности. В частности, Федя утверждает, что существуют три числа, для которых важен порядок, в котором их складывают (при этом разрешается складывать числа в любом порядке, например можно сначала сложить первое число и последнее, а затем прибавить к ним среднее). Федя привел даже пример трех таких чисел.\n[Решение]\nТребуется написать программу, которая поможет Феде и Володе определить, верно ли утверждение, что, складывая заданные три числа в разном порядке, можно получить разные суммы.\nВходные данные\nВходной файл INPUT.TXT содержит в одной строке три целых числа a, b и c (1 ≤ a, b, c ≤ 106). Все числа в строке разделены пробелом.\nВыходные данные\nВ первую строку выходного файла OUTPUT.TXT необходимо вывести слово YES, если данные три числа можно сложить разными способами и получить разные суммы. В противном случае, необходимо вывести слово NO.\nВ последующих строках необходимо вывести все возможные суммы, которые можно получить, складывая числа a, b и c. Суммы следует выводить по одной на строке и в порядке их возрастания.",
    "complexity": 41,
    "memory": 16000,
    "time": 1000,
    "examples": [
      {
        "input": "30 239 566",
        "output": "YES\n\n7945\n\n71215"
      },
      {
        "input": "643 733 553",
        "output": "NO\n18129"
      }
    ]
  },
  {
    "id": 406,
    "name": "Криптография",
    "description": "Подстановочным называется шифр, при использовании которого каждая буква сообщения заменяется какой-нибудь другой буквой, а все пробелы и знаки препинания удаляются. При этом для сохранения возможности однозначной расшифровки никакие две буквы не превращаются в одну.\nciOUTPUT.TXTr\ne\nc\n[Лучшие попытки]\nЗная тот факт, что частоты появления в осмысленном тексте букв различаются, можно с хорошей точностью установить, каким образом были зашифрованы буквы. Среди всех возможных способов перестановки букв следует выбрать такой, для которого минимально значение величины\ni\n∑c|ec – pc|\nЗдесь через ec и pc обозначены частоты символа c, рассчитанные для среднего текста и для записки, получающейся из зашифрованного текста после применения данной перестановки.\nТребуется по заданным частотам написать программу, расшифровывающую закодированное послание.\nВходные данные\nВ первой строке входного файла INPUT.TXT записаны два целых числа – N и M (1 ≤ N ≤ 26, 1 ≤ M ≤ 105). Следующие N строк задают буквы, которые, по сведениям Кристины, могли встречаться в исходном тексте. Соответствующая буква ci – первый символ строки, через пробел от него записана частота этой буквы pi, заданная с 4 знаками после десятичной точки. Все pi неотрицательны, а их сумма равна 1. Последняя строка содержит M символов – текст, который необходимо расшифровать. Исходный и зашифрованный текст состоит из строчных английских букв.\nВыходные данные\nВ выходной файл OUTPUT.TXT выведите N символов по одному на строке, которые, если верить описанному методу, должны быть сопоставлены символам из входного файла. Если оптимальных решений несколько, выведите любое из них.",
    "complexity": 48,
    "memory": 16000,
    "time": 1000,
    "examples": [
      {
        "input": "3 5\n\nt 0.1667\n\nr 0.5000\n\nq 0.3333\n\necere",
        "output": "r\n\ne\n\nc"
      }
    ]
  },
  {
    "id": 470,
    "name": "Земельный комитет",
    "description": "Земельный комитет города принял решение о сдаче в аренду части муниципальной территории, имеющей форму прямоугольника размером H на W километров. Стоимость аренды каждого квадратного участка 1×1 км была определена с учётом локальных условий, и занесена в таблицу.\niiOUTPUT.TXT16[Лучшие попытки]\nС целью организации открытого тендера на аренду, земельный комитет решил выставить на своём веб-сайте карту территории, и предоставить посетителям возможность узнавать суммарную стоимость аренды для произвольной прямоугольной группы соседних участков.\nii\nДанное предложение вызвало большой интерес у населения и предпринимателей, и нагрузка на сервер очень высока.\ni\nТребуется написать программу, позволяющую как можно более эффективно рассчитывать стоимость аренды для N запросов. В каждом запросе требуется определить общую стоимость участков внутри прямоугольной группы с противоположными углами, расположенными в элементах таблицы (ai, bi) и (ci, di).\ni\nВходные данныеi\nВ первой строке входного файла INPUT.TXT находятся числа H, W, N (1 ≤ H, W ≤ 100, 1 ≤ N ≤ 106). В следующих H строках содержится по W чисел (стоимости участков находятся в диапазоне от 0 до 10 000). Далее идут N строк с числами ai, bi, ci и di (1 ≤ ai ≤ ci ≤ H, 1 ≤ bi ≤ di ≤ W).\ni\niВыходные данные\nВ выходной файл OUTPUT.TXT должен содержать N чисел, по одному числу в строке.",
    "complexity": 41,
    "memory": 16000,
    "time": 1000,
    "examples": [
      {
        "input": "2 3 1\n\n5 1 2\n\n6 7 3\n\n2 1 2 3",
        "output": "16"
      }
    ]
  },
  {
    "id": 407,
    "name": "Сдача",
    "description": "Когда Миша и Маша покупали подарок, возникла интересная ситуация. У них была в распоряжении только одна большая купюра, а у продавца – некоторое количество мелочи. Дело происходило утром, поэтому продавцу нужно было экономить мелочь, и он хотел отдать сдачу минимальным количеством монет. Подумав некоторое время, они точно определили, с каким количеством монет продавцу придется расстаться.\n6OUTPUT.TXT325\n7 8 9 10 11\n13\n-1-1[Лучшие попытки]\nА вы сможете решить такую задачу?\nВходные данные\nВ первой строке входного файла INPUT.TXT записано число N (1 ≤ N ≤ 10) – количество различных номиналов монет, содержащихся в кассе. Можно считать, что количество монет каждого номинала достаточно. На следующей строке содержится N целых чисел ai (0 \u003c ai ≤ 2000) – номиналы монет. В третьей строке записано одно число K (1 ≤ K ≤ 106) – сумма, которую нужно набрать.\nВыходные данные\nВ выходной файл OUTPUT.TXT выведите минимальное количество монет, которое придется отдать продавцу, или -1, если продавец вообще не сможет дать им сдачу.",
    "complexity": 44,
    "memory": 16000,
    "time": 1000,
    "examples": [
      {
        "input": "3\n\n1 5 7\n\n19",
        "output": "3"
      },
      {
        "input": "5\n\n7 8 9 10 11\n\n13",
        "output": "-1"
      }
    ]
  },
  {
    "id": 541,
    "name": "Две строки",
    "description": "",
    "complexity": 47,
    "memory": 16000,
    "time": 1000,
    "examples": [
      {
        "input": "25\n12",
        "output": "40"
      },
      {
        "input": "100\n1",
        "output": "99"
      }
    ]
  },
  {
    "id": 539,
    "name": "Торт",
    "description": "На свой день рождения Петя купил красивый и вкусный торт, который имел идеально круглую форму. Петя не знал, сколько гостей придет на его день рождения, поэтому вынужден был разработать алгоритм, согласно которому он сможет быстро разрезать торт на N равных частей. Следует учесть, что разрезы торта можно производить как по радиусу, так и по диаметру.\nOUTPUT.TXT12333[Лучшие попытки]\nПомогите Пете решить эту задачу, определив наименьшее число разрезов торта по заданному числу гостей.\n[Решение]\nВходные данные\nВходной файл INPUT.TXT содержит натуральное число N – число гостей, включая самого виновника торжества (N ≤ 1000).\nВыходные данные\nВ выходной файл OUTPUT.TXT выведите минимально возможное число разрезов торта.",
    "complexity": 6,
    "memory": 16000,
    "time": 1000,
    "examples": [
      {
        "input": "2",
        "output": "1"
      },
      {
        "input": "3",
        "output": "3"
      }
    ]
  },
  {
    "id": 703,
    "name": "ACM-шахматы",
    "description": "Во многих видах спортивных соревнований имеются различные ритуалы, направленные для примирения конкурирующих команд или игроков. Это может быть рукопожатие, поклон или даже разбрызгивание шампанского. ACM (Alliance of Chess Masters) собирается создать свой собственный ритуал, шахматную миниигру, в которой участвует два игрока в союзе друг с другом (а не как обычно, друг против друга). Игра проходит на шахматной доске размером 3×3, у каждого из игроков имеется два шахматных коня, которых они должны переместить так, чтобы добраться от одной позиции до другой (игроки могут делать шаги в любом порядке, не обязательно по очереди). При этом два коня не могут занимать одну и ту же клетку.\nOUTPUT.TXT42..B ..B\nW.B ..B\nW.. WW.-1-1[Лучшие попытки]\nСтартовое и завершающее положения определены судьей. Оказывается, что некоторые такие задачи являются более трудными, чем другие, а некоторые могут быть даже неразрешимыми - поэтому, некоторые игроки иногда неспособны закончить ритуал. Ваша задача состоит в том, чтобы написать программу, которая по заданным положениям начальной и конечной расстановки, сможет определить возможность успешного окончания игры, а в случае успеха сможет так же определить сложность задачи – минимально возможное количество ходов, необходимых для разрешения данной задачи.\nВходные данные\nВходной файл INPUT.TXT содержит 3 строки по 7 символов в каждой. Первые 3 символа каждой строки описывают соответствующую строку шахматной строки для начальной позиции, затем идет пробел и замыкающие 3 символа, описывающие аналогичным образом строку конечной позиции. Белый конь обозначается символом «W», а черный – символом «B», пустые клетки помечаются «.» (точка).\nВыходные данные\nВ выходной файл OUTPUT.TXT выведите одно целое число – сложность задачи. Если задача не имеет решения, то следует вывести -1.",
    "complexity": 54,
    "memory": 16000,
    "time": 1000,
    "examples": [
      {
        "input": "WBB ..W\n\nW.. ..W\n\n... .BB",
        "output": "4"
      },
      {
        "input": "..B ..B\n\nW.B ..B\n\nW.. WW.",
        "output": "-1"
      }
    ]
  },
  {
    "id": 666,
    "name": "Абракадабра",
    "description": "Последовательность из английских букв строится следующим образом. Вначале она пуста. На каждом последующем шаге последовательность удваивается, после чего к ней слева дописывается очередная буква английского алфавита (a, b, c, …). Ниже приведены первые шаги построения последовательности:\nOUTPUT.TXTw[Лучшие попытки]\nШаг 1. a\nШаг 2. baa\nШаг 3. cbaabaa\nШаг 4. dcbaabaacbaabaa\n…………………………\nТребуется написать программу, которая по заданному числу N находит символ, который стоит на N-ом месте в последовательности, получившейся после 26-го шага.\nВходные данные\nВ единственной строке входного файла INPUT.TXT записано число N (1 ≤ N \u003c 226).\nВыходные данные\nВ единственную строку выходного файла OUTPUT.TXT нужно вывести символ, стоящий в N-й позиции получившейся последовательности.",
    "complexity": 41,
    "memory": 16000,
    "time": 1000,
    "examples": [
      {
        "input": "4",
        "output": "w"
      }
    ]
  },
  {
    "id": 664,
    "name": "Котлеты",
    "description": "На сковородке одновременно можно положить k котлет. Каждую котлету нужно с каждой стороны обжаривать m минут непрерывно. За какое наименьшее время удастся поджарить с обеих сторон n котлет?\nOUTPUT.TXT222 2 144[Лучшие попытки]\nВходные данные[Решение]\nВ единственной строке входного файла INPUT.TXT записано три натуральных числа: k, m, n, не превышающих 30000.\nВыходные данные\nВ единственную строку выходного файла OUTPUT.TXT нужно вывести единственное число – минимальное время, за которое можно поджарить все котлеты.",
    "complexity": 30,
    "memory": 16000,
    "time": 1000,
    "examples": [
      {
        "input": "1 1 1",
        "output": "2"
      },
      {
        "input": "2 2 1",
        "output": "4"
      }
    ]
  },
  {
    "id": 665,
    "name": "Палиндромное время",
    "description": "Пекарь считает, что для получения рождественского пирога идеальной симметричной формы его нужно вынимать из духовки в тот момент, когда часы показывают «палиндромное» время, которое читается одинаково слева-направо и справа-налево.\nOUTPUT.TXT01:10212:3413:3113:3100:00[Лучшие попытки]\nНапишите программу, которая определяет по времени установки пирога в духовку время, когда будет подходящее время для его извлечения.\n323:5900:00[Решение]\nВходные данные\nВ единственной строке входного файла INPUT.TXT записано время установки пирога в духовку в формате HH:MM (00 ≤ HH ≤ 23, 00 ≤ MM ≤ 59).\nВыходные данные\nВ единственную строку выходного файла OUTPUT.TXT нужно вывести ближайшее «палиндромное» время в формате HH:MM.",
    "complexity": 24,
    "memory": 16000,
    "time": 1000,
    "examples": [
      {
        "input": "00:00",
        "output": "01:10"
      },
      {
        "input": "12:34",
        "output": "13:31"
      },
      {
        "input": "23:59",
        "output": "00:00"
      }
    ]
  },
  {
    "id": 668,
    "name": "Змей Горыныч",
    "description": "В некотором царстве жил Змей Горыныч. У него было N голов и M хвостов. Иван-царевич решил уничтожить губителя человеческих душ, для чего ему его кума Баба Яга подарила волшебный меч, так как только им можно убить Змея Горыныча. Если отрубить одну голову, то на её месте вырастает новая, если отрубить хвост, то вместо него вырастет 2 хвоста. Если отрубить два хвоста, то вырастает 1 голова, и только когда отрубить 2 головы, то не вырастет ничего. Змей Горыныч гибнет только в том случае, когда ему отрубать все головы и все хвосты. Определить минимальное количество ударов мечом, нужное для уничтожения Змея Горыныча. \nOUTPUT.TXT9[Лучшие попытки]\nВходные данные\nВ единственной строке входного файла INPUT.TXT записаны через пробел два числа N, M (0 ≤ N, M ≤ 1000).\nВыходные данные\nВ единственную строку выходного файла OUTPUT.TXT нужно вывести одно число – минимальное количество ударов мечом, или -1, если уничтожить Змея Горыныча невозможно.",
    "complexity": 34,
    "memory": 16000,
    "time": 1000,
    "examples": [
      {
        "input": "3 3",
        "output": "9"
      }
    ]
  },
  {
    "id": 540,
    "name": "Таблица",
    "description": "121m12nmOUTPUT.TXT3 6 523 3 101 1 18 0 88 0 823 0 4 33[Лучшие попытки]\nРассмотрим прямоугольную таблицу размером n×m. Занумеруем строки таблицы числами от 1 до n, а столбцы – числами от 1 до m. Будем такую таблицу последовательно заполнять числами следующим образом. \n1m1m33 4 402 3 4 523 0 4 33\nОбозначим через aij  число, стоящее на пересечении i-ой строки и j-ого столбца. Первая строка таблицы заполняется заданными числами – a11, a12, …, a1m. Затем заполняются строки с номерами от 2 до n. Число aij вычисляется как сумма всех чисел таблицы, находящихся в «треугольнике» над элементом aij. Все вычисления при этом выполняются по модулю r.\nij1i\nij\nБолее точно, значение aij вычисляется по следующей формуле:\n9\nНапример, если таблица состоит из трех строк и четырех столбцов, и первая строка состоит из чисел 2,3,4,5, а r = 40 то для этих исходных данных таблица будет выглядеть следующим образом (взятие по модулю показано только там, где оно приводит к изменению числа):\nТребуется написать программу, которая по заданной первой строке таблицы (a11, a12, …, a1m), вычисляет последнюю строку, как описано выше.\nВходные данные\nПервая строка входного файла INPUT.TXT содержит числа n, m и r (2 ≤ n, m ≤ 2000, 2 ≤ r ≤ 109) – число строк и столбцов таблицы соответственно, а так же число, по модулю которого надо посчитать ответ. Следующая строка содержит m целых чисел – первую строку таблицы: a11, a12, …, a1m. Все a1i неотрицательны и не превосходят 109.\nВыходные данные\nВ первой строке выходного файла OUTPUT.TXT необходимо вывести m чисел – последнюю строку таблицы: an1, an2, …, anm.",
    "complexity": 45,
    "memory": 16000,
    "time": 1000,
    "examples": [
      {
        "input": "2 3 10\n1 2 3",
        "output": "3 6 5"
      },
      {
        "input": "3 3 10\n1 1 1",
        "output": "8 0 8"
      },
      {
        "input": "3 4 40\n2 3 4 5",
        "output": "23 0 4 33"
      }
    ]
  },
  {
    "id": 669,
    "name": "Произведение цифр - 3",
    "description": "Найти наименьшее и наибольшее натуральные числа, произведение цифр в которых равно заданному натуральному числу M или сообщить, что таких чисел не существует. Для записи искомых чисел нельзя использовать цифры 0 и 1.\nOUTPUT.TXT26 322211-1 -1-1 -1[Лучшие попытки]\nВходные данные\nВ единственной строке входного файла INPUT.TXT записано натуральное число M (2 ≤ M ≤ 1000).\nВыходные данные\nВ единственную строку выходного файла OUTPUT.TXT нужно вывести два натуральных числа в неубывающем порядке. Если таких чисел не существует, то вывести -1 -1.",
    "complexity": 39,
    "memory": 16000,
    "time": 1000,
    "examples": [
      {
        "input": "12",
        "output": "26 322"
      },
      {
        "input": "11",
        "output": "-1 -1"
      }
    ]
  },
  {
    "id": 667,
    "name": "Автобусы - 2",
    "description": "Для заезда в оздоровительный лагерь организаторы решили заказать автобусы. Известно, что в лагерь собираются поехать N детей и M взрослых. Каждый автобус вмещает K человек. В каждом автобусе, в котором поедут дети, должно быть не менее двух взрослых. \nOUTPUT.TXT2210 4 500[Лучшие попытки]\nОпределите, удастся ли отправить в лагерь всех детей и взрослых, и если да, то какое минимальное количество автобусов требуется для этого заказать.\nВходные данные\nВ единственной строке входного файла INPUT.TXT записано через пробел 3 натуральных числа - N, M и K, каждое из них не превосходит 10 000.\nВыходные данные\nВ единственную строку выходного файла OUTPUT.TXT нужно вывести количество автобусов, которые нужно заказать. Если же отправить всех в лагерь невозможно, выведите 0 (ноль).",
    "complexity": 28,
    "memory": 16000,
    "time": 1000,
    "examples": [
      {
        "input": "10 4 7",
        "output": "2"
      },
      {
        "input": "10 4 5",
        "output": "0"
      }
    ]
  },
  {
    "id": 687,
    "name": "Однонаправленная задача коммивояжёра",
    "description": "Задана матрица размером m×n из целых чисел. Путь начинается в любой строке первого столбца и состоит из последовательности шагов, обрывающихся в столбце n. Каждый шаг состоит в переходе из столбца i в столбец i+1 в соседнюю (по горизонтали или диагонали) ячейку. Весом пути называется сумма целых чисел, записанных в каждой из n посещенных ячеек.\nOUTPUT.TXT1 2 3 4 4 516[Лучшие попытки]\nТребуется написать программу, которая вычисляет путь с минимальным весом с левого края матрицы до правого.\nВходные данные\nВходной текстовый файл INPUT.TXT содержит в первой строке количество строк и столбцов матрицы, которые обозначаются m и n соответственно. Далее следует m строк по n чисел в каждой. Числа отделяются друг от друга пробелами. Число строк не превышает 10, столбцов – 100. Вес любого пути не будет превышать целого числа, для хранения которого потребуется больше 30 бит.\nВыходные данные\nВыходной текстовый файл OUTPUT.TXT должен содержать две строки. Первая строка задает путь минимальной стоимости, а вторая – соответственно стоимость этого пути. Путь состоит из последовательности n целых чисел (разделенных одним или более пробелами), задающих номера строк, из которых состоит путь минимальной стоимости. Если путей минимальной стоимости больше одного, то должен быть выведен лексикографически минимальный путь.",
    "complexity": 41,
    "memory": 16000,
    "time": 1000,
    "examples": [
      {
        "input": "5 6\n\n3 4 1 2 8 6\n\n6 1 8 2 7 4\n\n5 9 3 9 9 5\n\n8 4 1 3 2 6\n\n3 7 2 8 6 4",
        "output": "1 2 3 4 4 5\n16"
      }
    ]
  },
  {
    "id": 671,
    "name": "Счастливые числа",
    "description": "Все знают, что счастливые числа – это те числа, которые содержат только счастливые цифры 7 и 4. Вам нужно найти количество счастливых чисел не больших N.\nOUTPUT.TXT4[Лучшие попытки]\nВходные данные\nВ единственной строке входного файла INPUT.TXT записано натуральное число N, не превышающее 1032.\nВыходные данные\nВ единственную строку выходного файла OUTPUT.TXT нужно вывести одно целое число — ответ на задачу.",
    "complexity": 42,
    "memory": 16000,
    "time": 1000,
    "examples": [
      {
        "input": "56",
        "output": "4"
      }
    ]
  },
  {
    "id": 670,
    "name": "Числа без одинаковых цифр",
    "description": "Антон записал ряд натуральных чисел в порядке возрастания: 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16, 17, 18, 19, 20, 21, 22, 23 и т.д. Затем вычеркнул из него все числа, в которых имеется хотя бы две одинаковых цифры, и получил последовательность: 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 12, 13, 14, 15, 16, 17, 18, 19, 20, 21, 23 и т.д.\nOUTPUT.TXT123[Лучшие попытки]\nВам необходимо по заданному N найти N-ое по счету число в получившейся последовательности.\nВходные данные\nВ единственной строке входного файла INPUT.TXT записано натуральное число N (1 ≤ N ≤ 10000).\nВыходные данные\nВ единственную строку выходного файла OUTPUT.TXT нужно вывести N-ое по счету число без одинаковых цифр.",
    "complexity": 25,
    "memory": 16000,
    "time": 1000,
    "examples": [
      {
        "input": "100",
        "output": "123"
      }
    ]
  },
  {
    "id": 686,
    "name": "Колокол",
    "description": "Требуется написать программу, которая в массиве из n  целых чисел наименьший элемент поместит на первое место, наименьший из оставшихся – на последнее, следующий по величине – на второе место, следующий – на предпоследнее и так далее – до середины массива.\nOUTPUT.TXT1 3 5 4 2[Лучшие попытки]\nВходные данные[Решение]\nВо входном файле INPUT.TXT записано в первой строке число n (1 ≤ n ≤ 30000). Во второй строке записаны через пробел элементы массива, числа по абсолютной величине не большие 32767.\nВыходные данные\nВ единственную строку выходного файла OUTPUT.TXT нужно вывести элементы полученного массива, разделенные одним пробелом.",
    "complexity": 28,
    "memory": 16000,
    "time": 1000,
    "examples": [
      {
        "input": "5\n1 2 3 4 5",
        "output": "1 3 5 4 2"
      }
    ]
  },
  {
    "id": 672,
    "name": "N-значные числа",
    "description": "Найти количество N-значных чисел, у которых сумма цифр равна их произведению. Вывести наименьшее среди таких чисел для заданного N.\nOUTPUT.TXT10 0221 221 22[Лучшие попытки]\nВходные данные\nВ единственной строке входного файла INPUT.TXT записано одно натуральное число N, которое не превышает 10.\nВыходные данные\nВ единственную строку выходного файла OUTPUT.TXT нужно вывести через пробел 2 числа: количество искомых чисел и наименьшее среди них.",
    "complexity": 32,
    "memory": 16000,
    "time": 1000,
    "examples": [
      {
        "input": "1",
        "output": "10 0"
      },
      {
        "input": "2",
        "output": "1 22"
      }
    ]
  },
  {
    "id": 688,
    "name": "Суслик и собака",
    "description": "На большом поле находятся суслик и собака. Собака хочет суслика съесть, а суслик хочет оказаться в безопасности, добежав до одной из норок, выкопанных в поле. Ни собака, ни суслик в математике не сильны, но, с другой стороны, они и не беспросветно глупы. Суслик выбирает определенную норку и бежит к ней по прямой с определенной скоростью. Собака, которая очень хорошо понимает язык телодвижений, угадывает, к какой норке бежит суслик, и устремляется к ней со скоростью вдвое большей скорости суслика. Если собака добегает до норки первой (раньше суслика), то она съедает суслика; иначе суслик спасается.\nOUTPUT.TXTNO220 20\n10 10\n2\n15 15\n25 2522[Лучшие попытки]\nТребуется написать программу, которая поможет суслику выбрать норку, в которой он может спастись, если таковая существует.\nВходные данные\nВо входном файле INPUT.TXT записано в первой строке два числа – координаты суслика. Во второй строке записаны два числа – координаты собаки. В третьей строке записано число n – число норок на поле. В следующих n строках записаны координаты норок. Все координаты являются целыми числами, по модулю не превышающими 10000, и записываются через пробел. Количество норок не превышает 1000.\nВыходные данные\nВ единственную строку выходного файла OUTPUT.TXT нужно вывести число – номер норки, если у суслика есть возможность в ней спастись. Если у суслика есть возможность спрятаться в нескольких норках, то выведите ту, которая первая шла во входных данных. Если суслик не может спастись, то выведите в выходной файл «NO» (без кавычек).",
    "complexity": 19,
    "memory": 16000,
    "time": 1000,
    "examples": [
      {
        "input": "10 10\n\n20 20\n\n1\n\n15 15",
        "output": "NO"
      },
      {
        "input": "20 20\n\n10 10\n\n2\n\n15 15\n\n25 25",
        "output": "2"
      }
    ]
  },
  {
    "id": 690,
    "name": "Конная прогулка",
    "description": "Требуется выполнить обход прямоугольного поля, перемещаясь в нём по правилам шахматного коня. Начальная позиция коня определена. Необходимо посетить все клетки без повторных заходов. Гарантируется, что такой обход возможен.\nOUTPUT.TXT 1 16 27 22  3 18 47 54\n26 23  2 17 46 55  4 19\n15 28 25 50 21 48 53 56\n24 35 30 45 58 51 20  5\n29 14 59 34 49 44 57 52\n36 31 38 41 60 63  6  9\n13 40 33 62 11  8 43 64\n32 37 12 39 42 61 10  7[Лучшие попытки]\nВходные данные\nВ первой строке входного файла INPUT.TXT содержится два натуральных числа N и M – размеры поля (6 ≤ N, M ≤ 100). Далее следует карта поля: N строк по M символов в каждой строке. Символом «.» (точка) обозначается пустое пространство, начальная позиция коня задаётся единственным в поле символом «K» (заглавная буква английского алфавита).\nВыходные данные\nВ выходной файл OUTPUT.TXT выведите матрицу обхода поля, в каждой ячейке которого должен быть вписан номер шага её посещения (начиная с единицы). Числа следует разделять пробелами, допускается использовать лишние пробелы. В случае неоднозначного решения следует вывести любое.",
    "complexity": 71,
    "memory": 16000,
    "time": 1000,
    "examples": [
      {
        "input": "8 8\n\nK.......\n\n........\n\n........\n\n........\n\n........\n\n........\n\n........\n\n........",
        "output": "1 16 27 22  3 18 47 54\n26 23  2 17 46 55  4 19\n15 28 25 50 21 48 53 56\n24 35 30 45 58 51 20  5\n29 14 59 34 49 44 57 52\n36 31 38 41 60 63  6  9\n13 40 33 62 11  8 43 64\n32 37 12 39 42 61 10  7"
      }
    ]
  },
  {
    "id": 689,
    "name": "Упрощение номеров",
    "description": "Как, Вы не можете запомнить 6 или 7-значный номер телефона, появившийся на секунду на экране телевизора?! С помощью специальной методики, описываемой далее, Вы превратитесь в ходячий телефонный справочник!\nOUTPUT.TXT3 216 FFFF[Лучшие попытки]\nОчевидно, что число 402 запомнить легче, чем число 110010010, а число 337377 запомнить легче, чем число 957472. Значит, нужно чтобы запоминаемое число, с одной стороны, содержало как можно меньше цифр, а с другой стороны, желательно, чтобы в числе было как можно больше повторяющихся цифр. В качестве критерия сложности запоминания примем сумму количества цифр в числе и количества различных цифр в числе. Запоминаемое число можно записать в другой системе счисления, возможно, тогда его окажется легче запомнить. Например, число 65535 в шестнадцатеричной системе исчисления выглядит как FFFF. Таким образом, нужно написать программу подбора основания системы счисления для минимизации критерия сложности. Основание системы счисления нужно выбирать в диапазоне от 2 до 36, тогда для представления числа можно использовать цифры 0-9 и английские буквы A-Z.\nВходные данные\nВходной файл INPUT.TXT содержит в первой строке целое число n (1 ≤ n ≤ 100). Далее следует n строк, каждая строка содержит целое число от 1 до 999999999.\nВыходные данные\nВыходной файл OUTPUT.TXT должен содержать n строк. Для каждого из n заданных чисел строка содержит: основание системы счисления (от 2 до 36), минимизирующее критерий сложности запоминания, и число в выбранной системе исчисления, разделенные одним пробелом. Если несколько оснований дают одинаковое значение критерия, то выбрать наименьшее среди них.",
    "complexity": 26,
    "memory": 16000,
    "time": 1000,
    "examples": [
      {
        "input": "2\n2\n65535",
        "output": "3 2\n16 FFFF"
      }
    ]
  },
  {
    "id": 585,
    "name": "Египетские знаки",
    "description": "Прошлым летом школьник Вася побывал в Египте. И лишь сейчас он вспомнил, что во время своей поездки он успел сфотографировать много интересностей. Перебирая эти фотографии, больше всего он заинтересовался видами пирамид в Гизе. Пирамиды, помимо всяких иероглифов, содержали удивительные знаки - 1, 2, 3, 4, 5, 6, 7, 8, 9, 0. Внимательно присмотревшись Вася заметил, что каждая строка таких странных символов является степенью двойки и более того первая строка начинается последовательностью символов 1, вторая - 2, ..., сто двадцатая - 120, и т.д. Но все было бы хорошо, если бы Вася пользовался современными фотоаппаратами, поэтому его старенькая мыльница плохо сфотографировала наиболее освещенные части пирамиды, поэтому все символы разобрать невозможно и определить показатель степени двойки, соответствующий таким строкам, затруднительно. \nOUTPUT.TXT721342727209[Лучшие попытки]\nВася задумался о восстановлении символов и, наконец, решил попросить кого-нибудь написать программу (Вася учится в 6 классе и не знает языков программирования), которая бы определила показатель степени двойки, которая записана в N-ой строке.\n382209\nВходные данные\nВходной файл INPUT.TXT содержит единственное число N ≤ 107.\nВыходные данные\nВ выходной файл OUTPUT.TXT выведите минимальное натуральное число K такое, что 2K в десятичной записи начинается c числa N, или если Вася что-то напутал и такого числа нет - выведите -1.",
    "complexity": 72,
    "memory": 16000,
    "time": 1000,
    "examples": [
      {
        "input": "12",
        "output": "7"
      },
      {
        "input": "134",
        "output": "27"
      },
      {
        "input": "82",
        "output": "209"
      }
    ]
  },
  {
    "id": 691,
    "name": "Номера автобусов",
    "description": "Однажды Вася очень долго просидел на остановке, прежде чем дождался своего автобуса. Чтобы как-то занять время, он решил записывать на листочке государственные регистрационные номера проходящих мимо автобусов, следующих по другому маршруту, нежели нужен был Васе. При этом производилась запись лишь основного номера, без учета региональной принадлежности. В итоге Васе удалось записать N таких номеров.\nOUTPUT.TXTYes\nNo\nNo\nYes\nNo[Лучшие попытки]\nОсновная часть государственного регистрационного номера состоит из 6 символов: трех букв и трех цифр. Сначала идет буква, затем 3 цифры и еще 2 буквы заканчивают запись. В качестве цифр могут использоваться любые цифры от 0 до 9, а в качестве букв только прописные буквы, обозначения которых присутствуют как в английском, так и в русском алфавите, т.е. только следующие символы: A, B, C, E, H, K, M, O, P, T, X, Y. Например, «P204BT» - правильный номер, а «X182YZ» и «ABC216» - нет.\n[Решение]\nВаша задача заключается в проверке правильности проделанной Васей работы. А именно, нужно определить, какие из номеров соответствуют принятому стандарту, а какие нет.\nВходные данные\nПервая строка входного файла INPUT.TXT содержит единственное натуральное число N – количество записанных Васей номеров (N ≤ 50). Далее следует N строк с записями номеров автобусов. Длины строк от 1 до 300 и содержат только символы с кодами ASCII от 33 до 127 (не содержат пробелов, специальных и русских символов).\nВыходные данные\nВ выходной файл OUTPUT.TXT выведите N строк, в i-й строке должно содержаться «Yes», если соответствующая i-я запись номера верна и «No» в противном случае.",
    "complexity": 16,
    "memory": 16000,
    "time": 1000,
    "examples": [
      {
        "input": "5\n\nP204BT\n\nX182YZ\n\na216bc\n\nA216BC\n\nABC216",
        "output": "Yes\n\nNo\n\nNo\n\nYes\n\nNo"
      }
    ]
  },
  {
    "id": 692,
    "name": "Бинарные числа",
    "description": "Говорят, что плохой программист – это тот, кто считает, что в одном килобайте 1000 байт, а хороший программист – это тот, кто полагает, что в одном километре 1024 метра.\nOUTPUT.TXTYES223NONO[Лучшие попытки]\nМногим эта шутка понятна, так как все знают, что в процессах, связанных с информатикой и компьютерной техникой, фигурирует множество значений, выражаемых степенью двойки, то есть чисел вида 2K, где K – некоторое неотрицательное целое число. Назовем такие числа бинарными. Это такие числа как 2, 4, 8, 16, 32 и т.д. Действительно, когда речь идет о размере памяти или о разрешении экрана монитора, то мы часто наталкиваемся на бинарные числа. Все это связано с принципом хранения информации в памяти ЭВМ.\n[Решение]\nЗадано целое число N. Требуется определить, является ли оно бинарным.\nВходные данные\nВходной файл INPUT.TXT содержит единственное целое число N, не превосходящее 10000 по абсолютной величине.\nВыходные данные\nВ выходной файл OUTPUT.TXT выведите YES, если заданное число является бинарным, и NO в противном случае.",
    "complexity": 8,
    "memory": 16000,
    "time": 1000,
    "examples": [
      {
        "input": "1024",
        "output": "YES"
      },
      {
        "input": "23",
        "output": "NO"
      }
    ]
  },
  {
    "id": 693,
    "name": "Перестановка",
    "description": "Если Вы читали Гарри Поттера, то знаете, что повелитель зла, Лорд Волдеморт создал свое имя путем перестановки букв в своем настоящем имени. Так из имени «Tom Marvolo Riddle» он получил «I am Lord Voldemort».\nOUTPUT.TXTYes2stop potsYesYesNo[Лучшие попытки]\nНапишите программу, которая проверяет, можно ли получить из одного имени другое путем перестановки его букв. При этом регистром букв нужно пренебречь.\n3abbc bacNo[Решение]\nВходные данные\nВ первой строке входного файла INPUT.TXT записаны два слова, разделенные единственным в строке пробелом. Слова содержат только символы английского алфавита. Длина слов больше 0 и не превышает 50 символов.\nВыходные данные\nВ выходной файл OUTPUT.TXT выведите «Yes», если возможно получить из одного имени другое, и «No» в противном случае.",
    "complexity": 24,
    "memory": 16000,
    "time": 1000,
    "examples": [
      {
        "input": "TomMarvoloRiddle  IamLordVoldemort",
        "output": "Yes"
      },
      {
        "input": "stop pots",
        "output": "Yes"
      },
      {
        "input": "abbc bac",
        "output": "No"
      }
    ]
  },
  {
    "id": 694,
    "name": "Лентяй",
    "description": "Студент Валера являет собой классический пример лентяя. На занятия он практически не ходит, и только в конце семестра появляется в университете и сдает ”хвосты”. Его заветная мечта: найти такой день, когда можно будет сдать сразу все долги. У него есть расписание работы преподавателей, из которого точно известно, с какого и по какой день месяца каждый преподаватель ежедневно будет доступен. OUTPUT.TXTYES221 23 4NONOYES[Лучшие попытки]\nПомогите Валере написать программу, которая по расписанию будет определять, сможет ли Валера сдать все долги за один день или нет.\n331 83 54 9YES[Решение]\nВходные данные\nВ первой строке входного файла INPUT.TXT содержится натуральное число N – количество предметов, которые нужно сдать Валере (N  ≤ 100). Далее идет N строк, каждая из которых состоит из двух чисел A и B, задающих отрезок работы очередного преподавателя (1 ≤ A ≤ B ≤ 31).\nВыходные данные\nВ выходной файл OUTPUT.TXT выведите «YES», если возможно встретить всех преподавателей за один день, или «NO», если это сделать невозможно.",
    "complexity": 21,
    "memory": 16000,
    "time": 1000,
    "examples": [
      {
        "input": "1\n1 2",
        "output": "YES"
      },
      {
        "input": "2\n1 2\n3 4",
        "output": "NO"
      },
      {
        "input": "3\n1 8\n3 5\n4 9",
        "output": "YES"
      }
    ]
  },
  {
    "id": 663,
    "name": "Предприимчивый Петя",
    "description": "Петя решил организовать у себя в классе чемпионат по решению математических головоломок. В нем изъявили желание участвовать N человек. Каждый человек при регистрации указывает свое имя, состоящее из маленьких английских букв. Петя предлагает участникам решить M задач, каждая из которых  имеет название, состоящее из больших английских букв.\n1OUTPUT.TXT160[Лучшие попытки]\nПроверку решений задач осуществляет Петя. За каждое решение он ставит некоторое количество баллов и заносит эту информацию в некоторую базу данных на своем карманном компьютере как строку вида “A-B-C”, где A – имя участника, который сдал решение на проверку, B – название задачи, решение которой сдал этот участник, C – количество баллов, полученное решением. На каждую из предложенных задач участник мог сдать не более одного решения, кроме того, участник мог не сдавать решения некоторых задач. Количество баллов, которое набрал участник в итоге соревнования, равно сумме баллов, полученных каждым из решений, которые этот участник сдавал на проверку.\nM\nПосле окончания проверки решений Петя обнаружил, что информация в базе данных была повреждена, так как карманный компьютер, на котором она хранилась, был заражен компьютерным вирусом. А именно, некоторые большие и/или маленькие английские буквы в строках, которые хранятся в базе данных, могли быть заменены на вопросительные знаки. В этот момент Петя очень пожалел, что не может заново проверить все работы, так как они у него не сохранились. Но все же Петя хочет использовать возникшую ситуацию определенным образом. Дело в том, что некоторые из участников – его хорошие друзья, и он им симпатизирует. Поэтому Петя хочет объявить результаты соревнования таким образом, чтобы все участники, которым он симпатизирует, набрали в сумме максимальное количество баллов. Однако, объявленные Петей результаты не должны противоречить информации, которая хранится в базе данных.\ni\nСформулируем условие задачи более точно. Известны имена N человек Name1, …, NameN и названия M задач Problem1, …, ProblemM. Назовем статусной строкой строку вида “A-B-C”, где A = Namei для некоторого i, B = Problemj для некоторого j, С – целое неотрицательное число и ‘-‘ – символ с ASCII-кодом 45. Величины A, B и C будем называть атрибутами статусной строки. Набор статусных строк назовем статусом, если никакие две статусные строки в этом наборе не имеют одновременно одинаковые атрибуты A и B. Назовем маской статусной строки произвольную строку, символами которой могут быть большие и маленькие английские буквы, цифры и символы ‘-‘ и ‘?’ (ASCII-код 63). Будем говорить, что некоторая статусная строка S соответствует маске Q, если в маске Q можно заменить каждый символ ‘?’ на большую или маленькую английскую букву так, что в результате получится строка S. Произвольный набор масок статусных строк назовем маской статуса. Будем говорить, что маска статуса MS соответствует статусу ST, если количество масок в MS равно количеству статусных строк в ST и маски статусных строк из MS и статусные строки из ST можно расположить в некотором порядке так, что i-я статусная строка в ST будет соответствовать i-й маске в MS. Результатом i-го участника, вычисленным по статусу ST, назовем целое число, равное сумме значений атрибутов C по всем статусным строкам из ST, для которых значение атрибута A равно Namei. Множеством симпатий назовем произвольное множество, элементами которого являются числа от 1 до N. Значением симпатичности статуса ST относительно множества симпатий L будем называть число, равное сумме результатов i-х участников, вычисленных по статусу ST, по всем i из множества L.\nj\ni\nВаша задача заключается в следующем. Вашей программе на вход подается маска статуса MS и множество симпатий L. Пусть X – это множество всех статусов, соответствующих маске MS. Необходимо найти максимальное из значений симпатичности по всем статусам из множества X относительно множества L.\nВходные данные\nПервая строка входного файла INPUT.TXT содержит целые числа N и M – количества участников и задач соответственно. Следующие N строк описывают имена участников. В i-й из этих строк записано значение Namei – имя i-го участника. Следующие M строк описывают названия задач. В j-й из этих строк записано значение Problemj – название j-й задачи.\nВ следующей строке записано целое число K – количество строк в исходной маске статуса. В каждой из следующих K строк записана одна маска статусной строки.\nВ следующей строке находится целое число P – количество чисел в исходном множестве симпатий. В следующей строке находятся P различных целых чисел от 1 до N, разделенных одиночными пробелами – элементы исходного множества симпатий.\nОграничения: 2 ≤ N ≤ 10, 2 ≤ M ≤ 10, Namei – непустая строка из не более 100 маленьких английских букв, Problemj – непустая строка из не более 100 больших английских букв. Каждая маска статусной строки содержит не более 5 цифр. Существует хотя бы один статус, соответствующий исходной маске статуса\nВыходные данные\nВ первой строке выходного файла OUTPUT.TXT выведите одно целое число, равное максимальному из значений симпатичности по всем статусам, соответствующим исходной маске статуса, относительно исходного множества симпатий.",
    "complexity": 72,
    "memory": 16000,
    "time": 1000,
    "examples": [
      {
        "input": "3 2\n\npetr\n\nlexa\n\nsergey\n\nPROBA\n\nPROBB\n\n4\n\nlexa-PROBA-100\n\n???g??-?????-0\n\n?e??-PROBA-70\n\n?e??-PROB?-60\n\n2\n\n3 2",
        "output": "160"
      }
    ]
  },
  {
    "id": 587,
    "name": "Экспедиция на Морс",
    "description": "Для исследования плоского космоса была организована сверхсекретная научная экспедиция. Специально для нее был сконструирован космический корабль Z-239, а в качестве первой планеты для исследования была выбрана Зумла.\nOUTPUT.TXT21 322\n10.63 228.81\n10.63 48.811212[Лучшие попытки]\nНа Z-239 установлено n двигателей на антиматерии, каждый из которых характеризуется вектором силы тяги, которую он создает. Для перемещения корабля необходимо включить некоторые двигатели, при этом общая сила тяги будет равна векторной сумме тяг включенных двигателей.\nПри старте корабля его можно ориентировать произвольным образом, после чего включить некоторые (возможно, все) двигатели.\nОчередной целью экспедиции была выбрана планета Морс. Разумеется, руководитель экспедиции хочет добраться туда как можно быстрее. Чем больше модуль суммарной силы тяги, тем быстрее полетит корабль. Какие двигатели нужно включить, чтобы добраться на Морс как можно быстрее?\nВходные данные\nПервая строка входного файла INPUT.TXT содержит натуральное число n - количество двигателей (1 ≤ n ≤ 30 000). В i+1-ой строке записана пара чисел - модуль силы тяги i-ого двигателя, и угол в градусах между вектором его силы тяги и направлением на Полярную звезду перед поворотом корабля (вещественное число от 0 до 360 градусов). Модуль силы тяги каждого двигателя не превосходит 10 000.\nВыходные данные\nВ первой строке выходного файла OUTPUT.TXT выведите количество k двигателей, которые надо включить. Во строке должны быть записаны k различных чисел, разделенных пробелами - номера включаемых двигателей в любом порядке.",
    "complexity": 70,
    "memory": 16000,
    "time": 1000,
    "examples": [
      {
        "input": "3\n\n5.00 0.00\n\n3.00 90.00\n\n4.00 270.00",
        "output": "2\n1 3"
      },
      {
        "input": "2\n\n10.63 228.81\n\n10.63 48.81",
        "output": "1\n2"
      }
    ]
  },
  {
    "id": 586,
    "name": "Законопроект",
    "description": "В связи с изменением политической обстановки в мире и во избежание наступления экономического кризиса в стране, президент Флатландии на очередном заседании кабинета министров поставил перед правительством первоочередную задачу о подготовке пакета реформ. Сразу же после заседания был созван специальный комитет, который подготовил k различных законопроектов, каждый из которых описывал один из возможных путей проведения реформ. Перед парламентом Флатландии (который состоит из n депутатов) встала нелегкая задача выбора одного из этих законопроектов.\ni,3OUTPUT.TXT123 2 4\n3 1 4 2\n1 3 4 2\n4 2 3 133[Лучшие попытки]\nСогласно конституции Флатландии, все обсуждения законопроектов в парламенте проходят в одном чтении. После того, как депутаты ознакомятся с проектом закона, проводится голосование. Каждый из депутатов может проголосовать либо за принятие закона, либо против. При этом, закон принимается, если за него проголосовало как минимум m депутатов.\nИзвестно, что законопроекты, подготовленные специальным комитетом, будут обсуждаться на заседаниях парламента последовательно, начиная с проекта номер 1 и заканчивая проектом номер k. При этом, если в результате обсуждения законопроекта номер i этот законопроект будет принят, то оставшиеся законопроекты (с номерами от i + 1 до k) не будут обсуждаться вообще. Если же законопроект с номером i будет отклонен, то парламент перейдет к обсуждению следующего законопроекта (с номером i + 1). Если в результате последовательного голосования парламент отвергнет все проекты, то процесс проведения реформ отложится на неопределенное время (в этом случае страну, скорее всего, ожидает глубокий кризис).\nИзвестно также, что каждый депутат Флатландии кратко ознакомился с каждым законопроектом еще до первого заседания парламента и составил для себя список всех проектов в порядке своих предпочтений. Обозначим номер j-го законопроекта в списке предпочтений i-го депутата, как ai,j .\nТогда это будет означать, что i-й депутат во время голосований будет пытаться добиться принятия проекта с номером ai,1, а если это не возможно, то проекта с номером ai,2, если и этого никак не добиться, то i-й депутат будет пытаться протолкнуть закон номер ai,3 и так далее. При этом никакой депутат не хочет допустить кризиса в стране, и, поэтому, в первую очередь будет пытаться предотвратить тот случай, когда все законопроекты будут отвергнуты парламентом.\nВсе депутаты флатландского парламента знают не только свои предпочтения, но и предпочтения всех своих коллег. К тому же они достаточно умны и будут действовать оптимально (то есть будут пытаться добиться принятия закона, как можно более предпочтительного с их точки зрения).\nПрезидент Флатландии попросил Вас, как своего главного советника, предсказать результаты работы парламента (а именно то, какой из вариантов закона о реформах будет в итоге принят).\nВходные данные\nВ первой строке входного файла INPUT.TXT записаны три целых числа: n (1 ≤ n ≤ 1000), m (1 ≤ m ≤ n) и k (1 ≤ k ≤ 1000). Далее следует n строк, каждая из которых содержит k чисел (j-е число в i-й строке равно ai,j).\nВыходные данные\nВ выходной файл OUTPUT.TXT выведите номер законопроекта, который будет принят парламентом, или слово \"Crisis\" (без кавычек), если все они будут отклонены.",
    "complexity": 62,
    "memory": 16000,
    "time": 1000,
    "examples": [
      {
        "input": "3 2 4\n\n3 4 1 2\n\n2 3 4 1\n\n4 1 2 3",
        "output": "1"
      },
      {
        "input": "3 2 4\n\n3 1 4 2\n\n1 3 4 2\n\n4 2 3 1",
        "output": "3"
      }
    ]
  },
  {
    "id": 588,
    "name": "Число",
    "description": "Скажем, что число в b-ой системе счисления описывает себя, если оно - b-значное, его первая цифра равна числу единиц в нем, вторая цифра равна числу двоек, и т.д., b-1-ая цифра равна числу цифр b-1, а последняя цифра равна числу нулей. Примером такого числа для b = 5 является 12002.\nOUTPUT.TXT1\n2\n0\n0\n222-1-1[Лучшие попытки]\nЗадано число b. Требуется найти число в системе счисления по основанию b, которое описывает себя.\nВходные данные\nВходной файл INPUT.TXT содержит единственное целое число b (2 ≤ b ≤ 1000).\nВыходные данные\nВ выходной файл OUTPUT.TXT выведите любое описывающее себя число в системе счисления с основанием b, или -1, если такого числа не существует. Каждую цифру числа выводите на отдельной строке в десятичной записи.",
    "complexity": 39,
    "memory": 16000,
    "time": 1000,
    "examples": [
      {
        "input": "5",
        "output": "1\n\n2\n\n0\n\n0\n\n2"
      },
      {
        "input": "2",
        "output": "-1"
      }
    ]
  },
  {
    "id": 695,
    "name": "Мифические шахматы",
    "description": "OUTPUT.TXT22A6 F633[Лучшие попытки]\nВаш друг Вася занимается разработкой компьютерной игры «Мифические шахматы». Он не укладывается в установленные сроки сдачи проекта.\n[Решение]\nВася обратился к друзьям за помощью. Ему необходим модуль, вычисляющий оптимальные пути перемещения фигур из одной клетки в другую. Так как друзей у Васи много, то каждому досталась маленькая подзадача. Вам требуется написать программу, определяющую минимальное количество ходов, необходимое кентавру, чтобы добраться из одной клетки в другую.\nВ мифические шахматы играют на шахматной доске размером 9х9, угловые клетки которой окрашены в черный цвет. Кентавр – фигура мифических шахмат, объединяющая в себе свойства коня и слона. Когда кентавр стоит на белой клетке, он может ходить только как конь, а когда на черной – только как слон. На рисунках приведены варианты ходов для двух кентавров (буквой «K» отмечено местоположение кентавра, а звездочками – клетки, куда кентавр может сделать ход).\nВходные данные\nВ первой строке входного файла INPUT.TXT содержатся координаты (большая английская буква и цифра) двух клеток доски для мифических шахмат, разделенные пробелом.\nВыходные данные\nВ выходной файл OUTPUT.TXT выведите минимальное число ходов, необходимое кентавру, чтобы добраться из первой клетки во вторую. Если добраться невозможно, то следует вывести число «-1» (без кавычек).",
    "complexity": 42,
    "memory": 16000,
    "time": 1000,
    "examples": [
      {
        "input": "H6 E5",
        "output": "2"
      },
      {
        "input": "A6 F6",
        "output": "3"
      }
    ]
  },
  {
    "id": 697,
    "name": "Ремонт",
    "description": "Ваш любимый дядя – директор фирмы, которая делает евроремонты в офисах. В связи с финансово-экономическим кризисом, дядюшка решил оптимизировать свое предприятие.\nOUTPUT.TXT421 1 311[Лучшие попытки]\nДавно ходят слухи, что бригадир в дядюшкиной фирме покупает лишнее количество стройматериалов, а остатки использует для отделки своей новой дачи. Ваш дядя заинтересовался, сколько в действительности банок краски необходимо для покраски стен в офисе длиной L метров, шириной – W и высотой – H, если одной банки хватает на 16м2, а размерами дверей и окон можно пренебречь? Заказов много, поэтому дядя попросил написать программу, которая будет все это считать.\n[Решение]\nВходные данные\nПервая строка входного файла INPUT.TXT содержит три натуральных числа L, W, H через пробел – длину, ширину и высоту офиса в метрах соответственно. Каждое из них не превышает 1000.\nВыходные данные\nВ выходной файл OUTPUT.TXT выведите одно целое число – минимальное количество банок краски, необходимых для покраски стен в офисе.",
    "complexity": 11,
    "memory": 16000,
    "time": 1000,
    "examples": [
      {
        "input": "8 8 2",
        "output": "4"
      },
      {
        "input": "1 1 3",
        "output": "1"
      }
    ]
  },
  {
    "id": 696,
    "name": "Сон",
    "description": "Любознательный школьник Петя очень любит программировать. Однажды он настолько увлекся этим делом, что уснул прямо за компьютером! Пете приснилось, что он попал в альтернативную реальность. Альтернативная реальность представляет собой прямоугольный лабиринт, который можно изобразить в виде таблицы размером R × C клеток. Чтобы не опоздать школу, Пете нужно найти выход из лабиринта. Начальная позиция Пети обозначается символом ‘S’, выход из альтернативной реальности – ‘E’. За один ход Петя перемещается в одну из четырех смежных клеток (влево, вправо, вниз, вверх). Если клетка занята стеной (символ ‘X’), то Петя пройти в нее не может. В некоторых клетках расположены двери с замками одного из четырех цветов (‘R’, ‘G’, ‘B’, ‘Y’). Для прохода в эту клетку, необходимо обладать ключом определенного цвета. Так как ключи многоразовые, то одним ключом можно открыть сколь угодно много соответствующих ему замков.\nOUTPUT.TXTSleep26 6\n1 5 3 1\nXXXXXX\nXS.X.X\nX..R.X\nX.XXBX\nX.G.EX\nXXXXXX44[Лучшие попытки]\nВластелин альтернативной реальности предлагает Пете купить ключи, чтобы пройти к выходу. У нашего героя совсем немного денег с собой, поэтому ему хочется потратить как можно меньше денег и при этом пройти к выходу. Помогите ему определить минимальную сумму денег, которую нужно потратить на ключи.\nВходные данные\nПервая строка входного файла INPUT.TXT содержит натуральные числа R и C (R,C  ≤ 50). Вторая строка теста содержит 4 целых числа Pi, стоимости покупки ключей ‘R’, ‘G’, ‘B’ и ‘Y’ соответственно (Pi ≤ 100). Далее следуют R строк, в каждой из которых C символов, описывающих лабиринт. Каждый лабиринт содержит только один символ ‘S’ и один символ ‘E’.\nВыходные данные\nВ выходной файл OUTPUT.TXT выведите минимальную сумму денег, необходимую для покупки набора ключей, позволяющего пройти к выходу. Если пути к выходу из альтернативной реальности не существует, и Петя обречен проспать уроки, выведите «Sleep».",
    "complexity": 50,
    "memory": 16000,
    "time": 1000,
    "examples": [
      {
        "input": "3 7\n\n1 1 1 1\n\nXXXXXXX\n\nXS.X.EX\n\nXXXXXXX",
        "output": "Sleep"
      },
      {
        "input": "6 6\n\n1 5 3 1\n\nXXXXXX\n\nXS.X.X\n\nX..R.X\n\nX.XXBX\n\nX.G.EX\n\nXXXXXX",
        "output": "4"
      }
    ]
  },
  {
    "id": 589,
    "name": "Физика",
    "description": "",
    "complexity": 84,
    "memory": 16000,
    "time": 1000,
    "examples": [
      {
        "input": "3\n1.0 1.0 0.0 0.0 0.0 1.00 1.0 1.0\n\n2.0 2.0 10.0 10.0 10.0 -1.0 -1.0 -1.0\n3.0 3.0 20.0 20.0 20.0 -0.5 -0.5 -0.5\n100",
        "output": "-155.643 -155.643 -155.643 -1.667 -1.667 -1.667\n-47.028 -47.028 -47.028 -0.667 -0.667 -0.667\n26.566 26.566 26.566 0.167 0.167 0.167"
      },
      {
        "input": "2\n1.0 1.0 0 0 0 0 0 0\n\n1.0 1.0 10 0 0 -1 0 0\n9",
        "output": "-1.000 0.000 0.000 -1.000 0.000 0.000\n2.000 0.000 0.000 0.000 0.000 0.000"
      }
    ]
  },
  {
    "id": 590,
    "name": "Зазеркалье",
    "description": "Дано множество из N точек в декартовой системе координат. Требуется определить, является ли это множество центрально-симметричным.\nOUTPUT.TXTYes23\n0 0 5\n5 0 0\n0 5 0NoNo[Лучшие попытки]\nВходные данные\nВ первой строке входного файла INPUT.TXT записано натуральное число N, не превышающее 1000. В следующих N строках записаны по три целых числа x, y, z, обозначающие координаты точки. Все точки попарно различны. Все координаты не превышают по модулю 2×109.\nВыходные данные\nВ единственную строку выходного файла OUTPUT.TXT нужно вывести Yes, если множество является центрально-симметричным и No в противном случае.",
    "complexity": 42,
    "memory": 16000,
    "time": 1000,
    "examples": [
      {
        "input": "2\n0 0 0\n5 7 3",
        "output": "Yes"
      },
      {
        "input": "3\n\n0 0 5\n\n5 0 0\n\n0 5 0",
        "output": "No"
      }
    ]
  },
  {
    "id": 591,
    "name": "Транспортная реформа",
    "description": "Далекое королевство состоит из n городов, соединенных m дорогами, при этом из каждого города можно доехать в каждый по дорогам (по каждой из дорог можно ездить в обоих направлениях). Некоторые дороги находятся в хорошем состоянии, другие же требуют ремонта.\nOUTPUT.TXT2\n3\n4[Лучшие попытки]\nСодержание каждой из дорог обходится казне в 239239 дублонов в год. В связи с новой транспортной реформой, направленной на уменьшение ненужных расходов, было решено оставить на государственном содержании как можно меньше дорог, но по-прежнему должна остаться возможность из каждого города добраться в любой другой по государственным дорогам. Заметим, что при этом на государственном содержании останется ровно n - 1 дорога.\nПри этом, возможно, в число оставленных дорог войдут и требующие ремонта. Сэкономленные в связи с этой реформой деньги планируется направить на ремонт дорог, оставленных на государственном содержании.\nВ королевстве есть две конкурирующие фирмы, занимающиеся починкой дорог. Поскольку король не желает быть обвиненным в поддержке одной из этих фирм, он хочет иметь возможность распределить дороги, оставленные на государственном содержании и требующие ремонта, поровну между ними. В связи с этим требуется оставить на государственном содержании четное число дорог, требующих ремонта.\nТребуется составить соответствующий желанию короля список дорог, которые следует оставить на государственном содержании.\nВходные данные\nПервая строка входного файла INPUT.TXT содержит натуральные числа n (2 ≤ n ≤ 30 000) и m (1 ≤ m ≤ 100 000) - число городов и дорог в королевстве соответственно. Далее идут m строк - описание дорог. Дорога описывается тремя числами. Первые два из них - номера городов, которые она соединяет, третье равно 1, если дорога не требует ремонта, и 2, если требует. Города пронумерованы целыми числами от 1 до n. Ни одна дорога не соединяет город с самим собой, между любыми двумя городами не более одной дороги.\nВыходные данные\nВ выходной файл OUTPUT.TXT выведите n-1 строку - номера государственных дорог (дороги нумеруются с 1 в том порядке, в котором они идут во входном файле). Если оставить на государственном содержании дороги указанным образом невозможно, то следует вывести -1.",
    "complexity": 70,
    "memory": 32000,
    "time": 1000,
    "examples": [
      {
        "input": "4 4\n\n1 2 1\n\n2 3 2\n\n3 4 1\n\n4 1 2",
        "output": "2\n\n3\n\n4"
      }
    ]
  },
  {
    "id": 676,
    "name": "Игра со спичками",
    "description": "Двое играют в следующую игру. Из кучки спичек за один ход игрок вытягивает либо 1, либо 2, либо 1000 спичек. Выигрывает тот, кто забирает последнюю спичку. Кто выигрывает при правильной игре?\nOUTPUT.TXT12322[Лучшие попытки]\nВходные данные\nВ единственной строке входного файла INPUT.TXT записано одно натуральное число — N (1 ≤ N ≤ 10000) начальное количество спичек в кучке.\nВыходные данные\nВ единственную строку выходного файла OUTPUT.TXT нужно вывести 1, если выигрывает первый игрок (тот, кто ходит первым), или 2, если выигрывает второй игрок.",
    "complexity": 28,
    "memory": 16000,
    "time": 1000,
    "examples": [
      {
        "input": "2",
        "output": "1"
      },
      {
        "input": "3",
        "output": "2"
      }
    ]
  },
  {
    "id": 675,
    "name": "Детали",
    "description": "На клеточном поле N•M расположены две жёсткие детали. Деталь A накрывает в каждой строке несколько (не ноль) первых клеток, деталь B — несколько (не ноль) последних; каждая клетка либо полностью накрыта одной из деталей, либо нет.\nOUTPUT.TXT1[Лучшие попытки]\n[Решение]\nДеталь B начинают двигать влево, не поворачивая, пока она не упрётся в A хотя бы одной клеткой. Определите, на сколько клеток будет сдвинута деталь B.\nВходные данные\nВ первой строке входного файла INPUT.TXT записано два числа N и M — число строк и столбцов соответственно (1 ≤ N, M ≤ 100). Далее следуют N строк, задающих расположение деталей. В каждой находится ровно M символов \"A\" (клетка, накрытая деталью A), \"B\" (накрытая деталью B) или \".\" (свободная клетка).\nВыходные данные\nВ единственную строку выходного файла OUTPUT.TXT нужно вывести одно число — ответ на задачу.",
    "complexity": 20,
    "memory": 16000,
    "time": 1000,
    "examples": [
      {
        "input": "4 6\n\nAA.BBB\n\nA....B\n\nAAA..B\n\nA..BBB",
        "output": "1"
      }
    ]
  },
  {
    "id": 698,
    "name": "Игра в дурака",
    "description": "Как Вам уже стало известно, Петя очень любит программировать. Недавно он решил реализовать популярную карточную игру «Дурак». Но у Пети пока маловато опыта, ему срочно нужна Ваша помощь.\nOUTPUT.TXTYES24 1 D\n9S KC AH 7D\n8DNONO[Лучшие попытки]\nКак известно, в «Дурака» играют колодой из 36 карт. В Петиной программе каждая карта представляется в виде строки из двух символов, где первый символ означает ранг (‘6’, ‘7’, ‘8’, ‘9’, ‘T’, ‘J’, ‘Q’, ‘K’, ‘A’) карты, а второй символ означает масть (‘S’, ‘C’, ‘D’, ‘H’). Ранги перечислены в порядке возрастания старшинства.\n[Решение]\nПете необходимо решить следующую задачу: сможет ли игрок, обладая набором из N карт, отбить M карт, которыми под него сделан ход? Для того чтобы отбиться, игроку нужно покрыть каждую из карт, которыми под него сделан ход, картой из своей колоды. Карту можно покрыть либо старшей картой той же масти, либо картой козырной масти. Если кроющаяся карта сама является козырной, то её можно покрыть только старшим козырем. Одной картой можно покрыть только одну карту.\nВходные данные\nВ первой строке входного файла INPUT.TXT находятся два натуральных числа N и M (N ≤ 35, M ≤ 4, M ≤ N), а также символ R, означающий козырную масть. Во второй строке перечислены N карт, находящихся на руках у игрока. В третьей  строке перечислены M карт, которые необходимо отбить. Все карты отделены друг от друга одним пробелом.\nВыходные данные\nВ выходной файл OUTPUT.TXT выведите «YES» в случае, если отбиться можно, либо «NO» , если нельзя.",
    "complexity": 36,
    "memory": 16000,
    "time": 1000,
    "examples": [
      {
        "input": "6 2 C\n\nKD KC AD 7C AH 9C\n\n6D 6C",
        "output": "YES"
      },
      {
        "input": "4 1 D\n\n9S KC AH 7D\n\n8D",
        "output": "NO"
      }
    ]
  },
  {
    "id": 673,
    "name": "N-значные числа - 2",
    "description": "Найти количество N-значных чисел, у которых сумма цифр равна их произведению. Вывести наименьшее среди таких чисел для заданного N.\nOUTPUT.TXT10 0221 221 22[Лучшие попытки]\nВходные данные\nВ единственной строке входного файла INPUT.TXT записано одно натуральное число N, которое не превышает 20.\nВыходные данные\nВ единственную строку выходного файла OUTPUT.TXT нужно вывести через пробел 2 числа: количество искомых чисел и наименьшее среди них.",
    "complexity": 52,
    "memory": 16000,
    "time": 1000,
    "examples": [
      {
        "input": "1",
        "output": "10 0"
      },
      {
        "input": "2",
        "output": "1 22"
      }
    ]
  },
  {
    "id": 674,
    "name": "Выбор приборов",
    "description": "Для проведения эксперимента надо выбрать из N имеющихся приборов только три. Для этого выполняют следующую операцию - если в группе приборов больше трех, то их нумеруют и выбирают одну из групп: с четными или нечетными номерами. Операцию повторяют до тех пор, пока в группе не останется три или менее приборов. Если их остается ровно три, то они и берутся для эксперимента.\nOUTPUT.TXT12622[Лучшие попытки]\nТребуется написать программу, которая подсчитает количество способов такого выбора приборов.\n[Решение]\nВходные данные\nВ единственной строке входного файла INPUT.TXT записано число N (1 ≤ N ≤ 2147483647).\nВыходные данные\nВ единственную строку выходного файла OUTPUT.TXT нужно вывести одно число - найденное количество способов выбора приборов.",
    "complexity": 37,
    "memory": 16000,
    "time": 1000,
    "examples": [
      {
        "input": "3",
        "output": "1"
      },
      {
        "input": "6",
        "output": "2"
      }
    ]
  },
  {
    "id": 699,
    "name": "Грибной дождь",
    "description": "На лесной опушке растет дружная семейка грибов. Местоположение каждого гриба задается координатами X, Y, а шляпка гриба имеет радиус R. Когда идет дождь, радиус шляпки каждого гриба непрерывно и равномерно увеличивается cо скоростью 1 сантиметр в минуту. Когда дождь заканчивается (а он идет не более Т минут), шляпки прекращают расти. Если во время дождя шляпки двух грибов соприкоснулись, то они немедленно перестают расти, чтобы не навредить друг другу. Грибы очень дружные, поэтому если перестают расти два гриба, то и все остальные тоже не растут. \nOUTPUT.TXT0.4123 2\n0 0 1\n5 5 1\n10 10 12.002.00[Лучшие попытки]\nТребуется посчитать, на сколько сантиметров увеличился радиус шляпки каждого гриба после завершения дождя.\n[Решение]\nВходные данные\nПервая строка входного файла INPUT.TXT содержит два натуральных числа: количество грибов K (K ≤ 10) и длительность дождя T (T ≤ 100). Следующие К строк содержат описание грибов: целые координаты X и Y (0 ≤ X, Y ≤ 100) и радиус шляпки R (1 ≤ R ≤ 10). Координаты и радиус даны в сантиметрах.\nВыходные данные\nВ выходной файл OUTPUT.TXT выведите величину в сантиметрах, на которую увеличится радиус всех грибов. Результат следует вывести с точностью, не меньшей, чем два знака после запятой.",
    "complexity": 30,
    "memory": 16000,
    "time": 1000,
    "examples": [
      {
        "input": "2 1\n\n0 0 1\n\n2 2 1",
        "output": "0.41"
      },
      {
        "input": "3 2\n\n0 0 1\n\n5 5 1\n\n10 10 1",
        "output": "2.00"
      }
    ]
  },
  {
    "id": 700,
    "name": "Мёд",
    "description": "Все любят сладости и, в частности, мед. Винни-Пух тоже его любит. Каждый день он шел лакомиться медом, а по дороге домой заходил в гости к Кролику. Но приближалась зима, и Винни-Пух начал задумываться о запасах. Он решил в течении N дней не лакомиться медом, а собирать полный горшочек объемом V горстей и перекладывать его в бочку. В первый день своего собирательства он так и сделал. Терпения хватило на один день. А на следующий день он не смог устоять и по дороге домой съел K горстей меда из горшочка. В каждый следующий день из полного горшочка он съедал на K горстей больше.\nOUTPUT.TXTNO 550210 10 1YES 55YES 55[Лучшие попытки]\nНеобходимо определить объем меда, собранного Винни-Пухом на зиму.\n[Решение]\nВходные данные\nВходной файл INPUT.TXT содержит три натуральных числа N (N ≤ 300), V (V ≤ 107) и K (K ≤ 1000). K – объем, на который Винни-Пух с каждым днем съедал больше меда.\nВыходные данные\nВ выходной файл OUTPUT.TXT выведите два значения через пробел. Сначала идет строка «NO», если случилось, что Винни-Пух пришел к Кролику с пустым горшочком и «YES» в противном случае. Второе значение – объем меда, заготовленного Винни-Пухом на зиму.",
    "complexity": 23,
    "memory": 16000,
    "time": 1000,
    "examples": [
      {
        "input": "15 100 10",
        "output": "NO 550"
      },
      {
        "input": "10 10 1",
        "output": "YES 55"
      }
    ]
  },
  {
    "id": 702,
    "name": "Прямоугольники - 2",
    "description": "Выходные данные\nВ выходной файл OUTPUT.TXT выведите одно целое число – площадь найденной фигуры.",
    "complexity": 45,
    "memory": 16000,
    "time": 1000,
    "examples": [
      {
        "input": "2\n15 15 25 25\n10 10 20 20",
        "output": "175"
      },
      {
        "input": "5\n\n1 1 6 2\n\n2 1 3 5\n\n2 4 7 5\n\n6 2 7 5\n\n8 4 10 7",
        "output": "14"
      }
    ]
  },
  {
    "id": 701,
    "name": "Премия",
    "description": "Несмотря на кризис, компания Soft-Soft работает успешно. Директор компании принял решение выплатить сотрудникам премии. На следующий день был обнародован список счастливчиков. Чтобы не разглашать размер выплат, в списке напротив фамилий красовались странные цифры и даже буквы. Сотрудники быстро догадались, что размер премий записан в различных системах счисления. Но где и какая система счисления используется, сообразила только секретарша Танечка, которая вспомнила, что директор просил ее принести информацию о возрасте сотрудников. Она поняла, что директор отбрасывал десятки из числа, указывающего возраст, а к оставшимся единицам добавлял число 2. Полученное значение служило основанием для представления начисленной премии.\nOUTPUT.TXT2800230 10155[Лучшие попытки]\nПомогите любопытной Танечке узнать размер премий в десятичной системе счисления. Известно, что размер премий не превышает 100000 рублей в десятичной системе счисления.\nВходные данные\nВ первой строке входного файла INPUT.TXT записаны два целых числа N и K – возраст и размер премии, разделенные пробелом. Возраст не превышает 100, размер премии указан в некоторой системе счисления (запись числа не содержит незначащих нулей, использует арабские цифры и заглавные английские буквы).\nВыходные данные\nВ выходной файл OUTPUT.TXT выведите одно число – размер премии в десятичной системе счисления.",
    "complexity": 25,
    "memory": 16000,
    "time": 1000,
    "examples": [
      {
        "input": "28 2800",
        "output": "2800"
      },
      {
        "input": "30 101",
        "output": "5"
      }
    ]
  },
  {
    "id": 681,
    "name": "Спички",
    "description": "Какое минимальное количество спичек необходимо для того, чтобы выложить на плоскости N квадратов со стороной в одну спичку? Спички нельзя ломать и класть друг на друга. Вершинами квадратов должны быть точки, где сходятся концы спичек, а сторонами – сами спички.\nOUTPUT.TXT12[Лучшие попытки]\nНапишите программу, которая по количеству квадратов N, которые необходимо составить, находит минимальное необходимое для этого количество спичек.\nВходные данные\nВ единственной строке входного файла INPUT.TXT записано одно целое число N (1 ≤ N ≤ 109).\nВыходные данные\nВ единственную строку выходного файла OUTPUT.TXT нужно вывести одно целое число – минимальное количество спичек, требуемых для составления заданного количества квадратов.",
    "complexity": 43,
    "memory": 16000,
    "time": 1000,
    "examples": [
      {
        "input": "4",
        "output": "12"
      }
    ]
  },
  {
    "id": 532,
    "name": "Трамвай",
    "description": "С окраины в центр города каждое утро по одному маршруту едут в трамвае N человек. За долгое время поездок они достаточно хорошо узнали друг друга. Чтобы никому не было обидно, они захотели решить, кто из них и между какими остановками маршрута должен сидеть, а кто должен стоять. Все остановки пронумерованы от 1 до P.iiOUTPUT.TXT28На третьей остановке встают и выходят первый и третий пассажиры, второй и четвертый садятся на их места;[Лучшие попытки]\nОдин из пассажиров оказался знатоком теории математического моделирования. Он предложил рассмотреть значение суммарного удовлетворения пассажиров. Для каждого i-го пассажира он оценил две величины – ai и bi. Если в течение одного переезда между остановками пассажир сидит, то к суммарному удовлетворению прибавляется ai, если же он стоит, то прибавляется bi. iiНа четвертой остановке выходят второй  и четвертый пассажиры.\nВсего в трамвае M сидячих мест. Вставать и садиться пассажиры могут мгновенно на любой остановке. Кроме того, некоторые пассажиры предпочитают ехать стоя, даже если в трамвае есть свободные места (для них ai \u003c bi).6\nТребуется написать программу, которая вычисляет значение максимально достижимого суммарного удовлетворения, если для каждого i-го пассажира известны величины ai и bi, а также номера остановок, на которых он садится и выходит из трамвая.i\nВходные данныеi\nПервая строка входного файла INPUT.TXT содержит разделенные пробелом три целых числа N, M и P — число пассажиров, число сидячих мест и число остановок на маршруте соответственно (1 ≤ N, M, P ≤ 100 000; 2 ≤ P).6\nКаждая из следующих N строк содержит информацию об очередном пассажире в виде четырех целых чисел ai, bi, ci, di, где первые два числа определяют вклад в параметр счастья, третье – номер остановки, на которой пассажир садится в трамвай, и последнее – номер остановки, на которой он выходит из трамвая (−106 ≤ ai, bi ≤ 106; 1 ≤ ci \u003c di ≤ P).i\niВыходные данные\nВ выходной файл OUTPUT.TXT необходимо вывести одно целое число — максимальное суммарное удовлетворение, которого могут добиться пассажиры.",
    "complexity": 74,
    "memory": 16000,
    "time": 1000,
    "examples": [
      {
        "input": "4 2 4\n\n10 -10 2 3\n\n-1 -3 1 4\n\n6 -6 1 3\n\n7 4 2 4",
        "output": "28"
      }
    ]
  },
  {
    "id": 593,
    "name": "Башни - 2",
    "description": "iOUTPUT.TXT2\n5\n4\n4\n4\n10\n4\n4\n5\n3\n5[Лучшие попытки]\nДля того, чтобы защититься от некоторых соседей, король решил построить стену, имеющую форму отрезка. С некоторыми соседями король находится в хороших отношениях, а некоторым готовится объявить войну. Король решил не загораживаться от друзей очень высокой стеной. Однако, стена, отделяющая его от врагов, должна быть достаточно высокой. Было решено, что для наблюдения за прилежащей территорией нужно построить башни. При этом, на участках между башнями высота стен должна изменяться равномерно.\nПосле того, как стена и башни были построены, король заметил, что башни могут быть использованы для наблюдения за состоянием других башен. Однако, некоторые башни оказались очень высокими и загородили другие.\nДля каждой башни король попросил вас выяснить, сколько других башен из нее видно.\nВходные данные\nВ первой строке входного файла INPUT.TXT находится n (2 ≤ n ≤ 2000) - количество башен стены. В следующих n строках находятся натуральные числа xi и hi (0 ≤ xi ≤ 100000, 1 ≤ hi ≤ 10000) - координата и высота i-ой башни. Все xi различны.\nВыходные данные\nВыходной файл OUTPUT.TXT должен содержать n строк. В i-ой строке выведите количество башен, которые видно из башни номер i.",
    "complexity": 53,
    "memory": 16000,
    "time": 1000,
    "examples": [
      {
        "input": "11\n\n0 4\n\n3 5\n\n5 3\n\n6 4\n\n7 5\n\n8 8\n\n10 5\n\n12 4\n\n14 3\n\n17 1\n\n19 7",
        "output": "2\n\n5\n\n4\n\n4\n\n4\n\n10\n\n4\n\n4\n\n5\n\n3\n\n5"
      }
    ]
  },
  {
    "id": 627,
    "name": "Игра в слова",
    "description": "Существует множество игр, которые называются «игра в слова». В одной из вариаций правила следующие: выбирается длинное слово, после чего два игрока пытаются вспомнить все слова, которые можно составить, используя некоторые буквы загаданного слова. После этого они по очереди называют придуманные слова (называть одно слово два раза запрещается). Если первый игрок назвал больше слов, то он побеждает, если у обоих игроков слова закончились одновременно, засчитывается ничья, в оставшемся случае побеждает второй.\n1OUTPUT.TXT021[Лучшие попытки]\nОказывается, в этой игре важно не только знать много слов, но и придерживаться правильной стратегии. Напишите программу, которая будет узнавать, кто победит, если оба игрока будут играть идеально, если первый игрок будет играть оптимально, а второй - наихудшим образом, и если первый игрок будет поддаваться. При этом можно считать, что, придумав слова, игроки записывают их на бумагу, и каждый видит записи предыдущего. Если на ходу того игрока, который поддается, у него остаются не упоминавшиеся ранее слова, он обязан назвать одно из них.\n2\nВходные данные2\nВ первой строке входного файла INPUT.TXT записано загаданное слово. Затем описываются слова, которые знает первый игрок - на отдельной строке целое число n1 (0 ≤ n1 ≤ 10000), за которым следуют n1 слов по одному на строке. После этого задается число n2 слов  (0 ≤ n2 ≤ 10000), известных второму игроку, и описываются сами эти слова в таком же формате. Все слова состоят из маленьких букв английского алфавита, а их длины не превосходят 100 символов. В списках слов, известных игрокам, могут содержаться слова, которые нельзя составить из букв загаданного слова.\nВыходные данные\nВ выходной файл OUTPUT.TXT выведите три числа по одному на строке - ответы для случаев, когда оба игрока играют оптимально и когда поддаются первый и второй игроки соответственно: номер выигрывающего игрока и 0 в случае ничьи.",
    "complexity": 48,
    "memory": 16000,
    "time": 1000,
    "examples": [
      {
        "input": "internationalization\n\n6\n\nzone\n\noil\n\nrent\n\nimpression\n\nnoir\n\ntrail\n\n7\n\nteal\n\ncreativity\n\nrent\n\nrain\n\noil\n\nzealot\n\nzone",
        "output": "0\n2\n1"
      }
    ]
  },
  {
    "id": 678,
    "name": "Напёрстки",
    "description": "Шулер показывает следующий трюк. Он имеет три одинаковых наперстка. Под первый (левый) он кладет маленький шарик. Затем он очень быстро выполняет ряд перемещений наперстков, каждое из которых – это одно из трех перемещений - A, B, C:\nC - обменять местами левый и правый наперстки.OUTPUT.TXT1[Лучшие попытки]\nA - обменять местами левый и центральный наперстки,\nB - обменять местами правый и центральный наперстки,\nC - обменять местами левый и правый наперстки.\n[Решение]\nНеобходимо определить, под каким из наперстков окажется шарик после всех перемещений.\nВходные данные\nВ единственной строке входного файла INPUT.TXT записана строка длиной от 1 до 50 символов из множества {A, B, C} – последовательность перемещений.\nВыходные данные\nВ единственную строку выходного файла OUTPUT.TXT нужно вывести номер наперстка, под которым окажется шарик после перемещений.",
    "complexity": 15,
    "memory": 16000,
    "time": 1000,
    "examples": [
      {
        "input": "CBABCACCC",
        "output": "1"
      }
    ]
  },
  {
    "id": 679,
    "name": "Просто простые числа",
    "description": "Дано натуральное число N. Представить его в виде суммы простых натуральных чисел так, чтобы произведение этих слагаемых было максимально.\nOUTPUT.TXT2 1 3 12303 103 10[Лучшие попытки]\nВходные данные\nВ единственной строке входного файла INPUT.TXT записано одно натуральное число N (2 ≤ N ≤ 2 000 000 000).\nВыходные данные\nВ единственную строку выходного файла OUTPUT.TXT нужно вывести простые числа по возрастанию с указанием их количества при разложении, т.е.: \u003cчисло\u003e \u003cколичество\u003e.",
    "complexity": 40,
    "memory": 16000,
    "time": 1000,
    "examples": [
      {
        "input": "5",
        "output": "2 1 3 1"
      },
      {
        "input": "30",
        "output": "3 10"
      }
    ]
  },
  {
    "id": 683,
    "name": "Числа - 3",
    "description": "Дана последовательность чисел a1,  a2, …, aN. За одну операцию разрешается удалить любое (кроме крайних) число, заплатив за это штраф, равный произведению этого числа на сумму соседних. Требуется удалить все числа, кроме крайних, с минимальным суммарным штрафом.\nNУдаляем третье число, штраф 51(50+1)=2601, получаем 1 50 1.NOUTPUT.TXT5301[Лучшие попытки]\nНапример:\nУдаляем второе число, штраф 50(1+1)=100.[Решение]\nНачальная последовательность: 1 50 51 50 1.\nУдаляем четвёртое число, штраф 50(51+1)=2600, получаем 1 50 51 1.\nУдаляем третье число, штраф 51(50+1)=2601, получаем 1 50 1.\nУдаляем второе число, штраф 50(1+1)=100.\nИтого штраф 5301.\nИтого штраф 5301.\nВходные данные\nВ первой строке входного файла INPUT.TXT записано одно число N (1 ≤ N ≤ 100) - количество чисел в последовательности.\nВо второй строке находятся N целых чисел a1,  a2, …, aN; никакое из чисел не превосходит по модулю 100.\nВыходные данные\nВ единственную строку выходного файла OUTPUT.TXT нужно вывести одно число - минимальный суммарный штраф.",
    "complexity": 48,
    "memory": 16000,
    "time": 1000,
    "examples": [
      {
        "input": "5\n1 50 51 50 1",
        "output": "5301"
      }
    ]
  },
  {
    "id": 677,
    "name": "Количество участников олимпиады",
    "description": "Как известно, на вопрос о том, сколько у него учеников, древнегреческий учёный Пифагор отвечал так: \"Половина моих учеников изучает математику, четвертая часть изучает природу, седьмая часть проводит время в молчаливом размышлении, остальную часть составляют 3 девы\".\nOUTPUT.TXT2822 2 2 3-1-1[Лучшие попытки]\nСекретарь олимпиады на вопрос: \"Сколько участников на олимпиаде по информатике?\", отвечал подобно Пифагору: \"K-тая часть участников начала решать первую задачу, M-тая часть – вторую, а N-тая – третью. В то же время D участников решают проблему: \"С чего начать?\". Ваша задача определить количество участников олимпиады или вывести -1, если секретарь ошибся.\nВходные данные\nВ единственной строке входного файла INPUT.TXT записаны числа K, N, M, D (1 ≤ K, N, M, D ≤ 100).\nВыходные данные\nВ единственную строку выходного файла OUTPUT.TXT нужно вывести одно число - количество участников олимпиады или вывести -1, если секретарь ошибся.",
    "complexity": 29,
    "memory": 16000,
    "time": 1000,
    "examples": [
      {
        "input": "2 4 7 3",
        "output": "28"
      },
      {
        "input": "2 2 2 3",
        "output": "-1"
      }
    ]
  },
  {
    "id": 594,
    "name": "Треугольник - 2",
    "description": "После окончания многолетней войны короли-победители решили разделить между собой захваченную территорию. Для того, чтобы избежать лишних споров, короли решили делить территорию следующим образом.\nOUTPUT.TXT291590.02336241917 1 5[Лучшие попытки]\nКаждому королю был предоставлен набор, состоящий из n отрезков L1, . . . , Ln. Королям разрешается присоединять к их королевствам территорию, имеющую форму треугольника, составленного из имеющихся отрезков.\nПомогите королю вашего королевства максимизировать площадь треугольника.\nВходные данные\nНа первой строке входного файла INPUT.TXT задано число n (3 ≤ n ≤ 100000) - количество отрезков в наборе. В следующих n строках заданы длины отрезков в следующем формате.\nСначала указывается целое положительное число L - длина отрезка, а затем единица измерения (m, km, mile, uin, kairi, zhang, sen).\nНапомним, что: 1mile = 1609m, 1km = 1000m, 1uin = 33m, 1kairi = 1852m, 1zhang = 3m и 1sen = 38m.\nДлины всех отрезков не превосходят десяти километров. Гарантируется, что из заданных отрезков можно выбрать три отрезка так, что из них можно составить треугольник.\nВыходные данные\nВ выходной файл OUTPUT.TXT выведите максимальную площадь (в таланг  вахах) с точностью 10-6 и номера трех отрезков в любом порядке (если ответов несколько, выведите любой). Помните, что один таланг вах равен четырем квадратным метрам.",
    "complexity": 45,
    "memory": 32000,
    "time": 1000,
    "examples": [
      {
        "input": "7\n\n1mile\n\n1km\n\n100m\n\n20uin\n\n1kairi\n\n300zhang\n\n40sen",
        "output": "291590.0233624191\n7 1 5"
      }
    ]
  },
  {
    "id": 595,
    "name": "Слова",
    "description": "",
    "complexity": 48,
    "memory": 16000,
    "time": 1000,
    "examples": [
      {
        "input": "wpwdwpw\nwdwpwpw",
        "output": "Yes\n2"
      },
      {
        "input": "dWOddWd\ndOdWdWd",
        "output": "No"
      }
    ]
  },
  {
    "id": 684,
    "name": "Шашки - 2",
    "description": "На доске стоит белая шашка. Требуется определить, может ли она попасть в заданную клетку, делая ходы по правилам (не превращаясь в дамку).\nOUTPUT.TXTYES2b2 a1NOНазад шашка ходить не можетNONOYES[Лучшие попытки]\nВходные данныеКомментарииДля выполнения указанного перемещения шашка должна сделать один ход вперед и вправоНазад шашка ходить не может3a1 h7NOa1 и h7 - клетки разного цветаa1 и h7 - клетки разного цвета7 ходов вправо вверх\nВ единственной строке входного файла INPUT.TXT записаны клетка, где стоит шашка, в шахматной нотации, а затем, через пробел, клетка, куда шашка должна попасть. Начальная и конечная клетки не совпадают. Гарантируется, что стартовая позиция шашки находится на клетке черного цвета.\n4a1 h8YES7 ходов вправо вверх\nВыходные данные\nВ единственную строку выходного файла OUTPUT.TXT нужно вывести слово YES (заглавными буквами), если шашка может попасть из начальной клетки в конечную, и NO в противном случае.",
    "complexity": 27,
    "memory": 16000,
    "time": 1000,
    "examples": [
      {
        "input": "a1 b2",
        "output": "YES"
      },
      {
        "input": "b2 a1",
        "output": "NO"
      },
      {
        "input": "a1 h7",
        "output": "NO"
      },
      {
        "input": "a1 h8",
        "output": "YES"
      }
    ]
  },
  {
    "id": 597,
    "name": "Внеземные гости",
    "description": "Недавно на поле фермера Джона были обнаружены следы приземления летающих тарелок. Об этом даже писала газета Mew Yorc Courier.\n33OUTPUT.TXTNO210 3 4YESYES[Лучшие попытки]\nПоле фермера Джона имеет форму круга радиусом r1. По сообщениям журналистов были обнаружены два следа от летающих тарелок, имевшие форму кругов. Один из них имел радиус r2, второй - радиус r3. Также сообщается, что они находились внутри поля фермера Джона и не пересекались, ни один из них не лежал внутри другого. При этом, они, возможно, касались друг друга и/или границы поля.\n1[Решение]\nПоскольку журналисты часто склонны преувеличивать масштабы событий, необходимо написать программу, которая будет проверять, могли ли иметь место события, описанные в газете.\n2\nВходные данные3\nПервая строка входного файла INPUT.TXT содержит три положительных целых числа через пробел - r1, r2, r3 (1 ≤ r1, r2, r3 ≤ 109).\n9\nВыходные данные\nВ выходной файл OUTPUT.TXT выведите слово YES, если информация, опубликованная в газете, может соответствовать правде, и слово NO - иначе.",
    "complexity": 10,
    "memory": 16000,
    "time": 1000,
    "examples": [
      {
        "input": "10 10 10",
        "output": "NO"
      },
      {
        "input": "10 3 4",
        "output": "YES"
      }
    ]
  },
  {
    "id": 682,
    "name": "Сумма n-значных чисел",
    "description": "По заданному n найти сумму  всех n-значных чисел.\nOUTPUT.TXT452249054905[Лучшие попытки]\n[Решение]\nВходные данные\nВ единственной строке входного файла INPUT.TXT записано одно натуральное число n (1 ≤ n ≤ 100).\nВыходные данные\nВ единственную строку выходного файла OUTPUT.TXT нужно вывести все цифры суммы всех n-значных чисел.",
    "complexity": 30,
    "memory": 16000,
    "time": 1000,
    "examples": [
      {
        "input": "1",
        "output": "45"
      },
      {
        "input": "2",
        "output": "4905"
      }
    ]
  },
  {
    "id": 598,
    "name": "Друзья - 2",
    "description": "Несколько человек решили поехать отдохнуть на природе, подышать свежим воздухом и т.п. Как это часто бывает, некоторые из них дружат друг с другом, а некоторые - нет. Для того, чтобы не испортить никому настроение, они решили разделиться на несколько групп. При этом, в каждой группе должно быть не более 5 человек и они должны дружить друг с другом.\nOUTPUT.TXT21 1 228\n1 1 1 1 1 1 1 1\n1 1 1 1 1 1 1 1\n1 1 1 1 1 1 1 1\n1 1 1 1 1 1 1 1\n1 1 1 1 1 1 1 1\n1 1 1 1 1 1 1 1\n1 1 1 1 1 1 1 1\n1 1 1 1 1 1 1 131 1 1 1 1 2 2 331 1 1 1 1 2 2 3[Лучшие попытки]\nНайдите такое разбиение людей на группы, в котором размер наибольшей группы был бы максимальным (среди всех разбиений).\nВходные данные\nПервая строка входного файла INPUT.TXT содержит целое число n (1 ≤ n ≤ 15) - количество людей. Следующие n строк содержат по n чисел. Если i-ый и j-ый люди дружат, то j-ое число i + 1-ой строки равно 1, иначе - 0.\nВыходные данные\nВ первой строке выходного файла OUTPUT.TXT выведите число групп. Во второй строке выходного файла выведите n чисел (i-ое число - номер группы, в которой находится i-ый человек). Нумеруйте группы целыми числами от 1 до числа групп. Если решений несколько, то выведите любое.",
    "complexity": 51,
    "memory": 16000,
    "time": 1000,
    "examples": [
      {
        "input": "3\n\n1 1 0\n\n1 1 0\n\n0 0 1",
        "output": "2\n1 1 2"
      },
      {
        "input": "8\n\n1 1 1 1 1 1 1 1\n\n1 1 1 1 1 1 1 1\n\n1 1 1 1 1 1 1 1\n\n1 1 1 1 1 1 1 1\n\n1 1 1 1 1 1 1 1\n\n1 1 1 1 1 1 1 1\n\n1 1 1 1 1 1 1 1\n\n1 1 1 1 1 1 1 1",
        "output": "3\n1 1 1 1 1 2 2 3"
      }
    ]
  },
  {
    "id": 596,
    "name": "Сотовая связь в большом городе",
    "description": "В одном из больших городов нашей страны хорошо развит рынок сотовой связи. На рынке присутствуют несколько операторов, каждому из которых принадлежит некоторое количество базовых станций, с помощью которых организуется связь.\naOUTPUT.TXT5\nMegahorn 1\nBeepLine 1\nMPS 1\nEle2 0\nSkyPink 023\nMegahorn\n0 0 10\nMPS\n1 1 10\nMegahorn\n2 2 10\n1 12\nMegahorn 2\nMPS 12\nMegahorn 2\nMPS 1[Лучшие попытки]\nКаждая базовая станция характеризуется своими координатами (для простоты размерами базовых станций пренебрегаем) и радиусом надежной связи (если абонент находится на расстоянии, не превосходящем этот радиус, от базовой станции, то она может использоваться для работы с ним - передачи ему сигналов и приема сигналов от него).\na\nИзвестный производитель сотовых телефонов Mokea планирует оснастить свою новую модель сотового телефона функцией определения базовых станций, с которыми может работать абонент. Вам же предстоит написать программу, которая по местоположению абонента для каждого оператора определит, сколько базовых станций этого оператора могут работать с абонентом.\nВходные данные\nПервая строка входного файла INPUT.TXT содержит целое число n (1 ≤ n ≤ 10000) - количество базовых станций в городе. Далее идут описания этих базовых станций. Каждое описание занимает две строки. На первой расположено название оператора сотовой связи, которому принадлежит эта базовая станция, а на второй - три целых числа x, y, r (-10000 ≤ x, y ≤ 10000, 1 ≤ r ≤ 10000) - соответственно ее координаты и радиус надежной связи. Последняя строка входного файла содержит два целых числа xa, ya (-10000 ≤ xa, ya ≤ 10000) - координаты абонента.\nВсе координаты во входном файле даны в одной и той же декартовой прямоугольной системе координат. Названия операторов - это непустые строки длиной не более 50 символов, состоящие из цифр, строчных и прописных букв английского алфавита. Прописные и строчные буквы английского алфавита различаются (например, MPS и mps - два разных оператора).\nВыходные данные\nНа первой строке выходного файла OUTPUT.TXT выведите число k – количество операторов сотовой связи, работающих в городе (разумеется, два оператора считаются разными, если их названия не совпадают). Далее выведите k строк. Каждая из этих строк должна содержать название оператора и количество базовых станций этого оператора, доступных абоненту. Первым должно идти название оператора, число базовых станций должно быть отделено от него одним пробелом. В этом списке операторы должны быть перечислены в том же порядке, в каком они встречаются во входном файле (см. примеры). Гарантируется, что k ≤ 100.",
    "complexity": 35,
    "memory": 16000,
    "time": 1000,
    "examples": [
      {
        "input": "5\n\nMegahorn\n\n0 0 10\n\nBeepLine\n\n10 10 10\n\nMPS\n\n0 0 10\n\nEle2\n\n0 0 1\n\nSkyPink\n\n100 100 10\n\n5 5",
        "output": "5\n\nMegahorn 1\n\nBeepLine 1\n\nMPS 1\n\nEle2 0\n\nSkyPink 0"
      },
      {
        "input": "3\n\nMegahorn\n\n0 0 10\n\nMPS\n\n1 1 10\n\nMegahorn\n\n2 2 10\n\n1 1",
        "output": "2\n\nMegahorn 2\n\nMPS 1"
      }
    ]
  },
  {
    "id": 629,
    "name": "Сочетания",
    "description": "Петя выписал все сочетания из N первых английских букв по K букв. В каждом сочетании он выписывал буквы в лексикографическом порядке. Сочетания он выписывал в лексикографическом порядке по одному в строке. Теперь он хочет узнать: какое слово записано в M-ой строке.\nOUTPUT.TXTad[Лучшие попытки]\nВходные данные\nВо входном файле INPUT.TXT записаны целые числа N, K, M (1 ≤ N ≤ 26, 1 ≤ K ≤ N). Гарантируется, что M не превосходит количества всех выписанных сочетаний.\nВыходные данные\nВ выходной файл OUTPUT.TXT выведите M-ое выписанное сочетание.",
    "complexity": 55,
    "memory": 16000,
    "time": 1000,
    "examples": [
      {
        "input": "4 2 3",
        "output": "ad"
      }
    ]
  },
  {
    "id": 628,
    "name": "Clear World and Brothers",
    "description": "Наконец в деревнях Виллорибо и Виллобаджо закончились праздники. Перемыта вся посуда! Этот процесс прошел так быстро и непринужденно, что братьями Карлионе было решено открыть сеть агентств «Clear World and Brothers», специализирующихся на профессиональном мытье посуды. В области Новая Берляндия, где и находятся знаменитые деревни, всего N деревень. Система координат введена так, что Виллорибо имеет координаты (x1, 0), а Виллобаджо - (x2, 0). Координаты всех деревень целые числа не превосходящие по модулю 106. Вы работаете на мистера Берлионе старшего и ваша задача найти оптимальное расположение для регионального отделения «Clear World and Brothers», то есть сумма расстояний от агентства до всех деревень должна быть наименьшей и агентство обязательно должно располагаться на прямолинейном шоссе Виллорибо-Виллобаджо (возможно расположение не только внутри, но и на границе отрезка).\n6OUTPUT.TXT2.000000[Лучшие попытки]\nВходные данные\nВ первой строке входного файла INPUT.TXT записано натуральное число N (2 ≤ N ≤ 15000). Далее в N строках записаны пары координат всех вершин. Виллорибо и Виллобаджо первая и вторая деревня соответственно. Возможно, что сколько-то деревень расположены так близко, что их координаты совпадают.\nВыходные данные\nВ выходной файл OUTPUT.TXT выведите абсциссу оптимального расположения агентства. Разрешается абсолютная погрешность не более единицы.",
    "complexity": 46,
    "memory": 16000,
    "time": 1000,
    "examples": [
      {
        "input": "4\n\n-10 0\n\n10 0\n\n3 1\n\n1 -1",
        "output": "2.000000"
      }
    ]
  },
  {
    "id": 592,
    "name": "Небоскреб",
    "description": "Спасатели разрабатывают новую систему действий при возникновении аварийных ситуациях на небоскребах. В этих случаях важно определять, какие части здания стоят устойчиво, а какие - нет.\n(1)OUTPUT.TXT5 5 5 5 6 6 6 1[Лучшие попытки]\nНа данный момент используется следующая двумерная модель. Строение описывается как прямоугольник, составленный из одинаковых блоков квадратной формы. Предполагается, что при аварии некоторые из блоков полностью разрушаются, а остальные остаются неповрежденными. Будем называть сегментом множество блоков, таких что из любого можно дойти до любого другого, если разрешается переходить из блока в блок, имеющий с ним общую сторону.\ni\nСчитается, что сегмент стоит устойчиво, если один из его блоков соприкасается с нижней стороной прямоугольника. (1)\nСегменты из блоков, которые стоят неустойчиво, проваливаются вниз до тех пор, пока какой-либо из блоков сегмента не будет соприкасаться с нижней стороной прямоугольника или с блоком устойчивого сегмента. После этого сегмент так же считаются стоящим устойчиво.\ni\nПо данным о том, какие блоки сохранились, требуется определить положение верхнего блока в каждом вертикальном столбце.\n(2)\ni\nВходные данные(2)\nПервая строка входного файла INPUT.TXT содержит одно целое число m (1 ≤ m ≤ 10 000). За ней следуют m строк, описывающих вертикальные столбцы. Описание производится в таком порядке: сначала записано число ai оставшихся целыми фрагментов этого вертикального столбца, за которым следуют 2ai чисел l(1)i, r(1)i, l(2)i, r(2)i, …, l(ai)i, r(ai)i, задающие нижние и верхние границы уцелевших фрагментов. При этом 1 ≤ l(1)i ≤ r(1)i , l(2)i ≤ r(2)i , . . . , l(ai)i ≤ r(ai)i ≤ 106, для всех допустимых i и j выполнено r(j)i \u003c l(j+1)i - 1. Сумма всех ai не превосходит 100 000.\ni\n(ai)Выходные данные\ni\nВ выходной файл OUTPUT.TXT выведите m чисел - высоты, на которых находится самый верхний блок в соответствующем вертикальном столбце.\n(ai)Пример\ni\n№INPUT.TXTOUTPUT.TXT\n18\n2 1 1 4 6\n2 1 1 6 6\n2 1 4 6 6\n2 1 1 6 6\n3 1 1 4 6 8 8\n2 1 1 8 8\n2 1 3 7 8\n1 6 65 5 5 5 6 6 6 1\n(1)\niДля отправки решения задачи необходимо зарегистрироваться и авторизоваться!\n(1)\n\n  [Обсуждение]\n\n  [Все попытки]\n\n  [Лучшие попытки]\ni\n(2)\n\n\n\nwindow.yaContextCb.push(()=\u003e{\n  Ya.Context.AdvManager.render({\n    renderTo: 'yandex_rtb_R-A-122393-3',\n    blockId: 'R-A-122393-3'\n  })\n})\ni\n(2)\ni\n(ai)\ni\n(ai)\ni\n6\n(j)\ni\n(j+1)\ni\ni",
    "complexity": 77,
    "memory": 16000,
    "time": 1000,
    "examples": [
      {
        "input": "8\n\n2 1 1 4 6\n\n2 1 1 6 6\n\n2 1 4 6 6\n\n2 1 1 6 6\n\n3 1 1 4 6 8 8\n\n2 1 1 8 8\n\n2 1 3 7 8\n\n1 6 6",
        "output": "5 5 5 5 6 6 6 1"
      }
    ]
  },
  {
    "id": 511,
    "name": "Очередь",
    "description": "Студент Василий живет в общежитии. Отделение банка, в котором он производит оплату за проживание, имеет всего две кассы, поэтому почти всегда длинная очередь к ним. Первая касса открывается в 8.00, вторая – в 8.05. Последний клиент будет принят в 20.00. Очередь единая, и очередной клиент обслуживается, как только освобождается одна из касс. На обслуживание одного клиента уходит ровно 10 минут. Василий приходит ровно в 8.00 и видит, сколько человек стоит перед ним. Требуется определить, сколько времени ему придется простоять в очереди, и вообще обслужат ли его сегодня.\nOUTPUT.TXT0 02201 351 35NO[Лучшие попытки]\nВходные данные3235NO\nВходной файл INPUT.TXT содержит единственное натуральное число K – номер Василия в очереди (K \u003c 250).\nВыходные данные\nВ выходной файл OUTPUT.TXT выводится строка «NO», если Василий сегодня заплатить уже не успеет, и время его ожидания (в формате «X Y», где X – количество целых часов, которые простоит в очереди Василий, и Y – количество минут), если все же успеет заплатить.",
    "complexity": 20,
    "memory": 16000,
    "time": 1000,
    "examples": [
      {
        "input": "1",
        "output": "0 0"
      },
      {
        "input": "20",
        "output": "1 35"
      },
      {
        "input": "235",
        "output": "NO"
      }
    ]
  },
  {
    "id": 630,
    "name": "Охрана",
    "description": "На секретной военной базе работает N охранников. Сутки поделены на 10000 равных промежутков времени, и известно когда каждый из охранников приходит на дежурство и уходит с него. Например, если охранник приходит в 5, а уходит в 8, то значит, что он был в 6, 7 и 8-ой промежуток. В связи с уменьшением финансирования часть охранников решено было сократить. Укажите: верно ли то, что для данного набора охранников, объект охраняется в любой момент времени хотя бы одним охранником и удаление любого из них приводит к появлению промежутка времени, когда объект не охраняется.\nOUTPUT.TXTWrong AnswerAccepted[Лучшие попытки]\nВходные данные\nВ первой строке входного файла INPUT.TXT записано натуральное число K (1 ≤ K ≤ 30) – количество тестов в файле. Каждый тест начинается с числа N (1 ≤ N ≤ 10000), за которым следует N пар неотрицательных целых чисел A и B - время прихода на дежурство и ухода (0 ≤ A \u003c B ≤ 10000) соответствующего охранника. Все числа во входном файле разделены пробелами и/или переводами строки.\nВыходные данные\nВ выходной файл OUTPUT.TXT выведите K строк, где в M-ой строке находится слово Accepted, если M-ый набор охранников удовлетворяет описанным выше условиям. В противном случае выведите Wrong Answer.",
    "complexity": 42,
    "memory": 16000,
    "time": 1000,
    "examples": [
      {
        "input": "2\n\n3 0 3000 2500 7000 2700 10000\n\n2 0 3000 2700 10000",
        "output": "Wrong Answer\nAccepted"
      }
    ]
  },
  {
    "id": 685,
    "name": "Золотой песок",
    "description": "Выходные данные\nВ единственную строку выходного файла OUTPUT.TXT нужно вывести единственное целое число – сумму в рублях, которую смогут сотрудники заработать в случае наилучшего для себя заполнения емкостей песком.",
    "complexity": 10,
    "memory": 16000,
    "time": 1000,
    "examples": [
      {
        "input": "1 2 3 3 2 1",
        "output": "14"
      }
    ]
  },
  {
    "id": 632,
    "name": "Отрезки",
    "description": "Дан прямоугольник на координатной плоскости с левым нижним углом в точке (0, 0), а правым верхним - в точке (W, H) и отрезки, параллельные осям координат. Отрезки задаются координатами своих концов. Эти отрезки разрезают прямоугольник на несколько частей (возможно, одну). Требуется определить их площади. Отрезки могут пересекаться, накладываться и вырождаться в точку. Все координаты - целые числа по модулю не превосходящие 10000.\niOUTPUT.TXT5\n2\n1\n1[Лучшие попытки]\nВходные данныеi\nВ первой строке входного файла INPUT.TXT указываются числа W и H (1 ≤ W, H ≤ 10000). Во второй строке N (0 ≤ N ≤ 50) - количество отрезков. Далее в N строках через пробел указываются числа Ai, Bi, Ci, Di - координаты концов i-го отрезка: (Ai, Bi) и (Ci, Di).\ni\niВыходные данные\ni\nВыходной файл OUTPUT.TXT должен содержать последовательность положительных чисел – площади областей, записанные в порядке не возрастания.\niПример\n№INPUT.TXTOUTPUT.TXT\n13 3\n3\n1 3 1 1\n1 2 4 2\n2 0 2 85\n2\n1\n1\nДля отправки решения задачи необходимо зарегистрироваться и авторизоваться!\n[Обсуждение]\n\n  [Все попытки]\n\n  [Лучшие попытки]\nwindow.yaContextCb.push(()=\u003e{\n  Ya.Context.AdvManager.render({\n    renderTo: 'yandex_rtb_R-A-122393-3',\n    blockId: 'R-A-122393-3'\n  })\n})",
    "complexity": 68,
    "memory": 16000,
    "time": 1000,
    "examples": [
      {
        "input": "3 3\n\n3\n\n1 3 1 1\n\n1 2 4 2\n\n2 0 2 8",
        "output": "5\n\n2\n\n1\n\n1"
      }
    ]
  },
  {
    "id": 471,
    "name": "Ход конем",
    "description": "123\n456\n789\n0\n367899OUTPUT.TXT8221616[Лучшие попытки]\n0\nШахматная ассоциация решила оснастить всех своих сотрудников такими телефонными номерами, которые бы набирались на кнопочном телефоне ходом коня. Например, ходом коня набирается телефон 340-49-27. При этом телефонный номер не может начинаться ни с цифры 0, ни с цифры 8.\n[Решение]\nТребуется написать программу, определяющую количество телефонных номеров длины N, набираемых ходом коня.\nВходные данные\nВходной файл INPUT.TXT содержит натуральное число N (N ≤ 100).\nВыходные данные\nВ выходной файл OUTPUT.TXT выведите искомое количество телефонных номеров.",
    "complexity": 53,
    "memory": 16000,
    "time": 1000,
    "examples": [
      {
        "input": "2",
        "output": "3"
      },
      {
        "input": "5",
        "output": "6"
      },
      {
        "input": "8",
        "output": "9"
      },
      {
        "input": "0",
        "output": ""
      },
      {
        "input": "1",
        "output": "8"
      },
      {
        "input": "2",
        "output": "16"
      }
    ]
  },
  {
    "id": 631,
    "name": "Отгадай число",
    "description": "Двое играют в игру. Первый игрок (ведущий) загадал число от 1 до N. Второй хочет отгадать это число. Для достижения цели он задает вопросы. Каждый вопрос имеет вид: «Содержится ли загаданное число в наборе S?», где S - произвольный набор чисел от 1 до N. В случае положительного ответа второй игрок платит две конфеты ведущему, в противном случае - одну.\nOUTPUT.TXT52222[Лучшие попытки]\nКакое наименьшее количество конфет должен иметь второй игрок, чтобы наверняка суметь отгадать число?\nВходные данные\nВходной файл INPUT.TXT содержит целое число N (1 ≤ N ≤ 105).\nВыходные данные\nВ выходной файл OUTPUT.TXT выведите искомое количество конфет.",
    "complexity": 60,
    "memory": 16000,
    "time": 1000,
    "examples": [
      {
        "input": "6",
        "output": "5"
      },
      {
        "input": "2",
        "output": "2"
      }
    ]
  },
  {
    "id": 633,
    "name": "ACM World Finals",
    "description": "Некоторые из вас, наверно, знают, что ежегодно проводится чемпионат мира по программированию среди студентов (http://acm.baylor.edu). В финал этого соревнования проходят около 80 команд со всего мира.\nOUTPUT.TXTDream Team: Cormen, Dijkstra, Knuth2Ivanovs Team\nIvanov\nIvanov\nIvanovIvanovs Team: Ivanov, Ivanov, IvanovIvanovs Team: Ivanov, Ivanov, IvanovTeam: a, aa, aaaTeam: A, B, aSpace Team: de Gea, von Bismarck, von der Leyen[Лучшие попытки]\nКаждая команда состоит из трех человек и имеет название. Напишите программу, которая по краткому названию команды и фамилиям ее участников, строит полное название команды.\n3Team\na\naa\naaaTeam: a, aa, aaa\nПолное название команды состоит из краткого названия команды и списка фамилий ее участников. Фамилии участников в списке должны быть упорядочены по алфавиту и отделены друг от друга запятыми. Название команды от фамилий участников должно быть отделено двоеточием. После каждого знака препинания должен стоять ровно один пробел.\n4Team\na\nA\nBTeam: A, B, a\nВходные данные5Space Team\nvon der Leyen\nde Gea\nvon BismarckSpace Team: de Gea, von Bismarck, von der Leyen\nВходной файл INPUT.TXT содержит ровно 4 строки. Первая из строк содержит название команды. Каждая из следующих трех строк содержит фамилию одного из членов команды. Длины строк от 1 до 50 символов. Как в названии команды, так и в фамилиях участников могут использоваться строчные и прописные английские буквы, а также пробелы.\nВыходные данные\nВыходной файл OUTPUT.TXT должен содержать ровно одну строку, содержащую полное название команды.",
    "complexity": 20,
    "memory": 16000,
    "time": 1000,
    "examples": [
      {
        "input": "Dream Team\n\nKnuth\n\nDijkstra\n\nCormen",
        "output": "Dream Team: Cormen, Dijkstra, Knuth"
      },
      {
        "input": "Ivanovs Team\n\nIvanov\n\nIvanov\n\nIvanov",
        "output": "Ivanovs Team: Ivanov, Ivanov, Ivanov"
      },
      {
        "input": "Team\n\na\n\naa\n\naaa",
        "output": "Team: a, aa, aaa"
      },
      {
        "input": "Team\n\na\n\nA\n\nB",
        "output": "Team: A, B, a"
      },
      {
        "input": "Space Team\n\nvon der Leyen\n\nde Gea\n\nvon Bismarck",
        "output": "Space Team: de Gea, von Bismarck, von der Leyen"
      }
    ]
  },
  {
    "id": 771,
    "name": "Экзамен",
    "description": "Осень прошла, зима наступает, и листва покинула множество деревьев главного городского парка. В этот период многие впадают в депрессию, включая студента Василия,  так как ему предстоит сдать экзамен в конце года, а экзамен этот по теме «структуры данных», к которым в частности относятся и деревья. Пожалуйста, помогите ему подготовиться к экзамену, написав простую программу. \nNS(N) (если не NIL) должен печататься справа от узла N, разделяясь одним или несколькими символами '-'.OUTPUT.TXT1\n|\n2-3-4\n|   |\n5-6 7\n    |\n    8-921A -AA[Лучшие попытки]\nN-арное дерево – это дерево, степень каждого узла которого не превосходит N. Бинарные (двоичные) деревья – это частный случай n-арного дерева при n=2.\nУзлы одного уровня (с равным расстоянием от корня) всегда должны располагаться в одной строке.\nСуществует красивый способ представить любое n-арное дерево с помощью бинарного. Речь идет о так называемом (FC-NS)-представлении (First Child – Next Sibling). Каждый узел такого дерева слева ссылается на потомка (или на NIL), а справа ссылка осуществляется на брата (узел с общим предком). Пусть Par(N) – функция, возвращающая предка для N, либо NIL в том случае, когда N – корень. Таким образом, узлы N и S – братья, если Par(N)=Par(S). \nНикакие два символа не должны соприкасаться, они должны отделяться либо горизонтальной, либо вертикальной линией.\nБудем обозначать узлы дерева ASCII-символами '0'-'9', 'a'-'z', 'A'-'Z'. Пусть Val(N) – функция, возвращающая ASCII-код символа, обозначающего узел. Определим также функцию FC(N), возвращающую первого потомка для N (либо NIL при отсутствии такового). Аналогично определим функцию NS(N), которая будет возвращать следующего брата за узлом N.\nНикакие два символа не должны пересекаться (печататься один на другом), все должны быть видимыми.\nFC(N) – это потомок Сi с наименьшим значением Val(Ci) для всех потомков,\nКоличество символов при выводе должно быть минимальным (не должно быть лишних пробелов и лишних пропусков с использованием линий).\nNS(N) – такой брат Si, с наименьшим Val(Si) для всех Val(Si)\u003eVal(N).\nНиже рассмотрим пример 3-арного дерева и его бинарного (FC-NS)-представления, полученное в результате вышеупомянутых рассуждений:\n1                                           1\n                     /|\\                                          |\n                    / | \\                                         2-3-4\n                   /  |  \\                                        |   |\n                  2   3   4                                       5-6 7\n                 / \\       |                                          |\n                5   6      7                                          8-9\n                          / \\\t\t\t\t\t\t\t\t\n                         8   9\t\t\t\t\t\t\t\t\n\n                3-арное дерево\t                      Бинарное (FC-NS)-представление\nВаша задача по заданному дереву построить бинарное (FC-NS)-представление и вывести его в виде псевдографической схемы по правилам, описанным ниже.\nВходные данные\nПервая строка входного файла INPUT.TXT содержит P – количество узлов заданного множества деревьев (их может быть более одного). Далее следуют P строк, содержащие пары ASCII-символов ('0'-'9', 'a'-'z', 'A'-'Z'), разделенные пробелом. Первый из них – узел потомка, второй – узел предка. Родительский узел корневого узла обозначен символом '-'. Никакие узлы не повторяются дважды. Различные узлы обозначаются различными символами.\nВыходные данные\nВ выходной файл OUTPUT.TXT выведите заданное множество деревьев в бинарном (FC-NS)-представлении. Первая строка должна содержать корневые узлы деревьев, следующие в порядке возрастания ASCII-кодов по одному из нижеизложенных правил построения:\nКорневой узел первого дерева должен располагаться в первой строке, в самой левой позиции.\nFC(N) (если не NIL) должен печататься под узлом N, разделяясь вертикальной линией '|'.\nNS(N) (если не NIL) должен печататься справа от узла N, разделяясь одним или несколькими символами '-'.\nУзлы одного уровня (с равным расстоянием от корня) всегда должны располагаться в одной строке.\nНикакие два символа не должны соприкасаться, они должны отделяться либо горизонтальной, либо вертикальной линией.\nНикакие два символа не должны пересекаться (печататься один на другом), все должны быть видимыми.\nКоличество символов при выводе должно быть минимальным (не должно быть лишних пробелов и лишних пропусков с использованием линий).\nПросим учесть, что утверждение 7 не следует из примеров, приведенных ниже.",
    "complexity": 74,
    "memory": 16000,
    "time": 1000,
    "examples": [
      {
        "input": "9\n\n1 -\n\n2 1\n\n3 1\n\n4 1\n\n5 2\n\n6 2\n\n7 4\n\n8 7\n\n9 7",
        "output": "1\n|\n2-3-4\n|   |\n5-6 7\n    |\n    8-9"
      },
      {
        "input": "1\nA -",
        "output": "A"
      }
    ]
  },
  {
    "id": 634,
    "name": "Кубок CBOSS",
    "description": "В 2239 году команде-победителю Открытого кубка CBOSS достался весьма нетрадиционный приз - поездка по k самым красивым городам России. Так как в России красивых городов достаточно много, то победителям было предложено выбрать k городов из списка, содержащего n городов.\nj,inOUTPUT.TXT103 1 424 4\n0 3 2 1\n8 0 6 5\n1 2 0 4\n5 6 7 0\n1 2 3 4183 1 4 2183 1 4 2[Лучшие попытки]\nДля удобства занумеруем эти города целыми числами от 1 до n. Для каждого города известно ti - время, требующееся на осмотр его достопримечательностей. Также для каждой пары (i, j), 1 ≤ i, j ≤ n известно ai,j - время, которое требуется на проезд из i-ого города в j-ый. При этом может оказаться, что ai,j ≠ aj,i, но ai,i всегда равно нулю.\ni,i\nУ студентов, входящих в команду-победитель, не так много времени на посещение красивых городов, ведь скоро у них сессия. Поэтому они хотят выбрать k городов и посетить их в таком порядке, чтобы затраты времени были минимальны. Разумеется, посещать один город несколько раз им неинтересно. Также они не хотят приезжать в город, не осматривая при этом его достопримечательности.\nНапишите программу, находящую нужные k городов и порядок, в котором их нужно посетить.\nВходные данные\nПервая строка входного файла INPUT.TXT содержит целые числа n и k (1 ≤ n ≤ 7, 1 ≤ k ≤ n). Каждая из последующих n строк входного файла содержит по n целых чисел каждая: j-ое число (i + 1)-ой строки входного файла - это время, требуемое на проезд из i-ого города в j-ый (ai,j). Последняя строка входного файла содержит n целых чисел t1, …, tn.\nВсе числа во входном файле не превосходят 100. Все времена неотрицательны.\nВыходные данные\nВ первой строке выходного файла OUTPUT.TXT выведите минимальное время, которое потребуется для посещения k городов с учетом осмотра достопримечательностей. Во второй строке выходного файла выведите номера городов в порядке посещения, гарантирующем такое время.",
    "complexity": 52,
    "memory": 16000,
    "time": 1000,
    "examples": [
      {
        "input": "4 3\n\n0 3 2 1\n\n8 0 6 5\n\n1 2 0 4\n\n5 6 7 0\n\n1 2 3 4",
        "output": "10\n3 1 4"
      },
      {
        "input": "4 4\n\n0 3 2 1\n\n8 0 6 5\n\n1 2 0 4\n\n5 6 7 0\n\n1 2 3 4",
        "output": "18\n3 1 4 2"
      }
    ]
  },
  {
    "id": 705,
    "name": "Оценка",
    "description": "Вася очень любит программировать. Еще он очень любит научную фантастику. Как-то на каникулах, начитавшись книжек со своим другом Петей, Вася решил вывести формулу, показывающую рост популяции на Марсе. По прикидкам Васи после N лет жизни планеты популяция марсиан должна составлять SN  марсиан, где SN определяется по формуле:\nOUTPUT.TXT022 100022328[Лучшие попытки]\n28 427328\nПетя, после того как Вася рассказал ему свою теорию, засомневался и решил вычислить это число на компьютере, чтобы убедиться в его достоверности. К тому же, Петя недавно прочитал умную книжку по программированию, поэтому он думает, что это не займет много времени.\nВам предлагается сделать то же самое, но без чтения умной книжки. Заметьте, что для Вашего удобства необходимо вывести SN по модулю M.\nВходные данные\nВходной файл INPUT.TXT содержит число N – возраст планеты Марс и число M - модуль (0 \u003c N, M ≤ 109).\nВыходные данные\nВ выходной файл OUTPUT.TXT выведите ожидаемое число марсиан после N лет жизни планеты по модулю M.",
    "complexity": 65,
    "memory": 16000,
    "time": 1000,
    "examples": [
      {
        "input": "1 1000",
        "output": "0"
      },
      {
        "input": "2 1000",
        "output": "2"
      },
      {
        "input": "8 427",
        "output": "328"
      }
    ]
  },
  {
    "id": 704,
    "name": "Деление",
    "description": "На квадратном торте размером N×N расставлено M свечей. Определить, можно ли одним прямолинейным разрезом разделить торт на две части, равные по площади, так, чтобы все свечи оказались на одной половине. Свечи считаем точками. Разрез не может проходить через свечу.\n2OUTPUT.TXTYES220101 1 2 2 1 2 2 1 10 10 3 4 7 2 3 8 2 11 11 3NONO[Лучшие попытки]\nВходные данные2\nПервая строка входного файла INPUT.TXT содержит число N (1 \u003c N ≤ 100) – длину стороны квадрата. Вторая строка теста содержит число M (0 \u003c M ≤ 100) – количество свечей на торте. Третья строка – координаты свечей, разделенные пробелами: X1 Y1 X2 Y2 … Xm Ym (0 \u003c Xi, Yi \u003c N), заданные в системе координат с началом в одном из углов квадрата и осями – сторонами квадрата. Все исходные данные - целые положительные числа. Координаты всех свечей различны.\nm\nmВыходные данные\ni\nВ выходной файл OUTPUT.TXT выведите YES, если такое разделение возможно, или NO в противном случае.\niПримеры\n№INPUT.TXTOUTPUT.TXT\n1641 1 2 2 1 2 2 1YES\n220101 1 2 2 1 2 2 1 10 10 3 4 7 2 3 8 2 11 11 3NO\nДля отправки решения задачи необходимо зарегистрироваться и авторизоваться!\n[Обсуждение]\n\n  [Все попытки]\n\n  [Лучшие попытки]\nwindow.yaContextCb.push(()=\u003e{\n  Ya.Context.AdvManager.render({\n    renderTo: 'yandex_rtb_R-A-122393-3',\n    blockId: 'R-A-122393-3'\n  })\n})",
    "complexity": 40,
    "memory": 16000,
    "time": 1000,
    "examples": [
      {
        "input": "6\n4\n1 1 2 2 1 2 2 1",
        "output": "YES"
      },
      {
        "input": "20\n10\n1 1 2 2 1 2 2 1 10 10 3 4 7 2 3 8 2 11 11 3",
        "output": "NO"
      }
    ]
  },
  {
    "id": 706,
    "name": "Пушка",
    "description": "В начале координат установлена пушка, стреляющая шариками для пинг-понга. На некотором расстоянии R от нее, параллельно оси ОХ, находится кирпичная стена бесконечной длины. Между стеной и осью OX расположена точечная цель с координатами (X,Y). Требуется нацелить пушку так, чтобы шарик ударился сначала о стену, а затем попал в цель. Определите кратчайшее расстояние от оси OY до точки соударения шарика со стеной.\nOUTPUT.TXT3.33210 10 56.676.67[Лучшие попытки]\nВходные данные[Решение]\nВо входном файле INPUT.TXT содержится три целых числа R, X и Y (-10 ≤ X ≤ 10, 0 ≤ Y\u003c R ≤ 10), разделенных пробелами.\nВыходные данные\nВ выходной файл OUTPUT.TXT выведите расстояние по прямой линии от оси OY до точки удара шарика о стену с точностью не худшей, чем два знака после запятой.",
    "complexity": 20,
    "memory": 16000,
    "time": 1000,
    "examples": [
      {
        "input": "10 5 5",
        "output": "3.33"
      },
      {
        "input": "10 10 5",
        "output": "6.67"
      }
    ]
  },
  {
    "id": 635,
    "name": "Интернет-олимпиады",
    "description": "Многим известно о проекте «Интернет-олимпиады по информатике», расположенном в сети Интернет по адресу http://neerc.ifmo.ru/school/io/, где проводятся онлайн-олимпиады для школьников в двух номинациях: базовой и усложненной. Ваша задача состоит в том, чтобы написать программу, обрабатывающую результаты Интернет-олимпиады, то есть определяющую: какие команды в какой номинации будут участвовать в следующей олимпиаде.\nOUTPUT.TXT43 4 1999 2000[Лучшие попытки]\nПравила перехода команд из одной номинации в другую таковы. Задачи усложненной номинации решают следующие команды:\nучаствовавшие в предыдущей олимпиаде в усложненной номинации и решившие хотя бы одну задачу;\nучаствовавшие в предыдущей олимпиаде в базовой номинации, решившие хотя бы одну задачу, и при этом решившие либо столько же задач, сколько команда-победитель, либо строго больше задач, чем команда, занявшая медианное место среди команд, решивших хотя бы одну задачу (место с номером k/2, где k - число команд, участвовавших в базовой номинации, решивших хотя бы одну задачу, округление производится вниз).\nВсе остальные команды участвуют в следующей олимпиаде в базовой номинации. В этой задаче мы считаем, что никакие новые команды не регистрируются для участия в следующей олимпиаде.\nНапомним также, что при подведении итогов одной олимпиады команды сортируются по убывании количества решенных задач, а при равенстве количества решенных задач - по возрастанию штрафного времени.\nВходные данные\nПервая строка входного файла INPUT.TXT содержит два целых числа: n и m - соответственно, количество команд, участвовавших в базовой и усложненной номинациях (1 ≤ n, m ≤ 1000).\nПосле этого идут n строк, описывающих результаты команд, участвовавших в базовой номинации. Каждая из этих строк содержит три целых числа, разделенных пробелами, - id, s, t - соответственно, уникальный идентификатор команды, количество решенных задач и штрафное время. Количество решенных задач - целое число от 0 до 12, а штрафное время - целое число от 0 до 20000. Идентификатор команды - это целое число от 1 до 2000.\nПосле этого идут m строк, описывающих результаты усложненной номинации в таком же формате.\nВыходные данные\nВ первой строке выходного файла OUTPUT.TXT выведите число k команд, которые допускаются до участия в усложненной номинации в следующей олимпиаде. Вторая строка должна содержать k целых чисел - идентификаторы этих команд в возрастающем порядке.",
    "complexity": 33,
    "memory": 16000,
    "time": 1000,
    "examples": [
      {
        "input": "6 3\n\n1 1 45\n\n2 4 678\n\n3 5 1000\n\n4 5 894\n\n5 2 343\n\n6 3 555\n\n1998 0 0\n\n1999 1 34\n\n2000 3 366",
        "output": "4\n3 4 1999 2000"
      }
    ]
  },
  {
    "id": 637,
    "name": "NEERC",
    "description": "В полуфинале студенческого чемпионата мира по программированию NEERC (http://neerc.ifmo.ru) участвуют команды из n институтов. Участники для проведения соревнований распределяются по k залам, каждый из которых имеет размеры, достаточные для размещения всех команд от всех институтов. При этом по правилам соревнований в одном зале может находиться не более одной команды от института.\niOUTPUT.TXT623\n1 2 4\n477[Лучшие попытки]\nМногие институты уже подали заявки на участие в полуфинале. Оргкомитет полуфинала хочет допустить до участия максимально возможное количество команд. При этом, разумеется, должна существовать возможность рассадить их по залам без нарушения правил.\n[Решение]\nНапишите программу, определяющую максимальное количество команд, которые можно допустить до участия в полуфинале.\nВходные данные\nПервая строка входного файла INPUT.TXT содержит число n - число институтов, подавших заявки. Вторая строка входного файла содержит n чисел a1, …, an (ai - это количество команд, заявленных от института номер i). Последняя строка входного файла содержит число k - количество залов, в которых проходят соревнования.\nВсе числа во входном файле целые, положительные и не превосходят 10000.\nВыходные данные\nВ выходной файл OUTPUT.TXT выведите одно целое число - ответ на задачу.",
    "complexity": 17,
    "memory": 16000,
    "time": 1000,
    "examples": [
      {
        "input": "3\n\n1 2 4\n\n3",
        "output": "6"
      },
      {
        "input": "3\n\n1 2 4\n\n4",
        "output": "7"
      }
    ]
  },
  {
    "id": 707,
    "name": "Zuma",
    "description": "Возможно, некоторым из вас знакома игра Zuma о приключениях лягушки. В данной задаче правила похожи и довольно просты: в каменном жёлобе находится ряд разноцветных шаров; пушка, расположившаяся рядом с жёлобом, имеет некоторый запас разноцветных шаров и периодически закидывает их в желоб. Заброшенные шары встраиваются в ряд. Если после выстрела в желобе образуется непрерывная последовательность из трех или более шаров одного цвета, включающая заброшенный шар, то они исчезают, а соседние шары сдвигаются, смыкая ряд. Если после исчезновения шаров в месте стыка присутствуют соседние шары (как слева, так и справа), образующие непрерывную последовательность из трех или более шаров одного цвета, то они также исчезают, и так далее. Цель игры – уничтожить все шары. \nПояснениеВыстреливается новый шар «B», в позицию после шара №12После выстрела новый шар образует с соседними последовательность цвета «B», в позициях 2-5. Длина последовательности ≥3, поэтому шары 2-5 исчезнутПосле выстрела новый шар образует с соседними последовательность цвета «B», в позициях 2-5. Длина последовательности ≥3, поэтому шары 2-5 исчезнутОставшиеся шары займут позиции 1-3, и поскольку новая последовательность цвета «А» длины ≥3, она тоже исчезнетOUTPUT.TXT1 B12ACMNEERC10 A0 A0 C0 M2 M2 N2 N2 E2 R2 R210 A0 A0 C0 M2 M2 N2 N2 E2 R2 R23 B0 B0 A0[Лучшие попытки]\nЭтапРисунокПояснение\n1Выстреливается новый шар «B», в позицию после шара №1\n2После выстрела новый шар образует с соседними последовательность цвета «B», в позициях 2-5. Длина последовательности ≥3, поэтому шары 2-5 исчезнут\n3Оставшиеся шары займут позиции 1-3, и поскольку новая последовательность цвета «А» длины ≥3, она тоже исчезнет\n3Оставшиеся шары займут позиции 1-3, и поскольку новая последовательность цвета «А» длины ≥3, она тоже исчезнет3BAAA3 B0 B0 A0\nПронумеруем шары слева направо, начиная с единицы. Выстрел шара в позицию n означает, что он появится правее шара с номером n и окажется в позиции n+1. Номера шаров, расположенных правее прилетевшего шара, увеличиваются на единицу. Приземление шара левее всего ряда обозначается позицией с номером 0. После исчезновения некоторых шаров, шары в желобе нумеруются заново слева направо, начиная с единицы.\nТребуется написать программу, определяющую оптимальную стратегию стрельбы. Оптимальной стратегией называется та, при которой наименьшее количество выстрелов приводит к исчезновению всех шаров.\nВходные данные\nВходной файл INPUT.TXT содержит описание ряда шаров, цвет каждого шара описывается заглавной буквой английского алфавита (A..Z). Известно, что длина ряда не превышает 14 шаров, а для уничтожения ряда требуется не более 10 выстрелов, если следовать оптимальной стратегии.\nВыходные данные\nВ выходной файл OUTPUT.TXT выведите строку: сначала минимальное количество выстрелов, затем через пробел пары буква-число: цвет шара и позицию выстрела. Выстрелы в ответе должны быть перечислены в порядке их следования в игре. В случае наличия нескольких оптимальных стратегий выберите любую.",
    "complexity": 60,
    "memory": 64000,
    "time": 1000,
    "examples": [
      {
        "input": "",
        "output": "Выстреливается новый шар «B», в позицию после шара №1"
      },
      {
        "input": "",
        "output": "После выстрела новый шар образует с соседними последовательность цвета «B», в позициях 2-5. Длина последовательности ≥3, поэтому шары 2-5 исчезнут"
      },
      {
        "input": "",
        "output": "Оставшиеся шары займут позиции 1-3, и поскольку новая последовательность цвета «А» длины ≥3, она тоже исчезнет"
      },
      {
        "input": "ABBBAA",
        "output": "1 B1"
      },
      {
        "input": "ACMNEERC",
        "output": "10 A0 A0 C0 M2 M2 N2 N2 E2 R2 R2"
      },
      {
        "input": "BAAA",
        "output": "3 B0 B0 A0"
      }
    ]
  },
  {
    "id": 708,
    "name": "Хомяки и кролики",
    "description": "В поисках пропитания большая дружная семья кроликов добрела до морковного поля. К сожалению, чуть раньше сюда же прибыла большая дружная семья голодных хомяков. Во избежание конфликта было решено собирать урожай по очереди. Поле представляет собой N грядок по M кустов; на каждом кусте растет некоторое количество морковок. Очередной собирающий стартует от любого куста первой грядки и движется к последней, переходя от одного куста к другому по следующему правилу: от куста номер K на грядке L можно перейти только на грядку L+1 к одному из трех кустов с номерами K-1, K, K+1 (конечно, если кусты с такими номерами есть). Каждый посещенный куст очищается от моркови полностью. Первым на сбор урожая выходит один из кроликов, следом идет хомяк, потом снова кролик и так до тех пор, пока на поле есть хоть одна морковка.\ni,jOUTPUT.TXT7 1224 4\n1 1 1 2\n1 1 1 1\n1 1 1 1\n10 10 1 118 1718 17[Лучшие попытки]\nКролики суетливы, поэтому они выбирают путь наиболее выгодный внешне: стартуют от самого богатого куста первой грядки, а из трех последующих вариантов всегда выбирают самый большой куст (при наличии нескольких кустов с одинаковым числом морковок выбирается куст с наибольшим номером). Хомяки, прибыв на поле раньше, успели составить подробную карту поля и поддерживают её в актуальном состоянии на основе оперативных данных о сборе урожая, поэтому они для каждого хомяка выбирают путь, позволяющий собрать максимальное количество морковок из возможных (при наличии нескольких вариантов с максимально возможным количеством морковок выбирается тот, где лексикографически больше последовательность номеров кустов в порядке посещения).\nПо известной карте поля определите, сколько моркови удалось собрать кроликам и хомякам по отдельности.\nВходные данные\nВ первой строке входного файла INPUT.TXT содержится два целых числа N и M (1 ≤ N, M ≤ 100). Следом идут N строк, в каждой из которых M чисел Xi,j (0 ≤ Xi,j ≤ 10). Xi,j - количество морковок на j-ом кусте i-ой грядки.\nВыходные данные\nВ выходной файл OUTPUT.TXT выведите через пробел два числа: количество морковок, собранных кроликами и хомяками, соответственно.",
    "complexity": 48,
    "memory": 16000,
    "time": 1000,
    "examples": [
      {
        "input": "3 3\n\n1 1 2\n\n1 1 1\n\n10 1 1",
        "output": "7 12"
      },
      {
        "input": "4 4\n\n1 1 1 2\n\n1 1 1 1\n\n1 1 1 1\n\n10 10 1 1",
        "output": "18 17"
      }
    ]
  },
  {
    "id": 680,
    "name": "Садовник-художник",
    "description": "Садовник посадил N деревьев в один ряд. После посадки деревьев садовнику нужно их покрасить. В его распоряжении есть краска трех цветов: белая, синяя и оранжевая. Сколько способов покраски деревьев есть у него, если никакие два соседних дерева нельзя красить в одинаковый цвет?\nOUTPUT.TXT12[Лучшие попытки]\nВходные данные\nВ единственной строке входного файла INPUT.TXT записано одно натуральное число - количество деревьев N (1 ≤ N ≤ 50).\nВыходные данные\nВ единственную строку выходного файла OUTPUT.TXT нужно вывести одно число - количество способов покраски.",
    "complexity": 28,
    "memory": 16000,
    "time": 1000,
    "examples": [
      {
        "input": "3",
        "output": "12"
      }
    ]
  },
  {
    "id": 636,
    "name": "Java Challenge",
    "description": "Все участники олимпиад знают, что во время соревнования на счету каждая секунда. Иногда даже время, которое в суете затрачивается на переключение между окнами может оказаться критичным. В таких соревнованиях, как Java Challenge, количество окон может быть довольно большим (Java Challenge - это соревнование, проходящее в рамках финала чемпионата мира по программированию среди студентов. Оно состоит в разработке искусственного интеллекта для управления виртуальным роботом).\nOUTPUT.TXT0 1 2 2 2 1 3 2 1[Лучшие попытки]\nВ данной задаче мы будем считать, что этот процесс выполняется следующим способом. В системе хранится циклический список открытых окон. При нажатии определенной комбинации клавиш k раз можно перейти в этом списке на k позиций в одну или в другую сторону. Кроме того, окна, относящиеся к каждому приложению так же организованы в циклический список. По этому списку также можно перемещаться в обе стороны, для перемещения на k позиций так же требуется k нажатий клавиш. При этом после своей активизации окно перемещаются в позицию перед первым элементом общего списка окон. Напишите программу, которая для каждого из окон будет определять минимальное количество нажатий клавиш, которое нужно затратить для его активизации. До начала выполнения операции активным является первое окно.\nВходные данные\nПервая строка входного файла INPUT.TXT содержит целое число n (1 ≤ n ≤ 50000) - количество открытых окон. Следующие n строк описывают окна в том порядке, в котором они идут в списке. Для каждого из окон задается номер приложения, которому соответствует это окно, и его номер в циклическом списке окон этого приложения.\nВыходные данные\nНа единственной строке выходного файла OUTPUT.TXT для каждого окна выведите минимальное количество нажатий клавиш, которое надо затратить для его активации.",
    "complexity": 56,
    "memory": 16000,
    "time": 1000,
    "examples": [
      {
        "input": "9\n\n3 2\n\n2 2\n\n2 3\n\n1 3\n\n2 1\n\n3 1\n\n4 1\n\n1 2\n\n1 1",
        "output": "0 1 2 2 2 1 3 2 1"
      }
    ]
  },
  {
    "id": 638,
    "name": "Всероссийская олимпиада по информатике",
    "description": "2127 год. Прошло уже много лет с тех пор, как состоялась первая Всероссийская олимпиада по информатике. Как и многие другие соревнования, наши олимпиады теперь проводятся в несколько дней. Теперь даже задача выбора подходящего времени для олимпиады представляет определенные трудности. Ведь на разных планетах, входящих в состав Российской Федерации используются разные способы отсчета времени: длина месяца, количество дней в неделе и те дни, по которым невозможно проведение олимпиады, могут различаться. Возникла необходимость написания программы, которая поможет решить эту задачу. И тогда в жюри вспомнят, что уже сейчас мы предвидели такую ситуацию и предложили вам решить подобную задачу.\nwOUTPUT.TXT15[Лучшие попытки]\nВ качестве первого шага найдите количество способов выбрать время проведения олимпиады. \nm\nВходные данныеm\nВ первой строке входного файла INPUT.TXT содержатся два целых числа n и k (1 ≤ k ≤ n ≤ 100000) - количество дней месяца и продолжительность олимпиады соответственно. Во второй строке задаются количество дней в неделе w, количество дней, запрещенных еженедельно, dw и день недели, на который приходится первый день месяца s (1 ≤ s ≤ w ≤ n, 0 ≤ dw ≤ w). Третья строка содержит dw номеров дней недели (например, выходных), в которые нельзя проводить олимпиаду. В четвертой строке записано количество дней месяца dm, не подходящих для проведения олимпиады по причинам отличным от еженедельного распорядка (например, такими днями являются государственные праздники). Последняя строка содержит dm целых чисел - номера этих дней. Дни месяца так же нумеруются начиная с 1. Заметим, что некоторые дни могут быть запрещенными сразу по обеим причинам.\nВыходные данные\nВ выходной файл OUTPUT.TXT выведите единственное целое число - количество способов выбрать k подряд идущих дней, в которые возможно проведение олимпиады.",
    "complexity": 37,
    "memory": 16000,
    "time": 1000,
    "examples": [
      {
        "input": "31 3\n\n7 1 7\n\n7\n\n2\n\n1 9",
        "output": "15"
      }
    ]
  },
  {
    "id": 710,
    "name": "Булева алгебра - 2",
    "description": "В каждом языке программирования, даже самом простом, есть оператор ветвления, позволяющий проверить истинность логического выражения и, в зависимости от его результата, выполнить то или иное действие. Условие оператора ветвления представляет собой логическое (булевское) выражение, результатом которого может быть либо истина (TRUE), либо ложь (FALSE). Переменные, которые могут участвовать в логическом выражении, называются булевскими (boolean). Булевские переменные могут объединяться в сложные условия при помощи логических операций (функций):\nssNOT(x1). Операция «НЕ», меняет значение операнда х1 на противоположное (операнд всегда один).OUTPUT.TXTFALSE2OR(NOT(AND(A,B)),A)\n3 2\nA=FALSE\nB=TRUE\nA=TRUE\nB=TRUE\nA=FALSE\nB=FALSETRUETRUETRUETRUETRUETRUE[Лучшие попытки]\nAND(x1,x2,.. xs). Операция «И», возвращает истинное значение, если все ее операнды истинны. (2 ≤  количество операндов ≤ s);\nOR(x1,x2,.. xs). Операция «ИЛИ», возвращает истинное значение, если хотя бы один ее операнд истинен. (2 ≤  количество операндов ≤ s);\nNOT(x1). Операция «НЕ», меняет значение операнда х1 на противоположное (операнд всегда один).\nВ логическом условии может использоваться несколько логических функций, вложенных друг в друга, то есть результат одной функции может использоваться другой в качестве операнда. Например, AND(A, B, OR(С,D)). Данное выражение будет истинно тогда, когда истинны А, B и (С или D).\nТребуется написать программу, которая по имеющемуся логическому выражению и значению логических переменных определит результат выражения. Количество операндов у функций AND и OR может быть любым (2 ≤ s ≤ 26).\nВходные данные\nПервая строка входного файла INPUT.TXT содержит логическое выражение (длина не более 255 символов). Вторая строка содержит два числа, разделенных одним или несколькими пробелами: N – количество блоков (не более 10), K - количество переменных (не более 26). Далее следует N блоков, каждый имеет следующую структуру: состоит из K строк, каждая содержит выражение типа \u003cпеременная = значение\u003e. Переменные задаются заглавными английскими буквами, значение – константами TRUE или FALSE (заглавные буквы).\nВыходные данные\nВ выходной файл OUTPUT.TXT выведите N строк со значением результата логического выражения для переменных соответствующего блока.",
    "complexity": 57,
    "memory": 16000,
    "time": 1000,
    "examples": [
      {
        "input": "AND(A,NOT(B))\n\n1 2\n\nA=FALSE\n\nB=TRUE",
        "output": "FALSE"
      },
      {
        "input": "OR(NOT(AND(A,B)),A)\n\n3 2\n\nA=FALSE\n\nB=TRUE\n\nA=TRUE\n\nB=TRUE\n\nA=FALSE\n\nB=FALSE",
        "output": "TRUE\nTRUE\nTRUE"
      }
    ]
  },
  {
    "id": 709,
    "name": "Булева алгебра",
    "description": "В каждом языке программирования, даже самом простом, есть оператор ветвления, позволяющий проверить истинность логического выражения и, в зависимости от его результата, выполнить то или иное действие. Условие оператора ветвления представляет собой логическое (булевское) выражение, результатом которого может быть либо истина (TRUE), либо ложь (FALSE). Переменные, которые могут участвовать в логическом выражении, называются булевскими (boolean). Булевские переменные могут объединяться в сложные условия при помощи логических операций (функций):\nssNOT(x1). Операция «НЕ», меняет значение операнда х1 на противоположное (операнд всегда один).OUTPUT.TXTFALSE2OR(NOT(AND(A,B)),A)\n3 2\nA=FALSE\nB=TRUE\nA=TRUE\nB=TRUE\nA=FALSE\nB=FALSETRUETRUETRUETRUETRUETRUE[Лучшие попытки]\nAND(x1,x2,.. xs). Операция «И», возвращает истинное значение, если все ее операнды истинны. (2 ≤  количество операндов ≤ s);\nOR(x1,x2,.. xs). Операция «ИЛИ», возвращает истинное значение, если хотя бы один ее операнд истинен. (2 ≤  количество операндов ≤ s);\nNOT(x1). Операция «НЕ», меняет значение операнда х1 на противоположное (операнд всегда один).\nВ логическом условии может использоваться несколько логических функций, вложенных друг в друга, то есть результат одной функции может использоваться другой в качестве операнда. Например, AND(A, B, OR(С,D)). Данное выражение будет истинно тогда, когда истинны А, B и (С или D).\nТребуется написать программу, которая по имеющемуся логическому выражению и значению логических переменных определит результат выражения. Количество операндов у функций AND и OR всегда равно двум (s=2).\nВходные данные\nПервая строка входного файла INPUT.TXT содержит логическое выражение (длина не более 255 символов). Вторая строка содержит два числа, разделенных одним или несколькими пробелами: N – количество блоков (не более 10), K - количество переменных (не более 26). Далее следует N блоков, каждый имеет следующую структуру: состоит из K строк, каждая содержит выражение типа \u003cпеременная = значение\u003e. Переменные задаются заглавными английскими буквами, значение – константами TRUE или FALSE (заглавные буквы).\nВыходные данные\nВ выходной файл OUTPUT.TXT выведите N строк со значением результата логического выражения для переменных соответствующего блока.",
    "complexity": 52,
    "memory": 16000,
    "time": 1000,
    "examples": [
      {
        "input": "AND(A,NOT(B))\n\n1 2\n\nA=FALSE\n\nB=TRUE",
        "output": "FALSE"
      },
      {
        "input": "OR(NOT(AND(A,B)),A)\n\n3 2\n\nA=FALSE\n\nB=TRUE\n\nA=TRUE\n\nB=TRUE\n\nA=FALSE\n\nB=FALSE",
        "output": "TRUE\nTRUE\nTRUE"
      }
    ]
  },
  {
    "id": 651,
    "name": "Преобразование моноклеточных",
    "description": "Как великолепна страна Байтландия! В ней есть цветущие леса, прозрачные реки, кисельные берега… Но речь пойдет не о них. Уже много лет в Байтландии функционирует НИИ “Цитологии и генетики”. В нем выводятся новые формы жизни. Недавно ученым этого НИИ удалось разработать принципиально новый вид организмов. Особенностью этих организмов является то, что они состоят из большого количества однотипных клеток, то есть являются моноклеточными. \nOUTPUT.TXT3232768 316160[Лучшие попытки]\nПравительство Байтландии заинтересовалось новой разработкой и сделало заказ на производство двух моноклеточных организмов, в каждом из которых должно быть по M клеток. За несколько дней до сдачи проекта было обнаружено, что в одном из организмов получается не M клеток, а N. На какой из стадий разработки была допущена ошибка неизвестно, но положение надо исправлять!\n31434 14340\nСотрудниками НИИ было принято решение о преобразовании моноклеточного с N клетками в моноклеточное с M клетками. Для этого в экстренном режиме было разработано два типа вещества:\nВещество, которое делит клетки моноклеточного организма, т.е. каждая клетка делится на P частей. В результате количество клеток умножается на P, где P – простое число.\nВещество, объединяющее клетки.  Клетки организма объединяются в группы по T штук, где Т также простое число. Далее каждая группа клеток объединяется в одну клетку. В результате общее количество клеток делится на T. При этом T выбирается таким, чтобы деление происходило без остатка.\nОтметим, что натуральное число называется простым, если оно имеет только два натуральных делителя – это единица и само число.\nСерьезным недостатком этих веществ является их высокая стоимость. В соответствии с этим требуется преобразовать моноклеточное с N клетками в моноклеточное с M клетками за минимальное количество операций. За одну операцию к моноклеточному можно применить одно вещество из двух заданных типов. Помогите НИИ “Цитологии и генетики” разрешить эту непростую задачу!\nВходные данные\nВ первой строке входного файла INPUT.TXT заданы два натуральных числа N и M (1 ≤ N, M ≤ 109)  разделенные одиночным пробелом.\nВыходные данные\nЕдинственная строка выходного файла OUTPUT.TXT должна содержать целое число  – минимальное количество операций, необходимое для преобразования моноклеточного организма с N клетками в моноклеточный  организм с M клетками.",
    "complexity": 29,
    "memory": 16000,
    "time": 1000,
    "examples": [
      {
        "input": "2 36",
        "output": "3"
      },
      {
        "input": "32768 3",
        "output": "16"
      },
      {
        "input": "1434 1434",
        "output": "0"
      }
    ]
  },
  {
    "id": 640,
    "name": "Test-The-Best",
    "description": "Конкурс Test-the-best, в котором участвуют лучшие программисты из Беларуси, России и других стран, проводит очный тур. Стараясь не отставать от времени, организаторы решили позаботиться о безопасности. В последнее время на рынке техники есть много аппаратуры, позволяющей осуществлять видеонаблюдение.\nOUTPUT.TXTYes21 1\n#\n1 1\n.NoNoNo[Лучшие попытки]\nШироко распространены программы, позволяющие автоматически обрабатывать полученные результаты. Однако имея дело с участниками этих соревнований, на существующие разработки полагаться небезопасно. Поэтому у оргкомитета возникла необходимость написания собственной системы анализа изображений. Перед вами поставлена задача сравнения двух черно-белых изображений на клетчатой сетке. Изображения считаются одинаковыми, если множества черных пикселей в них могут быть получены друг из друга поворотом на 90, 180, или 270 градусов и, возможно, отражением относительно вертикальной оси.\n31 3\n#.#\n1 4\n#..#No\nВходные данные\nВходной файл INPUT.TXT содержит описания двух изображений в следующем формате: первая строка содержит два целых числа n и m (1 ≤ n, m ≤ 500) - высоту и ширину изображения соответственно. Затем следуют n строк, содержащих по m символов: «#» обозначает черный пиксель, «.» - белый.\nВыходные данные\nВ выходной файл OUTPUT.TXT выведите одно слово: «Yes», если изображения одинаковы и «No» в противном случае.",
    "complexity": 50,
    "memory": 16000,
    "time": 1000,
    "examples": [
      {
        "input": "7 8\n\n........\n\n..###...\n\n..#.....\n\n........\n\n........\n\n........\n\n........\n\n6 10\n\n..........\n\n...#......\n\n...#......\n\n...##.....\n\n..........\n\n..........",
        "output": "Yes"
      },
      {
        "input": "1 1\n\n#\n\n1 1\n\n.",
        "output": "No"
      },
      {
        "input": "1 3\n\n#.#\n\n1 4\n\n#..#",
        "output": "No"
      }
    ]
  },
  {
    "id": 711,
    "name": "Соревнование картингистов",
    "description": "После очередного этапа чемпионата мира по кольцевым автогонкам на автомобилях с открытыми колесами Формула-А гонщики собрались вместе в кафе, чтобы обсудить полученные результаты. Они вспомнили, что в молодости соревновались не на больших болидах, а на картах – спортивных автомобилях меньших размеров.\nOUTPUT.TXTVasya[Лучшие попытки]\nДрузья решили выяснить победителя в одной из гонок на картах. Победителем гонки являлся тот гонщик, у которого суммарное время прохождения всех кругов трассы было минимальным.\n[Решение]\nПоскольку окончательные результаты не сохранились, то каждый из n участников той гонки вспомнил и выписал результаты прохождения каждого из m кругов трассы. К сожалению, по этой информации гонщикам было сложно вычислить победителя той гонки. В связи с этим они попросили сделать это вас.\nТребуется написать программу, которая вычислит победителя гонки на картах, о которой говорили гонщики.\nВходные данные\nПервая строка входного файла INPUT.TXT содержит два целых числа n и m (1 ≤ n, m ≤ 100). Последующие 2∙n строк описывают прохождение трассы каждым из участников. Описание прохождения трассы участником состоит из двух строк. Первая строка содержит имя участника с использованием только английских букв (строчных и заглавных). Имена всех участников различны, строчные и заглавные буквы в именах различаются.\nВторая строка содержит m положительных целых чисел, где каждое число – это время прохождения данным участником каждого из m кругов трассы (каждое из этих чисел не превосходит 1000). Длина каждой строки с именем участника не превышает 255 символов.\nВыходные данные\nВ выходной файл OUTPUT.TXT необходимо вывести имя победителя гонки на картах. Если победителей несколько, требуется вывести имя любого из них.",
    "complexity": 18,
    "memory": 16000,
    "time": 1000,
    "examples": [
      {
        "input": "5 3\n\nSumaher\n\n2 1 1\n\nBarikelo\n\n2 1 2\n\nOlonso\n\n1 2 1\n\nVasya\n\n1 1 1\n\nFedya\n\n1 1 1",
        "output": "Vasya"
      }
    ]
  },
  {
    "id": 641,
    "name": "Странная лотерея",
    "description": "В честь успешного окончания первой четверти родители Пети и Вовы подарили им один лотерейный билет. Как обычно, ребята всерьез не восприняли данный подарок ввиду довольно скудной вероятности выигрыша по их мнению. Но каково было удивление братьев, когда они узнали из средств массовой информации, что номер их билета является выигрышным.   \nOUTPUT.TXT2299505199559955[Лучшие попытки]\nПосле продолжительных минут радости ребята бросились узнавать сумму выигрыша, но как оказалось, узнать это не так уж просто.  Дело в том, что сумма выигрыша отчасти определяется самим владельцем или владельцами (если их несколько) следующим образом. На обратной стороне билета есть определенная секция, стерев слой защитного покрытия, можно увидеть  целое положительное число N. После чего, каждый из владельцев билета должен зачеркнуть ровно по одной цифре данного числа N, полученное число и является суммой выигрыша.\nНиже приведен пример с N равным 995051.\nМаксимальное число, которое может быть получено из данного N посредством вычеркивания двух цифр является 9955. Помогите Пете и Вове в этой непростой, но очень актуальной для них задачей.\nВходные данные\nВ единственной строке входного файла INPUT.TXT находится число N (100 ≤ N \u003c 10250). Число не содержит лидирующих нулей. Строка входного файла заканчивается переводом строки и не содержит символов отличных от \"0\"-\"9\".\nВыходные данные\nВ выходной файл OUTPUT.TXT выведите одно число – максимальное значение, которое может быть получено из N посредством вычеркивания из него ровно двух цифр.",
    "complexity": 25,
    "memory": 16000,
    "time": 1000,
    "examples": [
      {
        "input": "102",
        "output": "2"
      },
      {
        "input": "995051",
        "output": "9955"
      }
    ]
  },
  {
    "id": 643,
    "name": "Временной ключ",
    "description": "Практически каждый уважающий себя программист знает, что для полного успеха зачастую мало написать программный продукт, его также успешно надо уметь продать, и тем более также успешно защитить от взлома, а соответственно и от несанкционированного распространения. \nOUTPUT.TXT3268831[Лучшие попытки]\nМногие годы основным способом защиты программного обеспечения от незаконного распространения было использование, так называемого, активационного ключа. Вся проблема заключалась и заключается в том, что зачастую используется статический ключ, то есть активационный ключ для конкретного программного продукта не зависит ни от каких параметров и всегда является неизменным. \n32731\nЗнаменитая компания \"Gold\u0026Silver Soft\" решилась на революционный шаг – было решено разработать принципиально новый способ динамической генерации активационного ключа. В данном  алгоритме ключ зависит от времени и меняется каждую минуту, что существенно затрудняет взлом.\nБудем считать, что активационным ключом является обычное целое положительное число. В данной версии алгоритма значение ключа на следующей минуте целиком и полностью зависит от значения ключа в текущий момент. Если в данный момент ключ равен N, то через минуту он будет равен N + S(N),  где S(N) – это число, называемое контрольной суммой числа N и равняется количеству единиц в двоичной записи числа N. То есть если N = 6, то в следующую минуту значение ключа будет равно 8, если быть точнее, то N’ = N + S(N) = 6 + S(6) = 610 + S(1102) = 6 + 2 = 8.\nБудем считать,  что на данный момент времени значение ключа равно N, вашей задачей является вычислить значение ключа через одну минуту.\nВходные данные\nВ первой и единственной строке входного файла INPUT.TXT находится одно натуральное число – N (1 ≤ N ≤ 2×109).\nВыходные данные\nВ выходной файл OUTPUT.TXT выведите одно число – значение активационного ключа на следующей минуте, учитывая, что на данный момент времени значение ключа равно N.",
    "complexity": 20,
    "memory": 16000,
    "time": 1000,
    "examples": [
      {
        "input": "2",
        "output": "3"
      },
      {
        "input": "6",
        "output": "8"
      },
      {
        "input": "27",
        "output": "31"
      }
    ]
  },
  {
    "id": 642,
    "name": "Кризисный бизнес",
    "description": "Петр Васильевич Колошин никогда не был пугливым человеком и всегда отличался спокойствием и прозорливостью, особенно в сфере мировых политических и экономических процессов. Однако, несмотря ни на что, Петр Васильевич очень недооценил последствия мирового финансового кризиса и, как следствие, был уволен пару недель назад с должности сетевого администратора одной большой и серьезной организации. \n9OUTPUT.TXT326 185 10 1 2 1 2044[Лучшие попытки]\nНесмотря ни на что, Петр Васильевич не отчаялся и решил начать свое дело. Тщательно проанализировав бизнес-климат в своем регионе, Петр Васильевич пришел к выводу, что наиболее целесообразным будет открыть новый таксопарк. Первое с чего решил начать новоиспеченный бизнесмен – это закупить автомобили. За все время работы Петр Васильевичу удалось накопить сумму S, которую он готов потратить на закупку машин.\nВ городе, в котором живет Петр Васильевич, есть только один автосалон. Известно, что в этом автосалоне выставлено на продажу N автомобилей, причем установлено, что стоимость i-го автомобиля равняется Ai. Вашей задачей является помочь еще неопытному бизнесмену Петр Васильевичу приобрести максимальное количество автомобилей, потратив сумму не более S.\nВходные данные\nВ первой строке входного файла INPUT.TXT находится два целых положительных числа разделенные одиночным пробелом – это числа N (1 ≤ N ≤ 100) и S (1 ≤ S ≤ 109) соответственно.\nВторая строка содержит ровно N чисел Ai (1 ≤ Ai ≤ 109) , которые описывают стоимость соответствующих автомобилей. Все числа в строке разделены одиночными пробелами.\nВыходные данные\nВ выходной файл OUTPUT.TXT выведите одно целое число – максимальное количество автомобилей, которые сможет приобрести Петр Васильевич на сумму не более чем S.",
    "complexity": 20,
    "memory": 16000,
    "time": 1000,
    "examples": [
      {
        "input": "5 30\n15 5 11 10 12",
        "output": "3"
      },
      {
        "input": "6 18\n5 10 1 2 1 20",
        "output": "4"
      }
    ]
  },
  {
    "id": 646,
    "name": "Сладкие забавы",
    "description": "Маленькие сладкоежки Сережа и Юля очень любят конфеты. Родители детей это знают, и потому у них не возникает вопросов о том, что ребятишкам дарить в день рождения.\n9OUTPUT.TXT825 6710 22 30 41 50660[Лучшие попытки]\nА тут подвернулся особый случай – обоим ребятишкам исполняется по 10 лет, и потому родители подсказали приглашенным гостям, чему дети больше всего обрадуются на их общем юбилее.\ni33 64 1 50\nГостей в день рождения  собралось  достаточно много – N человек. Гость,  пришедший i-м по счету, подарил детям коробку, содержащую Ai конфет. Коробки конфет были как совсем маленькие, так и невероятно большие. Коробки были с прозрачными крышками и  было видно, сколько там конфет.\nЧтобы все было честно, дети решили поделить коробки так, чтобы каждому досталось не менее K конфет. Однако дети обнаружили, что сделать это можно многими способами. Ваша задача – определить количество различных способов честного дележа конфет, учитывая, что коробки не вскрываются и конфеты поштучно не делятся, и каждая коробка должна достаться только одному из ребятишек. Два варианта деления конфет считаются различными, если существует коробка конфет, которая в данных вариантах принадлежит разным детям.\nВходные данные\nПервая строка входного файла INPUT.TXT содержит два натуральных числа N и K соответственно (1 ≤ N ≤ 50; 1 ≤ K ≤ 10000). Числа в строке разделены одиночным пробелом.\nВторая строка содержит N натуральных чисел Ai (1 ≤ i ≤ N, 1 ≤ Ai ≤ 109), разделенных одиночными пробелами, где число Ai – это количество конфет в коробке, подаренной гостем, пришедшим i-м по счету.\nВыходные данные\nЕдинственная строка выходного файла OUTPUT.TXT должна содержать одно  целое число — количество способов честно  поделить конфеты между детьми.",
    "complexity": 60,
    "memory": 16000,
    "time": 1000,
    "examples": [
      {
        "input": "4 3\n1 2 3 2",
        "output": "8"
      },
      {
        "input": "5 67\n10 22 30 41 50",
        "output": "6"
      },
      {
        "input": "3 6\n4 1 5",
        "output": "0"
      }
    ]
  },
  {
    "id": 644,
    "name": "Временной ключ-2",
    "description": "Практически каждый уважающий себя программист знает, что для полного успеха зачастую мало написать программный продукт, его также успешно надо уметь продать, и тем более также успешно защитить от взлома, а соответственно и от несанкционированного распространения. \nOUTPUT.TXT221 1022227[Лучшие попытки]\nМногие годы основным способом защиты программного обеспечения от незаконного распространения было использование, так называемого, активационного ключа. Вся проблема заключалась и заключается в том, что зачастую используется статический ключ, то есть активационный ключ для конкретного программного продукта не зависит ни от каких параметров и всегда является неизменным. \n32 37\nЗнаменитая компания \"Gold\u0026Silver Soft\" решилась на революционный шаг – было решено разработать принципиально новый способ динамической генерации активационного ключа. В данном  алгоритме ключ зависит от времени и меняется каждую минуту, что существенно затрудняет взлом.\nБудем считать, что активационным ключом является обычное целое положительное число. В данной версии алгоритма значение ключа на следующей минуте целиком и полностью зависит от значения ключа в текущий момент. Если в данный момент ключ равен N, то через минуту он будет равен N + S(N),  где S(N) – это число, называемое контрольной суммой числа N и равняется количеству единиц в двоичной записи числа N. То есть если N = 6, то в следующую минуту значение ключа будет равно 8, если быть точнее, то N’ = N + S(N) = 6 + S(6) = 610 + 1102  = 8.\nБудем считать,  что на данный момент времени значение ключа равно N, вашей задачей является вычислить значение ключа через K минут.\nВходные данные\nВ первой и единственной строке входного файла INPUT.TXT находятся два натуральных числа – N (1 ≤ N ≤ 2×109) и K (1 ≤ K ≤ 2×109).\nВыходные данные\nВ выходной файл OUTPUT.TXT выведите одно число – значение активационного ключа через K минут, учитывая, что на данный момент времени значение ключа равно N.",
    "complexity": 60,
    "memory": 16000,
    "time": 1000,
    "examples": [
      {
        "input": "1 1",
        "output": "2"
      },
      {
        "input": "1 10",
        "output": "22"
      },
      {
        "input": "2 3",
        "output": "7"
      }
    ]
  },
  {
    "id": 647,
    "name": "Адаптивный поиск",
    "description": "Знаменитая компания \"Gold\u0026Silver Soft\" решила занять ведущее место в области разработки реляционных баз данных. Руководство компании понимает, что для этого необходимо удивить потребителей быстродействием своего программного продукта.\niOUTPUT.TXT5 4210 1010 9 8 7 6 5 4 3 2 110 10 10 10 10 10 10 10 10 1010 10 10 10 10 10 10 10 10 103 3 2 1 3 1 3 1 2 1 1 1 2 2[Лучшие попытки]\nНи для кого не секрет, что в основе реляционной базы данных лежит таблица,  которую можно рассматривать как одномерный массив записей. Известно, что при поиске все записи таблицы просматриваются последовательно, начиная с самой первой и заканчивая найденной.  \ni33 14\n3 2 3 3 1 1 2 2 1 1 1 1 2 13 3 2 1 3 1 3 1 2 1 1 1 2 2\nТехнический отдел компании установил, что часто бывает так, что поиск одной и той же записи в таблице  производится несколько раз.  Основываясь на этом,  программисты решили после каждого нового поискового запроса  менять порядок следования записей в таблице. Другими словами, после поиска найденная запись перемещается на первое место в  таблице. Очевидно, что чем чаще осуществляется поиск определенной записи, тем ближе она будет к началу таблицы и тем быстрее будет поиск этой записи.\nВашей задачей является написать программу, которая для каждого из M последовательно заданных поисковых запросов будет определять количество просмотренных записей при поиске заданной. Для простоты обозначения будем считать, что имеется таблица с N записями, где запись – это число от 1 до N.  В начале все записи в таблице расположены в порядке возрастания, то есть на i-м месте в таблице находится число i. Для приведенного ниже примера  при M = 2, N = 6 и запросах на поиск чисел  «5» и «3» потребуется 5 и 4 просмотра записей соответственно.\nВходные данные\nПервая строка входного файла INPUT.TXT содержит два целых числа N и M  (1 ≤ N, M ≤ 65535) — количество записей в таблице и количество запросов на поиск соответственно.  Числа разделены одиночным пробелом.\nВторая строка содержит M натуральных чисел Ai (1 ≤ Ai ≤ N), разделенных одиночными пробелами, где Ai  — запрос на поиск числа Ai в таблице. Запросы на поиск выполняются последовательно в порядке их ввода.\nВыходные данные\nЕдинственная строка выходного файла OUTPUT.TXT должна содержать M натуральных чисел, разделенных одиночными пробелами, i-е число – это количество просмотренных записей при поиске числа Ai.",
    "complexity": 65,
    "memory": 16000,
    "time": 1000,
    "examples": [
      {
        "input": "6 2\n5 3",
        "output": "5 4"
      },
      {
        "input": "10 10\n10 9 8 7 6 5 4 3 2 1",
        "output": "10 10 10 10 10 10 10 10 10 10"
      },
      {
        "input": "3 14\n\n3 2 3 3 1 1 2 2 1 1 1 1 2 1",
        "output": "3 3 2 1 3 1 3 1 2 1 1 1 2 2"
      }
    ]
  },
  {
    "id": 649,
    "name": "Защищенный пароль",
    "description": "",
    "complexity": 50,
    "memory": 16000,
    "time": 1000,
    "examples": [
      {
        "input": "6 2\n7aaarr",
        "output": "15"
      },
      {
        "input": "4 1\nayay",
        "output": "7"
      }
    ]
  },
  {
    "id": 645,
    "name": "Красивая стена",
    "description": "Однажды великий художник Гигабайт подарил королю Байтландии одно из своих лучших полотен. Король, впечатленный произведением Гигабайта, в знак благодарности подарил ему K плиток из очень ценной разновидности мрамора размером 10×10 сантиметров каждая. \nOUTPUT.TXT3 3221 21 24 5[Лучшие попытки]\nХудожник решил украсить этими плитками одну из стен своего дома. Он задумал выложить из них прямоугольник высотой H плиток и шириной W плиток. Художник понимает, что число вариантов для выбора H и W достаточно велико. Из всех возможных вариантов он хочет выбрать самый красивый. Ваша задача – помочь ему с выбором!\n3204 5\nДля определения степени красоты художник решил учитывать два параметра:\nНасколько выбранный прямоугольник будет близок к квадрату. Значение этого параметра равно модулю разности чисел H и W(т.е. |H-W|).\nСколько плиток останется невостребованными после украшения стены. Значение этого параметра равно разности чисел K и H×W(т.е. K-H×W,  где K ≥ H×W ).\nСтепень красоты вычисляется как сумма значений двух описанных выше параметров. Например, имея 11 плиток, можно выбрать прямоугольник 3×3, степень красоты равна 0+2 = 2. Также можно выбрать прямоугольник 2×5, тогда степень красоты равна 3+1 = 4. Считается, что чем меньше степень красоты, тем красивее прямоугольник.\nВаша задача – написать программу, которая по заданному числу K находит размеры самого красивого прямоугольника.\nВходные данные\nЕдинственная строка входного файла INPUT.TXT содержит одно целое число K – количество  подаренных королем плиток (1 ≤ K ≤ 106).\nВыходные данные\nЕдинственная строка выходного файла OUTPUT.TXT должна содержать натуральные числа H и W соответственно, которые определяют размеры самого красивого прямоугольника. Числа должны быть разделены одиночным пробелом. Если решений несколько, выведите любое из них.",
    "complexity": 25,
    "memory": 16000,
    "time": 1000,
    "examples": [
      {
        "input": "11",
        "output": "3 3"
      },
      {
        "input": "2",
        "output": "1 2"
      },
      {
        "input": "20",
        "output": "4 5"
      }
    ]
  },
  {
    "id": 741,
    "name": "Замечательные дороги",
    "description": "В одной замечательной стране живут замечательные люди. По исследованиям замечательного правительства, большинство граждан на выходных садятся в машину, выбирают циклический маршрут между некоторыми городами и деревнями без повторяющихся населенных пунктов и катаются по этому маршруту, пока не надоест. Некоторые, правда, катаются по своему городу и никуда не выезжают.\nOUTPUT.TXT12 1 123 21 22 312 3 11 2 112 3 11 2 13\n1 2 1\n3 2 2\n3 1 3[Лучшие попытки]\nТак как правительство заботится о своих гражданах, оно хочет сделать их выходные максимально красочными. По этой причине недавно было принято решение покрасить каждую дорогу между населенными пунктами в какой-нибудь цвет. Причем так, чтобы ни на каком \"выходном\" маршруте не было дорог одинакового цвета. Но так как цветов могло понадобиться довольно много, правительство решило минимизировать количество различных цветов. Вам предстоит помочь этому замечательному государству в осуществлении его планов.\n33 3\n1 2\n2 3\n3 13\n1 2 1\n3 2 2\n3 1 3\nВходные данные\nВ первой строке находятся два числа: 1 ≤ n ≤ 50 000 - количество городов и деревень в стране и 1 ≤ m ≤ 100 000 - количество дорог. В m последующих строках находится по два числа – номера населенных пунктов, концов дороги. Ни одна дорога не ведет из города в себя, и между двумя населенными пунктами не может быть более одной дороги. Все дороги двусторонние.\nВыходные данные\nВ первой строке выведите минимальное количество цветов. В последующих m строках выведите по три числа: два конца дороги в любом порядке и ее цвет. Дороги разрешается выводить в произвольном порядке.",
    "complexity": 62,
    "memory": 16000,
    "time": 1000,
    "examples": [
      {
        "input": "2 1\n1 2",
        "output": "1\n2 1 1"
      },
      {
        "input": "3 2\n1 2\n2 3",
        "output": "1\n2 3 1\n1 2 1"
      },
      {
        "input": "3 3\n\n1 2\n\n2 3\n\n3 1",
        "output": "3\n\n1 2 1\n\n3 2 2\n\n3 1 3"
      }
    ]
  },
  {
    "id": 650,
    "name": "Странная сеть",
    "description": "",
    "complexity": 65,
    "memory": 32000,
    "time": 1000,
    "examples": [
      {
        "input": "2 1\n1 2",
        "output": "0"
      },
      {
        "input": "4 4\n\n1 2\n\n2 3\n\n4 3\n\n1 4",
        "output": "4"
      },
      {
        "input": "8 7\n\n1 3\n\n3 6\n\n4 2\n\n7 4\n\n2 5\n\n5 7\n\n6 8",
        "output": "12"
      }
    ]
  },
  {
    "id": 648,
    "name": "Азартный Шрэк",
    "description": "Как-то раз Шрек решил посетить казино. Не будучи заядлым любителем азартных игр, Шрек обнаружил, что он не знает правил ни одной из игр, доступных в казино. Недолго думая, Шрек решил все-таки поиграть. Его взор привлекла игра с довольно незамысловатыми правилами.\n6OUTPUT.TXT2243 1 8 100104104[Лучшие попытки]\nНа игровом столе лежат N карточек.  На каждой карточке написано целое положительное число. Игра проходит между игроком и крупье. Карточки лежат на столе числами вниз. Игра заключается в том, что игрок открывает ровно N/2 карточек. Сумма всех чисел, написанных на карточках открытых игроком, называется “суммой игрока”. Следующим ходом крупье открывает оставшиеся N/2 карточек. Сумма всех чисел, написанных на карточках открытых крупье, называется “суммой крупье”. Выигрыш игрока определяется  разностью чисел между “суммой игрока” и “суммой крупье”. Очевидно, что полученная  разность может быть отрицательным числом. Это свидетельствует о том, что игрок проиграл и должен казино соответствующую сумму.\ni\nВсе бы ничего, но Шрек обладает способностью  видеть надписи сквозь бумагу любой плотности. Ваша задача определить максимальную сумму выигрыша, которую может получить Шрек с учетом того, что он видит все числа, написанные на карточках.\nВходные данные\nПервая строка входного файла INPUT.TXT содержит одно четное натуральное число N (2 ≤ N ≤ 100). Вторая строка входного файла содержит ровно N чисел Ai(1 ≤ Ai ≤ 106) – числа, написанные на игральных карточках. Все числа в строке разделяются одиночными пробелами,  Ai – число, написанное на i-й карточке. Карточки нумеруются последовательно, начиная с единицы.\nВыходные данные\nЕдинственная строка выходного файла OUTPUT.TXT должна содержать ровно одно целое число – максимальный выигрыш, который может получить Шрек с учетом своей уникальной способности видеть числа, написанные на карточках.",
    "complexity": 25,
    "memory": 16000,
    "time": 1000,
    "examples": [
      {
        "input": "2\n1 3",
        "output": "2"
      },
      {
        "input": "4\n3 1 8 100",
        "output": "104"
      }
    ]
  },
  {
    "id": 712,
    "name": "Дипломы",
    "description": "Когда Петя учился в школе, он часто участвовал в олимпиадах по информатике, математике и физике. Так как он был достаточно способным мальчиком и усердно учился, то на многих из этих олимпиад он получал дипломы. К окончанию школы у него накопилось n дипломов, причем, как оказалось, все они имели одинаковые размеры: w – в ширину и h – в высоту.\nOUTPUT.TXT9[Лучшие попытки]\nСейчас Петя учится в одном из лучших российских университетов и живет в общежитии со своими одногруппниками. Он решил украсить свою комнату, повесив на одну из стен свои дипломы за школьные олимпиады. Так как к бетонной стене прикрепить дипломы достаточно трудно, то он решил купить специальную доску из пробкового дерева, чтобы прикрепить ее к стене, а к ней – дипломы. Для того чтобы эта конструкция выглядела более красиво, Петя хочет, чтобы доска была квадратной и занимала как можно меньше места на стене. Каждый диплом должен быть размещен строго в прямоугольнике размером w на h. Прямоугольники, соответствующие различным дипломам, не должны иметь общих внутренних точек.\n[Решение]\nТребуется написать программу, которая вычислит минимальный размер стороны доски, которая потребуется Пете для размещения всех своих дипломов.\nВходные данные\nВходной файл INPUT.TXT содержит три целых числа: w, h, n (1 ≤ w, h, n ≤ 109).\nВыходные данные\nВ выходной файл OUTPUT.TXT выведите ответ на задачу.",
    "complexity": 28,
    "memory": 16000,
    "time": 1000,
    "examples": [
      {
        "input": "2 3 10",
        "output": "9"
      }
    ]
  },
  {
    "id": 714,
    "name": "Кольцевая автодорога",
    "description": "К 2110 году город Флэтбург, являясь одним из крупнейших городов мира, не имеет обходной автомагистрали, что является существенным препятствием для его развития как крупнейшего транспортного центра мирового значения. В связи с этим еще в 2065 году при разработке Генерального плана развития Флэтбурга была определена необходимость строительства кольцевой автомобильной дороги.\nOUTPUT.TXT71.5 0.5 1.1441228120 00 11 01 1Infinity0.5 0.5 0.0Infinity0.5 0.5 0.0[Лучшие попытки]\nВ Генеральном плане также были обозначены требования к этой дороге. Она должна соответствовать статусу кольцевой – иметь форму окружности. Кроме этого, четыре крупные достопримечательности Флэтбурга должны быть в одинаковой транспортной доступности от дороги. Это предполагается обеспечить тем, что они будут находиться на равном расстоянии от нее. Расстоянием от точки расположения достопримечательности до дороги называется наименьшее из расстояний от этой точки до некоторой точки, принадлежащей окружности автодороги.\nДирекция по строительству города Флэтбурга, ответственная за постройку кольцевой автодороги, решила привлечь передовых программистов для выбора оптимального плана постройки дороги.\nТребуется написать программу, которая вычислит число возможных планов постройки кольцевой автомобильной дороги с соблюдением указанных требований и найдет такой план, для которого длина дороги будет минимальной.\nВходные данные\nВходной файл INPUT.TXT содержит четыре строки. Каждая из них содержит по два целых числа: xi и yi – координаты места расположения достопримечательности. Первая строка описывает первую достопримечательность, вторая – вторую, третья – третью, четвертая – четвертую. Никакие две достопримечательности не находятся в одной точке. Все числа во входном файле не превосходят 100 по абсолютной величине.\nВыходные данные\nВ первой строке выходного файла OUTPUT.TXT требуется вывести число возможных планов постройки кольцевой автомобильной дороги. Если таких планов бесконечно много, необходимо вывести в первой строке выходного файла слово Infinity.\nНа второй строке требуется вывести координаты центра дороги минимальной длины и ее радиус. Если существует несколько разных способов построения дороги минимальной длины, необходимо вывести координаты центра и радиус любой из них. Входные данные таковы, что существует хотя бы один вариант дороги. Координаты центра и радиус дороги должны быть выведены с точностью не хуже 10-5.",
    "complexity": 65,
    "memory": 16000,
    "time": 1000,
    "examples": [
      {
        "input": "0 0\n0 1\n1 0\n2 2",
        "output": "7\n1.5 0.5 1.14412281"
      },
      {
        "input": "0 0\n0 1\n1 0\n1 1",
        "output": "Infinity\n0.5 0.5 0.0"
      }
    ]
  },
  {
    "id": 713,
    "name": "Булева функция",
    "description": "Недавно на уроке информатики ученики одного из классов изучили булевы функции. Напомним, что булева функция f сопоставляет значениям двух булевых аргументов, каждый из которых может быть равен 0 или 1, третье булево значение, называемое результатом. Для учеников, которые выразили желание более подробно изучать эту тему, учительница информатики на дополнительном уроке ввела в рассмотрение понятие цепного вычисления булевой функции f.\nN33OUTPUT.TXT10112501001111111111No solution[Лучшие попытки]\nЕсли задана булева функция f и набор из N булевых значений a1, a2, ..., aN , то результат цепного вычисления этой булевой функции определяется следующим образом:\nN360000No solution[Решение]\nесли N = 1, то он равен a1;\nесли N \u003e 1, то он равен результату цепного вычисления булевой функции f для набора из (N–1) булевого значения f(a1,a2), a3, …, aN, который получается путем замены первых двух булевых значений в наборе из N булевых значений на единственное булево значение – результат вычисления функции f от a1 и a2.\n1\n2\nНапример, если изначально задано три булевых значения: a1 = 0, a2 = 1, a3 = 0, а функция f – ИЛИ (OR), то после первого шага получается два булевых значения – (0 OR 1) и 0, то есть, 1 и 0. После второго (и последнего) шага получается результат цепного вычисления, равный 1, так как 1 OR 0 = 1.\nВ конце дополнительного урока учительница информатики написала на доске булеву функцию f и попросила одного из учеников выбрать такие N булевых значений ai, чтобы результат цепного вычисления этой функции был равен единице. Более того, она попросила найти такой набор булевых значений, в котором число единиц было бы как можно большим.\nТребуется написать программу, которая решала бы поставленную учительницей задачу.\nВходные данные\nПервая строка входного файла INPUT.TXT содержит одно натуральное число N (2 ≤ N ≤ 100 000).\nВторая строка содержит описание булевой функции в виде четырех чисел, каждое из которых – ноль или единица.\nПервое из них есть результат вычисления функции в случае, если оба аргумента – нули, второе – результат в случае, если первый аргумент – ноль, второй – единица, третье – результат в случае, если первый аргумент – единица, второй – ноль, а четвертый – в случае, если оба аргумента – единицы.\nВыходные данные\nВ выходной файл OUTPUT.TXT необходимо вывести строку из N символов, определяющих искомый набор булевых значений ai с максимально возможным числом единиц. Если ответов несколько, требуется вывести любой из них. Если такого набора не существует, выведите в выходной файл фразу «No solution».",
    "complexity": 45,
    "memory": 16000,
    "time": 1000,
    "examples": [
      {
        "input": "4\n0110",
        "output": "1011"
      },
      {
        "input": "5\n0100",
        "output": "11111"
      },
      {
        "input": "6\n0000",
        "output": "No solution"
      }
    ]
  },
  {
    "id": 715,
    "name": "Миша и негатив",
    "description": "Миша уже научился хорошо фотографировать и недавно увлекся программированием. Первая программа, которую он написал, позволяет формировать негатив бинарного черно-белого изображения.\nOUTPUT.TXT222 2\nBW\nBB\n\nWWBW22[Лучшие попытки]\nБинарное черно-белое изображение – это прямоугольник, состоящий из пикселей, каждый из которых может быть либо черным, либо белым. Негатив такого изображения получается путем замены каждого черного пикселя на белый, а каждого белого пикселя – на черный.\n[Решение]\nМиша, как начинающий программист, написал свою программу с ошибкой, поэтому в результате ее исполнения мог получаться некорректный негатив. Для того чтобы оценить уровень несоответствия получаемого негатива исходному изображению, Миша начал тестировать свою программу.\nВ качестве входных данных он использовал исходные изображения. Сформированные программой негативы он начал тщательно анализировать, каждый раз определяя число пикселей негатива, которые получены с ошибкой.\nТребуется написать программу, которая в качестве входных данных использует исходное бинарное черно-белое изображение и полученный Мишиной программой негатив, и на основе этого определяет количество пикселей, в которых допущена ошибка.\nВходные данные\nПервая строка входного файла INPUT.TXT содержит целые числа n и m (1 ≤ n, m ≤ 100) – высоту и ширину исходного изображения (в пикселях). Последующие n строк содержат описание исходного изображения. Каждая строка состоит из m символов «B» и «W». Символ «B» соответствует черному пикселю, а символ «W» – белому. Далее следует пустая строка, а после нее – описание выведенного Мишиной программой изображения в том же формате, что и исходное изображение.\nВыходные данные\nВ выходной файл OUTPUT.TXT необходимо вывести число пикселей негатива, которые неправильно сформированы Мишиной программой.",
    "complexity": 17,
    "memory": 16000,
    "time": 1000,
    "examples": [
      {
        "input": "3 4\n\nWBBW\n\nBBBB\n\nWBBW\n\n\n\nBWWW\n\nWWWB\nBWWB",
        "output": "2"
      },
      {
        "input": "2 2\n\nBW\n\nBB\n\n\n\nWW\nBW",
        "output": "2"
      }
    ]
  },
  {
    "id": 716,
    "name": "Треугольник Максима",
    "description": "С детства Максим был неплохим музыкантом и мастером на все руки. Недавно он самостоятельно сделал несложный перкуссионный музыкальный инструмент – треугольник. Ему нужно узнать, какова частота звука, издаваемого его инструментом.\nii-1OUTPUT.TXT30.0 260.024554.0880.0 further440.0 closer622.0 closer531.0 660.0531.0 660.0[Лучшие попытки]\nУ Максима есть профессиональный музыкальный тюнер, с помощью которого можно проигрывать ноту с заданной частотой. Максим действует следующим образом: он включает на тюнере ноты с разными частотами и для каждой ноты на слух определяет, ближе или дальше она к издаваемому треугольником звуку, чем предыдущая нота. Поскольку слух у Максима абсолютный, он определяет это всегда абсолютно верно.\nтреуг.[Решение]\nВам Максим показал запись, в которой приведена последовательность частот, выставляемых им на тюнере, и про каждую ноту, начиная со второй, записано – ближе или дальше она к звуку треугольника, чем предыдущая нота. Заранее известно, что частота звучания треугольника Максима составляет не менее 30 герц и не более 4000 герц.\nТребуется написать программу, которая определяет, в каком интервале может находиться частота звучания треугольника.\nВходные данные\nПервая строка входного файла INPUT.TXT содержит целое число n – количество нот, которые воспроизводил Максим с помощью тюнера (2 ≤ n ≤ 1000). Последующие n строк содержат записи Максима, причем каждая строка содержит две компоненты: вещественное число fi – частоту, выставленную на тюнере, в герцах (30 ≤ fi ≤ 4000), и слово «closer» или слово «further» для каждой частоты, кроме первой. Частоты fi заданы с точностью, не превышающей 10 цифр после запятой.\nСлово «closer» означает, что частота данной ноты ближе к частоте звучания треугольника, чем частота предыдущей ноты, что формально описывается соотношением: |fi – fтреуг.| \u003c |fi-1 – fтреуг.| Слово «further» означает, что частота данной ноты дальше, чем предыдущая. Если оказалось, что очередная нота так же близка к звуку треугольника, как и предыдущая нота, то Максим мог записать любое из двух указанных выше слов. Гарантируется, что результаты, полученные Максимом, непротиворечивы.\nВыходные данные\nВ выходной файл OUTPUT.TXT необходимо вывести через пробел два вещественных числа – наименьшее и наибольшее возможное значение частоты звучания треугольника, изготовленного Максимом. Числа следует выводить с точностью, не худшей 10-6.",
    "complexity": 30,
    "memory": 16000,
    "time": 1000,
    "examples": [
      {
        "input": "3\n440.0\n220.0 closer\n300.0 further",
        "output": "30.0 260.0"
      },
      {
        "input": "4\n554.0\n880.0 further\n440.0 closer\n622.0 closer",
        "output": "531.0 660.0"
      }
    ]
  },
  {
    "id": 743,
    "name": "Алхимия",
    "description": "Алхимики средневековья владели знаниями о превращении различных химических веществ друг в друга. Это подтверждают и недавние исследования археологов.\nOUTPUT.TXT225\nAqua -\u003e AquaVita\nAquaVita -\u003e PhilosopherStone\nAquaVita -\u003e Argentum\nArgentum -\u003e Aurum\nAquaVita -\u003e Aurum\nAqua\nOsmium-1-1[Лучшие попытки]\nВ ходе археологических раскопок было обнаружено\tm глиняных табличек, каждая из которых была покрыта непонятными на первый взгляд символами. В результате расшифровки выяснилось, что каждая из табличек описывает одну алхимическую реакцию, которую умели проводить алхимики.\n[Решение]\nРезультатом алхимической реакции является превращение одного вещества в другое. Задан набор алхимических реакций, описанных на найденных глиняных табличках, исходное вещество и требуемое вещество. Необходимо выяснить: возможно ли преобразовать исходное вещество в требуемое с помощью этого набора реакций, а в случае положительного ответа на этот вопрос — найти минимальное количество реакций, необходимое для осуществления такого преобразования.\nВходные данные\nПервая строка входного файла INPUT.TXT содержит целое число m (0 ≤ m ≤ 1000) – количество записей в книге. Каждая из последующих m строк описывает одну алхимическую реакцию и имеет формат вещество1 -\u003e вещество2, где вещество1 – название исходного вещества, вещество2 – название продукта алхимической реакции. m+2-ая строка входного файла содержит название вещества, которое имеется исходно, m+3-ая – название вещества, которое требуется получить.\nВо входном файле упоминается не более 100 различных веществ. Название каждого из веществ состоит из строчных и заглавных английских букв и имеет длину не более 20 символов. Строчные и заглавные буквы различаются.\nВыходные данные\nВ выходной файл OUTPUT.TXT выведите минимальное количество алхимических реакций, которое требуется для получения требуемого вещества из исходного, или -1, если требуемое вещество невозможно получить.",
    "complexity": 42,
    "memory": 16000,
    "time": 1000,
    "examples": [
      {
        "input": "5\n\nAqua -\u0026gt; AquaVita\n\nAquaVita -\u0026gt; PhilosopherStone\n\nAquaVita -\u0026gt; Argentum\n\nArgentum -\u0026gt; Aurum\n\nAquaVita -\u0026gt; Aurum\n\nAqua\n\nAurum",
        "output": "2"
      },
      {
        "input": "5\n\nAqua -\u0026gt; AquaVita\n\nAquaVita -\u0026gt; PhilosopherStone\n\nAquaVita -\u0026gt; Argentum\n\nArgentum -\u0026gt; Aurum\n\nAquaVita -\u0026gt; Aurum\n\nAqua\n\nOsmium",
        "output": "-1"
      }
    ]
  },
  {
    "id": 742,
    "name": "Постройка дорог",
    "description": "В известном городе Кызылорда, где находятся N центров, живет некий граф - Азамат. Он желает узнать количество различных построек дорог между ними, если известно, что два центра могут быть связаны в одном из двух направлений или не связаны вообще. Например, при N=2 все получается 3 варианта:\nдорога идет из второго в первый центрOUTPUT.TXT324729729[Лучшие попытки]\nоба центра не связаны\nдорога идет из первого во второй центр\nдорога идет из второго в первый центр\nВходные данные\nВо входном файле INPUT.TXT записано единственное натуральное число - количество центров в городе, 2 ≤ N ≤ 100.\nВыходные данные\nВ единственную строку выходного файла OUTPUT.TXT нужно вывести число всевозможных построек дорог.",
    "complexity": 33,
    "memory": 16000,
    "time": 1000,
    "examples": [
      {
        "input": "2",
        "output": "3"
      },
      {
        "input": "4",
        "output": "729"
      }
    ]
  },
  {
    "id": 744,
    "name": "Скобочки-3",
    "description": "Выходные данные\nВ выходной файл OUTPUT.TXT выведите «YES», если s является циклическим сдвигом правильной скобочной последовательности, иначе – выведите \"NO\".",
    "complexity": 46,
    "memory": 16000,
    "time": 1000,
    "examples": [
      {
        "input": "}()[]{",
        "output": "YES"
      },
      {
        "input": "}([)]{",
        "output": "NO"
      },
      {
        "input": "()][",
        "output": "YES"
      }
    ]
  },
  {
    "id": 652,
    "name": "Квантовый имитатор",
    "description": "Знаменитая компания по разработке аппаратного обеспечения «Zhaleza» после многолетних исследований разработала опытный образец квантового компьютера. Разработанная архитектура концептуально отличалась от используемой микропроцессорной архитектуры. Будущей областью применения своего изобретения компания видит обработку и хранение огромных объемов информации. Основным объектом манипулирования квантового компьютера является одномерный массив. На данный момент в процессоре  квантового компьютера реализованы операции двух типов:\nOUTPUT.TXT19215 4\nS 2 11\nI 10 15\nI 1 10\nS 5 106521652111039\n101519\n86244\n194331[Лучшие попытки]\n1. Инвертирование части массива, начиная с индекса L и заканчивая индексом R. Под инвертированием части массива понимается изменение прямого порядка следования элементов массива на обратный, начиная с индекса L и заканчивая индексом R, то есть элемент L меняется местами с элементом R, элемент L+1 с элементом R-1 и так далее. На псевдоязыке эту операцию можно записать следующим образом:\n31000 9\nS 17 149\nI 199 428\nI 17 417\nI 212 987\nS 300 420\nI 400 700\nI 633 759\nS 11 238\nS 477 87211039\n101519\n86244\n194331\nFor i = 1 to [(R-L+1)/2] do Swap(A, L+i-1, R-i+1)\nОбозначение [X] – это наибольшее целое число, не превосходящее X, где X –действительное число.  Процедура  Swap(A, i, j) может быть записана следующим образом:\nProcedure Swap(A, i, j) \nBegin\n  Tmp = A[i]\n  A[i] = A[j]  \n  A[j] = Tmp \nEnd\n2. Вывод на экран суммы элементов массива, начиная с индекса L и заканчивая индексом R. На псевдоязыке процедура может быть реализована следующим образом:\nProcedure PrintSum(A, L, R)\nBegin\n  Sum = 0\n  For i = L to R do Sum = Sum + A[i]\n  Print(Sum)    \nEnd\nМассив, с которыми работает квантовый компьютер, являются одномерным. Все элементы являются натуральными числами и нумеруются последовательно,  начиная с единицы. Первоначально массив из N элементов заполнен числами от 1 до N, таким образом что  A[1] = 1, A[2] = 2,…, A[N] = N.\nПрограммой будем называть последовательность команд длины K, где каждая команда  – это операция одного из двух типов. Ваша задача разработать имитатор работы квантового компьютера, позволяющий по заданной размерности массива N и заданной программе определить последовательность чисел выведенных квантовым компьютером на экран.\nВходные данные\nПервая строка входного файла INPUT.TXT содержит два целых числа N и K (1 ≤ N ≤ 109, 1 ≤ K ≤ 5000). Каждая последующая строка описывает ровно одну операцию. Первый символ  строки входного файла характеризует тип операции: 'I'(ASCII 73) – первый тип запроса, 'S'(ASCII 83) – второй тип запроса. Далее в строке через пробел следуют два числа, характеризующие соответствующие индексы L и R (1 ≤ L ≤ R ≤ N), разделенные одиночным пробелом.\nВыходные данные\nВыходной файл OUTPUT.TXT должен содержать последовательность чисел выведенных на экран квантовым компьютером. Каждое число выводится в  отдельную строку. Гарантируется, что в программе присутствует операция второго типа.",
    "complexity": 70,
    "memory": 16000,
    "time": 1000,
    "examples": [
      {
        "input": "10 2\n\nI 1 5\n\nS 3 7",
        "output": "19"
      },
      {
        "input": "15 4\n\nS 2 11\n\nI 10 15\n\nI 1 10\n\nS 5 10",
        "output": "65\n21"
      },
      {
        "input": "1000 9\n\nS 17 149\n\nI 199 428\n\nI 17 417\n\nI 212 987\n\nS 300 420\n\nI 400 700\n\nI 633 759\n\nS 11 238\n\nS 477 872",
        "output": "11039\n\n101519\n\n86244\n\n194331"
      }
    ]
  },
  {
    "id": 718,
    "name": "Новое слово в рекламе",
    "description": "В наши дни предоставление поверхностей заборов и стен промышленных зданий рекламодателям – уже не оригинальный способ получить дополнительный заработок, а нечто само собой разумеющееся. \nOUTPUT.TXT31 2 322 11sillysamplehappysamplesam121222 2-1[Лучшие попытки]\nНебольшая компания «Домострой» также решила выйти на этот рынок и стала предлагать место для рекламы на своих блоках заборов. Блок представляет собой параллелепипед размером 1×1×L, на одной из сторон которого есть место для рекламы – пространство размера 1×L, в которое можно вписать ровно L букв английского алфавита.\n32 3baaaabbb22 2\nК сожалению, иногда сделки у компании срывались, и заранее подготовленные блоки с рекламой отправлялись на склад. Со временем там скопилось приличное количество блоков различных типов (блоки разных типов отличаются друг от друга только надписью), поэтому было решено использовать их вторично. \n42 3aaabbbcc-1\nБыла предложена следующая идея: если поставить несколько блоков друг на друга и закрасить ненужные буквы, то, читая сверху вниз и слева направо, можно будет прочитать какой-нибудь другой текст, как показано на рисунке.\nТаким образом, можно получить рекламную надпись для нового клиента. При этом из эстетических соображений при прочтении конечной надписи разрывы в виде закрашенных букв недопустимы.\nПосле того, как некоторое число K блоков, каждый из которых имеет длину L, поставили друг на друга, получилась прямоугольная таблица размером K×L, в каждой клетке которой находится буква английского алфавита. Каждый рекламный блок соответствует строке этой таблицы. Теперь содержимое этой таблицы выписывается по столбцам, начиная с самого левого. При этом в каждом столбце буквы выписываются сверху вниз. В случае, изображенном на рисунке, в результате этого процесса получилась бы строка «TOEIIZENITKN». Необходимо, чтобы рекламная надпись, требуемая заказчику, входила в получившуюся строку как подстрока «TOEIIZENITKN».\nТребуется написать программу, которая будет определять, какое минимальное количество блоков надо использовать, чтобы получить рекламную надпись, необходимую заказчику. При этом можно считать, что на складе блоков каждого типа неограниченно много.\nВходные данные\nПервая строка входного файла INPUT.TXT содержит два натуральных числа N и L – число различных типов блоков на складе и длина каждого блока соответственно (1 ≤ N ≤ 100, 1 ≤ L ≤ 100). Последующие N строк содержат по одной записи длиной L, состоящей из строчных английских букв – надписи на блоках соответствующего типа. Надписи на блоках разных типов не совпадают.\nПоследняя строка входного файла содержит новую рекламную надпись s – строку, состоящую только из строчных английских букв (1 ≤ |s| ≤ 200). Можно считать, что на складе находится неограниченное число блоков каждого типа.\nВыходные данные\nВ первой строке выходного файла OUTPUT.TXT необходимо вывести натуральное число K – минимальное количество блоков, которое нужно использовать для составления новой рекламы. Следующая строка должна содержать K чисел – номера типов блоков, которые нужно для этого использовать, перечисляя их сверху вниз. Типы блоков нумеруются с единицы в порядке их задания во входном файле.  Если ответов несколько, выведите любой из них. Если решения не существует, выведите в выходной файл число –1.",
    "complexity": 71,
    "memory": 64000,
    "time": 1000,
    "examples": [
      {
        "input": "3 4\ntiet\noink\nezin\nzenit",
        "output": "3\n1 2 3"
      },
      {
        "input": "2 11\nsillysample\nhappysample\nsam",
        "output": "1\n2"
      },
      {
        "input": "2 3\nbaa\naab\nbb",
        "output": "2\n2 2"
      },
      {
        "input": "2 3\naaa\nbbb\ncc",
        "output": "-1"
      }
    ]
  },
  {
    "id": 717,
    "name": "Производство деталей",
    "description": "Предприятие «Авто-2010» выпускает двигатели для известных во всем мире автомобилей. Двигатель состоит ровно из n деталей, пронумерованных от 1 до n, при этом деталь с номером i изготавливается за pi секунд. Специфика предприятия «Авто-2010» заключается в том, что там одновременно может изготавливаться лишь одна деталь двигателя. Для производства некоторых деталей необходимо иметь предварительно изготовленный набор других деталей.\nnOUTPUT.TXT300 22 1222 31 205 22 15 22 19 33 2 1[Лучшие попытки]\nГенеральный директор «Авто-2010» поставил перед предприятием амбициозную задачу – за наименьшее время изготовить деталь с номером 1, чтобы представить ее на выставке.\n9342 3 4 52 3 21 302 1 39 33 2 1[Решение]\nТребуется написать программу, которая по заданным зависимостям порядка производства между деталями найдет наименьшее время, за которое можно произвести деталь с номером 1.\nВходные данные\nПервая строка входного файла INPUT.TXT содержит число n (1 ≤ n ≤ 100000) – количество деталей двигателя. Вторая строка содержит n натуральных чисел p1, p2 … pn , определяющих время изготовления каждой детали в секундах. Время для изготовления каждой детали не превосходит 109 секунд.\nКаждая из последующих n строк входного файла описывает характеристики производства деталей. Здесь i-ая строка содержит число деталей ki, которые требуются для производства детали с номером i, а также их номера. Сумма всех чисел ki не превосходит 200000.\nИзвестно, что не существует циклических зависимостей в производстве деталей.\nВыходные данные\nВ первой строке выходного файла OUTPUT.TXT должны содержаться два числа: минимальное время (в секундах), необходимое для скорейшего производства детали с номером 1 и число k деталей, которые необходимо для этого произвести. Во второй строке требуется вывести через пробел k чисел – номера деталей в том порядке, в котором следует их производить для скорейшего производства детали с номером 1.",
    "complexity": 48,
    "memory": 64000,
    "time": 1000,
    "examples": [
      {
        "input": "3\n100 200 300\n1 2\n0\n2 2 1",
        "output": "300 2\n2 1"
      },
      {
        "input": "2\n2 3\n1 2\n0",
        "output": "5 2\n2 1"
      },
      {
        "input": "4\n2 3 4 5\n2 3 2\n1 3\n0\n2 1 3",
        "output": "9 3\n3 2 1"
      }
    ]
  },
  {
    "id": 639,
    "name": "TopCoder",
    "description": "Некоторые из вас, наверное, слышали о сайте http://www.topcoder.com, на котором часто проводятся различные соревнования по программированию.\niOUTPUT.TXT11\n909.94 Savior\n867.15 Ying\n448.12 natori\n439.51 tywok\n195.32 aubergineanode\n130.52 LimberG\n0.00 angsa\n0.00 shalinmangar\n0.00 BryanChen\n-25.00 Excilus\n-75.00 The_Hedgehog[Лучшие попытки]\nВ некоторых из них участникам предлагаются три задачи, каждая из которых оценивается в некоторое количество баллов. В зависимости от того, насколько долго участник решал задачу, количество полученных им за нее баллов уменьшается. Как и в большинстве других соревнований, выигрывает участник, набравший наибольшее число баллов. Участники, набравшие одинаковое число баллов, считаются выступившими одинаково и их порядок в таблице итоговых результатов не важен. Из-за некоторых особенностей этих соревнований для предотвращения жульничества участники разделены в группы по 20 человек, называемые комнатами.\ni\nВаша задача заключается в том, чтобы написать программу, которая по итоговым результатам в каждой комнате выводила бы суммарные итоговые результаты.\nj\nВходные данныеi\nПервая строка входного файла INPUT.TXT содержит целое число n (1 ≤ n ≤ 100) - число комнат. Далее следуют n описаний итоговых результатов в комнатах.\nj\nРезультаты в i-ой комнате заданы в следующем формате. Первая строка содержит целое число ni (1 ≤ ni ≤ 20)- количество участников в i-ой комнате. Следующие ni строк содержат информацию о выступлениях участников. j+1-ая строка описания результатов в i-ой комнате содержит информацию об участнике, занявшем в i-ой комнате j-ое место: разделенные одним пробелом вещественное число totalij (-5000 ≤ totalij ≤ 10000) и строку nameij - соответственно количество набранных участником баллов и его имя. Имя участника имеет длину от 1 до 25 и может содержать только буквы английского алфавита, цифры и символ подчеркивания. При этом первый символ имени не является цифрой. Все вещественные числа заданы с двумя знаками после десятичной точки.\ni\nj\nГарантируется, что в каждой комнате участники упорядочены по невозрастанию набранных ими баллов.\nВыходные данные\nНа первой строке выходного файла OUTPUT.TXT выведите N - суммарное число участников. На следующих N строках выведите информацию о выступлении участников. (k+1)-ая строка описания суммарных результатов должна содержать информацию об участнике, занявшем k-ое место: разделенные одним пробелом вещественное число totalk с двумя знаками после десятичной точки и строку namek - соответственно количество набранных участником баллов и его имя.\nНе забудьте, что участники должны быть упорядочены по невозрастанию набранных ими баллов.",
    "complexity": 25,
    "memory": 16000,
    "time": 1000,
    "examples": [
      {
        "input": "2\n\n6\n\n909.94 Savior\n\n439.51 tywok\n\n130.52 LimberG\n\n0.00 BryanChen\n\n0.00 angsa\n\n-75.00 The_Hedgehog\n\n5\n\n867.15 Ying\n\n448.12 natori\n\n195.32 aubergineanode\n\n0.00 shalinmangar\n\n-25.00 Excilus",
        "output": "11\n\n909.94 Savior\n\n867.15 Ying\n\n448.12 natori\n\n439.51 tywok\n\n195.32 aubergineanode\n\n130.52 LimberG\n\n0.00 angsa\n\n0.00 shalinmangar\n\n0.00 BryanChen\n\n-25.00 Excilus\n\n-75.00 The_Hedgehog"
      }
    ]
  },
  {
    "id": 653,
    "name": "Аттракцион",
    "description": "На протяжении многих лет в Байтландии существует парк развлечений “Funny byte”, в котором представлено много различных аттракционов: колесо вычислений, веселые горки с трассами в форме интегралов, равнобедренная ромашка и многие другие. \nOUTPUT.TXT2C 1 2R 1 223 51 2 3 4 56 7 8 9 1011 12 13 14 15005\nR 1 4\nC 1 5\nC 3 4\nR 2 4\nR 3 4[Лучшие попытки]\nВ последние годы популярность “Funny byte” стала неуклонно падать. В целях привлечения посетителей руководство парка решило открыть новый аттракцион, который представляет собой сложный механизм. \n34 5\n10 7 9 8 6\n15 12 14 13 11\n20 17 19 18 16\n5 2 4 3 15\nR 1 4\nC 1 5\nC 3 4\nR 2 4\nR 3 4\nКресла аттракциона  расположены в N рядов по M кресел в каждом. То есть каждое кресло характеризуется номером ряда и номером  колонки, в котором оно находится. Ряды нумеруются последовательно сверху вниз начиная с единицы, колонки нумеруются слева направо начиная с единицы. Каждое кресло имеет свой уникальный номер. Кресло, находящееся в i-м ряду и в j-ой колонке, имеет номер (i-1)*M + j.\nПосле посадки отдыхающих, кресла поднимают вверх над землей. И начинается веселье! Механизм аттракциона случайным образом производит некоторое количество операций. Под одной операцией понимается взаимная перестановка двух рядов либо двух колонок. При взаимной перестановке двух рядов или колонок каждое кресло в ряду или колонке заменятся на соответствующее ему кресло в   другом ряду или колонке.\nИ вот аттракцион завершил свою работу. Но есть одна трудность! Кресла надо вернуть в начальное положение при помощи таких же операций. Как количество, так и сами операции не обязательно должны быть идентичны тем, которые производил аттракцион во время сеанса. Руководство парка решило, что вернуть кресла в начальное положение необходимо не более чем за 1000 операций.\nТакая задача оказалась не по силам разработчикам механизма. Помогите им! От вас требуется разработать программу, позволяющую вернуть кресла в начальное положение. Гарантируется, что решение существует.\nВходные данные\nВ первой строке  входного файла INPUT.TXT заданы два натуральных числа N и M (1 ≤ N, M ≤ 250). В последующих  N строках задано по M натуральных чисел, где j-е число в i+1-й строке соответствует номеру кресла после окончания сеанса аттракциона. Числа в строках разделяются одиночными пробелами.\nВыходные данные\nВ первой строке выходного файла OUTPUT.TXT должно быть выведено количество операций перестановки K, которое не должно превышать 1000. Каждая из следующих K строк описывает одну операцию. Каждая операция описывается  строкой вида Q X Y, где Q – символ 'R'(ASCII 82) либо символ 'C'(ASCII 67). Если Q равно 'R', то данная операция является перестановкой рядов, если Q равно 'C', то  операция является перестановкой колонок. X и Y – два натуральных числа, соответствующие номерам рядов (колонок), которые будут переставлены в результате данной операции. Операции должны быть выведены в порядке осуществления, то есть последовательное применение которых позволит вернуть кресла в начальное положение.",
    "complexity": 50,
    "memory": 16000,
    "time": 1000,
    "examples": [
      {
        "input": "2 2\n4 3\n2 1",
        "output": "2\nC 1 2\nR 1 2"
      },
      {
        "input": "3 5\n1 2 3 4 5\n6 7 8 9 10\n11 12 13 14 15",
        "output": "0"
      },
      {
        "input": "4 5\n\n10 7 9 8 6\n\n15 12 14 13 11\n\n20 17 19 18 16\n\n5 2 4 3 1",
        "output": "5\n\nR 1 4\n\nC 1 5\n\nC 3 4\n\nR 2 4\n\nR 3 4"
      }
    ]
  },
  {
    "id": 657,
    "name": "Hello space!",
    "description": "Ученые из центра космических наблюдений зафиксировали полезный информационный сигнал, который поступает из далекой галактики. Оказалось, что информацию передают некоторые разумные существа, посылая в сторону Земли луч, яркость которого изменяется с обычной на повышенную, и наоборот. Если информация не передается, то яркость луча обычная и не меняется во времени (пустой сигнал). \n9OUTPUT.TXT110ERROR[Лучшие попытки]\nУченым удалось распознать правило, по которому инопланетяне кодируют полезный сигнал. Он является двоичным кодом, причем в течение сеанса связи передача каждого бита сигнала занимает одно и то же вещественное время T. Для передачи бита “1” яркость луча в течение времени T/2 повышенная, а в течение второй половины времени T/2 – обычная. Передача бита “0” осуществляется наоборот: в течение первой половины времени T/2 яркость луча обычная, а в течение второй половины времени T/2 – повышенная. Ученые считают, что первый бит полезного сигнала всегда равен единице, а последний бит – нулю. Для наглядности пример передачи каждого из битов представлен на рисунке:\nУченым удалось сконструировать прибор, который позволяет представить информацию, поступающую из далекой галактики, в виде последовательности нечетной длины, состоящей из целых чисел, определяющих, сколько времени передающий луч находился в постоянном состоянии. Первое число этой последовательности показывает время, в течение которого луч находился в состоянии повышенной яркости, второе число – в состоянии обычной яркости, третье – снова повышенной яркости и т.д. Последнее число последовательности (как и первое) показывает время нахождения луча в состоянии повышенной яркости.\nК сожалению, построенный прибор не является абсолютно точным – результаты всех измерений, которые он производит, имеют относительную погрешность, не превосходящую 10%. Это значит, что реальное время  , в течение которого луч находился в постоянном состоянии (L – вещественное число), и зафиксированное прибором время   (L' – целое число)  удовлетворяют неравенству |L - L'| / L ≤ 0.1 .\nВ качестве примера рассмотрим передачу сигнала “110”, если T = 84.6.\nПри точной работе прибор  зафиксировал бы следующую последовательность:\n42.3, 42.3, 42.3, 84.6, 42.3\nОбратите внимание, что данная последовательность не зависит от момента времени, в который началась передача сигнала.\nОднако из-за наличия погрешности результат работы прибора достаточно непредсказуем. К примеру, полученная последовательность может быть следующего вида:\n42, 43, 39, 93, 44\nУченым при помощи построенного прибора удалось получить информацию о K инопланетных сигналах. Теперь задача состоит в том, чтобы по полученной прибором информации  определить сами сигналы. Эта задача осложняется тем, что ученые не знают, какое значение T инопланетяне использовали для передачи сигналов. Более того, для передачи разных сигналов могли использоваться разные значения T.\nВам как начальнику отдела инновационных технологий центра космических наблюдений была поручена разработка программы для решения этой задачи.\nВходные данные\nВ первой строке входного файла INPUT.TXT записано целое число K – количество принятых инопланетных сигналов (1 ≤ K ≤ 5). Далее следует описание K сигналов. Описание каждого сигнала начинается со строки, содержащей целое нечетное число N – длина последовательности, которую зафиксировал прибор для данного сигнала (3 ≤ N ≤ 32767). Далее следует N строк, в каждой из которых записано одно целое число Ti –  значение i-го элемента последовательности (0 \u003c Ti ≤ 109).\nВыходные данные\nВ выходной файл OUTPUT.TXT для каждого из сигналов необходимо вывести одну строку из N символов '0'/'1' – двоичный код принятого сигнала. Если существует несколько способов восстановления сигнала, то выведите любой из них. Если не существует ни одного способа восстановления сигнала, то выведите строку \"ERROR\".",
    "complexity": 60,
    "memory": 16000,
    "time": 1000,
    "examples": [
      {
        "input": "2\n\n5\n\n42\n\n43\n\n39\n\n93\n\n44\n\n5\n\n10\n\n10\n\n22\n\n10\n\n30",
        "output": "110\nERROR"
      }
    ]
  },
  {
    "id": 654,
    "name": "Концертный зал",
    "description": "Большой концертный зал Байтланда — известное на весь мир место, где мечтают выступать величайшие оперные певцы и певицы. В желающих послушать их выступления, как правило, недостатка нет. Поэтому Министерством культуры Байтланда было принято решение увеличить размеры зала.\n9OUTPUT.TXT3241 2 4 2556[Лучшие попытки]\nОднако это вызвало другую проблему: на задних рядах обновленного концертного зала посетители практически ничего не слышат. Поэтому Инженерный институт предложил проект акустической системы, которая будет состоять из микрофонов, записывающих происходящее на сцене, и динамиков, транслирующих усиленный звук в зал.\nАЧХ из примера №2 и усилители, которые нужны, чтобы ее «выровнять» на уровне в 4 дБ (5 штук, усилители применяются в порядке от верхних к нижним)353 1 4 1 16\nВ идеальном случае динамики должны достоверно воспроизводить звук, записываемый с микрофонов. На практике этого добиться почти невозможно, так как при текущем уровне развития технологий практически все динамики воспроизводят различные частоты с различной громкостью. Мириться с этим инженеры, однако, не собираются.\nВ лаборатории удалось измерить АЧХ (амплитудно-частотную характеристику) динамиков и представить ее в следующей форме:\nвесь диапазон частот, воспроизводимых динамиками, разделен на N последовательных интервалов, нумеруемых от 1 до N;\nв i-м интервале известно Ai - значение усредненной по интервалу громкости в децибелах (Прим.: децибел (дБ) — единица измерения громкости).\n\nАЧХ из примера №2 и усилители, которые нужны, чтобы ее «выровнять» на уровне в 4 дБ (5 штук, усилители применяются в порядке от верхних к нижним)\nАЧХ динамиков можно править с помощью специальных электронных устройств — усилителей. Усилитель может поднять силу сигнала на всех интервалах с A-го по B-й на 1 дБ, где A, B — произвольные натуральные числа, не превосходящие N, A ≤ B. Из-за особенностей применяемых в устройстве радиодеталей, сила сигнала перед применением усилителя должна быть одинакова на всех интервалах с A-го по B-ой. Так как стоимость усилителя достаточно велика, то их количество должно быть минимально.\nСчитается, что динамики воспроизводят звук достоверно, если на всех интервалах значение громкости одинаково. Напишите программу, которая вычислит минимальное число усилителей, необходимое для достижения достоверного звучания.\nВходные данные\nПервая строка входного файла INPUT.TXT содержит одно число N (1 ≤ N ≤ 200000) — количество интервалов, на которых замерялась АЧХ. Вторая строка содержит N натуральных чисел Ai (1 ≤ i ≤ N, 1 ≤ Ai ≤ 109), разделенных одиночными пробелами — усредненная громкость на i-м интервале в децибелах.\nВыходные данные\nЕдинственная строка выходного файла OUTPUT.TXT должна содержать одно целое  число — минимальное число усилителей, с помощью которых можно добиться достоверного звучания.",
    "complexity": 36,
    "memory": 32000,
    "time": 1000,
    "examples": [
      {
        "input": "3\n1 3 2",
        "output": "3"
      },
      {
        "input": "4\n1 2 4 2",
        "output": "5"
      },
      {
        "input": "5\n3 1 4 1 1",
        "output": "6"
      }
    ]
  },
  {
    "id": 658,
    "name": "Фермерское счастье",
    "description": "На протяжении многих лет кролик Роджер известен всей округе как выдающийся фермер, в искусстве ведения хозяйства ему нет равных. В проведенном международном конкурсе «Фермер года», с большим отрывом   выиграл  кролик Роджер. \niOUTPUT.TXT15[Лучшие попытки]\nГлавный приз – возможность  первым из всех фермеров отгородить себе участок на специально  выделенном поле. Известно, что на поле растет N деревьев. Отгораживаемый участок должен иметь форму треугольника, вершинами которого являются некоторые из растущих на поле деревьев.\ni\nКролик быстро смекнул, что на самом деле существует много вариантов выбора участка, но его интересуют только такие варианты, при которых участок не содержит внутри себя других деревьев. Ваша задача состоит в том, чтобы помочь Роджеру определить  количество интересующих его вариантов выбора участка.\nВходные данные\nВ первой строке входного  файла INPUT.TXT находится одно целое число N (3 ≤ N ≤ 255).  В каждой из последующих N строк записаны два целых числа Xi и Yi – координаты  очередного дерева в прямоугольной декартовой системе координат (-10000 ≤ Xi,Yi ≤ 10000). Деревья достаточно малы, поэтому их можно считать точками на плоскости. Никакие три дерева не лежат на одной прямой. Числа в строках разделены одним пробелом.\nВыходные данные\nЕдинственная строка выходного файла OUTPUT.TXT должна содержать одно целое число –  количество вариантов выбора участка.",
    "complexity": 65,
    "memory": 16000,
    "time": 1000,
    "examples": [
      {
        "input": "6\n\n1 4\n\n0 0\n\n4 5\n\n3 1\n\n-2 2\n\n1 2",
        "output": "15"
      }
    ]
  },
  {
    "id": 655,
    "name": "Кодирование данных",
    "description": "В компании «Gold\u0026Silver Soft» разработан новый алгоритм кодирования натуральных чисел. Этот алгоритм основан на операции циклического сдвига числа.\nOUTPUT.TXT319[Лучшие попытки]\nЦиклическим сдвигом натурального числа N относительно числа K назовем операцию переноса K крайних слева цифр в десятичной записи числа N к цифре крайней справа. Обозначим через cyclic(N, K) число, получаемое из N посредством циклического сдвига относительно числа K.\nВведенное понятие можно проиллюстрировать на примерах:\nВ разработанном алгоритме предлагается для кодирования натурального числа N использовать число code(N) = N + cyclic(N, K) (где K – известный параметр).\nВы работаете в «Gold\u0026Silver Soft» и Вам была поручена разработка алгоритма декодирования, то есть восстановления числа N по числам code(N) и K.\nВходные данные\nВ первой строке входного файла INPUT.TXT находится целое число code(N). Во второй строке входного файла находится целое число K. Ограничения: 10K+1 ≤  code(N) ≤  1018, 1 ≤ K ≤ 17.\nВыходные данные\nВ первой и единственной строке выходного файла OUTPUT.TXT должно быть выведено целое число N. Если существует несколько вариантов восстановления числа N по числам code(N) и K, то выведите любой из них.",
    "complexity": 60,
    "memory": 16000,
    "time": 1000,
    "examples": [
      {
        "input": "512\n1",
        "output": "319"
      }
    ]
  },
  {
    "id": 656,
    "name": "Дорожный аукцион",
    "description": "Где-то далеко от нас, на краю земли, есть одна небольшая, но красивая страна WWW с богатейшим историческим прошлым. Люди, населяющие ее, известны  всему миру своей добротой и гостеприимством. Вся территория страны условно поделена на районы. Каждый район состоит из определенного количества городов, один из которых является районным центром.\niOUTPUT.TXT4183[Лучшие попытки]\nНекоторые пары городов данного государства соединены двусторонними дорогами, причем известно, что любой районный центр соединен дорогами со всеми остальными городами района, а также не более чем с двумя другими районными центрами. Никакая дорога не соединяет два города, не являющиеся районными центрами. Дорога может соединять два города из разных районов только в том случае, если оба они являются районными центрами. Между любой парой городов может быть не более одной дороги. Дороги построены таким образом, что по ним можно доехать из любого города в любой другой.\ni\nИсторически сложилось, что право на владение всеми дорогами до недавних пор принадлежали одной известной компании «АвтоДор». В связи с этим в конституционный суд  был подан антимонопольный иск, который был удовлетворен – теперь компании предстоит продать часть своих владений. Экономисты компании определили для каждой дороги ее стоимость.\ni\nОдна маленькая, небогатая, но гордая фирма «КурсИнвест», в которой Вы работаете финансовым директором, захотела выкупить часть дорог, а именно, K из них.  Причем необходимо, чтобы для любых двух городов, к которым примыкает хотя бы одна из выкупленных K дорог, существовало не менее одного  соединяющего их пути, состоящего только из приобретенных дорог. Вам, как финансовому директору, было поручено найти  экономически выгодное решение. Решение будем называть экономически выгодным, если денежная сумма, потраченная на приобретение дорог, является минимальной.\ni\nВходные данныеi\nВ первой строке входного файла INPUT.TXT находятся три целых числа N (3 ≤ N ≤ 2000), M и К (1 ≤ K \u003c M  ≤105), где N – общее количество городов, M – общее количество дорог, K – количество дорог, которое необходимо приобрести.\ni\nДалее следует M строк, в каждой из которых записаны три целых числа Ai, Bi и Ci, где Ai и Bi – номера городов, которые соединены дорогой (1 ≤ Ai, Bi ≤ N, Ai ≠ Bi), а Ci – стоимость дороги (1 ≤ Ci ≤ 106).\nВсе числа в строках разделены одиночными пробелами.\ni\niВыходные данные\ni\nВыходной файл OUTPUT.TXT должен состоят из K строк, каждая из которых должна содержать одно число – номер приобретенной дороги. Дороги нумеруются в порядке их ввода начиная с единицы. Если решений несколько, то выведите любое из них.\n6Пример\n№INPUT.TXTOUTPUT.TXT\n19 8 4\n8 9 2\n5 1 10\n3 8 11\n2 5 7\n8 7 8\n5 6 12\n4 7 9\n3 5 54183\nДля отправки решения задачи необходимо зарегистрироваться и авторизоваться!\n[Обсуждение]\n\n  [Все попытки]\n\n  [Лучшие попытки]\nwindow.yaContextCb.push(()=\u003e{\n  Ya.Context.AdvManager.render({\n    renderTo: 'yandex_rtb_R-A-122393-3',\n    blockId: 'R-A-122393-3'\n  })\n})",
    "complexity": 75,
    "memory": 16000,
    "time": 1000,
    "examples": [
      {
        "input": "9 8 4\n\n8 9 2\n\n5 1 10\n\n3 8 11\n\n2 5 7\n\n8 7 8\n\n5 6 12\n\n4 7 9\n\n3 5 5",
        "output": "4\n1\n8\n3"
      }
    ]
  },
  {
    "id": 746,
    "name": "Гонки",
    "description": "В области L находится n городов. Некоторые пары городов соединены проселочной дорогой с двусторонним движением. Начавшись в каком-то городе, дорога не может закончиться в нем же. В этом году состояние дорог позволило отделению ГИБДД области L провести гонки под лозунгом «Скажем НЕТ нарушениям скоростного режима». Было решено, что круговая трасса должна состоять из четырех дорог, но не может проходить через один город два раза. Естественно, свернуть с одной дороги на другую можно только в городе. Организаторы уже должны приступить к составлению отчета, и для этого требуется посчитать количество различных трасс.\nOUTPUT.TXT3[Лучшие попытки]\nВходные данные\nВ первой строке входного файла INPUT.TXT записаны количество городов n\t\n(1 ≤ n ≤ 300) и количество дорог m. В каждой из следующих m строк содержится два различных числа — номера городов, соединенных соответствующей дорогой.\nВыходные данные\nВ выходной файл OUTPUT.TXT выведите одно число – количество круговых трасс из четырех дорог, которые могут составить организаторы.",
    "complexity": 64,
    "memory": 16000,
    "time": 1000,
    "examples": [
      {
        "input": "4 6\n\n1 2\n\n2 3\n\n3 4\n\n4 1\n\n1 3\n\n2 4",
        "output": "3"
      }
    ]
  },
  {
    "id": 747,
    "name": "Декомпозиция строки",
    "description": "",
    "complexity": 65,
    "memory": 16000,
    "time": 1000,
    "examples": [
      {
        "input": "ABABAAABABA",
        "output": "5\nAB 2\nA 3\nBA 2"
      }
    ]
  },
  {
    "id": 661,
    "name": "«Стабильный» интернет",
    "description": "Выходные данные\nВыходной файл OUTPUT.TXT должен содержать одно число, равное минимальной сумме денег, необходимой Пете для приобретения множества сервис-карт, которое обеспечит ему «стабильный» Интернет на время выполнения заказа.",
    "complexity": 55,
    "memory": 16000,
    "time": 1000,
    "examples": [
      {
        "input": "7\n\n10 30\n\n9 14 10\n\n13 19 18\n\n14 18 16\n\n18 24 14\n\n24 30 9\n\n17 2005 24\n\n15 20 14",
        "output": "49"
      }
    ]
  },
  {
    "id": 745,
    "name": "Карта",
    "description": "Одним из разделов функционального анализа является теория сжимающих операторов. Важным фактом, который в ней доказывается, является теорема Банаха. Она гласит, что у оператора сжатия есть ровно одна неподвижная точка.\nOUTPUT.TXT0.0 0.0210 10 1 1 5 101.0050251256281408 1.01010101010101021.0050251256281408 1.0101010101010102[Лучшие попытки]\nИнтересным следствием из этой теоремы является следующее утверждение. Пусть есть карта небольшой части поверхности Земли (поверхность считается плоской). Если карту положить в некотором месте той части поверхности, которую она изображает, то будет существовать ровно одна точка, изображение которой на карте лежит на ней.\nДля удобства будем считать, что изображенная на карте часть поверхности Земли имеет форму прямоугольника со сторонами 2W и 2H метров. Введем прямоугольную декартову систему координат так, что ось Ox направлена с запада на восток, а ось Oy – с юга на север. Единичный отрезок выберем равным одному метру. Кроме этого, поместим начало координат в центр рассматриваемой части поверхности Земли, а стороны рассматриваемого прямоугольника параллельны осям координат. Расположим карту размером 2a на 2b сантиметров так, что ее центр находится в точке с координатами (x, y). Таким образом, изображенная на карте поверхность Земли имеет форму прямоугольника с углами (W, H ), (−W, H ), (−W, −H), (W, −H), а углы карты расположены в точках (x +a/100, y+b/100), (x –a/100, y+b/100), (x –a/100, y−b/100), (x +a/100, y−b/100).\nНайдите точку, изображение которой лежит на ней при таком расположении карты.\nВходные данные\nВходной файл INPUT.TXT содержит целые числа W, H, x, y, a, b (1 ≤ W, H, x, y, a, b ≤ 1000). Гарантируется, что карта целиком лежит внутри той части поверхности Земли, которая на ней изображена.\nВыходные данные\nВ выходной файл OUTPUT.TXT выведите координаты искомой точки с точностью до 10−6.",
    "complexity": 53,
    "memory": 16000,
    "time": 1000,
    "examples": [
      {
        "input": "10 10 0 0 5 5",
        "output": "0.0 0.0"
      },
      {
        "input": "10 10 1 1 5 10",
        "output": "1.0050251256281408 1.0101010101010102"
      }
    ]
  },
  {
    "id": 659,
    "name": "Перетягивание каната",
    "description": "Для участия в соревнованиях по перетягиванию каната зарегистрировалось N человек. Некоторые из участников могут быть знакомы друг с другом. Причем, если двое из них имеют общего знакомого, то это не означает, что они обязательно знакомы друг с другом.\nOUTPUT.TXT5 2 4[Лучшие попытки]\nОрганизаторы  соревнований заинтересованы в их качественном проведении. Они хотят разделить всех участников на две команды так, чтобы в первой команде было K человек, а во второй  – N-K человек. Из всех возможных вариантов формирования команд, организаторы хотят выбрать такой вариант, при котором сумма сплоченностей обеих команд максимальна. Сплоченностью команды называется количество пар участников этой команды, знакомых друг с другом. Ваша задача – помочь организаторам найти требуемое разделение участников на две команды.\nВходные данные\nВ первой строке входного файла INPUT.TXT задаются три числа N, K, M, разделенные одиночными пробелами, где N – общее число зарегистрированных участников, K – требуемое количество человек в первой команде, M – количество пар участников, знакомых друг с другом.\nКаждая из следующих M строк содержит два различных числа, разделенные пробелом – номера двух  участников, знакомых друг с другом. Все участники нумеруются от 1 до N.\nОграничения: все числа целые, 0 \u003c K \u003c N \u003c 25, 0 ≤ M ≤ N(N-1)/2\nВыходные данные\nВыходной файл OUTPUT.TXT должен содержать одну строку, состоящую из K чисел, каждое из которых задает номер участника, попавшего в первую команду. Числа должны быть разделены пробелами. Если существует несколько решений данной задачи, то выведите любое из них.",
    "complexity": 62,
    "memory": 16000,
    "time": 1000,
    "examples": [
      {
        "input": "5 3 3\n\n1 3\n\n2 5\n\n5 4",
        "output": "5 2 4"
      }
    ]
  },
  {
    "id": 748,
    "name": "Собери сам",
    "description": "Компания «Ёжики-Хрюшечки» готовит новый конструктор «Собери сам» для детей младшего школьного возраста. Одна из главных составных частей конструктора – электронное устройство, для работы которого надо соединить набор клемм на специальной доске проводами.\nOUTPUT.TXT21 1 1 1 1 2 1 1 1[Лучшие попытки]\nПровода, которыми требуется выполнить соединение, имеют топологическую структуру дерева, в вершинах которого расположены контакты, подключаемые к клеммам. В свою очередь, доска имеет изображенную на ней схему укладки проводов, поэтому на первый взгляд кажется, что подключить устройство очень просто. Однако, к сожалению, все контакты на проводах, кроме одного выделенного, подключаемого к «корню» дерева, одинаковые, поэтому понять какой контакт куда подключить непросто.\nНапример, рассмотрим изображенную на рисунке схему.\nНа этой схеме возможны два способа подключить провода, они показаны на следующем рисунке.\nРазработчики из компании «Ёжики-Хрюшечки» не хотят, чтобы у схемы было несколько возможных подключений. Конечно, можно было бы пометить каждый контакт и каждую клемму уникальным кодом, чтобы ясно было что куда надо подключить, но тогда игра получилась бы не слишком интересной. Поэтому они решили раскрасить клеммы и контакты в разные цвета, так, чтобы были выполнены следующие условия:\nконтакт и клемма, которые необходимо соединить, раскрашены в один цвет;\nсуществует ровно один способ соединить контакты и клеммы, чтобы не каждый контакт был соединен с клеммой того же цвета, провода проходили вдоль соответствующих линий на схеме и выделенный контакт соединялся с выделенной клеммой в корне дерева.\nРазумеется, разработчики хотели бы использовать по возможности меньшее число цветов. Например, для схемы, изображенной на рисунке выше, достаточно двух цветов:\nПо заданному дереву проводов определите, в какое минимальное число цветов его можно раскрасить, чтобы выполнить приведенные условия.\nВходные данные\nПервая строка входного файла INPUT.TXT содержит число n – количество вершин дерева (1 ≤ n ≤ 500). Пусть вершины дерева пронумерованы числами от 1 до n, так что номер родителя вершины меньше ее номера. Корень дерева имеет номер 1. Вторая строка входного файла содержит n-1 число, для каждой вершины, начиная со второй, указан номер ее родителя.\nВыходные данные\nПервая строка выходного файла OUTPUT.TXT должна содержать число k – минимальное необходимое количество цветов. Следующая строка должна содержать n целых чисел – цвета вершин.",
    "complexity": 79,
    "memory": 16000,
    "time": 1000,
    "examples": [
      {
        "input": "9\n1 2 2 4 1 6 7 6",
        "output": "2\n1 1 1 1 1 2 1 1 1"
      }
    ]
  },
  {
    "id": 662,
    "name": "Green Darts",
    "description": "",
    "complexity": 75,
    "memory": 16000,
    "time": 1000,
    "examples": [
      {
        "input": "3\n\n1 99 1\n\n100 100 100\n\n51 49 13",
        "output": "3"
      }
    ]
  },
  {
    "id": 750,
    "name": "Игра на графе",
    "description": "Наташа и Петя любят играть в следующую игру на лекциях по теории сложности. Они рисуют неориентированный двудольный граф G на листе бумаги и ставят фишку в одну из его вершин. После этого они делают ходы по очереди, Наташа ходит первой. Ход в игре заключается в том, что фишка перемещается по графу вдоль одного из ребер. После хода вершина, в которой фишка находилась перед ходом, а также все инцидентные ей ребра, удаляются из графа. Игрок, который не может сделать ход, проигрывает.\nOUTPUT.TXTNPPNPP[Лучшие попытки]\nВам задан граф, который нарисовали Наташа и Петя. Для каждой вершины графа определите, кто выиграет при оптимальной игре обоих игроков, если фишка будет исходно размещена в этой вершине.\nВходные данные\nПервая строка входного файла INPUT.TXT содержит три целых числа: n1, n2 и m – количество вершин в первой и второй доле, соответственно, а также количество ребер в графе (1 ≤ n1, n2 ≤ 500, 0 ≤ m ≤ 50 000). Следующие m строк описывают ребра – каждая строка содержит по два числа – номера вершин, соединенных соответствующим ребром. Вершины в каждой доле независимо пронумерованы, начиная с 1.\nВыходные данные\nВ выходной файл OUTPUT.TXT выведите две строки. Первая строка должна содержать n1 символов, i-й символ должен быть 'N', если при исходном расположении фишки в i-й вершине первой доли, выигрывает Наташа и 'P', если выигрывает Петя. Вторая строка должна описывать вершины второй доли аналогичным образом.",
    "complexity": 81,
    "memory": 16000,
    "time": 1000,
    "examples": [
      {
        "input": "3 3 5\n\n1 1\n\n1 2\n\n1 3\n\n2 1\n\n3 1",
        "output": "NPP\nNPP"
      }
    ]
  },
  {
    "id": 660,
    "name": "Контрольная работа",
    "description": "Петя для выполнения контрольной работы по математике аккуратно вырезал из бумаги в клеточку лист прямоугольной формы размером N клеток по вертикали и M клеток по горизонтали. \nOUTPUT.TXT22[Лучшие попытки]\nПеред уроком, в ожидании учителя, чтобы как-нибудь развлечься, Петя раскрасил ручкой на листе бумаги K различных клеток. Получив замечание учителя, Петя решил вырезать из этого листа бумаги меньший прямоугольный листок, на котором не было бы раскрашенных  клеток, и сказал учителю, что знает сколькими различными способами это можно сделать.\nПетя считает, что два способа вырезания прямоугольных листков являются различными, если на листе бумаги найдется хотя бы одна клетка, которая принадлежит одному из вырезаемых листков и не принадлежит другому.\n На самом деле, Петя не знает точного числа всевозможных способов вырезания листка прямоугольной формы. Однако он слышал о больших возможностях современных вычислительных машин, поэтому решил попросить помощи у участников республиканской олимпиады по информатике.\nПроизводить разрезы разрешается только по линиям, разделяющим клетки друг от друга.\nВходные данные\nВ первой строке входного файла INPUT.TXT находятся три числа N, M и K, разделенные пробелами, где N и M – размеры листа бумаги, а K – количество закрашенных Петей клеток. Каждая из следующих K строк содержит два числа, разделенные пробелом и описывающие одну закрашенную клетку. Первое число определяет номер строки листа бумаги, в которой находится закрашенная клетка, а второе число – номер столбца. Строки  листа бумаги нумеруются сверху вниз от 1 до N, а столбцы – слева направо от 1 до M.\nОграничения: все числа натуральные, K ≤ 100000; N, M ≤ 5000; K \u003c NM .\nВыходные данные\nВыходной файл OUTPUT.TXT должен состоять из одной строки, содержащей одно целое число, равное количеству способов, которыми можно вырезать прямоугольный листок, не содержащий раскрашенных клеток, из испорченного Петей листа бумаги.",
    "complexity": 60,
    "memory": 32000,
    "time": 1000,
    "examples": [
      {
        "input": "4 3 3\n\n1 2\n\n4 3\n\n3 1",
        "output": "22"
      }
    ]
  },
  {
    "id": 749,
    "name": "Неправильный RSA",
    "description": "Рома, Сережа и Андрюша решили улучшить знаменитый алгоритм шифрования RSA. Они решили, что в RSA в качестве модуля можно использовать в качестве числа n не только произведение двух простых чисел, но и произведение вида n = pkqk, где p и q – простые числа, а k – некоторое натуральное число.\nkOUTPUT.TXT1210088[Лучшие попытки]\nОднако Коля указал, что помимо различных математических трудностей, новая схема может оказаться менее устойчивой к взлому. А именно, большое число, равное произведению двух различных простых чисел, тяжело разложить на множители, в частности, поскольку у него существует ровно одно нетривиальное разложение. А у числа вида n = pkqk их может быть больше. Например, у числа 100 = 22•52 есть целых восемь нетривиальных разложений на множители: 2•50, 2•2•25, 2•2•5•5, 2•5•10, 4•25, 4•5•5, 5•20 и 10•10.\nТеперь Рома, Сережа и Андрюша думают – сколько же различных нетривиальных разложений на множители есть у числа n = pkqk?\nВходные данные\nВходной файл INPUT.TXT содержит число n (6 ≤ n ≤ 1018, гарантируется, что n = pkqk для различных простых p и q и натурального k).\nВыходные данные\nВ выходной файл OUTPUT.TXT выведите одно число — количество нетривиальных разложений на множители числа n.",
    "complexity": 64,
    "memory": 16000,
    "time": 1000,
    "examples": [
      {
        "input": "6",
        "output": "1"
      },
      {
        "input": "100",
        "output": "8"
      }
    ]
  },
  {
    "id": 751,
    "name": "Money, money, money",
    "description": "Правительство Флатландии решило провести реформу денежной системы. Цель реформы – радикально уменьшить число банкнот в обращении, в результате их должно остаться ровно две. Таким образом, после реформы во Флатландии будут циркулировать банкноты достоинством a тугриков и b тугриков, где a и b поручено выбрать министерству финансов.\nOUTPUT.TXT2 5240 00 03 4[Лучшие попытки]\nОдна из проблем заключается в том, что президент Флатландии ненавидит число x. Поэтому министр финансов решил, что выберет такие a и b, что нельзя будет заплатить ровно x тугриков без сдачи. С другой стороны, для любой суммы большей x должна быть возможность заплатить ее без сдачи.\n353 4\nИтак, вам поручено выбрать соответствующие a и b.\nВходные данные\nВходной файл INPUT.TXT содержит натуральное число x, не превосходящее 1012.\nВыходные данные\nВ выходной файл OUTPUT.TXT выведите два целых числа a и b такие, что сумму в x тугриков нельзя заплатить банкнотами в a и b тугриков без сдачи, а любую большую сумму – можно. Если решения не существует, выведите в выходной файл два нуля.",
    "complexity": 31,
    "memory": 16000,
    "time": 1000,
    "examples": [
      {
        "input": "3",
        "output": "2 5"
      },
      {
        "input": "4",
        "output": "0 0"
      },
      {
        "input": "5",
        "output": "3 4"
      }
    ]
  },
  {
    "id": 858,
    "name": "Площадь треугольника - 2",
    "description": "",
    "complexity": 41,
    "memory": 16000,
    "time": 1000,
    "examples": [
      {
        "input": "0 1 1\n\n1 0 1\n\n4 3 19",
        "output": "6.000"
      }
    ]
  },
  {
    "id": 773,
    "name": "Гулливер",
    "description": "Из книги Джонатана Свифта мы знаем, что тот Гулливер посетил страну «Лилипутию», где живут лилипуты, окруженные вещами, животными и заводами небольшого размера. Сначала лилипуты боялись Гулливера, но позже они поняли, что такое соседство приносит им большую выгоду, и они стали помогать ему. Например, лилипуты делали кровать для Гулливера из своих маленьких матрацев, сшитых вместе. Лилипутам были известны размеры Гулливера. Довольно быстро они смогли просчитать количество матрацев, необходимых для шитья большого матраца. Но у них постоянно возникали сложности с их небольшим ростом и стеля постель, они иногда не могли сшить достаточно толстый матрац.\nOUTPUT.TXT8212 4576576[Лучшие попытки]\nВходные данные[Решение]\nВходной файл INPUT.TXT содержит два целых числа, которые разделены пробелом: K – коэффициент, отражающий во сколько раз Гулливер больше лилипутов, и M – количество слоев матрацев (2 ≤ K, M ≤ 100).\nВыходные данные\nВ выходной файл OUTPUT.TXT выведите количество матрацев лилипутов, необходимых для построения матраца для Гулливера.",
    "complexity": 4,
    "memory": 16000,
    "time": 1000,
    "examples": [
      {
        "input": "2 2",
        "output": "8"
      },
      {
        "input": "12 4",
        "output": "576"
      }
    ]
  },
  {
    "id": 772,
    "name": "Конверт",
    "description": "i-12nOUTPUT.TXTP0R P3R23 3 2F 3R 1FP0F P1FP0F P1FSCRUFFYP0F P1F P2F P3F P0R P1R[Лучшие попытки]\nХорошие новости! Межпланетный экспресс запускает новую услугу – теперь компания доставляет не только посылки, но и письма! Письмо - это согнутый несколько раз лист, помещённый в конверт, имеющий прозрачные окошки. Таким образом, часть листа (например, с адресом получателя) видна при закрытом конверте. Линии сгибания листа параллельны и делят лист на одинаковые прямоугольные фрагменты. Тем не менее, единственный в компании специалист по сгибанию Бендер подходит к делу безответственно, иногда допускает ошибки, и в результате напротив прозрачного окошка в конверте может оказаться не тот фрагмент листа. Гермес Конрад хочет избежать ошибок, поэтому, тщательно записывает каждый сделанный сгиб. Теперь ему нужна программа, которая по этим записям вычислит, какие именно фрагменты будут смотреть наружу после проделанных сгибаний.\ni333 2 2R 1RSCRUFFY\nБюрократ Гермес придумал следующую систему обозначений: все возможные линии сгибов пронумерованы от 1 до n. Если мы смотрим на лицевую сторону листа и сгибаем «от себя», когда соприкасаются обратные стороны соседних фрагментов листа, а наружу смотрят лицевые стороны, такой сгиб обозначим буквой F (forward/front bend). Если сгибаем «на себя», когда соприкасаются лицевые стороны и наружу показываются обратные стороны – то буквой R (rear bend). Для фрагментов листа нумерация похожая, только с добавлением в начале буквы P, чтобы не перепутать обозначения сгибов и фрагментов: фрагменты письма пронумерованы от P0 до Pn, где сгиб i разделяет фрагменты Pi-1, Pi. Лицевая сторона письма и любого из фрагментов обозначена F (например, P1F), оборотная буквой R (например, P3R)\n144 2 4F 3FP0F P1F P2F P3F P0R P1R\n3\nНа иллюстрации, письмо изображается со стороны (лицевая сторона изначально «смотрит» влево, а сгибы изображены как точки). Лицевая сторона обозначается тонкой линией, оборотная – толстой линией, цифрами обозначены точки сгибания, стрелками подписаны некоторые возможные варианты сгибания письма. Размеры сгиба и толщину листа считаем нулевыми, все сгибания выполняются ровно на 180°. Фрагменты после сгибания плотно прилегают друг к другу (в примере просветы после сгибания изображены только для наглядности) – так, во втором примере точки 1 и 3R совмещаются, и фрагмент P0 может обернуться вокруг совмещённых точек. В третьем примере точки 1 и 3 также совмещаются, но при этом фрагмент P0 не может повернуться вокруг 1 – так как ему мешают фрагменты P2, P3. Если Бендер попытается сделать такой сгиб, то такое письмо будет скомкано и выкинуто – это уже работа для уборщика Скраффи.\nВходные данные\nВходной файл INPUT.TXT содержит одну строку данных, которая начинается с двух чисел: номер наибольшего фрагмента n, 1 ≤ n ≤ 20 (таким образом, письмо имеет n точек сгиба, и n+1 фрагментов с номерами P0, P1 … Pn), количество проделанных сгибаний 1 ≤ m ≤ n (сгибы могут быть сделаны не в каждой возможной точке). Далее выписаны наблюдаемые сгибания через пробел, в порядке их выполнения. Если сгибать бумагу в одной точке несколько раз, то ее прочность теряется, поэтому в каждой точке сгиб производится максимум один раз.\nВыходные данные\nВ выходной файл OUTPUT.TXT выведите перечисление всех видимых фрагментов, в порядке возрастания их номеров, сначала фрагменты стороной F, потом стороны R. Либо слово SCRUFFY, если письмо было скомкано.",
    "complexity": 75,
    "memory": 16000,
    "time": 1000,
    "examples": [
      {
        "input": "3 3 2F 3R 1R",
        "output": "P0R P3R"
      },
      {
        "input": "3 3 2F 3R 1F",
        "output": "P0F P1F"
      },
      {
        "input": "3 2 2R 1R",
        "output": "SCRUFFY"
      },
      {
        "input": "4 2 4F 3F",
        "output": "P0F P1F P2F P3F P0R P1R"
      }
    ]
  },
  {
    "id": 774,
    "name": "Шляпа",
    "description": "Фокусник Аркадий Великолепный разочаровался в доходности извлечения из цилиндра кроликов и голубей и решил заняться контрабандой драгоценностей. Его шляпа-цилиндр, высотой H и радиусом основания R, поможет ему в этом, ибо ни один таможенник не сможет обнаружить там ничего, кроме кучки заячьего помета. Перед Аркадием, однако, встал другой вопрос: что и куда везти? Разные драгоценности пользуются разной популярностью в разных городах; кроме того, драгоценности различаются между собой по размеру упаковки. Ценности хранятся в кубических контейнерах, которые размещаются в цилиндре так, что их дно параллельно дну цилиндра. Контейнеры могут помещаться друг на друга, образуя слои, причем в одном слое могут находиться только контейнеры с одинаковой длиной ребра. Из-за чисто технических ограничений более пяти контейнеров в один слой поместить нельзя. Контейнеры не должны выступать за границы цилиндра.\nNOUTPUT.TXT6023 3 1 2\n1 0.5 1\n10 10 10\n20 20 20\n30 30 30600600[Лучшие попытки]\nАркадий выяснил, какой длины ребро у контейнеров всех типов драгоценностей, и по какой цене можно продать те или иные драгоценности в тех или иных городах. Для начала фокусник решил совершить поездку в один город, взяв с собой драгоценности одного типа. Помогите ему рассчитать прибыль от сделки при такой упаковке цилиндра контейнерами, когда помещается их максимально возможное количество.\ni\nВходные данныеij\nПервая строка входного файла INPUT.TXT содержит четыре числа, разделенных пробелами: N – количество типов драгоценностей (1 ≤ N ≤ 10), M – количество городов (1 ≤ M ≤ 10), действительные числа R (1.0 ≤ R ≤ 100.0) и H (1.0 ≤ H ≤ 100.0).\nij\nВо второй строке расположены N действительных чисел a1, a2, …, aN – длина ребер контейнеров каждого типа драгоценностей, 0.5 ≤ ai ≤ 100.0. Далее во входном файле M строк – по одной для каждого города. Каждая из строк содержит N целых чисел Qij – стоимость драгоценностей каждого типа в текущем городе (0 ≤ Qij ≤ 1000).\nВсе вещественные числа во входных данных имеют не более 6 значащих разрядов.\nВыходные данные\nВ выходной файл OUTPUT.TXT выведите максимальную прибыль, которую фокусник может извлечь в текущей ситуации.",
    "complexity": 59,
    "memory": 16000,
    "time": 1000,
    "examples": [
      {
        "input": "2 2 1 2\n\n1 2\n\n10 20\n\n30 40",
        "output": "60"
      },
      {
        "input": "3 3 1 2\n\n1 0.5 1\n\n10 10 10\n\n20 20 20\n\n30 30 30",
        "output": "600"
      }
    ]
  },
  {
    "id": 754,
    "name": "Три толстяка",
    "description": "Три толстяка решили поспорить: кто из них самый тяжелый. После взвешивания оказалось, что их масса соответственно M1, M2 и M3 килограмм. Считается, что масса толстяка должна быть не менее 94 и не более 727 килограмм.\n33OUTPUT.TXT2142100 100 100100100Error[Лучшие попытки]\nПомогите определить массу самого тяжелого из них, либо выяснить, что была допущена ошибка при взвешивании.\n393 500 1000Error[Решение]\nВходные данные\nВходной файл INPUT.TXT содержит три целых числа M1, M2 и M3, разделенные пробелом. Все числа целые и не превосходят 10 000 по абсолютной величине.\nВыходные данные\nВ выходной файл OUTPUT.TXT выведите массу самого тяжелого толстяка в случае корректного взвешивания, либо слово «Error» в противном случае.",
    "complexity": 7,
    "memory": 16000,
    "time": 1000,
    "examples": [
      {
        "input": "98 106 214",
        "output": "214"
      },
      {
        "input": "100 100 100",
        "output": "100"
      },
      {
        "input": "93 500 1000",
        "output": "Error"
      }
    ]
  },
  {
    "id": 755,
    "name": "Сбор земляники",
    "description": "Маша и Миша собирали землянику. Маше удалось сорвать X ягод, а Мише – Y ягод. Поскольку ягода была очень вкусной, то ребята могли какую-то часть ягод съесть. По нашим подсчетам вместе они съели Z ягод.\nOUTPUT.TXT4212 13 52020Impossible[Лучшие попытки]\nТребуется определить: сколько ягод ребята собрали в результате, при этом следует проверить, не ошиблись ли мы в расчетах, подсчитывая количество съеденных ягод (их не должно было получиться больше, чем сорванных ягод).\n32 5 9Impossible[Решение]\nВходные данные\nВходной файл INPUT.TXT содержит три натуральных числа X, Y и Z, не превышающих 1000. Все числа расположены в первой строке файла и разделены пробелом.\nВыходные данные\nВ выходной файл OUTPUT.TXT выведите количество собранных ягод, если наши подсчеты оказались правдоподобными, либо слово «Impossible» в противном случае.",
    "complexity": 6,
    "memory": 16000,
    "time": 1000,
    "examples": [
      {
        "input": "3 2 1",
        "output": "4"
      },
      {
        "input": "12 13 5",
        "output": "20"
      },
      {
        "input": "2 5 9",
        "output": "Impossible"
      }
    ]
  },
  {
    "id": 752,
    "name": "2-3 Дерево",
    "description": "2-3 дерево — элегантная структура данных, изобретенная Джоном Хопкрофтом. Она предназначена для использования с той же целью, что и двоичное дерево поиска. 2-3 дерево представляет собой дерево с корнем, которое обладает следующими свойствами:\nOUTPUT.TXT227 100000000033[Лучшие попытки]\nкорень и каждая внутренняя вершина имеет либо 2 либо 3 ребенка;\nглубина всех листьев одна и та же.\nЕдинственное исключение — это когда дерево содержит ровно одну вершину. В этом случае корень дерева является и листом, и поэтому не имеет детей. Основная суть приведенных свойств в том, что дерево с L листьями имеет высоту O(log L).\nВообще говоря, может существовать несколько 2-3 деревьев с L листьями. Например, на следующем рисунке показаны два возможных дерева с 6 листьями.\nПо заданному числу L найдите количество различных 2-3 деревьев с L листьями. Так как ответ может быть довольно большим, выведите его по модулю R.\nВходные данные\nВходной файл INPUT.TXT содержит два целых числа: L и R (1 ≤ L ≤ 5 000, 1 ≤ R ≤ 109).\nВыходные данные\nВ выходной файл OUTPUT.TXT выведите одно число – количество различных 2-3 деревьев, имеющих ровно L листьев, взятое по модулю R.",
    "complexity": 61,
    "memory": 16000,
    "time": 1000,
    "examples": [
      {
        "input": "6 1000000000",
        "output": "2"
      },
      {
        "input": "7 1000000000",
        "output": "3"
      }
    ]
  },
  {
    "id": 599,
    "name": "Телешоу",
    "description": "В новом интеллектуальном телешоу участнику, проходящему в суперфинал, предлагается следующая игра: на каждом из n секторов большого барабана записывается буква английского алфавита Li. После минуты на размышления игрок указывает одну из позиций на барабане i. Его выигрыш вычисляется по такому правилу: для каждой позиции j меньшее из расстояний по и против часовой стрелке от i до j, измеренное в секторах, умножается на абсолютную величину разности номеров в алфавите букв Li и Lj , после чего все такие величины суммируются.\njOUTPUT.TXT553[Лучшие попытки]\nА Вы можете написать программу, находящую способ получения наибольшего выигрыша?\nВходные данные\nПервая строка входного файла INPUT.TXT содержит натуральное число n (1 ≤ n ≤ 100000) - размер барабана. Во второй строке задаются разделенные пробелами строчные английские буквы, записанные на барабане.\nВыходные данные\nВ первой строке выходного файла OUTPUT.TXT выведите наибольший выигрыш, который можно получить при заданном расположении букв на барабане. Во второй строке выведите номер какого-нибудь из секторов, на который игрок должен для этого указать.",
    "complexity": 66,
    "memory": 16000,
    "time": 1000,
    "examples": [
      {
        "input": "4\nr e a r",
        "output": "55\n3"
      }
    ]
  },
  {
    "id": 753,
    "name": "Различные слова",
    "description": "Дана строка S, состоящая из N символов. Назовем ее подстрокой Sij строку с i-го по j-й символ (i ≤ j). Ваша задача — посчитать количество различных подстрок заданной строки.\nOUTPUT.TXT62aaa33[Лучшие попытки]\nВходные данные\nВходной файл INPUT.TXT содержит одну непустую строку S, состоящую из маленьких английских букв, длиной не более чем 1024 символа.\nВыходные данные\nВ выходной файл OUTPUT.TXT выведите одно число — количество различных подстрок строки S.",
    "complexity": 52,
    "memory": 64000,
    "time": 1000,
    "examples": [
      {
        "input": "abc",
        "output": "6"
      },
      {
        "input": "aaa",
        "output": "3"
      }
    ]
  },
  {
    "id": 756,
    "name": "Рыболовная сеть",
    "description": "OUTPUT.TXT122 322[Лучшие попытки]\nБраконьер Петрович использует распространенный незаконный способ рыбалки с использованием рыболовной сети. Но проблема в том, что крупная рыба часто рвет сеть и приходится ее восстанавливать. Однажды Петрович задумался: какое максимальное количество повреждений может быть в рыболовной сети, таких, что сеть не будет разорвана на части? Вам предстоит помочь ему в вычислениях.\n[Решение]\nСеть имеет прямоугольную форму размером M×N узлов, все смежные узлы соединены леской. Под разрывом будем понимать только единичный обрыв лески между двумя смежными узлами сети.\nНапример, если сеть имеет размер 2х2, то внешний вид сети будет напоминать квадрат, где допустим только один разрыв в одном из четырех возможных соединений, т.к. любые 2 разрыва приведут к разделению сети на 2 части.\nВходные данные\nПервая строка входного файла INPUT.TXT содержит два целых числа M и N через пробел – размеры рыболовной сети (1 ≤ M, N ≤ 10 000).\nВыходные данные\nВ выходной файл OUTPUT.TXT выведите максимальное число разрывов заданной сети, которые не приведут к распадению рыболовной снасти Петровича.",
    "complexity": 10,
    "memory": 16000,
    "time": 1000,
    "examples": [
      {
        "input": "2 2",
        "output": "1"
      },
      {
        "input": "2 3",
        "output": "2"
      }
    ]
  },
  {
    "id": 600,
    "name": "Распознавание языка",
    "description": "Важным понятием теории формальных грамматик и автоматов является формальный язык. Неформально его можно определить как некоторое множество слов, где под словом понимается некоторая строка из символов.\nnOUTPUT.TXTYESNOYES220000111122220012NOYESNOYES[Лучшие попытки]\nВ этой задаче необходимо проверить, принадлежит ли данное слово языку {0n1n2n, n ≥ 1}. В этот язык входят те и только те слова, которые имеют такую структуру: в них нулей столько же, сколько единиц, а единиц - столько же, сколько и двоек. При этом любой ноль находится ближе к началу слова, чем любая единица, а любая единица находится ближе к началу слова, чем любая двойка. Например, слово 001122 принадлежит этому языку, а слово 0000111122220 - не принадлежит.\nВходные данные\nПервая строка входного файла INPUT.TXT содержит целое положительное число n (n ≤ 10) – количество слов, которые надо проанализировать. Далее идут n строк, каждая из которых содержит по одному слову. Слова имеют длину не более тридцати тысяч символов и состоят только из нулей, единиц и двоек. Каждое из слов состоит хотя бы из одного символа.\nВыходные данные\nВыходной файл OUTPUT.TXT должен содержать ровно n строк. Для каждого слова из входного файла выведите по одной строке, содержащей слово YES, если оно принадлежит указанному выше языку, и NO - иначе.",
    "complexity": 28,
    "memory": 16000,
    "time": 1000,
    "examples": [
      {
        "input": "3\n001122\n00011122222\n000111222",
        "output": "YES\nNO\nYES"
      },
      {
        "input": "2\n0000111122220\n012",
        "output": "NO\nYES"
      }
    ]
  },
  {
    "id": 758,
    "name": "Веревочный мост",
    "description": "Однажды N путешественников решили ночью пересечь по веревочному мосту быструю горную речку. Без освещения перейти мост невозможно. К счастью, у одного из них оказался с собой фонарик. Известно, что мост выдерживает только двоих, а скорости людей могут различаться. Если мост пересекают два человека с разной скоростью, то они вынуждены двигаться со скоростью самого медленного из них. Скорость движения каждого из путников известна.\nOUTPUT.TXT20245 10 20 256060[Лучшие попытки]\nПомогите путешественникам как можно быстрее перебраться через мост. Требуется написать программу, определяющую минимальное время, которое потребуется для такого перехода. Например, если N=4, а время, требуемое для перехода по мосту для каждого, составляет 5, 10, 20 и 25 минут соответственно, то наименьшее время, требуемое для пересечения моста, составит ровно 60 минут.\nВходные данные\nВ первой строке входного файла INPUT.TXT содержится натуральное число N – количество путешественников (N ≤ 105). Во второй строке располагаются N натуральных чисел – скорости всех путников, разделенные пробелом и не превосходящие 106. Здесь под скоростью человека понимается время в минутах, необходимое для перехода через мост.\nВыходные данные\nВ выходной файл OUTPUT.TXT выведите одно целое число – минимально возможное время, необходимое путникам для пересечения моста.",
    "complexity": 58,
    "memory": 16000,
    "time": 1000,
    "examples": [
      {
        "input": "2\n10 20",
        "output": "20"
      },
      {
        "input": "4\n5 10 20 25",
        "output": "60"
      }
    ]
  },
  {
    "id": 602,
    "name": "Точки на прямой",
    "description": "На прямой отмечено N точек. Требуется найти такой отрезок длины L, на котором лежат M из отмеченных точек (M ≥ 2), что величина L/M минимальна. Считается, что точки, совпадающие с одним из концов отрезка, лежат на нем.\niOUTPUT.TXT-2 -1[Лучшие попытки]\nВходные данныеj\nВходной файл INPUT.TXT содержит количество точек N (2 ≤  N ≤  10000). На второй строке записаны координаты этих точек Xi - целые числа, разделенные пробелами. При этом |Xi| ≤ 30000 и Xi \u003c Xj при i \u003c j.\nВыходные данные\nВ выходной файл OUTPUT.TXT выведите координаты начала и конца найденного отрезка A и B (A \u003c B). Если решений несколько, выведите любое.",
    "complexity": 32,
    "memory": 16000,
    "time": 1000,
    "examples": [
      {
        "input": "3\n-2 -1 1",
        "output": "-2 -1"
      }
    ]
  },
  {
    "id": 759,
    "name": "Али-Баба",
    "description": "Али-Баба стоял у входа в пещеру. «Сим-Сим, открой дверь!» – сказал он. И дверь распахнулась. Али-Баба зашел внутрь и обомлел – пещера была усыпана сокровищами. Золото, драгоценности, дорогое оружие и посуда, пещера буквально сверкала!\nOUTPUT.TXT724 20 3 -1 -233[Лучшие попытки]\nНо Али-Баба радовался недолго. Поразмыслив, он понял, что может унести \nс собой не более M предметов, в то время как в пещере находится целых N предметов. Али-Баба внимательно рассмотрел каждый предмет и оценил его стоимость. К своему удивлению Али-Баба обнаружил в пещере также бесполезные, и даже вредные вещи, ценность которых сомнительна. Естественно, что Али-Баба хочет взять с собой такие предметы, чтобы их суммарная ценность была максимальна. Помогите ему найти эту сумму.\n[Решение]\nВходные данные\nВ первой строке входного файла INPUT.TXT находятся два числа, разделенные пробелом: N – количество предметов в пещере (1 ≤ N ≤ 1000), M – максимальное количество предметов, которые Али-Баба может унести с собой (0 ≤ M ≤ N). Во второй строке располагаются N целых чисел, разделенных пробелами. Каждое такое число Ci означает стоимость i-го сокровища (1 ≤ i ≤ N,  -1000 ≤ Ci ≤ 1000).\nВыходные данные\nВ выходной файл OUTPUT.TXT выведите единственное целое число – максимальную суммарную стоимость сокровищ, которые Али-Баба может унести из пещеры.",
    "complexity": 22,
    "memory": 16000,
    "time": 1000,
    "examples": [
      {
        "input": "4 2\n2 3 1 4",
        "output": "7"
      },
      {
        "input": "4 2\n0 3 -1 -2",
        "output": "3"
      }
    ]
  },
  {
    "id": 601,
    "name": "Цветной лабиринт",
    "description": "В одном из парков одного большого города недавно был организован новый аттракцион Цветной лабиринт. Он состоит из n комнат, соединенных m двунаправленными коридорами. Каждый из коридоров покрашен в один из ста цветов, при этом от каждой комнаты отходит не более одного коридора каждого цвета. При этом две комнаты могут быть соединены любым количеством коридоров.\nOUTPUT.TXT323 2\n1 2 10\n2 3 5\n5\n5 10 10 10 10INCORRECTINCORRECTINCORRECT[Лучшие попытки]\nЧеловек, купивший билет на аттракцион, оказывается в комнате номер один. Кроме билета, он также получает описание пути, по которому он может выбраться из лабиринта. Это описание представляет собой последовательность цветов c1…ck. Пользоваться ей надо так: находясь в комнате, надо посмотреть на очередной цвет в этой последовательности, выбрать коридор такого цвета и пойти по нему. При этом если из комнаты нельзя пойти по коридору соответствующего цвета, то человеку приходится дальше самому выбирать, куда идти.\n33 2\n1 2 10\n1 3 5\n4\n10 10 10 5INCORRECT\nВ последнее время в администрацию парка стали часто поступать жалобы от заблудившихся в лабиринте людей. В связи с этим, возникла необходимость написания программы, проверяющей корректность описания и пути, и, в случае ее корректности, сообщающей номер комнаты, в которую ведет путь.\nОписание пути некорректно, если на пути, который оно описывает, возникает ситуация, когда из комнаты нельзя пойти по коридору соответствующего цвета.\nВходные данные\nПервая строка входного файла INPUT.TXT содержит два целых числа n (1 ≤ n ≤ 10000) и m (1 ≤ m ≤ 100000) - соответственно количество комнат и коридоров в лабиринте. Следующие m строк содержат описания коридоров. Каждое описание содержит три числа u (1 ≤ u ≤ n), v (1 ≤ v ≤ n), c (1 ≤ c ≤ 100) - соответственно номера комнат, соединенных этим коридором, и цвет коридора. Следующая, (m+2)-ая строка входного файла содержит длину описания пути - целое число k (0 ≤ k ≤ 100000). Последняя строка входного файла содержит k целых чисел, разделенных пробелами, - описание пути по лабиринту.\nВыходные данные\nВ выходной файл OUTPUT.TXT выведите строку INCORRECT, если описание пути некорректно, иначе выведите номер комнаты, в которую ведет описанный путь. Помните, что путь начинается в комнате номер один.",
    "complexity": 38,
    "memory": 16000,
    "time": 1000,
    "examples": [
      {
        "input": "3 2\n\n1 2 10\n\n1 3 5\n\n5\n\n10 10 10 10 5",
        "output": "3"
      },
      {
        "input": "3 2\n\n1 2 10\n\n2 3 5\n\n5\n\n5 10 10 10 10",
        "output": "INCORRECT"
      },
      {
        "input": "3 2\n\n1 2 10\n\n1 3 5\n\n4\n\n10 10 10 5",
        "output": "INCORRECT"
      }
    ]
  },
  {
    "id": 859,
    "name": "Сумма от 1 до N",
    "description": "Требуется найти сумму от 1 до N.\nOUTPUT.TXT15[Лучшие попытки]\nВходные данные\nВ единственной строке входного файла INPUT.TXT записано натуральное число N, не превышающее 10100.\nВыходные данные\nВ единственную строку выходного файла OUTPUT.TXT выведите одно целое число – ответ на задачу.",
    "complexity": 50,
    "memory": 16000,
    "time": 1000,
    "examples": [
      {
        "input": "5",
        "output": "15"
      }
    ]
  },
  {
    "id": 757,
    "name": "Спирт",
    "description": "Каждому школьнику из курса органической химии известна формула молекулы этилового спирта – C2H5(OH). Откуда видно, что молекула спирта состоит из двух атомов углерода (C), шести атомов водорода (H) и одного атома кислорода (O). \nOUTPUT.TXT1210 5 12003[Лучшие попытки]\nПо заданному количеству атомов каждого из описанных выше элементов требуется определить максимально возможное количество молекул спирта, которые могут образоваться в процессе их соединения.\n318 35 33[Решение]\nВходные данные\nПервая строка входного файла INPUT.TXT содержит 3 натуральных числа: C, Н и O – количество атомов углерода, водорода и кислорода соответственно.  Все числа разделены пробелом и не превосходят 1018.\nВыходные данные\nВ выходной файл OUTPUT.TXT выведите максимально возможное число молекул спирта, которые могут получиться из  атомов, представленных во входных данных.",
    "complexity": 10,
    "memory": 16000,
    "time": 1000,
    "examples": [
      {
        "input": "2 6 1",
        "output": "1"
      },
      {
        "input": "10 5 12",
        "output": "0"
      },
      {
        "input": "18 35 3",
        "output": "3"
      }
    ]
  },
  {
    "id": 860,
    "name": "Паркет",
    "description": "Недавно бизнесмен Борис купил себе новую квартиру в элитной новостройке. На данный момент он решил уложить весь пол в квартире паркетом. Дизайнер посоветовал ему уложить пол квадратными участками, Борису понравилась эта идея, но он потребовал узнать, сколькими способами можно это сделать. Пол в квартире должен быть весь уложен паркетом. Квадратные участки паркета не должны пересекаться или накладываться, а так же выходить на пределы квартиры. Куски паркета располагаются строго на полу параллельно стенам квартиры.\nOUTPUT.TXT623 3\n.#.\n...\n.#.111[Лучшие попытки]\nВходные данные31 1#1\nВ первой строке входного файла INPUT.TXT содержатся два числа N и M - размеры квартиры (1 ≤ N×M ≤ 100). Далее следуют N строк по M символов в каждой: карта квартиры. Символ '.' обозначает пол, а '#' - стену.\nВыходные данные\nВ единственную строку выходного файла OUTPUT.TXT выведете количество возможных укладок паркета.",
    "complexity": 68,
    "memory": 16000,
    "time": 1000,
    "examples": [
      {
        "input": "3 3\n\n...\n\n...\n\n...",
        "output": "6"
      },
      {
        "input": "3 3\n\n.#.\n\n...\n\n.#.",
        "output": "1"
      },
      {
        "input": "1 1\n#",
        "output": "1"
      }
    ]
  },
  {
    "id": 604,
    "name": "Кактусы",
    "description": "Вершинный кактус - это связный неориентированный граф, каждая вершина которого лежит не более, чем на одном простом цикле.\nOUTPUT.TXT12[Лучшие попытки]\nДерево можно превратить в кактус, добавив в него несколько ребер (поскольку дерево само является кактусом, то можно не добавлять ребер вообще). Вообще говоря, может существовать несколько способов превратить дерево в кактус. Количество способов сделать это назовем кактусастостью дерева.\nНапример, кактусастость дерева, изображенного на картинке слева, равна 12. Двенадцать кактусов, в которые оно может быть превращено, изображены справа.\nДля заданного дерева требуется найти его кактусастость.\nВходные данные\nПервая строка входного файла INPUT.TXT содержит одно целое число n - количество вершин в дереве (1 ≤ n ≤ 200). Следующие n-1 строк задают ребра дерева.\nВыходные данные\nВ выходной файл OUTPUT.TXT выведите единственное целое число - кактусастость заданного дерева.",
    "complexity": 78,
    "memory": 16000,
    "time": 1000,
    "examples": [
      {
        "input": "6\n\n1 3\n\n2 3\n\n3 4\n\n4 5\n\n4 6",
        "output": "12"
      }
    ]
  },
  {
    "id": 603,
    "name": "Поиск",
    "description": "Обычно программы, предоставляющие возможность поиска заданных строк в текстовых файлах, недостаточно гибко обрабатывают различные пробельные символы. Например, если в некотором тексте слова «Internet» и «olympiad» разделены переводом строки, словосочетание «Internet olympiad» чаще всего не будет обнаружено в этом месте. В данной задаче пробельными символами мы будем считать пробелы, символы табуляции (код символа 9), а так же переводы строк. Любую последовательность идущих подряд непробельных символов будем называть словом.\nOUTPUT.TXT@Internet Olympiads\nEveryone is welcome to\nparticipate in @internet\nolympiads.\nJury of\n@internet olympiads[Лучшие попытки]\nВаша программа должна производить обработку одного запроса на поиск словосочетания в тексте. Словосочетание будет задано как последовательность слов, состоящих из цифр и строчных и прописных букв английского алфавита, каждые два из которых разделены пробелом. Будем считать, что некоторая последовательность символов, первый и последний из которой непробельные, является вхождением этого словосочетания в текст, если после замены каждого блока пробельных символов из этой последовательности на один пробел она совпадет с заданным словосочетанием с точностью до регистра букв. Для представления ответа перед каждым вхождением словосочетания в исходный текст следует поставить символ «@».\nВходные данные\nПервая строка входного файла INPUT.TXT, заканчивающаяся переводом строки, задает запрос. Длина словосочетания не превосходит 100 символов. Последующие строки описывают сам текст, размер которого не превосходит 2000 символов. Файл заканчивается переводом строки.\nВыходные данные\nВ выходной файл OUTPUT.TXT выведите результат применения к тексту описанной процедуры. Он должен отличаться от исходного текста только добавлением символов «@».",
    "complexity": 48,
    "memory": 16000,
    "time": 1000,
    "examples": [
      {
        "input": "internet olympiad\n\nInternet Olympiads\n\nEveryone is welcome to\n\nparticipate in internet\n\nolympiads.\n\nJury of\n\ninternet olympiads",
        "output": "@Internet Olympiads\n\nEveryone is welcome to\n\nparticipate in @internet\n\nolympiads.\n\nJury of\n\n@internet olympiads"
      }
    ]
  },
  {
    "id": 1000,
    "name": "Упаковка чисел",
    "description": "При передаче данных по сети важно их эффективно кодировать, чтобы лучше использовать пропускную способность канала. Мы опишем процедуру декодирования чисел при одном эффективном способе их кодирования. Этот способ использует переменную длину кодов, для обеспечения единственности декодирования ни один код числа не является префиксом кода другого числа. Вы же должны реализовать процедуру оптимального кодирования.\n63OUTPUT.TXT00\n01\n02\n03\n8064\n81f4\ncf4240\n7f\nbf9c[Лучшие попытки]\nМетод применим для кодирования целых чисел от −263 до 263−1 (тип long в Java, int64 в Дельфи, __int64 в C++). Упакованное число занимает от 1 до 9 байт, в зависимости от своего значения.\nДекодирование происходит следующим образом. Сначала рассматривается первый байт числа. Просматривая его биты от старшего к младшему, найдем первый ноль. Пусть q – количество просмотренных при этом единиц (если первый бит равен 0xff, то q=8). Число q означает, сколько следующих байтов относятся к декодируемому числу. Если\tq=8, то эти байты – стандартная восьмибайтная запись числа, причем старшие байты идут сначала.\nВ противном случае выполним следующее. Если q+2-й бит первого байта равен нулю (биты нумеруются с единицы, сначала идет старший бит, если q=7, то рассматривается старший бит второго байта) то старшие единицы первого байта заменяются на нули, и число дополняется нулевыми байтами до размера 8 байтов. Иначе (если соответствующий бит равен единице) q+1-й бит (который всегда равен нулю) заменяется на единицу, число же дополняется слева байтами 0xff до восьми байтов. В обоих случаях получается стандартная восьмибайтная запись числа, причем старшие байты идут сначала.\nВам заданы несколько целых чисел, закодируйте каждое из них таким образом, чтобы длина закодированного числа была минимальной возможной, и оно декодировалось в исходное число.\nВходные данные\nПервая строка входного файла INPUT.TXT содержит n – количество тестовых примеров (1 ≤ n ≤ 104). Следующие n строк содержат по одному числу в интервале между -263 и 263-1 включительно.\nВыходные данные\nВ выходной файл OUTPUT.TXT выведите n строк, каждая строка должна содержать закодированную версию соответствующего числа, записанную как последовательность шестнадцатеричных цифр, старшие байты должны идти сначала. Используйте строчные буквы английского алфавита.",
    "complexity": 65,
    "memory": 16000,
    "time": 1000,
    "examples": [
      {
        "input": "9\n\n0\n\n1\n\n2\n\n3\n\n100\n\n500\n\n1000000\n\n-1\n\n-100",
        "output": "00\n\n01\n\n02\n\n03\n\n8064\n\n81f4\n\ncf4240\n\n7f\n\nbf9c"
      }
    ]
  },
  {
    "id": 760,
    "name": "Транспорт",
    "description": "Все автовладельцы рано или поздно встречаются с инспекторами ГИБДД. Ваша задача состоит в том, чтобы рассчитать минимальное время прохождения автомобилем прямого участка дороги, на котором стоят инспекторы. Известно, что на данном участке инспекторы останавливают все проезжающие мимо автомобили. Примем следующие допущения: автомобили являются материальными точками, которые могут мгновенно останавливаться или набирать максимальную скорость. Автомобиль начинает свой путь в точке 0 и заканчивает его в точке L.\niOUTPUT.TXT60.0022 78 1502 10 78 1126.38126.38[Лучшие попытки]\nВходные данныеi[Решение]\nПервая строка входного файла INPUT.TXT содержит три числа: N – количество инспекторов (0 ≤ N ≤ 30), V – максимальная скорость автомобиля (км/ч) и L – длина участка дороги (км) (1 ≤ V, L ≤ 200). Вторая строка содержит N пар чисел xi  – расстояние от точки 0 до инспектора (0 ≤ xi ≤ L) и ti – время (мин), на которое он останавливает машину (1 ≤ ti ≤ 10). Все инспектора стоят в разных точках. Все числа во входных данных целые.\nВыходные данные\nВ выходной файл OUTPUT.TXT выведите время преодоления участка дороги автомобилем в минутах с точностью до двух знаков после запятой (вещественное число с ровно двумя цифрами после запятой).",
    "complexity": 24,
    "memory": 16000,
    "time": 1000,
    "examples": [
      {
        "input": "3 60 45\n0 5 25 5 40 5",
        "output": "60.00"
      },
      {
        "input": "2 78 150\n2 10 78 1",
        "output": "126.38"
      }
    ]
  },
  {
    "id": 861,
    "name": "Осколки",
    "description": "На Землю надвигается страшная угроза, к нам летит облако из N огромных астероидов. Известно только то, что все они одинакового размера. У учёных есть ракеты, способные уничтожить астероиды, каждая такая ракета характеризуется зарядом m – натуральным числом от 1 до N. Но, к сожалению, неизвестно, как каждая из ракет поведёт себя при столкновении с астероидом, поэтому было принято решение запустить по одной ракете каждого вида. И только после столкновения стало известно, что ракета с зарядом m после уничтожения астероида образует осколки в количестве, равном наибольшему общему делителю чисел m и N. Помогите узнать, сколько осколков упадёт на Землю, у Вас совсем мало времени!\nOUTPUT.TXT5261515[Лучшие попытки]\nВходные данные\nВ единственной строке входного файла INPUT.TXT содержится натуральное число N – количество запущенных ракет и взорванных ими астероидов (1 ≤ N ≤ 1018).\nВыходные данные\nВ выходной файл OUTPUT.TXT выведите количество осколков, которые упадут на Землю.",
    "complexity": 88,
    "memory": 16000,
    "time": 1000,
    "examples": [
      {
        "input": "3",
        "output": "5"
      },
      {
        "input": "6",
        "output": "15"
      }
    ]
  },
  {
    "id": 605,
    "name": "Дартс",
    "description": "OUTPUT.TXT7\n1 D1 D1\n1 2 D1\n1 D2\nD1 1 D1\nT1 D1\n2 1 D1\n3 D1[Лучшие попытки]\nИгра в дартс очень популярна в Великобритании и Голландии. В игре принимают участие несколько игроков. Они по очереди бросают в мишень по три дротика.\nВ начале игры каждый игрок имеет некоторое количество очков, обычно 501. За каждое попадание дротика в мишень сумма игрока уменьшается на некоторое число, в зависимости от того, в какую часть мишени он попал. Первый, кто достигает нуля очков, считается победителем.\nВнешний вид мишени показан на рисунке справа. Она разделена на 20 секторов, расположенных вокруг небольшого центрального круга. Этот круг, в свою очередь, делится на внутреннюю и внешнюю часть (иногда внутренняя часть называется «яблочко»). Попадание во внешнюю часть центрального круга оценивается 25 очков, а в «яблочко» - вдвое больше, то есть в 50 очков. Стоимость сектора равняется числу, которое на нем написано. Кроме того на мишени выделены два кольца - внешнее и внутреннее. Попадание в них оценивается соответственно в два и в три раза больше, чем в оставшуюся часть соответствующего сектора.\nСуществуют дополнительные правила для последней серии бросков, в которой игрок должен достичь нуля очков. В этой серии игроку придется бросить в мишень от одного до трех дротиков. Игрок должен достичь в точности нуля очков, получение отрицательной суммы считается ошибкой. Последний дротик должен быть «двойным», то есть попасть во внешнее кольцо какого-либо сектора или в «яблочко» - (оно считается удвоением внешней часть центрального круга).\nНапример, один из правильных способов закончить игру, имея 50 очков - бросить дротики в «18» и «D16».\nСпособы «D20», «10», или «20», «T10» не подходят: последний бросок не является удвоенным. Еще один возможный способ победить в этом случае - просто попасть в «яблочко» («Bull»). По количеству оставшихся очков, найдите все способы правильно закончить игру.\nВходные данные\nВходной файл INPUT.TXT содержит число n - количество оставшихся очков (1 ≤ n ≤ 200).\nВыходные данные\nВ первой строке выходного файла OUTPUT.TXT выведите k - количество способов правильно завершить партию. Каждая из следующих k строк должна содержать описание одного правильного способа. При этом число от 1 до 20 отвечает попаданию в соответствующий сектор. Буква «D» перед числом обозначает попадание во внешнее (удваивающее) кольцо, а «T» - во внутреннее (утраивающее). Внешняя часть центрального круга обозначается как «25», а «яблочко» (bull eye) - словом «Bull».",
    "complexity": 38,
    "memory": 16000,
    "time": 1000,
    "examples": [
      {
        "input": "5",
        "output": "7\n\n1 D1 D1\n\n1 2 D1\n\n1 D2\n\nD1 1 D1\n\nT1 D1\n\n2 1 D1\n\n3 D1"
      }
    ]
  },
  {
    "id": 863,
    "name": "Антиарифметическая перестановка",
    "description": "",
    "complexity": 52,
    "memory": 16000,
    "time": 1000,
    "examples": [
      {
        "input": "5",
        "output": "3 1 0 4 2"
      }
    ]
  },
  {
    "id": 862,
    "name": "Домашняя работа",
    "description": "Витя наконец-то прошёл последний уровень своей любимой игры \"Прострели мне колено\". На часах было уже полдвенадцатого, а он до сих пор не сделал домашнюю работу по математике. Прочитав задание, Витя сказал: \"О, какое же оно скучное, посчитать сумму прогрессии... Вот посчитать сумму остатков - это весело!\". Витя написал в тетрадке \nOUTPUT.TXT14210 199[Лучшие попытки]\nи... задание было настолько весёлым, что он уснул через 5 минут прямо на столе. Завтра ему с утра нужно опять в школу, и опять он пойдёт с не сделанной домашней работой. Пока он спит, посчитайте для него ответ, на записанную им сумму, чтобы с утра у него было хорошее настроение.\nВходные данные\nВ единственной строке входного файла INPUT.TXT содержаться два числа n и m - числа, записанные Витей. Оба числа натуральные и не превосходят миллиарда.\nВыходные данные\nВ выходной файл OUTPUT.TXT выведете единственное число - ответ на задачу.",
    "complexity": 51,
    "memory": 16000,
    "time": 1000,
    "examples": [
      {
        "input": "5 5",
        "output": "14"
      },
      {
        "input": "10 1",
        "output": "9"
      }
    ]
  },
  {
    "id": 762,
    "name": "Взвешивание",
    "description": "Имеется N монет, не различимых на первый взгляд. Однако, одна из них фальшивая. Фальшивая монета чуть тяжелее, чем настоящая, но во всем остальном полностью идентична настоящим. Кроме того, есть чашечные весы без гирь и шкалы (по таким весам, можно определить, какая чаша тяжелее или легче, но нельзя сказать на сколько). Найти минимальное количество взвешиваний, за которое можно гарантированно определить фальшивку. \nOUTPUT.TXT12311[Лучшие попытки]\nВходные данные[Решение]\nВходной файл INPUT.TXT содержит одно натуральное число N – количество монет (2 ≤ N ≤ 109).\nВыходные данные\nВ выходной файл OUTPUT.TXT выведите минимальное количество взвешиваний.",
    "complexity": 28,
    "memory": 16000,
    "time": 1000,
    "examples": [
      {
        "input": "2",
        "output": "1"
      },
      {
        "input": "3",
        "output": "1"
      }
    ]
  },
  {
    "id": 606,
    "name": "Треугольник - 3",
    "description": "Даны длины трех отрезков. Требуется проверить: могут ли они являться сторонами невырожденного треугольника. \nOUTPUT.TXTYES21 1 5NONO[Лучшие попытки]\nВходные данные[Решение]\nПервая строка входного файла INPUT.TXT содержит 3 натуральных числа X Y Z через пробел – длины\nзаданных отрезков. Длины отрезков не превышают 1000.\nВыходные данные\nВ выходной файл OUTPUT.TXT выведите YES, если отрезки могут быть сторонами треугольника и NO в противном случае.",
    "complexity": 12,
    "memory": 16000,
    "time": 1000,
    "examples": [
      {
        "input": "3 4 5",
        "output": "YES"
      },
      {
        "input": "1 1 5",
        "output": "NO"
      }
    ]
  },
  {
    "id": 764,
    "name": "Охотник",
    "description": "Сезон охоты очень не долог, и поэтому оставшуюся часть года заядлые охотники развлекают себя тем, что стреляют по мишеням в тире. Тир представляет собой плоскость, на которой расставлены мишени. Размерами мишеней можно пренебречь и считать их точками с координатами (x, y). Также известно, что мишени сделаны из картона, поэтому за один выстрел можно поразить сразу все мишени, стоящие на линии выстрела. В начале координат стоит охотник и у него остался последний патрон. Охотник хочет использовать его эффективно – то есть за один выстрел поразить как можно больше целей. Помогите ему в этом.\nOUTPUT.TXT1221 12 2222[Лучшие попытки]\nВходные данные331 02 00 12[Решение]\nВ первой строке входного файла INPUT.TXT находится натуральное число N (N ≤ 100) – количество мишеней в тире. Далее следует N строк – описание мишеней. В (i+1)-й строке находится два целых числа x и y (-100 ≤ x, y ≤ 100) – координаты i-й мишени. Не существует двух мишеней, стоящих в одной точке, и никакая мишень не стоит в начале координат.\nВыходные данные\nВ выходной файл OUTPUT.TXT выведите максимальное количество мишеней, которое может подстрелить охотник за один выстрел.",
    "complexity": 27,
    "memory": 16000,
    "time": 1000,
    "examples": [
      {
        "input": "1\n1 1",
        "output": "1"
      },
      {
        "input": "2\n1 1\n2 2",
        "output": "2"
      },
      {
        "input": "3\n1 0\n2 0\n0 1",
        "output": "2"
      }
    ]
  },
  {
    "id": 761,
    "name": "Ковбои",
    "description": "Всем известно, что в позапрошлом веке ковбои занимались перегоном скота. Перегон скота всегда считался опасным делом. Ковбой Джон, готовясь к очередному перегону, изучал план местности. Так как местность гористая, то добраться из одного поселения в другое можно только по дорогам, возможно через другие поселения. Главной опасностью на пути были бандиты, проживающие в разных населенных пунктах, и организующие группировки для нападения на ковбоев. Чтобы их разобщить, Джон разработал гениальный план полной изоляции поселений друг от друга. \nnOUTPUT.TXT022 11 2112[Лучшие попытки]\nПосоветовавшись с напарниками, Джон пришел к выводу, что временно дороги можно вывести из строя, устроив камнепад. Под покровом ночи можно выехать из одного населения в другое, остановиться где-то посреди дороги и устроить камнепад так, чтобы по этой дороге нельзя больше проехать никому. Камни падают позади повозки, поэтому обратной дороги нет. Но зато можно ехать в другой населенный пункт, и если из него существуют дороги, то и их можно вывести из строя.\ni36 61 22 31 34 55 64 62\nСам Джон этого сделать не может, только он знает тайные тропы и должен перегонять стадо. Поэтому он решил использовать наемников. Наемники есть в любом поселении и в любом количестве, однако, за каждого из них приходится платить не малую сумму, поэтому Джон хочет потратить как можно меньше денег. Помогите Джону определить минимальное число наемников, которые смогут привести в непригодность абсолютно все дороги и изолировать все поселения.\ni+1\nВходные данные\nВ первой строке входного файла INPUT.TXT находятся два целых неотрицательных числа N (0 \u003c N \u003c 1000) – количество поселений и M (0 ≤ M ≤ 100 000) – количество дорог, их соединяющих. Далее следует M строк, содержащих описание дорог. В i-й строке находятся два натуральных числа V и U (1 ≤ V, U ≤ N) – номера поселений, которые соединяет i-я дорога. Между двумя различными поселениями существует не более одной дороги, но может существовать несколько маршрутов. Нет дорог, которые образуют петлю, исходящую из поселения и ведущую в него же, не заходя в другие поселения. Не гарантируется, что существует маршрут между любой парой поселений. Маршрутом называется такая последовательность поселений s1-s2- … -sn, что любые два последовательных поселения si и si+1 соединены дорогой.\nВыходные данные\nВ выходной файл OUTPUT.TXT выведите минимальное количество наемников, необходимое для изоляции всех поселений.",
    "complexity": 65,
    "memory": 16000,
    "time": 1000,
    "examples": [
      {
        "input": "1 0",
        "output": "0"
      },
      {
        "input": "2 1\n1 2",
        "output": "1"
      },
      {
        "input": "6 6\n1 2\n2 3\n1 3\n4 5\n5 6\n4 6",
        "output": "2"
      }
    ]
  },
  {
    "id": 765,
    "name": "Го",
    "description": "OUTPUT.TXT226\nWB.WBB\n.B.W.B\n..WW.W\nWWW..W\n..W...\nBBW...11[Лучшие попытки]\nСовсем недавно Али-Баба узнал от своего брата Касима об удивительной игре Го. В Го играют на прямоугольной доске – гобане, расчерченном вертикальными и горизонтальными линиями. Все линии пронумерованы. В игре участвуют два игрока, которые по очереди выставляют на гобан камни – специальные круглые фишки. Каждый камень ставится на незанятую точку пересечения линий доски (пересечения называют пунктами). У одного игрока – черные камни, у другого – белые. Камни одного цвета, смежные по вертикали, либо по горизонтали (но не диагонали), объединяются в группу. Одиночный камень также считается группой.\nОдин из способов набрать очки в Го – захватить камни противника. Каждый камень может иметь от двух до четырех смежных с ним пунктов (по вертикали и горизонтали, но не по диагонали). Если такой пункт не занят камнем, то он называется «дамэ». Дамэ группы – это все дамэ камней, составляющих группу. Как только оппонент своими камнями закрывает все дамэ чужой группы, то эта группа считается захваченной и снимается с доски. Если у группы осталось лишь одно дамэ, то говорят, что эта группа находится в «атари» т.е. на один шаг от захвата соперником.\nДамэ черных камней на рисунке отмечены крестиком. Группа черных из камней (1, 3) и (1, 4) имеет 4 дамэ. Группа (6, 1), (6, 2) и (6, 3) имеет одно дамэ и находится в атари. Черный камень (4, 5) также находится в атари. Помогите Али-Бабе, который всегда играет черными, определить, какие его группы находятся в атари.\nВходные данные\nПервая строка входного файла INPUT.TXT содержит целое число N – размерность игровой доски (6 ≤ N ≤ 19). Далее следует N строк по N символов каждая. Каждый символ описывает один пункт доски. «B» означает черный камень, «W» – белый, «.» означает пустой пункт. Все группы на доске имеют хотя бы одно дамэ.\nВыходные данные\nВ выходной файл OUTPUT.TXT выведите одно число – количество групп черных камней, находящихся в атари.",
    "complexity": 50,
    "memory": 16000,
    "time": 1000,
    "examples": [
      {
        "input": "9\n\n.........\n\n.........\n\n.........\n\n...WW....\n\n...BW.B..\n\nB..W.W...\n\nB...WBW..\n\n....WBW..\n\nW....BW..",
        "output": "2"
      },
      {
        "input": "6\n\nWB.WBB\n\n.B.W.B\n\n..WW.W\n\nWWW..W\n\n..W...\n\nBBW...",
        "output": "1"
      }
    ]
  },
  {
    "id": 766,
    "name": "Орешки",
    "description": "Белочка собрала в лесу N шишек c орешками. Белочка очень привередливо выбирала шишки, и брала только те, в которых ровно M орешков. Также известно, что для пропитания зимой ей необходимо не менее K орешков. Определите, хватит ли на зиму орешков белочке.\nOUTPUT.TXTYES24 5 21NONOYES[Лучшие попытки]\nВходные данные33 2 1YES[Решение]\nПервая строка входного файла INPUT.TXT содержит три натуральных числа через пробел: N, M и K (N, M ≤ 100, K ≤ 10 000).\nВыходные данные\nВ выходной файл OUTPUT.TXT выведите «YES» если белочке хватит орешков и «NO» в противном случае.",
    "complexity": 3,
    "memory": 16000,
    "time": 1000,
    "examples": [
      {
        "input": "4 5 20",
        "output": "YES"
      },
      {
        "input": "4 5 21",
        "output": "NO"
      },
      {
        "input": "3 2 1",
        "output": "YES"
      }
    ]
  },
  {
    "id": 763,
    "name": "Игра с ладьей",
    "description": "На бесконечной вправо и вверх шахматной доске находится ладья. Два игрока передвигают ее по очереди. За один ход разрешено сдвинуть ладью вниз или влево на произвольное (ненулевое) количество клеток так, чтобы ладья не покинула доску. Цель игры – переместить ладью в левый нижний угол, то есть клетку с координатами (1,1). Известно, что оба игрока придерживаются оптимальной стратегии. Игрок №1 ходит первым, при этом он обязан совершить хотя бы один ход. Если первый ход сделать нельзя, то определить победителя также невозможно. Требуется написать программу, которая найдет номер победившего игрока, либо определит, что этого сделать нельзя.\nOUTPUT.TXT021 611[Лучшие попытки]\nВходные данные[Решение]\nВходной файл INPUT.TXT содержит два натуральных числа, разделенных пробелами: X и Y – координаты ладьи перед первым ходом (X,Y ≤ 109).\nВыходные данные\nВ выходной файл OUTPUT.TXT выведите одно число – номер победившего игрока. Если победителя определить невозможно, то следует вывести 0.",
    "complexity": 19,
    "memory": 16000,
    "time": 1000,
    "examples": [
      {
        "input": "1 1",
        "output": "0"
      },
      {
        "input": "1 6",
        "output": "1"
      }
    ]
  },
  {
    "id": 768,
    "name": "Звездные прямоугольники",
    "description": "Астроном Костя очень любит разглядывать звездное небо в телескоп. Однажды, глядя на звезды, он задумался: а сколько различных звездных прямоугольников видно на небе?  Звездный прямоугольник – это четыре различных звезды, которые при соединении четырьмя прямыми линиями образуют прямоугольник.\nOUTPUT.TXT1241 12 109 1010 100[Лучшие попытки]\nДва звездных прямоугольника считаются различными, если хотя бы одна звезда из набора звезд, их формирующих отличается.\nПомогите Косте сосчитать количество различных звездных прямоугольников.\nВходные данные\nВходной файл INPUT.TXT содержит число N (1 ≤ N ≤ 100) – количество звезд. Следующие N строк содержат координаты звезд (X, Y), разделенные пробелом. Координаты представлены целыми числами (0 ≤ X, Y ≤ 105).\nВыходные данные\nВ выходной файл OUTPUT.TXT выведите количество различных прямоугольников, образующихся звездами.",
    "complexity": 35,
    "memory": 16000,
    "time": 1000,
    "examples": [
      {
        "input": "4\n1 1\n10 10\n1 10\n10 1",
        "output": "1"
      },
      {
        "input": "4\n1 1\n2 10\n9 10\n10 1",
        "output": "0"
      }
    ]
  },
  {
    "id": 769,
    "name": "Список предметов",
    "description": "Студент Василий к концу семестра решил выяснить, какие предметы ему в этом семестре преподавались. Полный список предметов есть в его записях, но при их просмотре возникли две серьезные трудности. Во-первых, некоторые предметы упоминаются в этих записях более одного раза. Во-вторых, что еще хуже, из-за постоянной спешки Василий часто использует сокращения. Сокращает он довольно просто – отбрасывает несколько последних букв слова.  Так, предмет “algebra” в записях может быть обозначен как “algeb”, “algebr” и “alg” (но не как “alg-ra”). Создайте для Василия программу, которая по его записям определяет, сколько предметов у него преподавалось в этом семестре.\nOUTPUT.TXT224\nalgebr\nalg\nalgebra\nalgeb11[Лучшие попытки]\nВходные данные\nПервая строка входного файла INPUT.TXT содержит число N – количество записей в списке Василия (1 ≤ N ≤ 10 000). Далее идет N строк, каждая из которых содержит строку символов длиной M (2 ≤ M ≤ 20). Строки состоят исключительно из английских символов в нижнем регистре и знаков подчеркивания ('_'). Гарантируется, что входные данные позволяют однозначно определить количество преподававшихся в семестре предметов.\nВыходные данные\nВ выходной файл OUTPUT.TXT выведите количество предметов, которые преподавались в семестре.",
    "complexity": 31,
    "memory": 16000,
    "time": 1000,
    "examples": [
      {
        "input": "3\n\nalgebra\n\nalgeb\n\nhistory",
        "output": "2"
      },
      {
        "input": "4\n\nalgebr\n\nalg\n\nalgebra\n\nalgeb",
        "output": "1"
      }
    ]
  },
  {
    "id": 767,
    "name": "Дороги - 3",
    "description": "Начинается зима, но в городе К на дорогах все еще продолжается ремонт. После того, как очередная дорога была отремонтирована, департамент транспорта пришел к выводу, что дешевле обслуживать дороги с односторонним движением.\nOUTPUT.TXT327\n0 1 0 1 0 0 0\n1 0 0 1 0 1 0\n0 0 0 0 1 1 1\n1 1 0 0 0 0 0\n0 0 1 0 0 1 0\n0 1 1 0 1 0 0\n0 0 1 0 0 0 066[Лучшие попытки]\nСейчас все дороги в городе К двусторонние. Дорога состоит из двух полос – встречного и попутного направления. Требуется превратить максимальное количество дорог в односторонние, оставив одну из двух полос так, чтобы сообщение между точками города не нарушилось. Это означает, что если из точки i можно проехать в точку j (прямо или через промежуточные точки), то после введения одностороннего движения эта возможность должна остаться.\nКарта города задаётся матрицей смежности M, заполненной нулями и единицами. Размерность матрицы N (1 ≤ N ≤ 100) –  число точек города. Если M[i, j] = 1, то существует полоса для перемещения из точки i в точку j, не проходящая через другие точки, иначе M[i, j] = 0 (M[i, i] = 0 для любого i). Матрица M симметрична относительно главной диагонали, т.е. M[i, j] = M[j, i], что означает двустороннюю дорогу (полоса встречного и попутного направления).\nВходные данные\nВ первой строке входного файла INPUT.TXT содержится натуральное число N – размерность матрицы M, следующие N строк, каждая по N символов (нули или единицы), разделенные пробелами – элементы матрицы M.\nВыходные данные\nВ выходной файл OUTPUT.TXT выведите максимально возможное число двусторонних дорог, которые можно превратить в односторонние.",
    "complexity": 67,
    "memory": 16000,
    "time": 1000,
    "examples": [
      {
        "input": "4\n\n0 0 1 1\n\n0 0 0 0\n\n1 0 0 1\n\n1 0 1 0",
        "output": "3"
      },
      {
        "input": "7\n\n0 1 0 1 0 0 0\n\n1 0 0 1 0 1 0\n\n0 0 0 0 1 1 1\n\n1 1 0 0 0 0 0\n\n0 0 1 0 0 1 0\n\n0 1 1 0 1 0 0\n\n0 0 1 0 0 0 0",
        "output": "6"
      }
    ]
  },
  {
    "id": 816,
    "name": "Система пересекающихся множеств",
    "description": "На вступительном экзамене в один из крупнейших университетов нашей страны Вам предложили реализовать структуру данных для хранения множеств натуральных чисел.\nLISTSETSOF element – вывести номера всех множеств, содержащих элемент element (1 ≤ element ≤ m).OUTPUT.TXT1 21 2210 10\n3\nADD 1 1\nLISTSET 10\nLISTSET 1-11-11[Лучшие попытки]\nСтруктура данных должна хранить n множеств, в каждое из которых могут входить натуральные числа от 1 до m, при этом одно и то же число может принадлежать нескольким множествам одновременно. Необходимо реализовать операции добавления элемента в множество, вывода всех элементов множества и вывода номеров всех множеств, в которых лежит данный элемент.\n[Решение]\nРеализуйте описанную структуру данных.\nВходные данные\nПервая строка входного файла INPUT.TXT содержит натуральные числа m и n (1 ≤ m, n ≤ 100). Вторая строка входного файла содержит натуральное число k –количество операций со структурой данных, которые необходимо выполнить (0 ≤ k ≤ 105).\nПоследующие k строк описывают эти операции. Описание операции может иметь один из трех форматов:\nADD element set – добавить элемент element (1 ≤ element ≤ m) в множество номер set (1 ≤ set ≤ n);\nLISTSET set – вывести все элементы множества номер set (1 ≤ set ≤ n);\nLISTSETSOF element – вывести номера всех множеств, содержащих элемент element (1 ≤ element ≤ m).\nОбщее количество операций LISTSET и LISTSETSOF не превышает 1000.\nВыходные данные\nДля каждой операции LISTSET или LISTSETSOF в выходной файл OUTPUT.TXT выведите соответствующий список элементов (или номеров множеств) в порядке возрастания. Если список пуст,  выведите -1. Порядок вывода должен соответствовать порядку, в котором операции заданы во входном файле.",
    "complexity": 35,
    "memory": 16000,
    "time": 1000,
    "examples": [
      {
        "input": "10 10\n\n5\n\nADD 1 1\n\nADD 1 2\n\nADD 2 1\n\nLISTSET 1\n\nLISTSETSOF 1",
        "output": "1 2\n1 2"
      },
      {
        "input": "10 10\n\n3\n\nADD 1 1\n\nLISTSET 10\n\nLISTSET 1",
        "output": "-1\n1"
      }
    ]
  },
  {
    "id": 776,
    "name": "Юпитер",
    "description": "На поверхности Юпитера приземлился летающий робот, его задачей является исследование поверхности планеты. Поверхность Юпитера представляет собой прямоугольное поле из N×M клеток, каждая из которых представляет лаву или твердую поверхность различной высоты. Для снятия проб грунта роботу необходимо переместиться из клетки с координатами (1,1) в клетку с координатами (X,Y). Для передвижения робот может использовать два типа действий - это переезд и перелет.\nOUTPUT.TXT524 4\n4 2\n1 3\n2 0 0 3\n3 0 4 3\n4 0 5 2\n4 5 5 133IMPOSSIBLE[Лучшие попытки]\nПереезд - перемещение в одну из четырех соседних клеток, имеющих общую грань с заданной, при этом высота клеток не должна отличаться больше чем на единицу.\n33 3\n3 3\n10 10\n1 0 0\n1 0 0\n0 1 1IMPOSSIBLE\nПерелет из одной клетки в другую позволяет преодолевать препятствия, но для него нужна энергия, которая расходуется из специальных аккумуляторов, количество которых на борту ограничено и равно K. Дальность перелета ограничена мощностью одного аккумулятора и составляет D единиц. Перелет возможен только по направлениям, параллельным границам поля. Во время перелета луноход не может менять направление, но при этом может менять высоту, облетая препятствия. На каждое перемещение на одну клетку вдоль выбранного направления, вверх или вниз на одну единицу по высоте, тратится ровно одна единица энергии. После перелета аккумулятор утилизируется и больше использоваться не может, оставшаяся в нем энергия пропадает.\nОдним действием назовем один переезд или один перелет. Ваша задача для заданной поверхности найти наименьшее количество действий, необходимых для достижения заданной клетки.\nВходные данные\nПервая строка входного файла INPUT.TXT содержит размеры поля N, M (1 ≤ N,M ≤ 100), разделенные пробелом. Во второй строке идут координаты клетки, куда необходимо найти путь X,Y (1 ≤ X ≤ N, 1 ≤ Y ≤ M). На третьей строке через пробел указаны целые K и D (0 ≤ K ≤ 10, 0 ≤ D ≤ 100). Далее в M строках идут по N чисел через пробел – высотные отметки участка Юпитера, высота каждой клетки - целое число, лежащее в диапазоне от 0 до 10000 включительно. Высота 0 (ноль) обозначает лаву, на которой останавливаться нельзя, но можно пролететь над ней.\nВыходные данные\nВ выходной файл OUTPUT.TXT выведите целое число - минимальное количество действий, необходимых для достижения заданной клетки. Если добраться до заданной клетки нельзя, то необходимо вывести в строке слово IMPOSSIBLE.",
    "complexity": 62,
    "memory": 64000,
    "time": 1000,
    "examples": [
      {
        "input": "5 4\n\n5 3\n\n1 6\n\n2 1 4 2 1\n\n1 2 4 2 1\n\n4 4 6 2 1\n\n2 2 2 2 1",
        "output": "5"
      },
      {
        "input": "4 4\n\n4 2\n\n1 3\n\n2 0 0 3\n\n3 0 4 3\n\n4 0 5 2\n\n4 5 5 1",
        "output": "3"
      },
      {
        "input": "3 3\n\n3 3\n\n10 10\n\n1 0 0\n\n1 0 0\n\n0 1 1",
        "output": "IMPOSSIBLE"
      }
    ]
  },
  {
    "id": 779,
    "name": "Строительство школы",
    "description": "В деревне Интернетовка все дома расположены вдоль одной улицы по одну сторону от нее. По другую сторону от этой улицы пока ничего нет, но скоро все будет – школы, магазины, кинотеатры и т.д.\nOUTPUT.TXT323-1 0 100[Лучшие попытки]\nДля начала в этой деревне решили построить школу. Место для строительства школы решили выбрать так, чтобы суммарное расстояние, которое проезжают ученики от своих домов до школы, было минимально.\nПлан деревни можно представить в виде прямой, в некоторых целочисленных точках которой находятся дома учеников. Школу также разрешается строить только в целочисленной точке этой прямой (в том числе разрешается строить школу в точке, где расположен один из домов – ведь школа будет расположена с другой стороны улицы).\nНапишите программу, которая по известным координатам домов учеников поможет определить координаты места строительства школы.\nВходные данные\nВ первой строке входного файла INPUT.TXT сначала записано число N — количество учеников (1 ≤ N ≤ 100000). Во второй строке записаны в строго возрастающем порядке координаты домов учеников — целые числа, не превосходящие 2∙109 по модулю.\nВыходные данные\nВ единственную строку выходного файла OUTPUT.TXT нужно вывести одно целое число — координату точки, в которой лучше всего построить школу. Если ответов несколько, выведите наибольший из них.",
    "complexity": 30,
    "memory": 16000,
    "time": 1000,
    "examples": [
      {
        "input": "4\n1 2 3 4",
        "output": "3"
      },
      {
        "input": "3\n-1 0 1",
        "output": "0"
      }
    ]
  },
  {
    "id": 778,
    "name": "Офис",
    "description": "Летом Вася очень любил смотреть в окно. Напротив его дома расположился офис некоторой строительной фирмы. В течение всего месяца Вася наблюдал за его сотрудниками. Про каждый из 31 дня месяца он знает, сколько сотрудников пришло на работу. Ему также известно, что каждый из сотрудников берет ровно по 4 выходных в месяц.\nOUTPUT.TXT10[Лучшие попытки]\nТеперь он ломает голову над загадкой – сколько всего сотрудников работает в этом офисе. Напишите программу, которая ответит Васе на этот вопрос.\nВходные данные\nВ единственной строке входного файла INPUT.TXT записано 31 целое неотрицательное число. Эти числа описывают количество сотрудников, пришедших в офис в соответствующие дни месяца. Гарантируется, что входные данные корректны.\nВыходные данные\nВ единственную строку выходного файла OUTPUT.TXT нужно вывести единственное число – общее количество сотрудников офиса. Гарантируется, что ответ не превышает 100.",
    "complexity": 18,
    "memory": 16000,
    "time": 1000,
    "examples": [
      {
        "input": "10 10 10 10 10 10 10 10 10 10 10 10 10 10 10 10 10 10 10 10 10 10 10 10 10 10 10 0 0 0 0",
        "output": "10"
      }
    ]
  },
  {
    "id": 770,
    "name": "Покорение вселенной",
    "description": "",
    "complexity": 48,
    "memory": 16000,
    "time": 1000,
    "examples": [
      {
        "input": "rsMauraL",
        "output": "Mars"
      },
      {
        "input": "erurPL",
        "output": "Per"
      },
      {
        "input": "iaiopeassMarsCunaL",
        "output": "MarsCassiopeia"
      }
    ]
  },
  {
    "id": 777,
    "name": "Будильник",
    "description": "Известный исследователь Чарльз Ф. Мантц, устав от долгого путешествия через джунгли, лег спать в 10 часов вечера, но предварительно он завел будильник на 12 часов следующего дня. Но проспать 14 часов ему не удалось – будильник зазвонил через 2 часа. Исследователь забыл, что на будильнике, имеющем 12-тичасовой циферблат, можно задать время до звонка только менее 12 часов.\nOUTPUT.TXT2[Лучшие попытки]\nНапишите программу, которая определяет, сколько часов успеет проспать исследователь, прежде чем будильник его разбудит.\nВходные данные\nВ единственной строке входного файла INPUT.TXT записаны два целых числа S и T (1 ≤ S, T ≤ 12; S ≠ T), разделенные одним пробелом - час, когда исследователь лег спать, и час, на который он установил будильник.\nВыходные данные\nВ единственную строку выходного файла OUTPUT.TXT нужно вывести одно целое число – через сколько часов зазвонит будильник.",
    "complexity": 12,
    "memory": 16000,
    "time": 1000,
    "examples": [
      {
        "input": "10 12",
        "output": "2"
      }
    ]
  },
  {
    "id": 780,
    "name": "Футбол",
    "description": "Вместо того чтобы делать уроки, Вася смотрел футбольный матч и записывал счет, который показывался на табло, после каждого забитого гола.\nНапример, у него могла получиться такая запись: 1:0, 1:1, 1:2, 2:2, 2:3.\nПосле этого он сложил все записанные числа: 1+0+1+1+1+2+2+2+2+3=15.\nOUTPUT.TXT5[Лучшие попытки]\nПо сумме, получившейся у Васи, определите, сколько всего мячей было забито в матче.\nВходные данные\nВ первой строке входного файла INPUT.TXT записано одно целое неотрицательное число, не превосходящее 1000 – сумма, полученная Васей.\nВыходные данные\nВ выходной файл OUTPUT.TXT выведите одно число – общее количество забитых мячей.",
    "complexity": 22,
    "memory": 16000,
    "time": 1000,
    "examples": [
      {
        "input": "15",
        "output": "5"
      }
    ]
  },
  {
    "id": 783,
    "name": "Укладка плитки",
    "description": "Бригаде строителей поручили уложить квадратной плиткой пол на кухне в виде шахматного узора. Но строители работали не очень слаженно, и когда весь пол уже был уложен, оказалось, что в некоторых местах плитки одинакового цвета граничат друг с другом.\nOUTPUT.TXT4[Лучшие попытки]\nПо заданному замощению определите, какое минимальное число строителей могло укладывать плитку.\nВходные данные\nВходной файл INPUT.TXT содержит восемь строк, состоящих из восьми символов W и B – полученное замощение. Символ W обозначает плитку белого цвета, а символ B – чёрную.\nВыходные данные\nВ выходной файл OUTPUT.TXT нужно вывести одно число - искомое число строителей.",
    "complexity": 50,
    "memory": 16000,
    "time": 1000,
    "examples": [
      {
        "input": "WBWBWBBW\n\nBWBBWBWB\n\nWBWWBWBW\n\nWBWWBWWB\n\nBWBBWBWB\n\nWBWBWWBW\n\nBWBWBBWB\n\nWBWBWWBW",
        "output": "4"
      }
    ]
  },
  {
    "id": 781,
    "name": "Две цифры",
    "description": "Сколько N-значных чисел можно составить, используя цифры 5 и 9, в которых три одинаковые цифры не стоят рядом?\nOUTPUT.TXT6[Лучшие попытки]\nВходные данные\nВо входном файле INPUT.TXT записано число N (1 ≤ N ≤ 30).\nВыходные данные\nВ выходной файл OUTPUT.TXT нужно вывести одно число - количество чисел с указанным свойством.",
    "complexity": 42,
    "memory": 16000,
    "time": 1000,
    "examples": [
      {
        "input": "3",
        "output": "6"
      }
    ]
  },
  {
    "id": 782,
    "name": "Турнир",
    "description": "Турнир проходит по олимпийской системе. В каждом матче участвуют два игрока. Проигравший игрок выбывает из турнира, а победитель проходит в следующий тур. Матчи продолжаются до тех пор, пока в турнире не останется один участник, который становится обладателем золотой медали. Серебро достаётся его оппоненту в финальном матче. Если количество участников больше трёх, то назначается дополнительный матч для определения бронзового победителя. В нём участвуют два игрока, выбывшие из турнира последними, не считая финалистов.\nOUTPUT.TXT22444[Лучшие попытки]\nНапишите программу определения минимального количества матчей, которые необходимо сыграть участникам турнира, чтобы определить из них тех, кто получит медали.\nВходные данные\nВо входном файле INPUT.TXT записано одно целое число N (0 ≤ N ≤ 2147483647) – количество участников турнира.\nВыходные данные\nВ выходной файл OUTPUT.TXT нужно вывести одно число - минимальное количество матчей в этом турнире.",
    "complexity": 29,
    "memory": 16000,
    "time": 1000,
    "examples": [
      {
        "input": "3",
        "output": "2"
      },
      {
        "input": "4",
        "output": "4"
      }
    ]
  },
  {
    "id": 786,
    "name": "Игра с камешками",
    "description": "В начале игры имеем N камешков. Играют двое. За один ход нужно разделить кучку на две неравные и забрать себе меньшую. Проиграл тот, кто не смог этого сделать.\nOUTPUT.TXT3[Лучшие попытки]\nСколько камешков взяли бы Вы первым ходом, если рассчитываете на победу и ходите первым?\nВходные данные\nВ единственной строке входного файла INPUT.TXT записано одно число - число камушков в кучке N (1 ≤ N ≤ 106).\nВыходные данные\nВ выходной файл OUTPUT.TXT выведите одно число - количество взятых Вами первым ходом камушков, либо 0, если выигрышного хода нет.",
    "complexity": 32,
    "memory": 16000,
    "time": 1000,
    "examples": [
      {
        "input": "7",
        "output": "3"
      }
    ]
  },
  {
    "id": 785,
    "name": "Автоморфные числа",
    "description": "Целое число называется автоморфным, если оно совпадает с последними цифрами своего квадрата. Например, число 25 автоморфно, так как 252=625. Напишите программу определения всех автомофных чисел на заданном промежутке [a, b].\nOUTPUT.TXT1 5 6[Лучшие попытки]\nВходные данные\nВходной файл INPUT.TXT содержит два натуральных числа a и b (a ≤ b ≤ 106).\nВыходные данные\nВ выходной файл OUTPUT.TXT выведите через пробел в порядке возрастания все автоморфные числа заданного промежутка.",
    "complexity": 26,
    "memory": 16000,
    "time": 1000,
    "examples": [
      {
        "input": "1 10",
        "output": "1 5 6"
      }
    ]
  },
  {
    "id": 787,
    "name": "Игра с пешкой",
    "description": "NNOUTPUT.TXT5[Лучшие попытки]\nВ левой нижней клетке шахматной доски размера N×N стоит пешка. Двое игроков по очереди двигают её, причём каждый может подвинуть её на одну клетку вверх или на одну клетку вправо. На диагонали доски написаны числа a1, a2, …, aN. Когда пешка попадает на диагональ, игра кончается и выигрыш первого игрока равен значению числа, написанного в клетке с остановившейся пешкой. Напишите программу определения гарантированного выигрыша первого игрока.\ni\nВходные данные\nВ первой строке входного файла INPUT.TXT записано число N (1 ≤ N ≤ 100). Во второй строке записаны натуральные числа a1, a2, …, aN (1 ≤ ai ≤ 100).\nВыходные данные\nВ выходной файл OUTPUT.TXT выведите одно число – выигрыш первого игрока.",
    "complexity": 31,
    "memory": 16000,
    "time": 1000,
    "examples": [
      {
        "input": "8\n3 1 4 1 5 9 2 6",
        "output": "5"
      }
    ]
  },
  {
    "id": 864,
    "name": "Шары и коробки - 2",
    "description": "По кругу стоит N коробок. Каждая коробка имеет одного правого и одного левого соседа. В i-ой коробке находится Ai шаров. Известно, что общее количество шаров во всех коробках не превосходит N. За один ход разрешается переложить один шар из коробки в соседнюю. Какое наименьшее количество ходов придется совершить, чтобы в каждой коробке находилось не более одного шара?\nNOUTPUT.TXT7[Лучшие попытки]\nВходные данныеi\nПервая строка входного файла INPUT.TXT содержит целое число N (1 ≤ N ≤ 1000). Во второй строке определена последовательность N целых чисел A1, A2, ... , AN (0 ≤ Ai ≤ N). Сумма всех значений Ai не превосходит N.\ni\nВыходные данные\nВ выходной файл OUTPUT.TXT выведите искомое минимальное количество ходов.",
    "complexity": 68,
    "memory": 16000,
    "time": 1000,
    "examples": [
      {
        "input": "7\n1 0 0 0 2 3 1",
        "output": "7"
      }
    ]
  },
  {
    "id": 784,
    "name": "Эволюция",
    "description": "На каждом шаге эволюции из каждого вида образовывались ровно два подвида, а предыдущий вид исчезал.OUTPUT.TXT32182330162330081456314563[Лучшие попытки]\nВо время исследований, посвященных появлению жизни на планете Олимпия, учеными было сделано несколько сенсационных открытий:\nЕсли считать появление бактерии Bitozoria Programulis первым шагом эволюции, то существующие сейчас живые организмы находятся на N-ом шаге.\nВсе живые организмы планеты происходят от бактерии Bitozoria Programulis.\nЭволюция происходила шаг за шагом (по предположению ученых – во время изменения климата на планете).\nНа каждом шаге эволюции из каждого вида образовывались ровно два подвида, а предыдущий вид исчезал.\nЕсли считать появление бактерии Bitozoria Programulis первым шагом эволюции, то существующие сейчас живые организмы находятся на N-ом шаге.\nЧтобы не придумывать названия во время исследований, ученые пронумеровали все виды организмов, которые когда-либо существовали на планете. Для этого они нарисовали дерево эволюции с корнем Bitozoria Programulis, которая получила номер 1. Далее нумеровали виды каждого шага эволюции слева направо. Таким образом непосредственные подвиды Bitozoria Programulis получили номера 2 и 3. Следующими были занумерованы виды третьего шага эволюции – подвиды вида 2 получили номера 4 и 5, а вида 3 – номера 6 и 7, и т.д.\nНапишите программу, которая по номерам двух видов вычислит номер вида их ближайшего общего предка в дереве эволюции.\nВходные данные\nВ первой строке входного файла INPUT.TXT записано целое число N (1 ≤ N ≤ 60) – количество этапов эволюции, которые произошли на планете Олимпия до текущего времени. Вторая и третья строки содержат по одному натуральному числу, которые представляют номера видов, для которых требуется найти номер их ближайшего общего предка.\nВыходные данные\nВ выходной файл OUTPUT.TXT выведите одно натуральное число – номер ближайшего предка для двух видов.",
    "complexity": 32,
    "memory": 16000,
    "time": 1000,
    "examples": [
      {
        "input": "4\n15\n12",
        "output": "3"
      },
      {
        "input": "18\n233016\n233008",
        "output": "14563"
      }
    ]
  },
  {
    "id": 865,
    "name": "Проверка орфографии",
    "description": "Профессор Далл разработал новую систему проверки и исправления орфографии. Расстоянием между двумя английскими буквами в одинаковом регистре называется кратчайшее расстояние между ними по алфавиту, записанному по кругу. Например, d(B, G) = 5, а d(Z, A) = 1. Расстояние между буквами разных регистров равно расстоянию между соответствующими буквами одного регистра. Например, d(a, A) = 0, d(Z, a) = 1.\nOUTPUT.TXTSaratovStateUniversitY[Лучшие попытки]\nРасстоянием между двумя строками одинаковой длины называется сумма расстояний между соответствующими буквами. Метод профессора основывается на словаре правильных слов и представляет введенную последовательность в виде конкатенации слов из словаря таким образом, чтобы расстояние между заданным текстом и результатом было наименьшим. Регистр букв в тексте сохраняется. Реализуйте метод Далла.\nСлово из словаря может использоваться более одного раза.\nВходные данные\nВ первой строке входного файла INPUT.TXT содержится N (1 ≤ N ≤ 100), обозначающее количество слов в словаре. Далее, в N строках содержатся слова из словаря. Длины слов  от 1 до 32 символов включительно.\nПоследняя строка файла содержит текст. Текст состоит из английских букв, длина текста не менее 1 символа и не более 1000. Возможно, словарь содержит одинаковые слова. Слова в словаре записываются буквами произвольного регистра.\nВыходные данные\nВ выходной файл OUTPUT.TXT выведите результат. Если решений несколько, выведите любое. Если решения не существует, выведите -1.",
    "complexity": 56,
    "memory": 16000,
    "time": 1000,
    "examples": [
      {
        "input": "4\n\nSaratoV\n\nStaTe\n\nThe\n\nUniversity\n\nSaratofStataUniversitI",
        "output": "SaratovStateUniversitY"
      }
    ]
  },
  {
    "id": 867,
    "name": "Экзамен - 2",
    "description": "Экзамен по берляндскому языку проходит в узкой и длинной аудитории. На экзамен пришло N студентов. Все они посажены в ряд. Таким образом, позиция каждого человека задается координатой на оси  Ox (эта ось ведет вдоль длинной аудитории). Два человека могут разговаривать, если расстояние между ними меньше или равно D. Какое наименьшее количество типов билетов должен подготовить преподаватель, чтобы никакие два студента с одинаковыми билетами не могли разговаривать? Выведите способ раздачи преподавателем билетов.\n1OUTPUT.TXT21 1 2 224 011 1 12 211 1 1 111 1 1 1[Лучшие попытки]\n2\nВходные данныеN\nВ первой строке входного файла INPUT.TXT содержится два целых числа N, D (1 ≤ N ≤ 104; 0 ≤ D ≤ 106). Вторая строка содержит последовательность различных целых чисел X1, X2, ... , XN, где Xi (0 ≤ Xi ≤ 106) обозначает координату вдоль оси Ox i-го студента.\ni\niВыходные данные\n6\nВ первую строку выходного файла OUTPUT.TXT выведите Q – наименьшее количество типов билетов, необходимых для проведения экзамена. Во вторую строку выведите последовательность N целых чисел от 1 до Q, i-ое число этой последовательности обозначает номер типа билета i-го студента. Если ответов несколько, выведите любой.",
    "complexity": 45,
    "memory": 16000,
    "time": 1000,
    "examples": [
      {
        "input": "4 1\n11 1 12 2",
        "output": "2\n1 1 2 2"
      },
      {
        "input": "4 0\n11 1 12 2",
        "output": "1\n1 1 1 1"
      }
    ]
  },
  {
    "id": 868,
    "name": "Матрица: правый нижний элемент",
    "description": "Матрица A считается меньше (больше) матрицы B, если при просмотре слева направо и сверху вниз после всех равенств элементов матриц следующий элемент из матрицы A\tменьше (больше), чем соответствующий элемент из B. Такое сравнение называется лексикографическим и напоминает способ сравнения слов в словаре.\nOUTPUT.TXT122 33 2 14 5 633[Лучшие попытки]\nДана прямоугольная матрица A размером n×m, все элементы которой различны. В ней можно менять местами два произвольных столбца, а также менять местами две произвольных строки.\nПусть Amax – максимальная матрица, получаемая из исходной матрицы путем любого требуемого количества вышеприведенных операций. Необходимо написать программу, находящую последний (правый нижний) элемент из Amax.\nВходные данные\nВ первой строке входного файла INPUT.TXT записаны целые числа n, m (1 ≤ n, m ≤ 400). Далее в n строках содержится сама матрица. Каждая из этих строк содержит m целых чисел от 0 до 2147483647. Все элементы матрицы различны.\nВыходные данные\nВ выходной файл OUTPUT.TXT выведите искомый правый нижний элемент матрицы Amax.",
    "complexity": 38,
    "memory": 16000,
    "time": 1000,
    "examples": [
      {
        "input": "2 3\n1 2 3\n4 5 6",
        "output": "1"
      },
      {
        "input": "2 3\n3 2 1\n4 5 6",
        "output": "3"
      }
    ]
  },
  {
    "id": 866,
    "name": "Берляндия в опасности",
    "description": "Выходные данные\nВ выходной файл OUTPUT.TXT выведите две искомые перестановки, по одной в строке. Если решений несколько, то следует вывести любое.",
    "complexity": 82,
    "memory": 16000,
    "time": 1000,
    "examples": [
      {
        "input": "5\n\n6\n\n1 2\n\n2 3\n\n3 4\n\n4 1\n\n4 5\n\n5 2",
        "output": "1 2 3 5 4\n\n1 4 5 3 2"
      }
    ]
  },
  {
    "id": 788,
    "name": "Интересная игра c числами",
    "description": "Рассмотрим следующую интересную игру для двух игроков. Для этой игры необходима таблица из 2-х строк и N столбцов, в клетках которой записаны натуральные числа, следующего вида:\nA3B31iOUTPUT.TXT1221 11 1002[Лучшие попытки]\nA1A2A3...AN\nB1B2B3...BN\n......2i331 23 45 62\nANBN\nИгроки делают ходы по очереди. Начинает игру 1-й игрок.\n1\nЗа один ход 1-й игрок выполняет следующие два действия:\n2\nвыбирает произвольный столбец (к примеру, j-й), который еще ни разу не был выбран одним из игроков на предыдущих ходах;\n  прибавляет к своим очкам число Aj.\n2\nЗа один ход 2-й игрок выполняет следующие два действия:\n1\nвыбирает произвольный столбец (к примеру, j-й), который еще ни разу не был выбран одним из игроков на предыдущих ходах;\n  прибавляет к своим очкам число Bj.\n1\nИгра заканчивается, когда какой-либо из игроков не сможет сделать ход (по той причине, что все столбцы уже были выбраны). Изначально, у каждого из игроков есть 0 очков.\n2\nПосле того, как игра закончилась, происходит взаиморасчет между игроками. К примеру, 1-й игрок набрал S1 очков, а 2-й игрок - S2 очков. В случае, когда S1 \u003e S2, 2-й игрок отдает 1-му игроку S1-S2 УДЕ (условных денежных единиц). В противном случае, 1-й игрок отдает 2-му игроку S2-S1 УДЕ. С этих позиций, целью 1-го игрока является максимизация величины S1-S2, а целью 2-го игрока - максимизация S2-S1.\n2\n1\nНазовем стоимостью игры величину S1-S2 при оптимальной игре обоих игроков. Напишите программу, которая определяет стоимость игры.\nВходные данные\nВ первой строке входного файла INPUT.TXT записано натуральное число N - количество столбцов в таблице (1 ≤ N ≤ 300000). Следующие N строк описывают числа в столбцах таблицы. i-я из этих строк содержит два натуральных числа Ai и Bi, разделенные одним пробелом (1 ≤ Ai, Bi ≤ 3000).\nВыходные данные\nВ выходной файл OUTPUT.TXT выведите одно целое число - стоимость игры.",
    "complexity": 48,
    "memory": 16000,
    "time": 1000,
    "examples": [
      {
        "input": "1\n1 1",
        "output": "1"
      },
      {
        "input": "2\n1 1\n1 1",
        "output": "0"
      },
      {
        "input": "3\n1 2\n3 4\n5 6",
        "output": "2"
      }
    ]
  },
  {
    "id": 870,
    "name": "URL Validator",
    "description": "Для идентификации ресурсов в сети Internet используются URL (Uniform Resource Locator). URL состоит из нескольких элементов: протокол, хост, порт, путь и файл. Некоторые элементы URL могут быть опущены. Рассмотрим упрощенный формат URL:\nOUTPUT.TXTYES\nNO\nYES\nYES[Лучшие попытки]\n[http://]host[:port][/path][/file]\nЗаключенные в квадратные скобки элементы могут быть опущены, то есть, например, можно не указать протокол или файл. Элемент host представляет собой либо IP-адрес – четыре целых числа без лидирующих нулей от 0 до 255, разделенные точкой (например, 212.193.39.146), либо строковое имя ресурса. Во втором случае имя имеет вид\t prefix.domain, либо это просто имя компьютера.\nВ первом случае\tprefix  это последовательность одного или более слов, разделенных точкой, а domain – слово из английских букв длиной 2 или 3 символа. А в случае, если host является просто именем компьютера, то host – это одно слово.\nЭлемент port –  это целое число от 0 до 65535 без лидирующих нулей.\nЭлемент path – это последовательность одного или более слов, разделенных символом «/» (код 47).\nЭлемент file – это нуль или более слов, разделенных символом точка «.» (код 46).\nСлово – это последовательность из одного или более символов. Если не оговорено специально, то допустимыми символами слова считаются английские буквы произвольного регистра, цифры и символ подчеркивание «_» (код 95).\nВходные данные\nВходной файл INPUT.TXT содержит не более 10000 строк. Все строки содержат символы с кодами от 33 до 127 включительно. Длина каждой строки не превосходит 1000 символов. Размер файла не превосходит 500Кб. Помните, что любой тест (как и любой корректный тестовый файл) заканчивается символом перевода строки.\nВыходные данные\nВ выходной файл OUTPUT.TXT для каждой из строк выведите в отдельной строке «YES», если строка представляет корректную запись URL, либо «NO» в противном случае.",
    "complexity": 55,
    "memory": 16000,
    "time": 1000,
    "examples": [
      {
        "input": "http://acm.sgu.ru/index.html\n\n212.193.39/index.jsp\n\nhttp://acm.sgu.ru/01/index.php\n\n212.193.39.146/start/index.jsp",
        "output": "YES\n\nNO\n\nYES\n\nYES"
      }
    ]
  },
  {
    "id": 791,
    "name": "Соседние клетки",
    "description": "Клетки шахматной доски пронумерованы числами от 1 до 64 по строкам слева направо и снизу вверх. Напишите программу, которая по заданному номеру клетки определяет номера всех клеток, имеющих с ней общую сторону.\nOUTPUT.TXT1 3 1026456 6356 63[Лучшие попытки]\nВходные данные\nВходной файл INPUT.TXT содержит одно целое число от 1 до 64.\nВыходные данные\nВ выходной файл OUTPUT.TXT выведите через пробел в порядке возрастания номера всех клеток, имеющих с заданной общую сторону.",
    "complexity": 15,
    "memory": 16000,
    "time": 1000,
    "examples": [
      {
        "input": "2",
        "output": "1 3 10"
      },
      {
        "input": "64",
        "output": "56 63"
      }
    ]
  },
  {
    "id": 871,
    "name": "Автогонки",
    "description": "В городе N в ближайшее время состоится этап чемпионата мира по автогонкам среди автомобилей класса Формула-0. Поскольку специальный автодром для этих соревнований организаторы построить не успели, было решено организовать трассу на улицах города.\nOUTPUT.TXTYES22 31 22 12 1NONO[Лучшие попытки]\nВ городе N есть n перекрестков, некоторые пары которых соединены дорогами, движение по которым возможно в обоих направлениях. При этом любые два перекрестка соединены не более чем одной дорогой, и есть возможность доехать по дорогам от любого перекрестка до любого другого.\nТрасса, на которой будут проводиться соревнования, должна быть круговой (т.е. должна начинаться и заканчиваться на одном и том же перекрестке), при этом в процессе движения по ней никакой перекресток не должен встречаться более одного раза.\nНа предварительном этапе подготовки оргкомитетом был создан список всех дорог города. Теперь настало время его использовать. Первый вопрос, который необходимо решить,  вопрос о существовании в городе требуемой круговой трассы (разумеется, если ответ будет отрицательным, организаторам придется в срочном порядке построить еще несколько дорог). Единственная проблема заключается в том, что у организаторов есть подозрение, что, поскольку список составлялся не очень внимательно, в нем некоторые дороги указаны больше одного раза.\nНапишите программу, которая по заданному списку дорог города определит, возможна ли организация в городе требуемой круговой трассы.\nВходные данные\nПервая строка входного файла INPUT.TXT содержит два целых числа: n (1 ≤ n ≤ 103) –  количество перекрестков в городе N и m (0 ≤ m ≤ 105) – количество дорог в составленном списке.\nПоследующие m строк описывают дороги. Каждая дорога описывается двумя числами: u и v (1\t≤ u, v ≤ n, u ≠ v)  номерами перекрестков, которые она соединяет. Так как дороги двухсторонние, то пара чисел (u, v) и пара чисел (v, u) описывают одну и ту же дорогу.\nВыходные данные\nВ выходной файл OUTPUT.TXT выведите слово YES, если в городе возможно организовать круговую трассу для соревнований, и слово NO в противном случае.",
    "complexity": 35,
    "memory": 32000,
    "time": 1000,
    "examples": [
      {
        "input": "3 4\n1 2\n2 3\n3 1\n3 2",
        "output": "YES"
      },
      {
        "input": "2 3\n1 2\n2 1\n2 1",
        "output": "NO"
      }
    ]
  },
  {
    "id": 790,
    "name": "Развлечения гномов",
    "description": "Гномы свободно владеют системами счисления с разными основаниями и достигли они этого ежедневными тренировками. Именно поэтому каждое утро у гномов начинается с того, что они текущую календарную дату переводят в другую систему счисления. Ваше задание такое же: перевести заданную дату D/M/Y в систему счисления с основанием D+1.\nOUTPUT.TXT1/1010/11111010000[Лучшие попытки]\nДля обозначения цифр больших 9 используются большие английские буквы в алфавитном порядке.\nВходные данные\nВходной файл INPUT.TXT содержит строку, содержащую дату в формате D/M/Y в десятичной системе счисления (1 ≤ D ≤ 31, 1 ≤ M ≤ 12, 1 ≤ Y ≤ 9999).\nВыходные данные\nВ выходной файл OUTPUT.TXT выведите одну строку – дату в формате D/M/Y в системе счисления с основанием D+1.",
    "complexity": 28,
    "memory": 16000,
    "time": 1000,
    "examples": [
      {
        "input": "1/10/2000",
        "output": "1/1010/11111010000"
      }
    ]
  },
  {
    "id": 869,
    "name": "Байдарочный поход",
    "description": "Компания из N человек собирается пойти в байдарочный поход, i-ый человек характеризуется своей массой Mi кг. На лодочной базе имеется в наличии неограниченное количество одинаковых байдарок. Каждая байдарка может вмещать одного или двух людей. Байдарки имеют грузоподъемность D кг. Какое наименьшее количество байдарок придется арендовать компании, чтобы всем отправиться в поход?\nNOUTPUT.TXT226 13550 120 74 60 100 8244[Лучшие попытки]\nВходные данныеi\nВ первой строке входного файла INPUT.TXT содержится пара натуральных чисел N, D (1 ≤ N ≤ 15000; 1 ≤ D ≤ 15000). Во второй строке содержится последовательность натуральных чисел M1, M2, ... , MN (1 ≤ Mi ≤ D).\nВыходные данные\nВ выходной файл OUTPUT.TXT выведите искомое наименьшее количество необходимых байдарок.",
    "complexity": 35,
    "memory": 16000,
    "time": 1000,
    "examples": [
      {
        "input": "4 135\n50 74 60 82",
        "output": "2"
      },
      {
        "input": "6 135\n50 120 74 60 100 82",
        "output": "4"
      }
    ]
  },
  {
    "id": 789,
    "name": "Последовательность - 3",
    "description": "Найдите n-й элемент строго возрастающей последовательности, которая \nописывается следующими правилами:\nпоследовательности принадлежат только элементы, заданные правилами 1 и 2.OUTPUT.TXT2291010[Лучшие попытки]\nчисло 1 является элементом последовательности;\nесли a – элемент последовательности, то 2a, 3a, 5a тоже являются элементами последовательности;\nпоследовательности принадлежат только элементы, заданные правилами 1 и 2.\nВходные данные\nВходной файл INPUT.TXT содержит одно натуральное число n (n ≤ 10000).\nВыходные данные\nВ выходной файл OUTPUT.TXT выведите одно число – n-й элемент последовательности.",
    "complexity": 37,
    "memory": 16000,
    "time": 1000,
    "examples": [
      {
        "input": "2",
        "output": "2"
      },
      {
        "input": "9",
        "output": "10"
      }
    ]
  },
  {
    "id": 872,
    "name": "Цепочка слов",
    "description": "Цепочкой слов длины N назовем последовательность слов W1, W2, ..., WN такую, что для 1 ≤ i \u003c N слово Wi является собственным префиксом слова Wi+1.\nNMOUTPUT.TXT325aabbcbcdadd22[Лучшие попытки]\ni\nНапомним, что слово U длины K называется собственным префиксом слова V длины L, если K \u003c L и первые K букв слова V совпадают со словом U.\ni+1\nЗадан набор слов S = {S1, S2, ..., SM}. Найдите максимальную длину цепочки слов, которую можно построить, используя (возможно, не все) слова этого набора.\nВходные данные\nВходной файл INPUT.TXT содержит целое число M (1 ≤ M ≤ 255). Каждая из последующих M строк содержит по одному слову из набора S. Все слова не пусты, имеют длину, не превосходящую 255 символов, и состоят только из строчных букв английского алфавита.\nВыходные данные\nВ выходной файл OUTPUT.TXT выведите ответ на задачу.",
    "complexity": 37,
    "memory": 16000,
    "time": 1000,
    "examples": [
      {
        "input": "3\na\nab\nabc",
        "output": "3"
      },
      {
        "input": "5\na\nab\nbc\nbcd\nadd",
        "output": "2"
      }
    ]
  },
  {
    "id": 873,
    "name": "Шифр «Решетка»",
    "description": "Рассмотрим перестановочный шифр, называемый «Решетка» («перестановочный» означает, что символы, составляющие послание, не изменяются, но меняются местами). Суть его заключается в следующем. Выбирается четное число n, затем в квадрате n×n вырезается n2/4 клеток. При этом клетки выбираются так, что если наложить решетку на квадрат n х n, и затем последовательно развернуть ее на 90, 180 и 270 градусов, то каждый раз квадратики, совмещенные с вырезанными клетками, будут различны.\nOUTPUT.TXT4[Лучшие попытки]\nТакой квадрат n×n называется «правильным ключом». Ваша задача  посчитать количество «правильных ключей». Так как это число может быть очень большим, мы предлагаем Вам найти его значение по модулю m. Ключи, получаемые поворотом на 90, 180 и 270 градусов считаются различными.\nВходные данные\nВходной файл INPUT.TXT содержит целые числа n и m (2 ≤ n, m ≤ 106), n - четно.\nВыходные данные\nВ выходной файл OUTPUT.TXT выведите количество «правильных ключей» размером n×n по модулю m.",
    "complexity": 54,
    "memory": 16000,
    "time": 1000,
    "examples": [
      {
        "input": "2 100",
        "output": "4"
      }
    ]
  },
  {
    "id": 792,
    "name": "Торговые сделки в Амбере",
    "description": "В стране Амбер очень сложные торгово-финансовые отношения. Если один торговец хочет обменять свой товар на товар другого торговца, тогда они идут в Торговую Гильдию Амбера. Наверное, вы подумали, что торговцы просто обменяются товарами и уйдут в разные стороны довольными от выгодной сделки? Как бы не так! Законы в Амбере таковы, что Торговая Гильдия может получить прибыль от сделки между двумя торговцами, равную нормирующему коэффициенту одного из торговцев, только в том случае, когда нормирующие коэффициенты этих торговцев совпадут. Вы, наверное, не знаете что такое нормирующий коэффициент в Амбере? Это не удивительно…\n2OUTPUT.TXT325 85 20016[Лучшие попытки]\nПусть торговцу N лет. В стране, откуда он приехал, для расчета операций с денежными единицами,  действует система счисления с основанием P. Его нормирующим коэффициентом называется сумма цифр числа N в системе счисления с основанием P. \n2331 16400 916\nНапишите программу, которая покажет, сколько сможет заработать Торговая Гильдия после заключения сделки между двумя торговцами.\n1\nВходные данные2\nВ первой строке входного файла INPUT.TXT содержится данные о первом торговце - числа N1 и P1, а во второй – данные о втором торговце –  N2 и P2. Где N1 и N2 – возраст двух торговцев, которые хотят заключить сделку (0 ≤ N1, N2 ≤ 2147483647), а P1 и P2 – основания систем счисления, действующие в их странах (2 ≤  P1, P2 ≤ 16).\n1\n2Выходные данные\n1\nВ выходной файл OUTPUT.TXT вывести, сколько заработает Торговая Гильдия после заключения сделки между торговцами.\n2Примеры\n1\n№INPUT.TXTOUTPUT.TXT\n17 29 43\n25 85 20\n331 16400 916\n2\nДля отправки решения задачи необходимо зарегистрироваться и авторизоваться!\n[Обсуждение]\n\n  [Все попытки]\n\n  [Лучшие попытки]\nwindow.yaContextCb.push(()=\u003e{\n  Ya.Context.AdvManager.render({\n    renderTo: 'yandex_rtb_R-A-122393-3',\n    blockId: 'R-A-122393-3'\n  })\n})",
    "complexity": 21,
    "memory": 16000,
    "time": 1000,
    "examples": [
      {
        "input": "7 2\n9 4",
        "output": "3"
      },
      {
        "input": "5 8\n5 2",
        "output": "0"
      },
      {
        "input": "31 16\n400 9",
        "output": "16"
      }
    ]
  },
  {
    "id": 793,
    "name": "Числа Смита",
    "description": "Число Смита — такое составное число, сумма цифр которого равняется сумме цифр всех его простых сомножителей. Так, примером числа Смита может служить 202, поскольку 2 + 0 + 2 = 4 и 2 + 1 + 0 + 1 = 4 (202 = 2 * 101). Напишите программу, которая для заданной последовательности чисел определяет, какие из них являются числами Смита.\nOUTPUT.TXT1001[Лучшие попытки]\nВходные данные\nВходной файл INPUT.TXT содержит не более 20 натуральных чисел в пределах от 4 до 106.\nВыходные данные\nВ выходной файл OUTPUT.TXT выведите строку из 0 и 1 (1, если соответствующее число является числом Смита и 0 иначе).",
    "complexity": 30,
    "memory": 16000,
    "time": 1000,
    "examples": [
      {
        "input": "4 20 17 202",
        "output": "1001"
      }
    ]
  },
  {
    "id": 794,
    "name": "Ролевая игра",
    "description": "Вася готовит инвентарь для ролевой игры. В игре должны принять участие n игроков, каждый из которых будет изображать персонажа фантастического мира. В процессе игры каждый персонаж будет обладать некоторым уровнем x, который представляет собой целое число от 1 до m. \n5OUTPUT.TXT9[Лучшие попытки]\nДля обозначения уровня планируется использовать специальные значки двух цветов. Белый значок обозначает один уровень, а красный значок – k уровней. Игрок, изображающий персонажа с уровнем x, должен иметь a белых значков и b красных значков, чтобы сумма (a + b*k) была равна x. При этом персонажу не разрешается иметь более чем (k – 1) белых значков.\n[Решение]\nЗначки для игры готовятся заранее, однако уровни персонажей заранее неизвестны. Для успешного проведения игры всем персонажам необходимо выдать соответствующее их уровням количество значков. Возникает вопрос: какое минимальное суммарное количество значков необходимо подготовить для успешного проведения игры при любых уровнях участвующих персонажей.\nТребуется написать программу, которая по заданным числам n, m и k вычисляет минимальное количество значков, которое необходимо подготовить для успешного проведения игры.\nВходные данные\nВходной файл INPUT.TXT содержит расположенные в одной строке три целых числа: n, m и k (1 ≤ n ≤ 104, 1 ≤ m ≤ 105, 1 ≤ k ≤ 105).\nВыходные данные\nВ выходной файл OUTPUT.TXT выведите одно целое число — минимальное количество значков, которое требуется подготовить.",
    "complexity": 20,
    "memory": 16000,
    "time": 1000,
    "examples": [
      {
        "input": "3 4 2",
        "output": "9"
      }
    ]
  },
  {
    "id": 796,
    "name": "Форматирование текста",
    "description": "Многие системы форматирования текста, например TEX или Wiki, используют для разбиения текста на абзацы пустые строки. Текст представляет собой последовательность слов, разделенных пробелами, символами перевода строк и следующими знаками препинания: «,», «.», «?», «!», «-», «:» и «’» (ASCII коды 44, 46, 63, 33, 45, 58, 39). Каждое слово в тексте состоит из заглавных и прописных букв английского алфавита и цифр. Текст может состоять из нескольких абзацев. В этом случае соседние абзацы разделяются одной или несколькими пустыми строками. Перед первым абзацем и после последнего абзаца также могут идти одна или несколько пустых строк.\nOUTPUT.TXT\n    Yesterday, All\nmy troubles seemed\nso far away, Now it\nlooks as though\nthey' re here to\nstay, Oh, I believe\nin yesterday. \n    Suddenly, I' m\nnot half the man I\nused to be, There' s\na shadow hanging\nover me, Oh,\nyesterday came\nsuddenly...\n[Лучшие попытки]\nДальнейшее использование исходного текста предполагает его форматирование, которое осуществляется следующим образом. Каждый абзац должен быть разбит на строки, каждая из которых имеет длину не больше w. Первая строка каждого абзаца должна начинаться с отступа, состоящего из b пробелов. Слова внутри одной строки должны быть разделены ровно одним пробелом. Если после слова идет один или несколько знаков препинания, они должны следовать сразу после слова без дополнительных пробелов. Если очередное слово вместе со следующими за ним знаками препинания помещается на текущую строку, оно размещается на текущей строке. В противном случае, с этого слова начинается новая строка. В отформатированном тексте абзацы не должны разделяться пустыми строками. В конце строк не должно быть пробелов.\nТребуется написать программу, которая по заданным числам w и b и заданному тексту выводит текст, отформатированный описанным выше образом.\nВходные данные\nПервая строка входного файла INPUT.TXT содержит два целых числа: w и b (5 ≤ w ≤ 100, 1 ≤ b ≤ 8, b \u003c w). Затем следует одна или более строк, содержащих заданный текст. Длина слова в тексте вместе со следующими за ними знаками препинания не превышает w, а длина первого слова любого абзаца вместе со следующими за ним знаками препинания не превышает (w – b). Текст содержит хотя бы одну букву. Перед первой буквой каждого абзаца знаков препинания нет.\nВыходные данные\nВыходной файл OUTPUT.TXT должен содержать заданный текст, отформатированный в соответствии с приведенными в условии задачи правилами. Размер входного файла не превышает 100 Кбайт. Длина каждой строки во входном файле не превышает 250.",
    "complexity": 51,
    "memory": 16000,
    "time": 1000,
    "examples": [
      {
        "input": "20 4\nYesterday, \nAll my troubles seemed so far away, \nNow it looks as though they\u0026#39;re here to stay, \nOh, I believe in yesterday. \n\nSuddenly, \nI\u0026#39;m not half the man I used to be, \nThere\u0026#39;s a shadow hanging over me, \nOh, yesterday  came suddenly...",
        "output": "Yesterday, All\nmy troubles seemed\nso far away, Now it\nlooks as though\nthey\u0026#39; re here to\nstay, Oh, I believe\nin yesterday. \n    Suddenly, I\u0026#39; m\nnot half the man I\nused to be, There\u0026#39; s\na shadow hanging\nover me, Oh,\nyesterday came\nsuddenly..."
      }
    ]
  },
  {
    "id": 607,
    "name": "Домино в казино",
    "description": "Домино известно в качестве игры, в которую люди обычно играют во дворе, чтобы расслабиться после рабочего дня. Но так было лишь до того времени, пока Джон Бигбак не предоставил возможность играть в домино в своем казино «BUMP» (Bring Us Money, Please).\nOUTPUT.TXT11[Лучшие попытки]\nОбычная игра в домино не совсем подходит для казино, поэтому Джон создал свою собственную игру. Партия играется на прямоугольной доске размера m_n. В каждой ее клетке записано некоторое целое число.\nУ игрока есть k костей домино - прямоугольников 2×1. Он кладет их на доску так, чтобы не возникало наложений, и его выигрыш вычисляется как сумма произведений чисел, накрытых каждой из костей домино.\nНапример, существует два способа положить две кости домино на доску размера 2×2. Для доски, приведенной ниже, лучший способ положить домино показан слева - в этом случае сумма составляет 1×3 + 4×2 = 11. Если игрок выберет способ, показанный справа, то сумма составит 1×4 + 3×2 = 10, что меньше чем 11.\nПо заданному расположению чисел на доске и количеству костей домино, которыми располагает игрок, найдите наибольшую сумму, которую он может получить.\nВходные данные\nПервая строка входного файла INPUT.TXT содержит целые числа m, n и k (1 ≤ m ≤ 16, 1 ≤ n ≤ 100, 1 ≤ k ≤ 200). Следующие m строк содержат по n целых чисел каждая и описывают доску. Числа, записанные на доске, неотрицательны и по величине не превосходят 1000. Гарантируется, что существует хотя бы один способ разместить все кости домино на доске.\nВыходные данные\nВ выходной файл OUTPUT.TXT выведите одно целое число - наибольшую сумму, которую может получить игрок.",
    "complexity": 72,
    "memory": 16000,
    "time": 1000,
    "examples": [
      {
        "input": "2 2 2\n1 4\n3 2",
        "output": "11"
      }
    ]
  },
  {
    "id": 795,
    "name": "Колесо Фортуны",
    "description": "OUTPUT.TXT5251 2 3 4 515 15 2445[Лучшие попытки]\nРазвлекательный телеканал транслирует шоу «Колесо Фортуны». В процессе игры участники шоу крутят большое колесо, разделенное на сектора. В каждом секторе этого колеса записано число. После того как колесо останавливается, специальная стрелка указывает на один из секторов. Число в этом секторе определяет выигрыш игрока.\n355 4 3 2 12 5 25[Решение]\nЮный участник шоу заметил, что колесо в процессе вращения замедляется из-за того, что стрелка задевает за выступы на колесе, находящиеся между секторами. Если колесо вращается с угловой скоростью v градусов в секунду, и стрелка, переходя из сектора X к следующему сектору, задевает за очередной выступ, то текущая угловая скорость движения колеса уменьшается на k градусов в секунду. При этом если v ≤ k, то колесо не может преодолеть препятствие и останавливается. Стрелка в этом случае будет указывать на сектор X.\nЮный участник шоу собирается вращать колесо. Зная порядок секторов на колесе, он хочет заставить колесо вращаться с такой начальной скоростью, чтобы после остановки колеса стрелка указала на как можно большее число. Колесо можно вращать в любом направлении и придавать ему начальную угловую скорость от a до b градусов в секунду.\nТребуется написать программу, которая по заданному расположению чисел в секторах, минимальной и максимальной начальной угловой скорости вращения колеса и величине замедления колеса при переходе через границу секторов вычисляет максимальный выигрыш.\nВходные данные\nПервая строка входного файла INPUT.TXT содержит целое число n – количество секторов колеса (3 ≤ n ≤ 100). Вторая строка входного файла содержит n положительных целых чисел, каждое из которых не превышает 1000 — числа, записанные в секторах колеса. Числа приведены в порядке следования секторов по часовой стрелке. Изначально стрелка указывает на первое число.\nТретья строка содержит три целых числа: a, b и k (1 ≤ a ≤ b ≤ 109, 1 ≤ k ≤ 109).\nВыходные данные\nВ выходной файл OUTPUT.TXT выведите одно целое число – максимальный выигрыш.",
    "complexity": 37,
    "memory": 16000,
    "time": 1000,
    "examples": [
      {
        "input": "5\n1 2 3 4 5\n3 5 2",
        "output": "5"
      },
      {
        "input": "5\n1 2 3 4 5\n15 15 2",
        "output": "4"
      },
      {
        "input": "5\n5 4 3 2 1\n2 5 2",
        "output": "5"
      }
    ]
  },
  {
    "id": 874,
    "name": "Гирлянда",
    "description": "Приближается Новый Год, и в магазинах начинают появляться различные елочные украшения. На прилавках можно увидеть различные шарики, шишечки, звездочки, но все-таки самым красивым украшением является гирлянда из разноцветных лампочек. Одна из фирм, занимающихся изготовлением елочных украшений, решила в этом году изготавливать гирлянды на заказ.\nOUTPUT.TXT224 4 025625624[Лучшие попытки]\nГирлянды, изготавливаемые этой фирмы, состоят из лампочек различных цветов, соединенных проводами. Всего в гирлянде n лампочек, каждая из которых покрашена в один из k цветов, и m проводов (каждый провод соединяет ровно две лампочки). Далее мы будем считать, что лампочки пронумерованы натуральными числами от 1 до n.\n34 4 61 21 31 42 32 43 424\nК сожалению, не каждый дизайн гирлянды соответствует эстетическим взглядам заказчиков. Во-первых, лампочки, соединенные одним проводом должны быть разного цвета, во-вторых, сама конфигурация гирлянды (то есть то, какие лампочки и как соединены проводами) не может быть любой.\nОдин из отделов фирмы уже провел исследование и нашел наиболее «удачную» конфигурацию. Ваша же задача состоит в том, чтобы найти число способов раскрасить лампочки, чтобы получившаяся гирлянда удовлетворяла эстетическим взглядам заказчиков.\nВходные данные\nПервая строка входного файла INPUT.TXT содержит три целых числа: n, k, m (1 ≤ n, k ≤ 8, 0 ≤ m ≤ 10). Последующие m строк описывают провода. Описание каждого провода состоит из двух чисел u и v (1 ≤ u, v ≤ n, u ≠ v) – номеров лампочек, соединенных этим проводом.\nВыходные данные\nВ выходной файл OUTPUT.TXT выведите ответ на задачу.",
    "complexity": 50,
    "memory": 16000,
    "time": 1000,
    "examples": [
      {
        "input": "2 2 1\n1 2",
        "output": "2"
      },
      {
        "input": "4 4 0",
        "output": "256"
      },
      {
        "input": "4 4 6\n1 2\n1 3\n1 4\n2 3\n2 4\n3 4",
        "output": "24"
      }
    ]
  },
  {
    "id": 875,
    "name": "Игра «Жизнь»",
    "description": "Игра «Жизнь» была придумана английским математиком Джоном Конвейем в 1970 году. Впервые описание этой игры опубликовано в октябрьском выпуске (1970) журнала Scientic American, в рубрике «Математические игры» Мартина Гарднера.\nOUTPUT.TXT\n.*.**\n*.*..\n.*.*.\n..*..\n.**..2\n5 5 5\n**...\n..**.\n.*...\n..*..\n...*.\n.***.\n.*...\n.*...\n..**.\n.....\n.***.\n.*...\n.*...\n..**.\n.....\n.......\n.......\n.......\n.......[Лучшие попытки]\nМесто действия этой игры – «вселенная» – это размеченная на клетки поверхность. Каждая клетка на этой поверхности может находиться в двух состояниях: быть живой или быть мертвой. Клетка имеет восемь соседей. Распределение живых клеток в начале игры называется первым поколением. Каждое следующее поколение рассчитывается на основе предыдущего по таким правилам:\n3\n4 7 5\n.*.*.*.\n*.*.*.*\n.*.*.*.\n*.*.*.*\n.......\n.......\n.......\n.......\nпустая (мертвая) клетка с ровно тремя живыми клетками-соседями оживает;\n если у живой клетки есть две или три живые соседки, то эта клетка продолжает жить; в противном случае (если соседок меньше двух или больше трех) клетка умирает (от «одиночества» или от «перенаселенности»).\nВ этой задаче рассматривается игра «Жизнь» на торе. Представим себе прямоугольник размером n строк на m столбцов. Для того, чтобы превратить его в тор мысленно «склеим» его верхнюю сторону с нижней, а левую  с правой.\nТаким образом, у каждой клетки, даже если она раньше находилась на границе прямоугольника, теперь есть ровно восемь соседей.\nВаша задача состоит в том, чтобы найти конфигурацию клеток, которая будет через k поколений от заданного.\nВходные данные\nПервая строка входного файла INPUT.TXT содержит три целых числа: n, m, k (4 ≤ n, m ≤ 100; 0 ≤ k ≤ 100). Последующие n строк содержат по m символов каждая и описывают начальную конфигурацию. j-ый символ i-ой строки равен «.» (точка), если соответствующая клетка мертва, и «*» (звездочка) –  если жива.\nВыходные данные\nВ выходной файл OUTPUT.TXT выведите конфигурацию клеток через k поколений после начального в том же формате, в каком конфигурация задается во входном файле.",
    "complexity": 29,
    "memory": 16000,
    "time": 1000,
    "examples": [
      {
        "input": "5 5 1\n\n**...\n\n..**.\n\n.*...\n\n..*..\n\n...*.",
        "output": ".*.**\n\n*.*..\n\n.*.*.\n\n..*..\n\n.**.."
      },
      {
        "input": "5 5 5\n\n**...\n\n..**.\n\n.*...\n\n..*..\n\n...*.",
        "output": ".***.\n\n.*...\n\n.*...\n\n..**.\n\n....."
      },
      {
        "input": "4 7 5\n\n.*.*.*.\n\n*.*.*.*\n\n.*.*.*.\n\n*.*.*.*",
        "output": ".......\n\n.......\n\n.......\n\n......."
      }
    ]
  },
  {
    "id": 608,
    "name": "Про любовь",
    "description": "2i,2OUTPUT.TXTYES\n0.0 4.022 0-2 03-1 -1 1 1-3 -3 -1 -1-3 1 1 3NONO[Лучшие попытки]\nВаське нравится Машка. Она симпатичная, и он очень любит смотреть на нее. Но ему нравится и Ленка! Она тоже довольно симпатичная. Васька может смотреть на нее часами, когда она сидит на скамейке и читает книгу. Почему бы не подойти и поговорить с ней? Есть небольшая проблема. Васька - кот.\n2i,2\nНо надо сказать, что это его не очень беспокоит. В общем, он даже привык к этому. Ему просто нравится смотреть на девочек. К сожалению, часто дома и другие препятствия не дают увидеть обеих девочек одновременно. А даже когда это можно сделать, найти подходящую точку довольно сложно. Васька просит вас, своего любимого хозяина, помочь ему.\nДаны положения препятствий и точки, в которых находятся девочки. Найдите точку, из которой видны обе девочки, или установите, что такой точки нет. Конечно, Васька не может забираться внутрь препятствий.\nВходные данные\nПервая строка входного файла INPUT.TXT содержит два целых числа x1 и y1 - координаты Машки. Следующая строка содержит x2 и y2 - координаты Ленки. Третья строка входного файла содержит n - количество препятствий (0 ≤ n ≤ 10).\nВсе препятствия являются прямоугольниками со сторонами, параллельными осям координат. Каждая из следующих n строк содержит четыре целых числа xi,1, yi,1, xi,2 и yi,2 – координаты левого нижнего и правого верхнего углов препятствий. Все координаты не превосходят 100 по абсолютному значению. Препятствия не пересекаются, но могут касаться друг друга. Если два препятствия касаются друг друга углами или сторонами, между ними нет зазора. В противном случае Васька может смотреть таким образом, что линия его взгляда касается угла или идет вдоль стороны препятствия.\nНи одна из девочек не находится внутри или на границе какого-то из препятствий. Девочки находятся в разных точках.\nВыходные данные\nВ первой строке выходного файла OUTPUT.TXT выведите «YES» , если точка, из которой Васька может видеть обеих девочек, существует. В этом случае вторая строка должна содержать два вещественных числа - координаты точки, из которой должен смотреть Васька. Эта точка не должна быть внутри какого-либо препятствия, но может быть на его границе. Васька не должен находиться в точке, которая одновременно принадлежит углам двух зданий, не имеющих общей стороны. Координаты должны быть выведены с точностью не менее, чем 10-6. Если искомой точки нет, выведите «NO» в единственную строку выходного файла.",
    "complexity": 70,
    "memory": 16000,
    "time": 1000,
    "examples": [
      {
        "input": "2 0\n-2 0\n1\n-1 -2 1 2",
        "output": "YES\n\n0.0 4.0"
      },
      {
        "input": "2 0\n-2 0\n3\n-1 -1 1 1\n-3 -3 -1 -1\n-3 1 1 3",
        "output": "NO"
      }
    ]
  },
  {
    "id": 798,
    "name": "Шахматная доска - 2",
    "description": "equal, если черных и белых клеток на доске поровну.OUTPUT.TXTblack23 5 2 1 0whitewhiteequal[Лучшие попытки]\nАня разделила доску размера m × n на клетки размера 1×1 и раскрасила их в черный и белый цвет в шахматном порядке. Васю заинтересовал вопрос: клеток какого цвета получилось больше – черного или белого. \n34 4 1 1 1equal[Решение]\nДля того чтобы выяснить это, он спросил у Ани, в какой цвет она раскрасила j-ю клетку в i-м ряду доски. По этой информации Вася попытался  определить, клеток какого цвета на доске больше.\nТребуется написать программу, которая по размерам доски и цвету j-й клетки в i-м ряду определит, клеток какого цвета на доске больше — черного или белого.\nВходные данные\nВходной файл INPUT.TXT содержит пять целых чисел: m, n, i, j и c (1 ≤ m, n ≤ 109, 1 ≤ i ≤ m, 1 ≤ j ≤ n, с = 0 или с = 1). Значение c = 0 означает, что j-я клетка в i-м ряду доски раскрашена в черный цвет, а значение c = 1 – в белый цвет.\nВыходные данные\nВ выходной файл OUTPUT.TXT выведите одно из трех слов:\nblack, если черных клеток на доске больше,\nwhite, если белых клеток на доске больше,\nequal, если черных и белых клеток на доске поровну.",
    "complexity": 18,
    "memory": 16000,
    "time": 1000,
    "examples": [
      {
        "input": "3 5 1 1 0",
        "output": "black"
      },
      {
        "input": "3 5 2 1 0",
        "output": "white"
      },
      {
        "input": "4 4 1 1 1",
        "output": "equal"
      }
    ]
  },
  {
    "id": 797,
    "name": "Космические исследования",
    "description": "iOUTPUT.TXT3024 21 110 21 310 4101007[Лучшие попытки]\nОтделу космических исследований поступило задание сфотографировать из космоса n объектов в заданной области. Область имеет форму квадрата размером 50×50 километров. Если разделить ее на квадраты размером 1×1 километр, то интересующие отдел объекты окажутся в центрах некоторых единичных квадратов. \ni31 11 10\nВведем систему координат, направив ось OX с запада на восток и ось OY с юга на север. Тогда каждому единичному квадрату будут сопоставлены координаты в диапазоне от 1 до 50, как показано на рисунке ниже.\n43 33 33 66 37\nДля космической съемки используется специальный фотоаппарат высокого разрешения, установленный на космическом спутнике. Фотоаппарат может делать снимки квадратных участков земной поверхности размером k × k километров. Исходно аппарат наведен на юго-западный угол заданной области, то есть, если сделать снимок, на нем будут видны единичные квадраты с координатами x и y от 1 до k километров.\nС помощью специальных двигателей можно изменять орбиту спутника, что приводит к изменению участка съемки. За один день орбиту спутника можно изменить таким образом, что участок съемки сместится либо на один километр на запад, либо на один километр на восток, либо на один километр на север. Переместить участок съемки на юг невозможно. Непосредственно между перемещениями спутника можно сделать снимок, временем съемки можно пренебречь.\nРуководство отдела заинтересовалось вопросом: за какое минимальное количество дней можно сделать снимки всех объектов заданной области.\nТребуется написать программу, которая по заданному расположению объектов и размеру снимка k определит минимальное время, за которое можно сделать снимки всех объектов заданной области.\nВходные данные\nПервая строка входного файла INPUT.TXT содержит два целых числа: n и k (1 ≤ n ≤ 1000, 1 ≤ k ≤ 5). Следующие n строк содержат по два целых числа: xi и yi — координаты объектов в заданной области (1 ≤ xi, yi ≤ 50).\nВыходные данные\nВ выходном файле OUTPUT.TXT должно содержаться одно целое число: минимальное количество дней, которое требуется для получения снимков всех объектов в заданной области.",
    "complexity": 82,
    "memory": 64000,
    "time": 1000,
    "examples": [
      {
        "input": "4 1\n1 1\n10 2\n1 3\n10 4",
        "output": "30"
      },
      {
        "input": "4 2\n1 1\n10 2\n1 3\n10 4",
        "output": "10"
      },
      {
        "input": "1 1\n1 1",
        "output": "0"
      },
      {
        "input": "3 3\n3 3\n3 6\n6 3",
        "output": "7"
      }
    ]
  },
  {
    "id": 799,
    "name": "Чемпионат по стрельбе",
    "description": "Победитель школьного этапа олимпиады по информатике нашел дома в старых бумагах результаты чемпионата страны по стрельбе из лука, в котором участвовал его папа. К сожалению, листок с результатами сильно пострадал от времени, и разобрать фамилии участников было невозможно. Остались только набранные каждым участником очки, причем расположились они в том порядке, в котором участники чемпионата выполняли стрельбу.\nOUTPUT.TXT62315 15 10110[Лучшие попытки]\nРасспросив папу, школьник выяснил, что количество очков, которое набрал папа, заканчивается на 5, хотя бы один из победителей чемпионата стрелял раньше, а папин друг, который стрелял сразу после папы, набрал меньше очков. Теперь он заинтересовался, какое самое высокое место мог занять его папа на том чемпионате.\n3310 15 200[Решение]\nБудем считать, что участник соревнования занял k-е место, если ровно \n(k – 1) участников чемпионата набрали строго больше очков, чем он. При этом победителями считались все участники чемпионата, занявшие первое место.\nТребуется написать программу, которая по заданным результатам чемпионата определяет, какое самое высокое место на чемпионате мог занять папа победителя школьного этапа олимпиады по информатике.\nВходные данные\nПервая строка входного файла INPUT.TXT содержит целое число n — количество участников чемпионата страны по стрельбе (3 ≤ n ≤ 105). Вторая строка содержит n положительных целых чисел, каждое из которых не превышает 1000, — очки участников чемпионата, приведенные в том порядке, в котором они выполняли стрельбу.\nВыходные данные\nВ выходном файле OUTPUT.TXT должно содержаться одно целое число — самое высокое место, которое мог занять папа школьника. Если не существует ни одного участника чемпионата, который удовлетворяет, описанным выше условиям, выведите в выходной файл число 0.",
    "complexity": 32,
    "memory": 16000,
    "time": 1000,
    "examples": [
      {
        "input": "7\n10 20 15 10 30 5 1",
        "output": "6"
      },
      {
        "input": "3\n15 15 10",
        "output": "1"
      },
      {
        "input": "3\n10 15 20",
        "output": "0"
      }
    ]
  },
  {
    "id": 719,
    "name": "Фотограф-псих",
    "description": "Пришел как-то раз в гости к фотографу-зануде его двоюродный брат, и начали они спорить о том, кто сколько человек сфотографировал и кто больше фотографий сделал. После долгого подсчета выяснилось, что фотограф-зануда выиграл. Брату это, естественно, не понравилось, поэтому он пошел к себе ставить новый рекорд.\nOUTPUT.TXT2262270208001313[Лучшие попытки]\nДля этого он пригласил к себе N человек и фотографировал их, располагая всеми различными способами вдоль одной линии. Всего получилось F фотографий.\n[Решение]\nРазумеется, сделать их за один день он не смог, так как в ближайших магазинах попросту не хватало фотопленки.  Когда же он закончил работу, он приступил к рассылке извещений всем своим клиентам. Каждое извещение помещается в отдельный конверт и отправляется по адресу прописки клиента.\nПомогите фотографу определить число конвертов, которое необходимо закупить, если известно число фотографий F. Известно также, что число клиентов положительное и не превышает 105.\nВходные данные\nВ единственной строке входного файла INPUT.TXT содержится натуральное число F, не превосходящее 10500000.\nВыходные данные\nВ единственную строку выходного файла OUTPUT.TXT нужно вывести одно натуральное число — количество конвертов для закупки.",
    "complexity": 43,
    "memory": 16000,
    "time": 1000,
    "examples": [
      {
        "input": "2",
        "output": "2"
      },
      {
        "input": "6227020800",
        "output": "13"
      }
    ]
  },
  {
    "id": 720,
    "name": "Клетки в кругу",
    "description": "Дан действительный радиус круга R и размер клетки L на клеточной бумаге. Известно, что центр круга находится на пересечении линий. Требуется найти число целых клеток, лежащих внутри круга. 0 ≤ R ≤ 25000, 1 \u003c L \u003c 100.\nOUTPUT.TXT60[Лучшие попытки]\nВходные данные[Решение]\nВ единственной строке входного файла INPUT.TXT находятся действительное число R, заданное не более чем с 9 цифрами после десятичной точки, и натуральное число L, разделенные пробелом.\nВыходные данные\nВ единственную строку выходного файла OUTPUT.TXT нужно вывести одно натуральное число — количество клеток, целиком лежащих в кругу.",
    "complexity": 32,
    "memory": 16000,
    "time": 1000,
    "examples": [
      {
        "input": "5 1",
        "output": "60"
      }
    ]
  },
  {
    "id": 609,
    "name": "Разбиения множества",
    "description": "Выходные данные\nВ выходной файл OUTPUT.TXT для каждого теста выведите следующее в лексикографическом порядке разбиение. Если разбиение во входном файле является последним в лексикографическом порядке, выведите первое в лексикографическом порядке. Используйте тот же формат, что и во входном файле. Отделяйте разбиения друг от друга пустыми строками. Элементы каждого множества следует выводить в порядке возрастания.",
    "complexity": 69,
    "memory": 16000,
    "time": 1000,
    "examples": [
      {
        "input": "5 2\n\n1 2 3\n\n4 5\n\n\n\n5 2\n\n1 3 5\n\n2 4\n\n\n\n5 1\n\n1 2 3 4 5\n\n\n\n5 5\n\n1\n\n2\n\n3\n\n4\n\n5\n\n\n\n0 0",
        "output": "5 2\n\n1 2 3 4\n\n5\n\n\n\n5 4\n\n1 4\n\n2\n\n3\n\n5\n\n\n\n5 2\n\n1 2 3 5\n\n4\n\n\n\n5 4\n\n1\n\n2\n\n3\n\n4 5"
      }
    ]
  },
  {
    "id": 721,
    "name": "Стрелки - 2",
    "description": "OUTPUT.TXT\nRRRD\nUUDL\n.UL.\n\nRLDD\nRLUU\n.RL.[Лучшие попытки]\nКостя нашел головоломку, в которую его дедушка играл в детстве - доску n_m клеток, на некоторых из которых прикреплены вращающиеся стрелки (Костя предполагает, что раньше стрелки были на всех клетках). К сожалению, дедушка уже не помнит, что нужно было сделать в этой головоломке, поэтому Костя придумывает правила сам.\nОн заметил следующую особенность. Направим каждую стрелку на одну из соседних клеток, на которой тоже есть стрелка (оказалось, что одиноко стоящих стрелок на доске нет). Теперь на доске появились циклы, идя по которым, мы всегда будем идти по направлению стрелок. Например, при расстановке, которая отражена на рисунке, есть четыре цикла.\nКостя придумал сразу два задания: «поставить стрелки так, чтобы число циклов было минимально», и «поставить стрелки так, чтобы число циклов было максимально». Пока Костя ищет решение вручную, напишите программу, находящую требуемые расстановки.\nВходные данные\nВходной файл INPUT.TXT содержит Первая строка входного файла содержит числа n и m (1 ≤ n, m ≤ 100). Следующие n строк по m символов содержат описание доски: символ «?» соответствует клетке со стрелкой, а символ «.» - пустой клетке.\nВыходные данные\nВ выходной файл OUTPUT.TXT выведите сначала расстановку, в которой число циклов минимально, а затем расстановку, в которой число циклов максимально. Разделите расстановки одной пустой строкой.\nРасстановку стрелок выводите, заменив в описании доски символы «?» на символы, соответствующие направлениям стрелок. Используйте символы «R», «L», «U» и «D» для обозначения направлений вправо, влево, вверх и вниз соответственно.",
    "complexity": 68,
    "memory": 16000,
    "time": 1000,
    "examples": [
      {
        "input": "3 4\n\n????\n\n????\n\n.??.",
        "output": "RRRD\n\nUUDL\n\n.UL.\n\n\n\nRLDD\n\nRLUU\n\n.RL."
      }
    ]
  },
  {
    "id": 610,
    "name": "Прокладка труб",
    "description": "В некоторых районах города строится система центрального отопления. Каждый район города имеет форму прямоугольника и состоит из квадратных кварталов. Система центрального отопления каждого из районов представляет собой замкнутую трубу.\nOUTPUT.TXT625 7001102283239429[Лучшие попытки]\nЧтобы сантехникам не приходилось скучать, мэр города хочет, чтобы в каждом районе трубы были уложены по-разному. Труба в каждом районе должна быть уложена таким образом, чтобы она проходила через каждый квартал. При этом существует шесть способов проложить трубу внутри квартала:\n32 81\n412 8102283239429\nДля того, чтобы спланировать работы, мэр хочет узнать, сколькими способами можно проложить трубу в каждом районе.\nНапример, существует ровно 6 различных способов проложить трубу в районе из 16 кварталов, имеющего форму квадрата 4 на 4:\nВходные данные\nВходной файл INPUT.TXT содержит два целых числа r (r \u003e 1) и c (c \u003e 1) - размеры района города. Общее число кварталов в районе не превосходит 100 (r×c ≤ 100).\nВыходные данные\nВ выходной файл OUTPUT.TXT выведите число различных способов проложить трубу в данном районе.",
    "complexity": 82,
    "memory": 16000,
    "time": 1000,
    "examples": [
      {
        "input": "4 4",
        "output": "6"
      },
      {
        "input": "5 7",
        "output": "0"
      },
      {
        "input": "2 8",
        "output": "1"
      },
      {
        "input": "12 8",
        "output": "102283239429"
      }
    ]
  },
  {
    "id": 800,
    "name": "Делители - 2",
    "description": "Натуральное число a называется делителем натурального числа b, если b = ac для некоторого натурального числа c. Например, делителями числа 6 являются числа 1, 2, 3 и 6. Два числа называются взаимно простыми, если у них нет общих делителей кроме 1. Например, 16 и 27 взаимно просты, а 18 и 24 – нет.\nkkчисла ai и ai+1 для всех i от 1 до k – 1 являются взаимно простыми;kOUTPUT.TXT16210 244[Лучшие попытки]\nБудем называть нормальным набор из k чисел (a1, a2, …, ak), если выполнены следующие условия:\nпроизведение a1a2 … ak не превышает n.\nкаждое из чисел ai является делителем числа n;\nвыполняется неравенство a1 \u003c a2 \u003c … \u003c ak;\nчисла ai и ai+1 для всех i от 1 до k – 1 являются взаимно простыми;\nпроизведение a1a2 … ak не превышает n.\nНапример, набор (2, 9, 10) является нормальным набором из 3 делителей числа 360.\nТребуется написать программу, которая по заданным значениям n и k определяет количество нормальных наборов из k делителей числа n.\nВходные данные\nПервая строка входного файла INPUT.TXT содержит два целых числа: n и k (2 ≤ n ≤ 108, 2 ≤ k ≤ 10).\nВыходные данные\nВ выходном файле OUTPUT.TXT должно содержаться одно число – количество нормальных наборов из k делителей числа n.",
    "complexity": 55,
    "memory": 16000,
    "time": 1000,
    "examples": [
      {
        "input": "90 3",
        "output": "16"
      },
      {
        "input": "10 2",
        "output": "4"
      }
    ]
  },
  {
    "id": 722,
    "name": "Шоколадки",
    "description": "Рома играет сам с собой в очень интересную игру. Для нее нужна коробка конфет, в которой конфеты расположены прямоугольником n×m штук. В игре участвуют конфеты из темного и белого шоколада. Сначала коробка заполняется конфетами произвольным образом. Далее Рома повторяет следующие операции. Он находит три конфеты одного цвета, лежащие рядом (в ряд, или в виде буквы «Г»), съедает их и заполняет освободившиеся места новыми конфетами произвольным образом. Если же он не находит трех конфет одного цвета, лежащих рядом, то игра заканчивается.\nOUTPUT.TXT8[Лучшие попытки]\nПосчитайте, сколько различных комбинаций может остаться на доске (то есть, в коробке) после окончания игры. Например, если n = 2, m = 3, то может остаться восемь различных комбинаций:\n(здесь символами «B» и «W» обозначены конфеты из темного и белого шоколада соответственно)\nВходные данные\nВходной файл INPUT.TXT содержит два целых числа - n и m. (1 ≤ n, m ≤ 1000).\nВыходные данные\nВ выходной файл OUTPUT.TXT выведите одно число - ответ на вопрос задачи.",
    "complexity": 60,
    "memory": 16000,
    "time": 1000,
    "examples": [
      {
        "input": "2 3",
        "output": "8"
      }
    ]
  },
  {
    "id": 615,
    "name": "Новый год",
    "description": "Санта Клаус решил сделать новогодний подарок своим эльфам. Конечно же, Санта был бы не Санта, если бы его подарок был обыкновенным. Подарок просто замечательный - эльфы идут в кино!\niOUTPUT.TXT1142 3 4 6[Лучшие попытки]\nКонечно же, если все эльфы пойдут в кино одновременно, это может показаться кому-нибудь подозрительным. Ну, вы понимаете, некоторые люди все еще не верят в эльфов. Так что каждый день ровно одна пара эльфов пойдет в кино. Конечно, идти в кино самому по себе неинтересно, гораздо интереснее пойти с другом или подругой. Таким образом, каждый день один мальчик-эльф и одна девочка-эльф вместе пойдут в кино.\ni\nНо эльфы, они такие разные. Каждый эльф четко знает, с какими эльфами и на какой фильм он или она хотели бы пойти. Поскольку у каждой пары эльфов свои взаимоотношения, для каждой пары, которая согласна вместе пойти в кинотеатр, известно какой именно фильм они хотели бы посмотреть.\ni\nНо на самом деле все еще хуже. Дело в том, что билеты в кино стоят денег. Конечно, Санта не беден, но ему нужно много денег на подарки детям. Так что собрав у эльфов пожелания, кто куда и с кем хотел бы пойти в кино, Санта решил удовлетворить некоторые пожелания таким образом, чтобы потратив как можно меньше денег, добиться того, что каждый эльф хотя бы один раз побывает в кино.\ni\nПомогите Санте, он пока не до конца освоился с компьютером.\ni\nВходные данные\nПервая строка входного файла INPUT.TXT содержит два целых числа n и m - количество мальчиков-эльфов и девочек-эльфов, соответственно (1 ≤ n, m ≤ 100). Вторая строка содержит r – количество пожеланий, которое Санта получил от своих эльфов (1 ≤ r ≤ 1500). Следующие r строк содержат по три целых числа ai, bi и ci каждая. Числа означают, что мальчик-эльф ai хотел бы пойти в кино с девочкой-эльфом bi, и билет на фильм, на который они хотели бы пойти, стоит ci (1 ≤ ci ≤ 1000). Каждый эльф хочет пойти в кино хотя бы с одним другим эльфом.\nВыходные данные\nНа первой строке выходного файла OUTPUT.TXT выведите минимальную сумму, которую Санте придется потратить, чтобы сделать своим эльфам подарок. На второй строке выведите k - количество билетов, которое Санта должен купить. Наконец, третья строка должна содержать k целых чисел – номера пожеланий, которые следует удовлетворить.",
    "complexity": 71,
    "memory": 16000,
    "time": 1000,
    "examples": [
      {
        "input": "3 3\n\n7\n\n1 1 3\n\n1 2 2\n\n1 3 4\n\n2 1 3\n\n2 2 9\n\n3 1 2\n\n3 3 11",
        "output": "11\n4\n2 3 4 6"
      }
    ]
  },
  {
    "id": 612,
    "name": "Подстрока",
    "description": "Рассмотрим слова, состоящие из букв «A», «B», «a» и «b». Скажем, что два слова эквивалентны, если одно может быть получено из другого с помощью следующих операций:\nOUTPUT.TXTaAaBabaAbA[Лучшие попытки]\nудалить в любой позиции подстроку, равную Aa, aA, Bb или bB;\nдобавить в любую позицию подстроку, равную Aa, aA, Bb или bB.\nНапример, слова abAaBBabbA и aAaBabaAbA эквивалентны:\nabAaBBabbA → abBBabbA → aBabbA → aAaBabbA → aAaBabaAbA,\nа слова abAB и baBA - нет.\nИнтересно отметить, что для произвольных слов X и Y найдется такое слово Z, эквивалентное X, которое содержит Y в качестве подстроки. Ваша задача - найти кратчайшее такое слово.\nВходные данные\nПервая строка входного файла INPUT.TXT содержит X. Вторая строка содержит Y. Оба слова непустые и каждое из них имеет длину не больше 2000.\nВыходные данные\nВ выходной файл OUTPUT.TXT выведите одну строку, содержащую минимальное по длине слово, эквивалентное X, содержащее Y в качестве подстроки. Если решений несколько, выведите любое.",
    "complexity": 68,
    "memory": 32000,
    "time": 1000,
    "examples": [
      {
        "input": "abAaBBabbA\nAaBaba",
        "output": "aAaBabaAbA"
      }
    ]
  },
  {
    "id": 611,
    "name": "Словарные квадраты",
    "description": "Некоторые наборы из n слов длины n обладают интересным свойством - их можно расположить в клетках квадрата n×n так, что все слова набора можно прочитать как в вертикали, так и по горизонтали.\nOUTPUT.TXTCRAB\nRARE\nARTS\nBEST\n\nFIND\nIDEA\nNEXT\nDATE[Лучшие попытки]\nПримером такого набора слов является {\"DATE\", \"FIND\", \"IDEA\", \"NEXT\"}. Их можно расположить так:\nЗаметьте, что каждое слово можно прочитать как по горизонтали, так и по вертикали. Такие квадраты называются словарными квадратами, наибольший известный словарный квадрат в английском языке имеет размер 10×10.\nРассмотрим еще один пример словарного квадрата:\nВам даны такие 2n слов, что из них можно построить два различных словарных квадрата размера n×n. Ваша задача состоит в том, чтобы разбить эти слова на две группы, по n слов в каждой, и построить из слов каждой группы словарный квадрат.\nГарантируется, что все данные вам слова являются английскими словами (некоторые из них могут быть достаточно редкими словами, именами, или специальными терминами).\nВходные данные\nПервая строка входного файла INPUT.TXT содержит целое число n (2 ≤ n ≤ 10). Каждая из следующих 2n строк содержит слово, состоящее из заглавных букв английского алфавита. Каждое слово содержит ровно n букв.\nВыходные данные\nВ выходной файл OUTPUT.TXT выведите два словарных квадрата, построенных из данных слов. Разделите квадраты пустой строкой.",
    "complexity": 50,
    "memory": 16000,
    "time": 1000,
    "examples": [
      {
        "input": "4\n\nARTS\n\nBEST\n\nCRAB\n\nDATE\n\nFIND\n\nIDEA\n\nNEXT\n\nRARE",
        "output": "CRAB\n\nRARE\n\nARTS\n\nBEST\n\n\n\nFIND\n\nIDEA\n\nNEXT\n\nDATE"
      }
    ]
  },
  {
    "id": 613,
    "name": "Поле чудес - 2",
    "description": "Всем известно сверхпопулярное теле-шоу «Поле чудес».\nOUTPUT.TXT0.4648222937[Лучшие попытки]\nВ игре принимают участие n человек. Их цель - отгадать загаданное слово. Изначально известна только длина слова, а буквы на специальном табло закрыты черными прямоугольниками. В свой ход игрок называет одну букву. Если эта буква встречается в слове, то все ее вхождения открываются, и игрок делает еще один ход. Если в слове нет такой буквы, то ход передается следующему игроку. От последнего игрока ход передается первому. Выигрывает тот игрок, который отгадывает последнюю букву.\nПусть, например, загадано секретное слово «CONTEST». Изначально игроки видят только «-------». Если первый игрок скажет 'E', то она открывается, и теперь табло выглядит как «----E--». Первый игрок делает еще один ход - пусть, например, он называет 'A'. В слове нет такой буквы, поэтому ход передается следующему игроку. Если тот скажет 'T', то игроки увидят «---TE-T», и так далее.\nПашин друг собирается поучаствовать в игре. Павлу интересно: каковы шансы на победу его друга. Паша оценил интеллектуальный потенциал каждого из игроков qt. Вероятность того, что игрок t правильно отгадает букву в ситуации, когда еще не были названы i букв, неизвестны еще j разных букв слова, и на табло осталось k закрытых букв, вычисляется по следующей формуле:\nЗдесь мы будем считать, что 00 = 1.\nВероятности угадывания каждой из все еще неизвестных букв слова одинаковы. По заданным n, очереди хода друга Павла r, загаданному слову и значениям интеллектуального потенциала игроков, определите вероятность того, что Пашин друг победит в игре.\nВходные данные\nПервая строка входного файла INPUT.TXT содержит n и r (2 ≤ n ≤ 10, 1 ≤ r ≤ n). На второй строке записано загаданное слово. Оно состоит из больших букв английского алфавита, и его длина не превосходит 12. Третья строка содержит n вещественных чисел - значения интеллектуального потенциала игроков (0 ≤ qt ≤ 0.99).\nВыходные данные\nВ выходной файл OUTPUT.TXT выведите одно число - вероятность победы друга Павла. Ответ должен быть дан с точностью, не хуже, чем 10-8.",
    "complexity": 76,
    "memory": 32000,
    "time": 1000,
    "examples": [
      {
        "input": "3 1\nCONTEST\n0.7 0.2 0.1",
        "output": "0.4648222937"
      }
    ]
  },
  {
    "id": 614,
    "name": "Скобки - 3",
    "description": "Рассмотрим скобочные последовательности с одним типом скобок. Для заданной скобочной последовательности найдите количество ее подпоследовательностей, которые являются правильными скобочными последовательностями.\nOUTPUT.TXT8[Лучшие попытки]\nНапример, для последовательности \"((())())(\" таких последовательностей восемь: \"((())())\", \"(())()\", \"((()))\", \"(()())\", \"(())\", \"()()\", \"()\" и \"\".\nВходные данные\nВходной файл INPUT.TXT содержит последовательность, состоящую не более чем из 300 круглых скобок.\nВыходные данные\nВ выходной файл OUTPUT.TXT выведите количество различных правильных скобочных подпоследовательностей заданной последовательности.",
    "complexity": 61,
    "memory": 32000,
    "time": 1000,
    "examples": [
      {
        "input": "((())())(",
        "output": "8"
      }
    ]
  },
  {
    "id": 618,
    "name": "Диаграммы Юнга",
    "description": "Диаграммы Юнга используются для того, чтобы изобразить разбиение числа на слагаемые. Разбиение числа n на слагаемые представляет собой сумму вида n = m1 + m2 + … + mk, где m1 ≥ m2 ≥ … ≥ mk.\nOUTPUT.TXT414 2 2 1 1[Лучшие попытки]\nДиаграмма состоит из n квадратиков, организованных в виде k рядов, где k количество слагаемых в разбиении. Ряд, соответствующий числу mi, содержит mi квадратиков. Все ряды выровнены по левому краю и упорядочены от более длинного к более короткому.\nНапример, диаграмма Юнга, приведенная на рисунке, соответствует разбиению 10 = 5 + 3 + 2.\nИногда можно вписать одну диаграмму Юнга в другую. Диаграмму X можно вписать в диаграмму Y , если можно удалить некоторые квадратики из диаграммы Y так, чтобы получилась диаграмма X. Отметим, что разрешается только удалять некоторые квадратики, вращать или отражать диаграмму не разрешается. Например, диаграмма для разбиения 5 = 3 + 2 может быть вписана в диаграмму для разбиения 10 = 5 + 3 + 2, как показано на рисунке.\nС другой стороны, диаграмму для разбиения 8 = 4+4 нельзя вписать в диаграмму для разбиения 10 = 5 + 3 + 2.\nДля заданного n найдите такое разбиение n на слагаемые, что в соответствующую ему диаграмму Юнга можно вписать максимальное количество различных диаграмм.\nНапример, в диаграмму для разбиения 10 = 5 + 3 + 2 можно вписать 36 различных диаграмм. Однако это не максимальное значение. В диаграмму для разбиения 10 = 4 + 2 + 2 + 1 + 1 можно вписать 41 диаграмму Юнга.\nВходные данные\nВходной файл INPUT.TXT содержит целое число n (1 ≤ n ≤ 100).\nВыходные данные\nНа первой строке выходного файла OUTPUT.TXT выведите максимальное число диаграмм Юнга, которые можно вписать в некоторую диаграмму, соответствующую разбиению на слагаемые числа n. На второй строке выведите одно или более целых чисел - количество квадратиков в каждом из рядов оптимальной диаграммы.",
    "complexity": 74,
    "memory": 16000,
    "time": 1000,
    "examples": [
      {
        "input": "10",
        "output": "41\n4 2 2 1 1"
      }
    ]
  },
  {
    "id": 616,
    "name": "Отношения",
    "description": "n1OUTPUT.TXTYES\n0 1 2\n2 1 023\n110\n101\n011NONO[Лучшие попытки]\nБинарным отношением R на множестве X называется множество упорядоченных пар элементов из X. Если X конечно и содержит n элементов, то отношение можно задать как квадратную булеву матрицу размера n×n.\ni2\nВ некоторых случаях бывает важно задать отношение в более компактной форме. Один из способов компактного задания отношений применяется, в частности, при описании грамматик операторного предшествования.\njn\nРассмотрим две функции f и g, каждая из которых сопоставляет элементам X целые числа. Будем говорить, что эти функции описывают отношение R, если для любых x и y из X пара (x, y) принадлежит R тогда и только тогда, когда f(x) ≤ g(y).\nПо заданному отношению R, найдите способ описать его указанным образом с помощью двух функций f и g, либо выясните, что это невозможно сделать.\nВходные данные\nПервая строка входного файла INPUT.TXT содержит n - количество элементов в множестве X = {x1, x2, …, xn} (1 ≤ n ≤ 1 000). Следующие n строк описывают отношение R. Каждая строка содержит n символов, j-й символ i-й из этих строк равен 1, если (xi, xj) принадлежит R, и 0 в противном случае.\nВыходные данные\nНа первой строке выходного файла OUTPUT.TXT выведите \"YES\", если отношение можно описать указанным образом. В этом случае вторая строка должна содержать n целых чисел в диапазоне от -109 до 109 - значения функции f на элементах x1, x2, … , xn, соответственно, а третья строка должна описывать функцию g аналогичным образом.\nЕсли отношение нельзя закодировать описанным образом с помощью двух функций, выведите \"NO\" на первой строке выходного файла.",
    "complexity": 54,
    "memory": 16000,
    "time": 1000,
    "examples": [
      {
        "input": "3\n\n111\n\n110\n\n100",
        "output": "YES\n\n0 1 2\n\n2 1 0"
      },
      {
        "input": "3\n\n110\n\n101\n\n011",
        "output": "NO"
      }
    ]
  },
  {
    "id": 617,
    "name": "Ладьи",
    "description": "Напомним, что ладья - это шахматная фигура, которая ходит по вертикалям и горизонталям.\nOUTPUT.TXT18[Лучшие попытки]\nБудем называть расстановку w белых и b черных ладей на доске размера m×n мирной, если ни одна ладья не угрожает ладье другого цвета.\nДля заданных m, n, w и b найдите количество мирных расстановок ладей на доске.\nВходные данные\nВходной файл INPUT.TXT содержит четыре целых числа: m, n, w и b (2 ≤ m, n ≤ 10, 1 ≤ w, 1 ≤ b, w+b ≤ m•n).\nВыходные данные\nВ выходной файл OUTPUT.TXT выведите одно целое число - количество мирных расстановок w белых и b черных ладей на доске размера m×n.",
    "complexity": 80,
    "memory": 16000,
    "time": 1000,
    "examples": [
      {
        "input": "3 3 2 2",
        "output": "18"
      }
    ]
  },
  {
    "id": 619,
    "name": "Бросание кубика",
    "description": "Кубик, грани которого помечены цифрами от 1 до 6, бросают N раз. Требуется найти вероятность того, что сумма выпавших чисел будет равна Q.\nOUTPUT.TXT0.16666721 7000.1126541.530647E-78[Лучшие попытки]\nВходные данные34 140.112654\nВходной файл INPUT.TXT содержит натуральные числа N и Q (N ≤ 500, Q ≤ 3000).\n4100 1001.530647E-78\nВыходные данные\nВ выходной файл OUTPUT.TXT выведите единственное вещественное число – искомую вероятность, которая должна отличаться от истинного значения не более чем на 10-6.",
    "complexity": 42,
    "memory": 16000,
    "time": 1000,
    "examples": [
      {
        "input": "1 6",
        "output": "0.166667"
      },
      {
        "input": "1 7",
        "output": "0"
      },
      {
        "input": "4 14",
        "output": "0.112654"
      },
      {
        "input": "100 100",
        "output": "1.530647E-78"
      }
    ]
  },
  {
    "id": 620,
    "name": "Бассейн реки",
    "description": "",
    "complexity": 67,
    "memory": 16000,
    "time": 1000,
    "examples": [
      {
        "input": "6",
        "output": "9"
      },
      {
        "input": "11",
        "output": ""
      },
      {
        "input": "12",
        "output": ""
      },
      {
        "input": "10",
        "output": ""
      },
      {
        "input": "7",
        "output": ""
      },
      {
        "input": "7",
        "output": "9"
      },
      {
        "input": "7",
        "output": ""
      },
      {
        "input": "5,5",
        "output": ""
      },
      {
        "input": "3",
        "output": "10"
      },
      {
        "input": "8",
        "output": ""
      },
      {
        "input": "6",
        "output": ""
      },
      {
        "input": "5,5",
        "output": ""
      },
      {
        "input": "5",
        "output": ""
      },
      {
        "input": "5",
        "output": ""
      },
      {
        "input": "3\n\n5\n\n6 9\n\n5 11\n\n3 12\n\n2 10\n\n1 7\n\n3\n\n7 9\n\n5 7\n\n5 5.5\n\n6\n\n3 10\n\n5 8\n\n4 6\n\n5 5.5\n\n6 5\n\n3 5",
        "output": "16.00"
      },
      {
        "input": "2\n\n5\n\n6 9\n\n5 11\n\n3 12\n\n2 10\n\n1 7\n\n6\n\n3 10\n\n5 8\n\n4 6\n\n5 5.5\n\n6 5\n\n3 5",
        "output": "12.50"
      }
    ]
  },
  {
    "id": 621,
    "name": "Ближайшее число",
    "description": "Дана матрица A размером N×N, заполненная неотрицательными целыми числами. Расстояние между двумя элементами Ai j и Ap q определено как |i - p| + |j - q|. Требуется заменить каждый нулевой элемент матрицы ближайшим ненулевым. Если есть две или больше ближайших ненулевых ячейки, нуль должен быть оставлен.\nOUTPUT.TXT1 0 21 0 20 3 0[Лучшие попытки]\nВходные данные\nВ первой строке входного файла INPUT.TXT содержится натуральное число N (N ≤ 200). Затем идут N строк по N чисел, разделённых пробелами и представляющих собой матрицу. Элементы матрицы не превосходят значения 106. Входные данные могут содержать несколько пробелов подряд, пробелы до первого числа строки и после последнего.\nВыходные данные\nВ выходной файл OUTPUT.TXT выведите N строк по N чисел, разделённых пробелами, - модифицированную матрицу.",
    "complexity": 52,
    "memory": 16000,
    "time": 1000,
    "examples": [
      {
        "input": "3\n0 0 0\n1 0 2\n0 3 0",
        "output": "1 0 2\n1 0 2\n0 3 0"
      }
    ]
  },
  {
    "id": 724,
    "name": "Убить Вову",
    "description": "Таня хочет убить Вову. Разумеется, виртуально. Сначала Вова выбирает одну из n тактик защиты, потом Таня, не зная, какую тактику выбрал Вова, атакует несколько раз, каждый раз выбирая одну из m тактик нападения. Для каждой тактики защиты известно, от каких тактик нападения она защищает. Помогите Тане узнать, за сколько атак она может гарантированно убить Вову и какие тактики нападения ей нужно для этого использовать.\nOUTPUT.TXT3\n2 4 523 3\n1 1 1\n0 1 0\n0 0 1ImpossibleImpossible[Лучшие попытки]\nВходные данные\nПервая строка входного файла INPUT.TXT содержит два числа - n и m. (1 ≤ n, m ≤ 20). Далее идут n строк по m чисел, j-е число в i-ой строке равно 1, если тактика защиты i спасает от тактики нападения j и равно 0 в противном случае.\nВыходные данные\nВыведите в выходной файл OUTPUT.TXT число k - минимальное число атак, за которое можно гарантированно убить Вову и далее k чисел - номера стратегий нападения, которые нужно использовать. Если Вову убить невозможно, выведите строку «Impossible».",
    "complexity": 50,
    "memory": 16000,
    "time": 1000,
    "examples": [
      {
        "input": "4 5\n\n1 0 0 0 0\n\n1 1 1 0 1\n\n1 0 1 1 1\n\n1 1 0 1 0",
        "output": "3\n\n2 4 5"
      },
      {
        "input": "3 3\n\n1 1 1\n\n0 1 0\n\n0 0 1",
        "output": "Impossible"
      }
    ]
  },
  {
    "id": 723,
    "name": "Доставка грибов",
    "description": "Леша работает в службе доставки сушеных грибов. Некоторые клиенты жалуются, что грибы доставляются слишком долго. Леша хочет проверить, не является ли это следствием неэффективной системы доставки.\niiOUTPUT.TXT2 5 6 8 -1[Лучшие попытки]\nСистема доставки устроена следующим образом. Существуют n распределительных пунктов, между некоторыми из которых есть односторонние каналы доставки. Грибы могут быть перевезены из пункта ai в пункт bi за время ti. С основной базы грибы поступают на пункт номер 1 и далее доставляются до нужного пункта по каналам доставки. Система каналов довольна сложна, так что есть несколько путей, по которым можно доставить грибы до некоторых пунктов. При этом никто не следит за тем, чтобы выбранный путь был самым коротким.\ni\nЛеша хочет узнать для каждого пункта, какое максимальное время до него могут идти грибы от первого пункта при условии, что на промежуточных пунктах грибы не задерживаются.\ni\nВходные данныеi\nВ первой строке входного файла INPUT.TXT содержатся числа n и m - количество распределительных пунктов и количество каналов доставки (2 ≤ n ≤ 100, 1 ≤ m ≤ 10000). Далее следуют m троек ai, bi, ti (ai ≠ bi, 1 ≤ ti ≤ 100).\nВыходные данные\nВ выходной файл OUTPUT.TXT выведите n-1 число – максимальное время доставки грибов до второго, третьего, …, n-го пункта. Если грибы до пункта могут идти сколь угодно долго, выведите вместо соответствующего числа -1.",
    "complexity": 70,
    "memory": 16000,
    "time": 1000,
    "examples": [
      {
        "input": "6 7\n\n1 2 2\n\n2 3 3\n\n1 3 1\n\n3 4 1\n\n4 5 2\n\n5 3 1\n\n3 6 1",
        "output": "2 5 6 8 -1"
      }
    ]
  },
  {
    "id": 622,
    "name": "Прямоугольное деление",
    "description": "Дано N прямоугольников со сторонами, параллельными осям координат. Требуется определить, на сколько частей эти прямоугольники разбивают плоскость (внутри частей не должно быть границ прямоугольников).\n2OUTPUT.TXT6[Лучшие попытки]\nВходные данные2\nВ первой строке входного файла INPUT.TXT содержится число прямоугольников N (1 ≤ N ≤ 100). Далее идут N строк, содержащих по 4 числа x1, y1, x2, y2 - координаты двух противоположных углов прямоугольника. Координаты представляют собой целые числа и по абсолютной величине не превосходят 10 000.\nВыходные данные\nВ выходной файл OUTPUT.TXT выведите одно число - количество частей, на которые разбивается плоскость.",
    "complexity": 66,
    "memory": 16000,
    "time": 1000,
    "examples": [
      {
        "input": "3\n\n10 20 50 30\n\n40 10 50 25\n\n40 25 80 30",
        "output": "6"
      }
    ]
  },
  {
    "id": 725,
    "name": "Громоотвод",
    "description": "1OUTPUT.TXT4.898979485794484[Лучшие попытки]\nВ одном маленьком городке летом часто бывают грозы, поэтому жители решили на крыше одного из зданий установить громоотвод, защищающий все дома от ударов молнии. Громоотвод защищает точку в пространстве, если угол φ между направлением от вершины громоотвода до этой точки и отвесом не превышает некоторого угла φ0.\n1\nДля большей устойчивости громоотвода жители хотят сделать его минимально возможной высоты (высота измеряется от крыши дома, на котором устанавливается громоотвод). Помогите жителям найти минимально возможную высоту громоотвода, защищающего от молнии все здания города.\n2\nВходные данные2\nПервая строка входного файла INPUT.TXT содержит два целых числа: количество зданий n (1 ≤ n ≤ 10) и величину угла φ0 в градусах (1 ≤ φ0 ≤ 89). Следующие n строк описывают здания. Все здания имеют форму параллелепипедов со сторонами, параллельными координатным осям (ось z направлена вертикально вверх). Таким образом, каждое здание описывается пятеркой x1, y1, x2, y2, h, где x1, y1 и x2, y2 - координаты противоположных углов здания, h - его высота. 0 ≤ x1, y1, x2, y2 ≤ 1000, 1 ≤ h ≤ 1000, x1 \u003c x2, y1 \u003c y2, все числа целые.\n1\n1Выходные данные\n2\nВ выходной файл OUTPUT.TXT выведите минимально возможную высоту громоотвода, защищающего от молнии все здания города, с точностью не менее 10-2.\n2Пример\n1\n№INPUT.TXTOUTPUT.TXT\n12 30\n0 0 3 3 1\n3 3 4 4 14.898979485794484\n1\n2Для отправки решения задачи необходимо зарегистрироваться и авторизоваться!\n2\n\n  [Обсуждение]\n\n  [Все попытки]\n\n  [Лучшие попытки]\n1\n2\n\n\n\nwindow.yaContextCb.push(()=\u003e{\n  Ya.Context.AdvManager.render({\n    renderTo: 'yandex_rtb_R-A-122393-3',\n    blockId: 'R-A-122393-3'\n  })\n})\n1\n2",
    "complexity": 72,
    "memory": 16000,
    "time": 1000,
    "examples": [
      {
        "input": "2 30\n\n0 0 3 3 1\n\n3 3 4 4 1",
        "output": "4.898979485794484"
      }
    ]
  },
  {
    "id": 623,
    "name": "Снова Фибоначчи",
    "description": "Выходные данные\nВ выходной файл OUTPUT.TXT необходимо вывести одно число - последнюю цифру числа Fn.",
    "complexity": 23,
    "memory": 16000,
    "time": 1000,
    "examples": [
      {
        "input": "1",
        "output": "1"
      },
      {
        "input": "5",
        "output": "8"
      }
    ]
  },
  {
    "id": 624,
    "name": "Электронная почта",
    "description": "Современный мир немыслим без Интернета и электронной почты. Для того, чтобы людям было проще ориентироваться в потоке поступающих писем, были созданы специальные программы - почтовые клиенты. Фирма TIRLABS занимается разработкой почтового клиента The Bar!.\niOUTPUT.TXTYESNO212 32 1 -1\n4 239 -239 366 -366YESYES[Лучшие попытки]\nНедавно программисты компании завершили разработку очередной, 366239-ой, версии этого почтового клиента. Менеджеры по продажам и рекламе уже готовы вовсю рекламировать и продавать эту новую программу. Однако, генеральный директор компании TIRLABS считает, что любая программа должна быть подвергнута всестороннему тестированию, прежде чем она будет продаваться. «Да и не работающую программу, скорее всего, никто не купит!» - сказал он.\ni,j\nОдним из видов тестирования сложных программ является так называемое стресс-тестирование. При нем программа тестируется в экстремальных условиях, часто даже в таких, на какие она не рассчитана. Для тестирования The Bar! ver. 366239 был выбран такой метод: программа запускается на n компьютерах, стоящих в одной комнате, после чего с компьютеров друг на друга посылается m писем. При этом никакие два события (отправление или прием письма) не происходят одновременно, а сеть настолько надежна, что все письма доходят до адресата. Адресат у каждого письма при этом только один.\ni,j\nПочтовый клиент The Bar! в процессе работы ведет протокол, в который заносятся идентификаторы отправленных и полученных писем в том порядке, в котором они были обработаны почтовым клиентом. При этом при оценке результатов тестирования в расчет принимаются только события, отраженные в этом протоколе.\ni,j\nПрограмма считается правильно работающей по результатам тестирования, если всем событиям, указанным в протоколах, можно сопоставить моменты времени таким образом, что никакие два события не происходят одновременно, и каждое из писем отправляется до того, как получается. При этом, разумеется, внутри каждого из протоколов порядок событий должен остаться прежним.\ni,j\nДаны протоколы работы почтового клиента на каждом из компьютеров. Напишите программу, проверяющую, можно ли по результатам этого тестирования признать программу правильно работающей.\ni,j\nВходные данныеi,j\nВходной файл INPUT.TXT содержит несколько наборов входных данных. Первая строка содержит t - число наборов входных данных. Оставшиеся строки входного файла содержат эти наборы.\nОписание каждого набора начинается со строки, содержащей два целых числа n (1 ≤ n ≤ 50000) и m (1 ≤ m ≤ 100000) - количество компьютеров и отправленных писем соответственно. Далее следуют n строк, i-ая из которых содержит протокол работы почтового клиента на i-ом компьютере. Протокол работы состоит из целого числа ki(0 ≤ ki ≤ 2m) и ki чисел ai,j , описывающих события. Если ai,j \u003e 0, то j-ым по счету событием на i-ом компьютере была посылка письма с идентификатором ai,j , если же ai,j \u003c 0, то j-ым по счету событием на i-ом компьютере было получение письма с идентификатором -ai,j. Нулю ai,j равно быть не может.\nИдентификатор письма - это целое число от 1 до 106. Внутри одного набора входных данных все письма имеют различные идентификаторы. Гарантируется, что все письма, которые были отправлены, были кем-то приняты, то есть сумма всех ki в одном наборе входных данных равна 2m.\nСумма чисел n по всем наборам входных данных не превосходит 50000, сумма чисел m по всем наборам входных данных не превосходит 100000.\nВыходные данные\nВ выходной файл OUTPUT.TXT для каждого набора входных данных выведите ровно одну строку. Эта строка должна содержать слово YES, если программу можно считать правильно работающей по результатам тестирования, и NO - в противном случае.",
    "complexity": 62,
    "memory": 32000,
    "time": 1000,
    "examples": [
      {
        "input": "2\n\n2 2\n\n2 1 -2\n\n2 2 -1\n\n2 2\n\n2 -2 1\n\n2 -1 2",
        "output": "YES\nNO"
      },
      {
        "input": "1\n2 3\n2 1 -1\n\n4 239 -239 366 -366",
        "output": "YES"
      }
    ]
  },
  {
    "id": 726,
    "name": "Остатки",
    "description": "Саша устроился программистом в одну серьезную компанию. Однажды к нему зашел начальник и сказал: «Саша, что за бред выдает твоя программа? В одном месте у нее получается, что число 3∙n - нечетное, а в другом - что число 5∙n делится на 10. Ну и как такое может быть? У тебя что, по математике в школе было?». По математике у Саши была твердая тройка, поэтому, чтобы больше не попадать в такие неприятные ситуации, он просит вас написать программу, проверяющую, может ли число a∙n давать остаток b по модулю c, и в то же время число d∙n давать остаток e по модулю f.\nOUTPUT.TXTNO23 1 2 5 5 10YESYES[Лучшие попытки]\nВходные данные\nВходной файл INPUT.TXT содержит шесть целых чисел: a, b, c, d, e и f (1 ≤ a, c, d, f ≤ 109, 0 ≤ b ≤ c, 0 ≤ e ≤ f).\nВыходные данные\nВыведите в выходной файл OUTPUT.TXT строку «YES», если это возможно и «NO» в противном случае.",
    "complexity": 55,
    "memory": 16000,
    "time": 1000,
    "examples": [
      {
        "input": "3 1 2 5 0 10",
        "output": "NO"
      },
      {
        "input": "3 1 2 5 5 10",
        "output": "YES"
      }
    ]
  },
  {
    "id": 625,
    "name": "SMS - 2",
    "description": "В наше время непросто найти человека, который ни разу в жизни не использовал мобильный телефон для отправления текстовых сообщений. Старые телефоны поддерживали только один способ набора текста, упрощенно описывающийся следующими правилами: Каждой из восьми кнопок от «2» до «9» ставится в соответствие несколько букв, а кнопка «1» отводится для знаков препинания. Пробел ставится нажатием кнопки «0». Для ввода первого из соответствующих кнопке символов, ее надо нажать один раз, для ввода второго - два раза и так далее. Если два подряд идущие символа (кроме пробела) сопоставлены одной кнопке, то после ввода первого из них можно, либо подождать, либо нажать на кнопку перемещения курсора (второй вариант оказывается быстрее). Для переключения регистра букв используется кнопка «#». Кроме того, для удобства, после ввода вопросительного и восклицательного знаков, а так же точки (если на этот момент включен нижний регистр), активируется режим «первой заглавной буквы». При этом следующая буква автоматически печатается заглавной, после чего опять включается нижний регистр.  В начале набора включен режим «первой заглавной буквы».OUTPUT.TXT120[Лучшие попытки]\nВ последнее время в Интернете стали появляться результаты различных исследований, доказывающих неэффективность обычной раскладки телефонной клавиатуры, в которой буквы сопоставляются цифрам в алфавитном порядке. Составьте программу, которая по заданному сопоставлению букв кнопкам, будет находить минимальное количество нажатий, необходимых для максимально быстрого ввода данного текста при условии, что на каждое нажатие уходит одинаковое количество времени.\nВходные данные\nСтроки с первой по девятую входного файла INPUT.TXT задают символы, сопоставленные соответствующим кнопкам. Следующая строка содержит сообщение длиной от 1 до 1000 символов. Гарантируется, что в первой строке находятся символы «?», «!» и «.», заданные в определенном порядке; в последующих 8 строках расположены все строчные английские символы от «a» до «z» без повторов, не менее одной буквы в строке. Текст сообщения содержит только те символы, которые возможно напечатать.\nВыходные данные\nВ выходной файл OUTPUT.TXT выведите единственное число - минимальное количество нажатий на кнопки, требующееся для наискорейшего ввода сообщения.",
    "complexity": 50,
    "memory": 16000,
    "time": 1000,
    "examples": [
      {
        "input": ".?!\n\nabc\n\ndef\n\nghi\n\njkl\n\nmno\n\npqrs\n\ntuv\n\nwxyz\n\nHello. How do you do? i hope everything is fine See ya!",
        "output": "120"
      }
    ]
  },
  {
    "id": 626,
    "name": "Преобразователь строк",
    "description": "Преобразователь строк - это специальная компьютерная программа. Она получает на вход строку S и набор правил преобразования строки. Каждое из правил имеет вид c1c2 → E, где c1 и c2 - маленькие буквы английского алфавита. Символом E здесь обозначена пустая строка. При этом каждый символ присутствует не более, чем в одном правиле.\n1OUTPUT.TXTcba20\nabcdefghijklmnopqrstuvwxyzabcdefghijklmnopqrstuvwxyzabcdefghijklmnopqrstuvwxyz[Лучшие попытки]\n2\nПреобразователь строк работает по шагам. За один шаг он находит в текущей строке подстроку, совпадающую с правой частью одного из правил, после чего эта подстрока удаляется из текущей строки (этот процесс называется применением правила). Этот процесс продолжается до тех пор, пока существует правило, которое можно применить. Строка, которая остается к моменту, когда нельзя применить никакое правило, считается результатом T работы преобразователя строк.\nПусть, например, набор правил таков: {ab → E, cd → E}, а исходная строка S = aabbccdba. Тогда работа преобразователя будет выглядеть так: aabbccdba → abccdba → ccdba → cba, и результатом T работы преобразователя будет строка cba.\nВаша задача состоит в том, чтобы написать программу, моделирующую работу преобразователя строк с заданным набором правил на заданной строке S.\nВходные данные\nПервая строка входного файла INPUT.TXT содержит целое число n (0 ≤ n ≤ 13) - количество правил. Далее идут n строк, каждая из которых описывает одно из правил. Гарантируется, что каждая из маленьких букв английского алфавита присутствует не более, чем в одном правиле.\nПоследняя, (n+2)-ая строка входного файла содержит исходную строку S. Она не пуста и состоит только из маленьких букв английского алфавита. Длина S не превосходит 100000.\nВыходные данные\nВ выходной файл OUTPUT.TXT выведите строку T - результат работы преобразователя на строке S.",
    "complexity": 52,
    "memory": 16000,
    "time": 1000,
    "examples": [
      {
        "input": "2\nab\ncd\naabbccdba",
        "output": "cba"
      },
      {
        "input": "0\n\nabcdefghijklmnopqrstuvwxyz",
        "output": "abcdefghijklmnopqrstuvwxyz"
      }
    ]
  },
  {
    "id": 877,
    "name": "Диалоги по UCM",
    "description": "Федя живет активной жизнью онлайн. Он легко ищет самые сложные рефераты, используя всемирно известные поисковые машины, скачивает музыку и делится ею с друзьями, он присоединился к многим популярным сообществам в Jивом Jурнале. И конечно же, он много общается с интернет-друзьями по UCM (You Seek Me)  известному чат-клиенту.\nOUTPUT.TXT\"Privet!\" --- skazal Fedya.\n\"Privet,\" --- skazal Vasya.[Лучшие попытки]\nФедя учится в школе. В школе изучают русский язык. Однажды учительница задала домашнее задание  написать не менее 10-15 фраз, используя косвенную речь. Феде лень переписывать стандартные фразы из школьных учебников, он хочет мыслить нестандартно. И вот у Феди блеснула оригинальная идея – а не взять ли несколько диалогов из его любимого UCM и не перевести ли их в косвенную речь?\nИдея хороша, но, к сожалению, Федя не умеет программировать, так как его еще не учили этому в школе. Помогите ему!\nВходные данные\nВо входном файле находится распечатка одного из диалогов по UCM. В первой строке находится сообщение о том, что собеседник Феди вошел с ним в контакт. Оно выглядит так:\nЧЧ:ММ:СС: \u003cИмя\u003e signed on\nгде ЧЧ:ММ:СС – время, когда собеседник вошел в контакт, \u003cИмя\u003e – имя собеседника, записанное в транслите (английскими буквами). Любое число в отображении времени занимает две цифры, например, 9 часов 43 минуты 5 секунд будет выглядеть как 09:43:05.\nВ каждой из последующих строк (кроме самой последней строки файла) находится реплика участника диалога. Если каждой реплике присвоить ее порядковый номер (начиная с единицы), то нечетные реплики были произнесены Федей, а четные – его собеседником.\nРеплика находится целиком на одной строке и состоит из метки времени, смысловой части и знака препинания конца предложения. Гарантируется, что последний символ реплики не является пробелом.\nМетка времени имеет вид ЧЧ:ММ:СС:.\nСмысловая часть отделена от метки времени пробелом и содержит текст, состоящий из больших или маленьких английских букв, цифр, одиночных пробелов, апострофов (заменяют мягкий и твердый знаки в транслите), а также запятых, точек с запятыми и круглых скобок.\nЗнак препинания – это восклицательный знак, вопросительный знак или точка. Он может быть опущен, в этом случае подразумевается точка.\nВыходные данные\nВ выходной файл OUTPUT.TXT выведите для каждой реплики ее же, преобразованную в косвенную речь. Преобразование заключается в следующем. Сначала заключите реплику в двойные кавычки, при этом если она оканчивается на точку, то вместо точки поставьте запятую, иначе оставьте знак препинания без изменений, например:\nZakanchivayu tochkoi. → «Zakanchivayu tochkoi,»\nEto voskhititel'no!\t→ «Eto voskhititel'no!»\nЗатем поставьте пробел, три знака «–» (тире) и снова пробел, после чего выведите слово «ѕkazal» и имя собеседника, произнесшего эту реплику. После имени выведите точку. Федя запишется как «Fedya», имя его собеседника можно узнать из первой строки входного файла.",
    "complexity": 31,
    "memory": 16000,
    "time": 1000,
    "examples": [
      {
        "input": "08:59:59: Vasya signed on\n\n09:00:00: Privet!\n\n09:00:31: Privet\n\n09:00:59: Vasya signed off",
        "output": "\u0026#34;Privet!\u0026#34; --- skazal Fedya.\n\n\u0026#34;Privet,\u0026#34; --- skazal Vasya."
      }
    ]
  },
  {
    "id": 876,
    "name": "Оптимизация на окружности",
    "description": "Найдите максимальное значение функции f(x, y) = Ax + By при условии, что x2 + y2 = R2, и аргументы, при котором оно достигается.\n2−5OUTPUT.TXT1.414213562373\n0.707106781187 0.707106781187\n22.0 1.0 1.02.236067977500\n0.894427191000 0.4472135955002.236067977500\n0.894427191000 0.447213595500[Лучшие попытки]\nВходные данные\nВходной файл INPUT.TXT содержит три вещественных числа: A, B, R (1 ≤ A, B, R ≤ 10), заданные не более чем с тремя знаками после десятичной точки.\nВыходные данные\nВ первой строке выходного файла OUTPUT.TXT выведите максимальное значение, которое достигает функция. Во второй строке выведите значения аргументов x0,y0, при которых это значение достигается. Все числа должны быть выведены с точностью не хуже 10−5.",
    "complexity": 27,
    "memory": 16000,
    "time": 1000,
    "examples": [
      {
        "input": "1 1 1",
        "output": "1.414213562373\n\n0.707106781187 0.707106781187"
      },
      {
        "input": "2.0 1.0 1.0",
        "output": "2.236067977500\n\n0.894427191000 0.447213595500"
      }
    ]
  },
  {
    "id": 878,
    "name": "Алфавит",
    "description": "Воспитательница Галя работает в детском саду. Кроме детских игр в этом детском саду проходят занятия. Вот уже неделю ребята изучают буквы английского алфавита. Каждое утро воспитательница выстраивает всех своих подопечных в ряд и они играют в игру.\nOUTPUT.TXTYES1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 262BCARTYXYZZYZZYXYXYZZYZZYXVYES3 1 2 4 5 26 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 25 24 23YES3 1 2 4 5 26 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 25 24 23NO[Лучшие попытки]\nПервый ребенок в ряду громко называет первую букву алфавита – A. Второй должен назвать B, третий – C и так далее. По счастливому стечению обстоятельств всего в группе 26 детей и столько же сколько и букв в английском алфавите.\n3AAZZZZZZZZZZZZZZZZZZZZZZZZNO\nЕсли каждый ребенок без ошибки назовет свою букву, то группа отпразднует знание английского алфавита и ребята по этому случаю съедят большой торт. Однако, пока что группе не удается правильно назвать все 26 букв и каждое утро то один, то другой называет свою букву неправильно и игра на этом заканчивается.\nРебята учат буквы подряд и каждый из них знает первые несколько букв алфавита и не может назвать остальные. Поэтому возможность выиграть напрямую зависит от их расстановки. К примеру, если последним в ряду окажется ребенок, знающий английский алфавит только до буквы D, то букву Z он назвать не сможет и группа не выиграет независимо от того, насколько хорошо выучили алфавит остальные ребята.\nГаля считает, что группа в целом уже достаточно хорошо знает алфавит и хочет помочь своим ребятам выиграть. Для этого ей нужно всего лишь расставить их так, чтобы первый ребенок в ряду знал алфавит хотя бы до буквы A, второй хотя бы до буквы B и так далее, последний в ряду должен знать все буквы.\nПомогите Гале решить: в каком порядке расставить ребят, чтобы они смогли выиграть или выясните, что это пока невозможно.\nВходные данные\nВходной файл INPUT.TXT содержит строку, состоящую из 26 заглавных букв английского алфавита, записанных слитно; i-я из этих букв говорит о том, до какой буквы знает алфавит i-й ребенок.\nВыходные данные\nВ первой строке выходного файла OUTPUT.TXT выведите YES, если воспитательнице удастся выстроить своих детей в ряд так, чтобы они выиграли и  NO, если им для этого еще надо поучиться. Если расстановка возможна, во второй строке выведите перестановку из 26 чисел от 1 до 26 через пробел – порядок детей в ряду. Если решений несколько, можно вывести любое.",
    "complexity": 25,
    "memory": 16000,
    "time": 1000,
    "examples": [
      {
        "input": "ABCDEFGHIJKLMNOPQRSTUVWXYZ",
        "output": "YES\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26"
      },
      {
        "input": "BCARTYXYZZYZZYXYXYZZYZZYXV",
        "output": "YES\n3 1 2 4 5 26 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 25 24 23"
      },
      {
        "input": "AAZZZZZZZZZZZZZZZZZZZZZZZZ",
        "output": "NO"
      }
    ]
  },
  {
    "id": 880,
    "name": "Покрытие",
    "description": "Представим себе комнату размера m×n, пол которой расчерчен линиями сетки на квадраты 1×1. Предлагается покрыть пол этой комнаты дощечками весьма необычного вида.\nOUTPUT.TXT323 2\nXXX\nXXX...1122[Лучшие попытки]\nОдна дощечка представляет собой фигуру, состоящую ровно из 6 клеток квадрата 3×3 и являющуюся связной по стороне (иными словами, из любой клетки можно попасть в любую другую, перемещаясь между центрами соседних клеток только по вертикали и горизонтали и не покидая пределов фигуры). Все дощечки одинаковы. Дощечки выкладываются на пол так, чтобы стороны их клеток совмещались с линиями сетки на полу; их нельзя ни поворачивать, ни перевернуть и положить обратной стороной вверх.\n32 3\nXXX\nXXX\n...2\nПокрытием назовем такое положение дощечек, что каждая клетка пола покрыта хотя бы одной дощечкой из этого набора. Покрытие клетки пола более чем одной дощечкой, равно как и покрытие клеток вне пределов комнаты, допускается.\n42 2\nXXX\nX.X\n..X2\nТребуется узнать, какое минимальное количество дощечек данного вида потребуется, чтобы построить покрытие пола нашей комнаты.\nВходные данные\nВ первой строке входного файла INPUT.TXT заданы через пробел два целых числа m и n (1 ≤ m, n ≤ 9). В следующих трех строках описан квадрат 3×3, содержащий дощечку. Каждая из этих строк содержит ровно три символа. Символ «X» (икс большое) соответствует клетке дощечки, а символ «.» (точка) – пустой клетке. Гарантируется, что эти строки не содержат других символов, суммарное количество символов «X» на них равно шести, и фигура из букв «X» связна по стороне.\nВыходные данные\nВ выходной файл OUTPUT.TXT выведите минимальное количество дощечек данного вида, которые нам потребуются, чтобы построить покрытие пола.",
    "complexity": 74,
    "memory": 32000,
    "time": 1000,
    "examples": [
      {
        "input": "3 3\n\n.X.\n\nXXX\nXX.",
        "output": "3"
      },
      {
        "input": "3 2\n\nXXX\n\nXXX\n...",
        "output": "1"
      },
      {
        "input": "2 3\n\nXXX\n\nXXX\n\n...",
        "output": "2"
      },
      {
        "input": "2 2\n\nXXX\n\nX.X\n\n..X",
        "output": "2"
      }
    ]
  },
  {
    "id": 879,
    "name": "Графы",
    "description": "Однажды в древнее государство Оссия приехал ученый японец Хисикоши. Он обнаружил, что в этом государстве есть одна большая проблема – дороги, а точнее их отсутствие. Еще он обнаружил другую проблему – графов (а было их N), которые, мягко говоря, не отличались особенным уровнем интеллекта. Хисикоши решил помочь построить дороги. С рабочей силой проблем не было, поэтому он решил подойти к этому мероприятию с выдумкой. Он узнал имена всех графов и записал их по-японски (а в Японии, как известно, пользуются иероглифами). Он решил, что надо провести дорогу между замками двух графов (и ввести на ней одностороннее движение от первого ко второму – чтобы интереснее было), если последняя буква имени первого графа совпадает с первой буквой имени второго. Однако, оказалось, что не от каждого графа можно доехать до всех других. Тогда он решил поселить еще несколько графов и дать им имена так, чтобы теперь можно было бы доехать от любого графа до любого другого. Какое наименьшее количество графов ему надо добавить?\nOUTPUT.TXT122\nAAABBB\nCCCDDD222[Лучшие попытки]\nБудем считать, что японский иероглиф однозначно кодируется тремя английскими буквами. И каждой трехбуквенной комбинации соответствует свой иероглиф.\n33\nAAABAA\nABAAAB\nAABBAA2\nВходные данные\nВ первой строке входного файла INPUT.TXT находится целое число N – количество графов (1 ≤ N ≤ 100 000). В следующих N строках написаны их имена. При этом гарантируется, что длина каждого имени (в английских символах) делится на 3. Имена написаны большими английскими буквами. Каждое имя содержит от одного до десяти иероглифов.\nВыходные данные\nВ выходной файл OUTPUT.TXT выведите единственное целое число – минимальное количество графов, которые должен поселить Хисикоши.",
    "complexity": 70,
    "memory": 16000,
    "time": 1000,
    "examples": [
      {
        "input": "2\n\nAAABBB\n\nBBBCCC",
        "output": "1"
      },
      {
        "input": "2\n\nAAABBB\n\nCCCDDD",
        "output": "2"
      },
      {
        "input": "3\n\nAAABAA\n\nABAAAB\n\nAABBAA",
        "output": "2"
      }
    ]
  },
  {
    "id": 881,
    "name": "Фатализм",
    "description": "Роботу Прайму (конструктору роботов) надоели его творения – они получаются слишком тупыми и бездумными, и среди них не найти собеседника и даже просто мыслителя, достойного общаться с самим Праймом, великим и неповторимым. Прайм испробовал уже все известные ему методы, но создать себе подобного до сих пор не получилось. В отчаянии он придумал себе игру, чтобы как то отвлечься от своей неразрешимой проблемы, преодолеть творческий кризис и заодно пустить побольше своих творений по правильному пути. Игра называется «Фатализм» и заключается в следующем.\nдля оставшихся роботов, если какой-то из них оказался между другим роботом и стеной, до которой светит луч его лазера, то этот робот взрывается. Взрывы от лучей лазера происходят одновременно: тем не менее, даже если какой-то робот взорвался, луч его лазера успевает взорвать всех роботов, которые находились между ним и стеной, до которой светит его лазер.iOUTPUT.TXT224 4 4\nX..X\n....\n....\nX..X\n1 3 R\n3 4 U\n4 2 L\n2 1 D1145[Лучшие попытки]\nПрайм создает лабиринт размера m×n клеток, огороженный со всех сторон стенами. Каждая клетка лабиринта – либо свободное пространство, либо стена. В начальный момент времени в некоторых клетках, где нет стены, стоят роботы и смотрят в одном из четырех направлений. Никакие два робота не стоят в одной клетке.\ni34 5 3\n....\n....\n....\n....\n....\n1 4 R\n3 5 U\n4 5 U4\nКаждый робот движется с постоянной скоростью – одна клетка в секунду – в направлении, в котором он смотрит, и светит лазером в этом же направлении до ближайшей стены. В конце каждой секунды некоторые роботы взрываются. Это происходит в трех случаях:\ni43 6 5\n.X.\n.X.\n.X.\n...\n...\n.X.\n1 4 R\n2 5 U\n3 5 U\n1 6 R\n3 6 L5\nесли робот оказался за пределами лабиринта или в клетке, которая заполнена стеной, то он взрывается;\nесли в какой-то клетке оказалось два или более робота, то все они взрываются;\nдля оставшихся роботов, если какой-то из них оказался между другим роботом и стеной, до которой светит луч его лазера, то этот робот взрывается. Взрывы от лучей лазера происходят одновременно: тем не менее, даже если какой-то робот взорвался, луч его лазера успевает взорвать всех роботов, которые находились между ним и стеной, до которой светит его лазер.\ni\nИзвестно, что в начальный момент времени никакой робот не светит на другого робота лазером. Взорвавшиеся роботы не оказывают влияния на ситуацию в лабиринте в последующие секунды. Понятно, что жизнь любого робота будет в таких условиях очень недолгой. Прайм хочет выяснить, сколько времени просуществует самый долгоживущий из них.\nВыясните, сколько времени пройдет до того момента, как все роботы взорвутся.\ni\nВходные данныеi\nВ первой строке входного файла INPUT.TXT заданы через пробел три числа m, n и k (1 ≤ m, n, k ≤ 100). В следующих n строках содержится ровно по m символов в каждой: i-ый символ в j-ой из этих строк равен «X» (икс большое), если соответствующая клетка (i, j)\t занята стеной, и «.» (точка), если эта клетка пуста. Далее идут k строк, описывающие роботов. Каждая из них имеет вид (xi,yi,zi), где xi и yi – координаты робота (1 ≤ xi ≤ m, 1 ≤ yi ≤ n), а zi – один из четырех символов направления: символ «U» (up) соответствует уменьшению координаты y, символ «L» (left) – уменьшению координаты x, символ «D» (down) – увеличению y, а символ «R» (right) – увеличению x. Все числа во входном файле целые.\nВыходные данные\nВ выходной файл OUTPUT.TXT выведите одно число – сколько секунд пройдет до того момента, как все роботы взорвутся.",
    "complexity": 42,
    "memory": 16000,
    "time": 1000,
    "examples": [
      {
        "input": "5 1 2\n\nX...X\n\n3 1 L\n\n4 1 R",
        "output": "2"
      },
      {
        "input": "4 4 4\n\nX..X\n\n....\n\n....\n\nX..X\n\n1 3 R\n\n3 4 U\n\n4 2 L\n\n2 1 D",
        "output": "1"
      },
      {
        "input": "4 5 3\n\n....\n\n....\n\n....\n\n....\n\n....\n\n1 4 R\n\n3 5 U\n\n4 5 U",
        "output": "4"
      },
      {
        "input": "3 6 5\n\n.X.\n\n.X.\n\n.X.\n\n...\n\n...\n\n.X.\n\n1 4 R\n\n2 5 U\n\n3 5 U\n\n1 6 R\n\n3 6 L",
        "output": "5"
      }
    ]
  },
  {
    "id": 883,
    "name": "Самое экстравагантное дупло",
    "description": "В Звенящем Лесу проводится конкурс на самое экстравагантное дупло. Правда, в целях экономии нервов зрителей, конкурс проводится среди макетов, а не самих дупел.\niOUTPUT.TXT0 10 20 3[Лучшие попытки]\nВ качестве исходного материала каждому из участников предоставляется доска размером 20 000 x 20 000 метров. Макет элементарного дупла представляет собой окружность, аккуратно выдолбленную на плоскости. Макет же экстравагантного дупла представляет из себя несколько макетов элементарных дупел, выдолбленных на одной доске.\ni\nКаждому участнику уже заданы радиусы всех элементарных дупел, которые он должен выдолбить. Более того, даже последовательность их выдалбливания строго зафиксирована. Таким образом, единственное, что каждый из участников может варьировать – это координаты центра каждого элементарного дупла.\ni\nКазалось бы, все возможности для свободного творчества уже перекрыты, но это не так. Во-первых, каждому элементарному дуплу соответствует некоторое изначальное количество баллов. Во-вторых, сразу после выдалбливания очередного элементарного дупла за него начисляется итоговый балл, равный сумме изначального балла за это дупло и всех итоговых баллов за уже выдолбленные элементарные дупла, с которыми данное дупло пересекается. Итоговый балл за экстравагантное дупло начисляется как сумма итоговых баллов за все элементарные дупла, из которых оно состоит. Два дупла считаются пересекающимися, если соответствующие им на макете окружности пересекаются, либо одна лежит внутри другой. Касания окружностей на макете недостаточно, чтобы считать дупла пересекающимися.\ni\nВам предлагается примерить на себя шкуру дятла и написать программу, которая по заданным радиусам элементарных дупел, баллов за них, а также последовательности их выдалбливания определила бы координаты центров элементарных дупел, да так, чтобы получившееся экстравагантное дупло имело бы максимальный возможный итоговый балл.\nВходные данные\nВ первой строке входного файла INPUT.TXT задано число n – количество элементарных дупел, которые надо задействовать (1 ≤ n ≤ 1 000). Далее следуют n строк, каждая из которых описывает соответствующее дупло и содержит два целых числа: ri и ci (0 \u003c ri, ci ≤ 1000), где ri – радиус соответствующего дупла в метрах, а ci – изначальное количество баллов, соответствующее данному элементарному дуплу. Дупла даны в порядке выдалбливания.\nВыходные данные\nВыходной файл OUTPUT.TXT должен содержать ровно n строчек, в каждой по два числа – координаты центра соответствующего элементарного дупла в метрах с точностью не менее 10−6 метра. Кроме того, макеты дупел не должны выходить за пределы исходной доски, а расстояние между любыми двумя центрами должно быть не менее сантиметра. Точка (0, 0) соответствует центру исходной доски. Если возможны несколько вариантов расстановки дупел, дающих максимальный балл, выведите любой.",
    "complexity": 35,
    "memory": 16000,
    "time": 1000,
    "examples": [
      {
        "input": "3\n10 10\n20 20\n30 30",
        "output": "0 1\n0 2\n0 3"
      }
    ]
  },
  {
    "id": 882,
    "name": "Губернатор",
    "description": "Вам, как губернатору города, необходимо организовать в своем городе постройку нескольких зданий, чтобы привести его в соответствие мировым стандартам. Губернатор вы не простой, а с высшим экономическим образованием, поэтому Вас в первую очередь заботит денежная сторона вопроса. Создав комиссию по этому поводу и проведя первое заседание, вы выяснили следующее.\niiOUTPUT.TXT2124 6\n1.2 3\n1.5 2\n2.0 4\n0.5 123142314[Лучшие попытки]\nВ настоящее время, то есть до постройки требуемых зданий, город приносит стабильный доход – K золотых монет в месяц. Однако постройка любого здания может существенно изменить сложившееся положение.\nii\nПронумеруем здания, требующие постройки числами от 1 до N, где N – их количество. Каждое здание i характеризуется двумя числами. Во-первых, это число ai – его эффективность. Она является вещественным числом и обозначает то, во сколько раз возрастет текущая прибыль при постройке этого здания. Второй параметр bi – это количество золотых монет, которые каждый месяц уходят на содержание этого здания. В итоге, если к моменту постройки i-го здания месячный доход составлял X монет, то после постройки этого здания его величина станет равна ai•X – bi. Отметим, что итоговый доход не обязательно будет целым числом.\ni\nСледует также учесть, что комитет по городскому строительству имеет сравнительно небольшой и мало обученный штат. Нехватка квалифицированных административных кадров проявляется прежде всего в том, что строители не могут работать над двумя проектами одновременно, а начав работу над одним зданием, не могут перейти к другому, не закончив первое.\ni\nПеред комиссией теперь стоит нелегкая задача: решить, в каком порядке строить здания – а строить их надо все, даже те, которые невыгодны – чтобы получать максимальный доход после постройки всех зданий. Как и следовало ожидать, для ваших коллег это оказалось слишком сложной задачей. Помогите им!\ni\nВходные данные\nВ первой строке входного файла INPUT.TXT записаны через пробел два целых числа N и K (1 ≤ N ≤ 10 000, 1 ≤ K ≤ 106). Далее, в каждой из N последующих строк описано по зданию. Каждое описание имеет вид ai bi, где число ai – вещественное (0 ≤ ai ≤ 10), а bi – целое (0 ≤ bi ≤ 100). i-ая из строк файла соответствует (i−1)-му зданию в нумерации, используемой комиссией.\nВыходные данные\nВ выходной файл OUTPUT.TXT выведите перестановку из N чисел от 1 до N, по одному числу на строку – номера зданий в порядке их постройки. Если существует несколько перестановок, максимизирующих прибыль, разрешается вывести любую.",
    "complexity": 56,
    "memory": 16000,
    "time": 1000,
    "examples": [
      {
        "input": "2 10\n\n1 5\n\n2 3",
        "output": "2\n1"
      },
      {
        "input": "4 6\n\n1.2 3\n\n1.5 2\n\n2.0 4\n\n0.5 1",
        "output": "2\n3\n1\n4"
      }
    ]
  },
  {
    "id": 727,
    "name": "Распределение участков",
    "description": "В одном маленьком городке начинают работать n крупных компаний. Для начала они хотят поделить между собой n земельных участков. По расчетам экономистов, компания i может получить с участка j доход ai,j . Каждая компания, разумеется, хочет получить наибольший доход.\n9OUTPUT.TXT1 3 2[Лучшие попытки]\nРаспределением участков занимается лично мэр города. Распределение происходит следующим образом. Каждая компания сообщает мэру, какой участок ей бы хотелось получить. После этого, если на участок претендует несколько компаний, то он отдается той из них, которая может получить с него наибольший доход (чем больше доход, тем больше налогов), а если таких несколько, то той, у которой наименьший номер (меньшие номера, разумеется, имеют знакомые мэра).\nЗная, как происходит распределение, представители компаний решили собраться вместе и решить, кто на какой участок будет претендовать. Чтобы избежать жульничества, они хотят сделать так, чтобы доход компании не мог увеличиться, если она отклонится от выбранного плана, а все остальные будут ему следовать.\nОказалось, однако, что найти такой план не так-то просто. Помогите им сделать это.\nВходные данные\nВ первой строке входного файла INPUT.TXT содержится число n (1 ≤ n ≤ 400). Далее идут n строк по n чисел. j-е число в i-ой строке - это ai,j, доход i-ой компании с j-го участка (1 ≤ ai,j ≤ 109).\nВыходные данные\nВ выходной файл OUTPUT.TXT выведите n чисел. i-е число - это участок, на который должна претендовать i-я компания. Если ответ не однозначен, выведите любой.",
    "complexity": 62,
    "memory": 16000,
    "time": 1000,
    "examples": [
      {
        "input": "3\n\n5 4 4\n\n5 2 3\n\n2 1 2",
        "output": "1 3 2"
      }
    ]
  },
  {
    "id": 729,
    "name": "Эксперимент",
    "description": "Ученые в одной сверхсекретной лаборатории проводят эксперименты над сверхсекретными газами Аккермана. Перед началом эксперимента у них есть n пронумерованных колб, в которых находятся разные газы. Ученые соединяют колбы трубками, и содержащиеся в них газы приходят в контакт. Известно, что если в контакт приходят какие-то два газа, то тот из них, который изначально находился в колбе с большим номером, неимоверно быстро расширяется, уничтожает другой газ и занимает все освобождающееся пространство.\nOUTPUT.TXT3 305 20[Лучшие попытки]\nПо заданной последовательности действий, которую проводят ученые, вы должны предсказать результат эксперимента.\n[Решение]\nВходные данные\nПервая строка входного файла INPUT.TXT содержит количество колб n и количество действий m (0 \u003c n ≤ 10, 0 ≤ m ≤ 15). Во второй строке записаны n целых чисел vi (0 \u003c vi ≤ 10) - объемы колб. Каждая из последующих m строк содержит два различных целых числа от 1 до n - номера колб, соединяемых на соответствующем шаге.\nВыходные данные\nДля каждого из сохранившихся газов выведите в выходной файл OUTPUT.TXT его номер и занимаемый им объем в отдельной строке. Информацию выводите в порядке увеличения номеров газов.",
    "complexity": 36,
    "memory": 16000,
    "time": 1000,
    "examples": [
      {
        "input": "5 3\n\n10 10 10 10 10\n\n1 2\n\n2 3\n\n4 5",
        "output": "3 30\n5 20"
      }
    ]
  },
  {
    "id": 885,
    "name": "Звезды за кормой",
    "description": "В последнее время Петя очень заинтересовался одной игрой. Вкратце правила таковы:\nИмеется море размером (2•n+1) x (2•n+1) клеток. Изначально в некоторых клетках находятся острова, в некоторых – вражеские корабли, в центре стоит корабль игрока. За один ход игрок может либо переместиться, либо выстрелить; пропустить ход нельзя.\ns«O» (o большое английское) – остров;OUTPUT.TXTIMPOSSIBLE25\n....t..O.O.\n....t......\n...........\n...........\n...........\n..O..+.....\n...........\n...........\n...........\n.t.........\n.....O.....7\n5 5\n5 5\n5 5\n5 4\n5 3\n6 25 17\n5 5\n5 5\n5 5\n5 4\n5 3\n6 25 1[Лучшие попытки]\nПеремещение производится на одну из восьми соседних клеток, при условии, что она существует и свободна. При этом считается, что корабль сначала поворачивается на месте носом к выбранной клетке, а затем двигается в нее.\ns«+» (плюс) – корабль игрока.\nПри выстреле корабль производит залп обоими бортами. Ядра при этом летят перпендикулярно текущему курсу корабля. Ядра каждого борта поражают первую встретившуюся в данном направлении цель (корабль или остров), но не далее трех клеток от корабля игрока (не считая клетку, на которой находится сам корабль игрока). Например, если корабль приплыл из клетки (2, 1) в клетку (1, 2), а затем выстрелил, то он уничтожит вражеский корабль на клетке (4, 5), но не поразит корабль на (5, 6). Если к тому же на клетке (2, 3) будет стоять корабль или остров, то корабль на (4, 5) останется цел. Изначально корабль игрока стоит на клетке (n, n) с таким направлением, будто он приплыл из клетки (n−1, n).\nПосле каждого хода игрока вражеские корабли одновременно делают ход. Каждый из кораблей ходит на ту из восьми соседних клеток, сумма модулей разностей координат которой и координат корабля игрока минимальна. Формально, если корабль игрока находится на клетке (xs, ys), то выбирается такая клетка (x,  y), для которой |xs−x|+|ys−y| минимально. Если при этом оказывается, что в данной клетке находится остров, то вражеский корабль погибает. Если хотя бы один вражеский корабль попадает на клетку с кораблем игрока, то игрок проигрывает. Если хотя бы два вражеских корабля оказываются на одной клетке, то они погибают и на этой клетке образуются обломки, которые далее действуют так же, как остров за тем исключением, что снаряды перелетают через обломки, а не поражают их. При уничтожении корабля ядром тоже образуются обломки. На месте острова обломки не образуются. Игрок побеждает, если на поле нет ни одного живого вражеского корабля.\nПете стало очень интересно, можно ли в каждой конкретной ситуации выиграть или нет. Для этого он решил написать программу. Нет, Вам не надо ему помогать. Он с этой задачей уже справился, а вот справитесь ли вы?\nВходные данные\nВ первой строке входного файла INPUT.TXT задано число n (1 ≤ n ≤ 6), определяющее размер поля. Далее следуют 2•n+1 строк по 2•n+1 символов в каждой. При этом i-й символ (j+1)-й строки описывает клетку поля с координатами (i−1, j−1) (клетки нумеруются с 0). Значение символов следующее:\n«.» (точка) – пустая клетка;\n«t» (t маленькое английское) – вражеский корабль;\n«O» (o большое английское) – остров;\n«+» (плюс) – корабль игрока.\nСимвол «+» всегда присутствует и располагается только в клетке с координатами (n×n). Количество остальных символов может быть любым, и ограничено только размерами доски.\nВыходные данные\nВ первой строке выходного файла OUTPUT.TXT выведите количество ходов, необходимых для выигрыша. В последующих строках выведите координаты корабля после каждого из ходов, по одной паре в строке. Минимизировать число ходов не обязательно; тем не менее, если вражеских кораблей уже не осталось, дальнейшие ходы делать не следует. Если решения не существует, выведите IMPOSSIBLE в единственной строке файла. Если существует несколько решений, выведите любое.",
    "complexity": 65,
    "memory": 16000,
    "time": 1000,
    "examples": [
      {
        "input": "5\n\n..........t\n\n.......t...\n\nO......t...\n\nt..........\n\n.........tO\n\n..t..+.....\n\n...........\n\n...O.....Ot\n\n...O.......\n\n....t......\n\n..t..O.....",
        "output": "IMPOSSIBLE"
      },
      {
        "input": "5\n\n....t..O.O.\n\n....t......\n\n...........\n\n...........\n\n...........\n\n..O..+.....\n\n...........\n\n...........\n\n...........\n\n.t.........\n\n.....O.....",
        "output": "7\n\n5 5\n\n5 5\n\n5 5\n\n5 4\n\n5 3\n\n6 2\n5 1"
      }
    ]
  },
  {
    "id": 886,
    "name": "Суффиксы",
    "description": "Назовем строкой последовательность из маленьких букв английского алфавита. Строкой, например, является пустая последовательность “”, слово “aabaf” или бесконечная последовательность букв “a”.\n7*6iOUTPUT.TXT22ab1141[Лучшие попытки]\ni-ый суффикс Si строки S – это строка S, из которой вырезаны первые i букв: так, для строки S = “aabaf” суффиксы будут такими:\n**3qqqq4\nS0 = “aabaf”\n74xyzzyxy1\nS1 = “abaf”\n*\nS2 = “baf”\nS3 = “af”\nS4 = “f”\nS5 = S6 = S7 = . . . = “”\nСуффиксы определены для всех i \u003e 0.\nЦиклическое расширение S* конечной строки S – это строка, полученная приписыванием ее к самой себе бесконечное количество раз. Так,\nS* = S0* = “aabafaabafaa...”\nS1* = “abafabafabaf...”\nS2* = “bafbafbafbaf...”\nS3* = “afafafafafaf...”\nS4* = “ffffffffffff...”\nS5* = S6* = S7*= . . . = “”\nПо данной строке S выясните, сколько ее суффиксов Si имеют такое же циклическое расширение, как и сама строка S, то есть количество таких i, что S*= Si*.\nВходные данные\nВходной файл INPUT.TXT содержит строку S, состоящую не менее, чем из одной и не более, чем из 100 000 маленьких английских букв.\nВыходные данные\nВ выходной файл OUTPUT.TXT выведите количество суффиксов строки S, имеющих такое же циклическое расширение, как и она сама.",
    "complexity": 45,
    "memory": 16000,
    "time": 1000,
    "examples": [
      {
        "input": "aa",
        "output": "2"
      },
      {
        "input": "ab",
        "output": "1"
      },
      {
        "input": "qqqq",
        "output": "4"
      },
      {
        "input": "xyzzyxy",
        "output": "1"
      }
    ]
  },
  {
    "id": 728,
    "name": "Закупка носков",
    "description": "В одной военной части было принято революционное решение перейти от портянок к носкам. По такому случаю прапорщику Недалекому было поручено закупить n пар носков. Однако предложенная прапорщиком смета не удовлетворила начальство, и прапорщику было предложено очень-очень быстро переделать ее так, чтобы затраты были минимально возможными. Помогите бедному прапорщику составить такую смету.\niOUTPUT.TXT8[Лучшие попытки]\nИзучение рынка показало, что всего существует m различных поставщиков, которые продают носки разными пачками и по разным ценам. Пачка, содержащая ai пар носков, продается за bi рублей. \ni[Решение]\nРазрешено покупать любое количество пачек у одного поставщика. Разрешено покупать пачки у нескольких поставщиков.\nВходные данные\nВ первой строке входного файла INPUT.TXT содержатся числа n и m (1 ≤ n ≤ 10000, 1 ≤ m ≤ 100). Далее идут m пар чисел ai, bi (1 ≤ ai ≤ 10000, 1 ≤ bi ≤ 10000).\nВыходные данные\nВыведите в выходной файл OUTPUT.TXT минимальную сумму денег, которую нужно потратить на покупку n пар носок.",
    "complexity": 43,
    "memory": 16000,
    "time": 1000,
    "examples": [
      {
        "input": "9 2\n1 1\n10 8",
        "output": "8"
      }
    ]
  },
  {
    "id": 730,
    "name": "Пересылка файлов",
    "description": "В постиндустриальную эпоху основной ценностью является информация. Поэтому особо важен контроль над каналами передачи информации. В одной стране все каналы связи контролируются государством.\nOUTPUT.TXT3 1123 3\n1 2 5\n1 3 10\n3 2 414 22 314 22 3[Лучшие попытки]\nПеред ИТ-отделом одной достаточно крупной фирмы, занимающейся консалтингом в области инновационных технологий, была поставлена задача распространить некий файл по филиалам этой фирмы, находящимся в различных городах страны.\nКаналы передачи информации в этой стране, как уже говорилось, контролируются государством, поэтому за передачу по ним информации приходится платить деньги. Ситуация также осложняется тем, что каналы однонаправленные, то есть информацию по ним можно передавать только в одном направлении.\nПусть, для удобства, города пронумерованы натуральными числами от 1 до n. Главный офис находится в городе номер 1, таким образом, необходимо найти такой набор каналов связи, по которым можно доставить файл от города номер 1 до любого другого, а среди всех таких наборов выбрать имеющий наименьшую суммарную стоимость.\nЗадан список каналов связи, которыми может воспользоваться фирма. Напишите программу, находящую требуемый набор каналов связи.\nВходные данные\nПервая строка входного файла INPUT.TXT содержит числа n и m - количество городов и количество каналов связи соответственно (1 ≤ n ≤ 22, 0 ≤ m ≤ 22). Последующие m содержат описания каналов связи. Каждое описание содержит три целых числа: u, v и c - соответственно номера городов, соединенных каналом и стоимость пересылки файла по этому каналу (1 ≤ u, v ≤ n, 0 ≤ c ≤ 1000). Ни один из каналов не соединяет город с самим собой, но между двумя городами может быть больше одного канала.\nВыходные данные\nВ первой строке выходного файла OUTPUT.TXT выведите стоимость пересылки файла и число каналов, обеспечивающих такую стоимость. Во второй строке выведите номера каналов, составляющих такой набор. Каналы нумеруются от 1 до m в том порядке, в котором они перечислены во входном файле.",
    "complexity": 49,
    "memory": 16000,
    "time": 1000,
    "examples": [
      {
        "input": "2 2\n1 2 3\n1 2 4",
        "output": "3 1\n1"
      },
      {
        "input": "3 3\n\n1 2 5\n\n1 3 10\n\n3 2 4",
        "output": "14 2\n2 3"
      }
    ]
  },
  {
    "id": 888,
    "name": "Карусель",
    "description": "Карусель – одна из популярных форм проведения командных соревнований по решению задач. Наибольшую известность в использовании данной модели в России получил ресурс «Интернет-карусели», расположенный в сети Интернет по адресу http://karusel.desc.ru. \nесли на задачу дан неверный ответ, то команда получает за решение 0 баллов, а следующая задача будет стоить на 3 балла меньше, но не менее 3 баллов.OUTPUT.TXT12291 0 1 1 1 1 0 1 13030[Лучшие попытки]\nВсем командам, участвующим в карусели, предлагаются в строгом порядке одни и те же задачи, которые необходимо решить в установленное время. Система подсчета баллов такова, что доминирующим фактором является не количество решенных задач, а длины последовательностей правильных решений.\nНачисление баллов происходит согласно следующей схеме:\nпервая задача стоит 3 балла;\nесли к задаче дан верный ответ, то команда получает ее стоимость, а следующая задача будет стоить на 1 балл больше;\nесли на задачу дан неверный ответ, то команда получает за решение 0 баллов, а следующая задача будет стоить на 3 балла меньше, но не менее 3 баллов.\nВам требуется написать программу, которая по результатам ответов команды определит итоговый балл.\nВходные данные\nПервая строка входного файла INPUT.TXT содержит натуральное число N – количество задач в карусели (N ≤ 105). Во второй строке расположены N цифр 0 или 1, разделенные пробелом; i-я цифра соответствует корректности ответа команды на i-ю задачу (0 – неверный ответ, 1 – верный ответ).\nВыходные данные\nВ выходной файл OUTPUT.TXT выведите целое число – количество набранных баллов.",
    "complexity": 22,
    "memory": 16000,
    "time": 1000,
    "examples": [
      {
        "input": "3\n1 1 1",
        "output": "12"
      },
      {
        "input": "9\n1 0 1 1 1 1 0 1 1",
        "output": "30"
      }
    ]
  },
  {
    "id": 884,
    "name": "Дорога",
    "description": "В Древнем государстве Оссия было два города, между которыми была проложена дорога длиной S метров. Через каждый метр стояли столбики, на каждом из которых по некоторому принципу (этот секретный принцип был известен только древним монахам Шамбалы) было написано по букве (а алфавит там у них был английский). Однажды князь-король Василий I решил, что человек, когда он едет по этой дороге, слишком редко вспоминает о нем. Он решил это исправить. Для этого он повелел на некоторых столбиках вместо буквы написать «Здесь был Вася». По его представлению, человек, проехав любой участок дороги длиной K метров, должен обязательно хоть раз увидеть такую надписью Иными словами, среди каждых K идущих подряд столбиков должен оказаться хоть один, на котором буква заменена на надпись. При этом, чтобы не слишком раздражать монахов (а они люди обидчивые), Василий I приказал выбрать для надписи такие столбики, чтобы среди стертых букв оказалось как можно меньше различных букв английского алфавита.\nOUTPUT.TXT1A22ABBAA2AB2AB[Лучшие попытки]\nПомогите боярам выполнить приказ своего повелителя.\nВходные данные\nВ первой строке входного файла INPUT.TXT написано одно целое число K (1 ≤ K ≤ 100 000). Во второй строке – без пробелов написано S заглавных английских букв в той последовательности, в которой ими помечены столбики вдоль дороги. Гарантируется, что K ≤ S ≤ 100 000.\nВыходные данные\nВ первой строке выходного файла OUTPUT.TXT выведите N –  минимальное количество различных букв английского алфавита, которые хотя бы на одном столбике придется стереть, чтобы написать «Здесь был Вася». В следующих N строках выведите те заглавные буквы английского алфавита, которые потребуется хоть раз стереть. Буквы можно выводить в любом порядке. Если ответов с минимальным N несколько, можно вывести любой из них.",
    "complexity": 85,
    "memory": 16000,
    "time": 1000,
    "examples": [
      {
        "input": "2\nABA",
        "output": "1\nA"
      },
      {
        "input": "2\nABBAA",
        "output": "2\nA\nB"
      }
    ]
  },
  {
    "id": 887,
    "name": "Доказательство теоремы",
    "description": "",
    "complexity": 47,
    "memory": 16000,
    "time": 1000,
    "examples": [
      {
        "input": "2\n\n2 0\n0",
        "output": "2\n2\n1"
      },
      {
        "input": "6\n\n2 3 6 0\n\n4 0\n\n0\n\n0\n\n0\n\n5 0",
        "output": "4\n\n4\n\n3\n\n2\n1"
      },
      {
        "input": "3\n\n0\n\n1 0\n\n2 0",
        "output": "1\n1"
      }
    ]
  },
  {
    "id": 889,
    "name": "Паутина",
    "description": "OUTPUT.TXT2[Лучшие попытки]\nИмеется паутина на плоскости, состоящая из нитей, параллельных осям координат. В основе конструкции паутины лежит бесконечное множество вертикальных нитей, пронумерованных слева направо, начиная с единицы. Смежные вертикальные нити могут быть соединены горизонтальными нитями на некоторой высоте. Для каждой вертикальной нити на определенной высоте может быть не более одного подобного соединения.\nНа одной из вертикальных нитей, в самом верху (выше всех горизонтальных соединений) находится паук, который начинает свое движение вниз. Натыкаясь на очередную нить, паук меняет свое направление. Движение паука продолжается до тех пор, пока все горизонтальные нити не окажутся выше паука.\nПо заданной конструкции паутины и начальному расположению паука требуется определить номер нити, на которой окажется паук в конце своего движения.\nВходные данные\nПервая строка входного файла INPUT.TXT содержит два числа K и M, где K – номер нити, соответствующей начальному положению паука. Далее идут M строк, определяющих горизонтальные соединения, по одному в каждой строке. Каждое такое соединение определяется двумя числами P и H, обозначающие соединение смежных вертикальных нитей с номерами P и P+1 на высоте H. Во входных данных все числа натуральные, имеющие следующие ограничения: K, P, H ≤ 109, M ≤ 105.\nВыходные данные\nВ выходной файл OUTPUT.TXT выведите целое число – ответ на задачу.",
    "complexity": 38,
    "memory": 64000,
    "time": 1000,
    "examples": [
      {
        "input": "3 6\n\n1 2\n\n3 4\n\n2 5\n\n3 1\n\n1 4\n\n2 3",
        "output": "2"
      }
    ]
  },
  {
    "id": 890,
    "name": "Охрана - 2",
    "description": "В одном из секретных учреждений в целях безопасности установлены два инфракрасных датчика движения. Каждый датчик позволяет контролировать пространство, ограниченное формой прямоугольного параллелепипеда. Причем, датчики в здании установлены таким образом, что все грани охраняемых датчиками граничных зон параллельны стенам здания. При этом охраняемые зоны могут пересекаться, совпадать, включаться одна в другую и т.д.\n1OUTPUT.TXT920 0 3 3 3 02 2 2 4 4 43434[Лучшие попытки]\nПо заданным координатам охраняемых зон необходимо определить общий объем территории, покрываемой датчиками.\n2\nВходные данные2\nВходной файл INPUT.TXT содержит две строки, каждая из которых определяет охраняемую датчиком зону. Каждая зона определяется 6 целыми числами x1, y1, z1, x2, y2, z2, где (x1, y1, z1) и (x2, y2, z2) – координаты противоположных вершин правильного параллелепипеда. Все числа записаны через пробел и не превосходят 104 по абсолютной величине.\n2\n1Выходные данные\n1\nВ выходной файл OUTPUT.TXT выведите целое число – совокупный объем охраняемой территории.\n1Примеры\n2\n№INPUT.TXTOUTPUT.TXT\n10 0 0 2 2 23 3 3 4 4 49\n20 0 3 3 3 02 2 2 4 4 434\n2\n2Для отправки решения задачи необходимо зарегистрироваться и авторизоваться!\n4\n\n  [Обсуждение]\n\n  [Все попытки]\n\n  [Лучшие попытки]\nwindow.yaContextCb.push(()=\u003e{\n  Ya.Context.AdvManager.render({\n    renderTo: 'yandex_rtb_R-A-122393-3',\n    blockId: 'R-A-122393-3'\n  })\n})",
    "complexity": 41,
    "memory": 16000,
    "time": 1000,
    "examples": [
      {
        "input": "0 0 0 2 2 2\n3 3 3 4 4 4",
        "output": "9"
      },
      {
        "input": "0 0 3 3 3 0\n2 2 2 4 4 4",
        "output": "34"
      }
    ]
  },
  {
    "id": 733,
    "name": "Последовательность - 2",
    "description": "",
    "complexity": 32,
    "memory": 16000,
    "time": 1000,
    "examples": [
      {
        "input": "12\n1 2 3 2 4 1 3 4 2 3 2 1",
        "output": "8\n1 2 3 4 4 3 2 1"
      }
    ]
  },
  {
    "id": 732,
    "name": "Треугольная комната",
    "description": "Во многих книгах по занимательной математике приводится такая задача. Расставить по периметру треугольной комнаты 3 стула так, чтобы у каждой стены стояло по 2. Ее решение - поставить по стулу в каждый из углов комнаты.\nACACBOUTPUT.TXTYES1 0 1 0 1 023 3 2 2NONO[Лучшие попытки]\nЭта задача легко обобщается. Пусть комната представляет собой треугольник ABC. Даны: общее количество стульев n, количество стульев nAB, которое должно стоять у стены AB, количество стульев nBC, которое должно стоять у стены BC, количество стульев nAC, которое должно стоять у стены AC. Необходимо найти соответствующую расстановку стульев или установить, что ее не существует. При этом стулья можно ставить только в углы комнаты и вдоль стен, в центр комнаты стулья ставить нельзя. В любой из углов можно поставить произвольное количество стульев.\nABBC\nВходные данныеBCC\nВходной файл INPUT.TXT содержит целые числа n, nAB, nBC, nAC (0 ≤ n, nAB, nBC, nAC ≤ 1000).\nACAC\nВыходные данные\nВ первой строке выходного файла OUTPUT.TXT выведите NO, если стулья указанным способом расставить невозможно. В противном случае выведите YES в первой строке выходного файла, а во второй выведите 6 целых неотрицательных чисел: kA, kAB, kB, kBC, kC, kAC - соответственно количество стульев, которые необходимо поставить в угол A, вдоль стены AB, в угол B, вдоль стены BC, в угол C и вдоль стены AC.",
    "complexity": 39,
    "memory": 16000,
    "time": 1000,
    "examples": [
      {
        "input": "3 2 2 2",
        "output": "YES\n1 0 1 0 1 0"
      },
      {
        "input": "3 3 2 2",
        "output": "NO"
      }
    ]
  },
  {
    "id": 891,
    "name": "Кубик Рубика",
    "description": "OUTPUT.TXTSolved2RR BG GR GB GR BB\nGG BR GR RB BB GRF'RF'RLULU'LB'DBR[Лучшие попытки]\nКубик Рубика – популярная головоломка в форме куба, состоящая из множества мелких кубиков. Каждая видимая сторона такого кубика окрашена в определенный цвет. Повороты сторон кубика позволяют переупорядочить цветные квадраты множеством различных способов. Целью игры служит поиск последовательности поворотов сторон куба таким образом, чтобы он вернулся в первоначальное состояние, где каждая из граней состоит из квадратов одного цвета.\n3BR GR GR GR BB RR\nBG RG RG BB GB BGLULU'LB'DBR\nДоказано, что число всех достижимых различных состояний традиционного 6-цветного кубика Рубика 3×3×3 равно 43 252 003 274 489 856 000, а оптимальная последовательность ходов, необходимых для сборки кубика Рубика из любого состояния не превышает 20. Алгоритм, собирающий кубик Рубика за минимальное число ходов, традиционно называется «алгоритмом Бога», а 20 – числом Бога.\nРассмотрим более простую модель кубика Рубика 2×2×2, в которой используется всего 3 цвета: красный (R), синий (B) и зеленый (G). При этом противоположные грани  окрашены в одинаковый цвет. Под ходом будем понимать вращение одной из граней на угол 90º. Поскольку всего 6 граней (передняя (F), левая (L), задняя (B), правая (R), верхняя (U) и нижняя (D)), то всего может быть 12 различных ходов (по часовой и против часовой стрелки для каждой грани). Ходы обозначаются буквами соответствующих граней, если ход происходит против часовой стрелки, то после буквы ставится апостроф (ASCII 39).\nПо заданной конфигурации трехцветного кубика Рубика 2×2×2 требуется найти оптимальный алгоритм (алгоритм Бога), решающий головоломку.\nВходные данные\nВходной файл INPUT.TXT содержит две строки, определяющие конфигурацию кубика Рубика. Первая строка содержит информацию о цветах верхнего слоя для каждой грани – пары символов, разделенные пробелом. Вторая строка аналогичным образом описывает нижние слои. Порядок граней (слева направо): передняя, левая, задняя, правая, верхняя, нижняя.\nВыходные данные\nВ выходной файл OUTPUT.TXT выведите оптимальное решение головоломки для заданной конфигурации кубика Рубика. Если решений несколько, выведите любое. Если задана начальная конфигурация (кубик Рубика собран), то следует вывести «Solved».",
    "complexity": 67,
    "memory": 16000,
    "time": 1000,
    "examples": [
      {
        "input": "RR GG RR GG BB BB\n\nRR GG RR GG BB BB",
        "output": "Solved"
      },
      {
        "input": "RR BG GR GB GR BB\n\nGG BR GR RB BB GR",
        "output": "F\u0026#39;R"
      },
      {
        "input": "BR GR GR GR BB RR\n\nBG RG RG BB GB BG",
        "output": "LULU\u0026#39;LB\u0026#39;DBR"
      }
    ]
  },
  {
    "id": 731,
    "name": "Проценты",
    "description": "Списки ингредиентов на упаковках иногда сопровождаются их процентным содержанием, чаще всего округленным до целого числа процентов. Чтобы такой список выглядел правдоподобным, в сумме указанные числа должны давать 100%.\nOUTPUT.TXT663423- 10- 10- 10333433333433[Лучшие попытки]\nОднако и здесь есть определенные тонкости. Нетрудно убедиться, что, если округлять все дробные числа процентов по математическим правилам, то результирующая сумма может отличаться от нужной. Поэтому никто не сможет усомниться в вашей честности, если вы произведете округление так, как сочтете нужным. Осталось только найти лучший вариант.\nВам заданы количества всех ингредиентов, входящих в состав продукта. Для каждого ингредиента известно, положительно или отрицательно влияет на продажи его присутствие в составе. По этим данным необходимо рассчитать процентные доли каждого из ингредиентов от их суммарного количества и округлить их в нужную сторону. При этом не следует допускать, чтобы одновременно доля какого-либо вредного компонента была округлена вверх, а доля какого-либо хорошего - вниз.\nВходные данные\nВ первой строке входного файла INPUT.TXT задано количество ингредиентов n (1 ≤ n ≤ 30). Следующие n строк описывают сами ингредиенты: знак «+» для положительно влияющих на продажи, и «-» для отрицательно влияющих, а затем, через пробел, количество соответствующего ингредиента - целое число от 1 до 1000.\nВыходные данные\nВ выходной файл OUTPUT.TXT выведите n целых чисел, в сумме дающих 100, по одному на строке - процентные содержания ингредиентов.",
    "complexity": 33,
    "memory": 16000,
    "time": 1000,
    "examples": [
      {
        "input": "2\n- 10\n+ 5",
        "output": "66\n34"
      },
      {
        "input": "3\n- 10\n- 10\n- 10",
        "output": "33\n34\n33"
      }
    ]
  },
  {
    "id": 381,
    "name": "Lines",
    "description": "В таблице из N строк и N столбцов некоторые клетки заняты шариками, другие свободны. Выбран шарик, который нужно переместить, и место, куда его нужно переместить. Выбранный шарик за один шаг перемещается в соседнюю по горизонтали или вертикали свободную клетку. Требуется выяснить, возможно ли переместить шарик из начальной клетки в заданную, и, если возможно, то найти путь из наименьшего количества шагов.\nOUTPUT.TXTYes\n+++++\n+OOOO\n+++++\nOOOO+\n@++++\n25\n..X..\n.....\nOOOOO\n.....\n..@..\nNoNo[Лучшие попытки]\nВходные данные\nВ первой строке входного файла INPUT.TXT находится число N, в следующих N строках - по N символов. Символом точки обозначена свободная клетка, английской заглавной O - шарик, @ - исходное положение шарика, который должен двигаться, английской заглавной X - конечное положение шарика. (2 ≤ N ≤ 40)\nВыходные данные\nВ выходной файл OUTPUT.TXT выведите  в первой строке Yes, если движение возможно, или No, если нет. Если движение возможно, то далее следует вывести N строк по N символов - как и на вводе, но букву X, а также все точки по пути следует заменить плюсами. Если решений несколько, выведите любое.",
    "complexity": 43,
    "memory": 16000,
    "time": 1000,
    "examples": [
      {
        "input": "5\n\n....X\n\n.OOOO\n\n.....\n\nOOOO.\n\n@....",
        "output": "Yes\n\n+++++\n\n+OOOO\n\n+++++\n\nOOOO+\n\n@++++"
      },
      {
        "input": "5\n\n..X..\n\n.....\n\nOOOOO\n\n.....\n\n..@..",
        "output": "No"
      }
    ]
  },
  {
    "id": 738,
    "name": "Слова - 2",
    "description": "Вася умеет быстро набирать на клавиатуре разные слова. Иногда он делает это так быстро, что в слове меняются местами какие-то две буквы (не обязательно стоящие подряд). И тогда, если Вася общается в чате, собеседник не всегда понимает его правильно: ведь, скажем, если Вася набрал «BEATS» и при этом, возможно, поменял местами две буквы, он мог иметь в виду и «BEATS», и «BEAST», и даже «BETAS». . .\nOUTPUT.TXTTATRAARATT[Лучшие попытки]\nКак хорошо бы было, если бы осмысленные слова нельзя было перепутать, даже если переставить в них какие-то две буквы! Васю заинтересовала теоретическая сторона этого вопроса. А именно: сколько же можно выделить слов из заданного набора букв так, чтобы никакие два слова, если в одном из них или даже в каждом переставить две буквы местами, не стали бы одинаковыми. Например, множество слов «BEAST» и «BETAS» не подходит, потому как из каждого слова можно перестановкой двух букв получить «BEATS». С другой стороны, «WORDS» и «SWORD» - подходящее множество: как ни переставляй пару букв в одном и в другом слове, одинаковую последовательность не получить.\nВася хочет по набору букв выяснить, какое максимальное количество слов, являющихся перестановками букв этого набора, можно объявить осмысленными, чтобы никакие два из них нельзя было перепутать, переставив пару букв в одном или в обоих словах. Помогите ему справиться с этой задачей.\nВходные данные\nВ первой строке входного файла INPUT.TXT записаны подряд пять заглавных букв английского алфавита.\nВыходные данные\nВ выходной файл OUTPUT.TXT выведите максимальное по размеру множество слов, являющихся перестановками данного набора букв, которые можно объявить осмысленными, чтобы их нельзя было перепутать. Слова следует выводить по одному на строке. Если таких множеств несколько, разрешается вывести любое из них.",
    "complexity": 74,
    "memory": 16000,
    "time": 1000,
    "examples": [
      {
        "input": "TATRA",
        "output": "TATRA\nARATT"
      }
    ]
  },
  {
    "id": 734,
    "name": "Строковый компьютер",
    "description": "Василий Афанасьев в качестве курсовой работы получил задание - построить компьютер, который бы работал не с числами, а со строками. Вася для начала фиксировал некоторый алфавит. Обозначим за K количество букв в этом алфавите. Далее, Вася фиксировал некоторый набор различных строк, длины не более N каждая, который он назвал базовым. Компьютер умеет работать только со строками, которые получаются конкатенацией (т.е. приписыванием) некоторых строк из этого набора друг к другу (одну и ту же строку при приписывании можно использовать несколько раз). Однако оказалось, что исходный базовый набор оказался чрезмерным! Это значит, что в нем была строка, при удалении которой из набора не изменяется множество строк, с которыми умеет работать компьютер.\nOUTPUT.TXT1123 2121121[Лучшие попытки]\nВасю заинтересовал вопрос - как много может быть строк в нечрезмерном наборе, и сколько таких максимальных наборов существует.\nТак как его компьютер еще не готов, то он попросил Вас посчитать это число.\nВходные данные\nВо входном файле INPUT.TXT содержится два целых числа 1 ≤ N ≤ 1 000 и 1 ≤ K ≤ 100 – соответственно максимальная длина строки и количество символов в алфавите.\nВыходные данные\nВ первой строке выходного файла OUTPUT.TXT выведите количество строк в максимальном наборе. Во второй – количество таких наборов.",
    "complexity": 61,
    "memory": 16000,
    "time": 1000,
    "examples": [
      {
        "input": "1 1",
        "output": "1\n1"
      },
      {
        "input": "3 2",
        "output": "12\n1"
      }
    ]
  },
  {
    "id": 737,
    "name": "ДНК",
    "description": "Вася никогда не любил биологию. Но когда он узнал про ДНК, у него появился живой интерес. Он решил, что если все существа произошли друг от друга, то и ДНК у них должны быть похожими. У некоторых более похожие, у некоторых - менее, но у всех ДНК можно записать в виде строки, состоящей из символов A, C, G и T. Поэтому он решил найти какой-нибудь показатель родства. И придумал следующее. Он берет из двух ДНК по подстроке. Если одна из них является анаграммой другой (т. е. получается перестановкой букв), то это хорошая пара подстрок. Естественно, в любой хорошей паре обе подстроки имеют одинаковую длину. Тогда степень родства двух ДНК – это максимально возможная длина подстрок в хорошей паре.\nOUTPUT.TXT32 12ACGTCAT21 121 122 1[Лучшие попытки]\nВходные данные3ACAAC22 1\nВ первой строке входного файла INPUT.TXT находится ДНК Васи. А во второй строке - ДНК первого попавшегося Васе живого существа. Обе строки не пусты и состоят не более, чем из 1 300 символов A, C, G и T.\nВыходные данные\nВ первую строку выходного файла OUTPUT.TXT выведите степень родства Васи с подопытным существом. Если степень родства отлична от нуля, то во вторую следует вывести две начальные позиции подстрок из соответствующей хорошей пары в первой и второй ДНК соответственно. В случае неоднозначности последних двух чисел, выведите любые подходящие.",
    "complexity": 56,
    "memory": 32000,
    "time": 1000,
    "examples": [
      {
        "input": "ACGT\nGTC",
        "output": "3\n2 1"
      },
      {
        "input": "ACGT\nCAT",
        "output": "2\n1 1"
      },
      {
        "input": "ACA\nAC",
        "output": "2\n2 1"
      }
    ]
  },
  {
    "id": 736,
    "name": "Удаление",
    "description": "Вася уже долго занимается K-расширениями. Недавно ему это надоело, и он стал изучать следующую операцию на строках: сначала удаляется каждый K-ый символ строки с начала и до конца (т. е. сначала K-й, потом 2K-й, и т. д., пока число iK не превосходит длины строки). Потом эта операция повторяется, и так далее, пока в строке есть хотя бы K символов.\nOUTPUT.TXT0\n1\n6\n8\n5\n8[Лучшие попытки]\nНапример, если дана строка длины 10, и K = 2, то сначала будут удалены 2, 4, 6, 8 и 10 символы. Затем будут удалены 2 и 4 символы новой строки, которые соответствуют 3 и 7 символам старой. Затем будет удален 2 символ получившейся строки - 5 символ старой. Последним будет удален 9 символ старой строки.\nСобственно, задумал он это все для того, чтобы узнать, какой и когда символ исчезнет. Но когда ему надоело вручную удалять символы, он решил поручить это Вам. А именно, Вам придется отвечать на его вопросы: \"А на какой секунде был удален i-ый символ строки?\" На удаление каждого символа тратится одна секунда.\nВходные данные\nВ первой строке входного файла INPUT.TXT находятся три числа: 1 ≤ N ≤ 5×106 - количество символов, которые написал Вася, число 1 ≤ K ≤ N, и 1 ≤ L ≤ 10 000 - количество вопросов, которые задает Вася. В последующих L строках указаны номера символов, для которых Вася хочет узнать, когда они были удалены. Все номера лежат в пределах от 1 до N и могут повторяться.\nВыходные данные\nВ выходной файл OUTPUT.TXT выведите L строк с ответами на вопросы в том порядке, в каком они были во входном файле. Если окажется, что символ из строки не будет удален никогда, выведите 0.",
    "complexity": 45,
    "memory": 64000,
    "time": 1000,
    "examples": [
      {
        "input": "10 2 6\n\n1\n\n2\n\n3\n\n5\n\n10\n\n5",
        "output": "0\n\n1\n\n6\n\n8\n\n5\n\n8"
      }
    ]
  },
  {
    "id": 740,
    "name": "Ключи",
    "description": "Для доступа в лаборатории НИИ Исследований Данных Строк используются ключи в виде прямоугольных карточек N×M, в которых вырезаны дырки. Эти ключи можно вставлять только одним способом (то есть ни поворачивать, ни переворачивать нельзя). При этом дырки имеют прямоугольную форму. К Васе попало два ключа от разных лабораторий. Он решил их наложить друг на друга так, чтобы получившаяся фигура имела максимальное количество дырок (просветов). При этом исходно ключи лежали в том положении, в котором их необходимо вставлять в замок, а Вася не хочет их поворачивать. Помогите Васе определить максимальное число дырок. При наложении считаются только те дырки, внутренности которых не пусты.\n1OUTPUT.TXT1210 10\n2\n1 1 2 2\n3 3 4 4\n1\n1 1 2 2112[Лучшие попытки]\nВходные данные1310 10\n2\n1 1 2 2\n3 3 4 4\n1\n1 1 3 32\nПервая строка входного файла INPUT.TXT содержит два целых числа - 1 ≤ N, M ≤ 109 - длины сторон ключа. Вторая строка содержит единственное целое число - 1 ≤ K1 ≤ 500 - число дырок в первом ключе. Далее в K1 строках написано по четыре целых числа - X1, Y1, X2, Y2 (0 ≤ X1 \u003c X2 ≤ N, 0 ≤ Y1 \u003c Y2 ≤ M) – координаты углов соответствующих прямоугольных дырок. Дырки в ключе не пересекаются и не касаются.\n1\n2\nДалее следует описание второго ключа в таком же формате.\n2Выходные данные\n1\nВ выходной файл OUTPUT.TXT выведите единственное целое число - максимальное количество дырок, которое может получить Вася.\n2Примеры\n1\n№INPUT.TXTOUTPUT.TXT\n110 10\n1\n1 1 2 2\n1\n1 1 2 21\n210 10\n2\n1 1 2 2\n3 3 4 4\n1\n1 1 2 21\n310 10\n2\n1 1 2 2\n3 3 4 4\n1\n1 1 3 32\n2\nДля отправки решения задачи необходимо зарегистрироваться и авторизоваться!\n[Обсуждение]\n\n  [Все попытки]\n\n  [Лучшие попытки]\nwindow.yaContextCb.push(()=\u003e{\n  Ya.Context.AdvManager.render({\n    renderTo: 'yandex_rtb_R-A-122393-3',\n    blockId: 'R-A-122393-3'\n  })\n})",
    "complexity": 61,
    "memory": 32000,
    "time": 1000,
    "examples": [
      {
        "input": "10 10\n\n1\n\n1 1 2 2\n\n1\n\n1 1 2 2",
        "output": "1"
      },
      {
        "input": "10 10\n\n2\n\n1 1 2 2\n\n3 3 4 4\n\n1\n\n1 1 2 2",
        "output": "1"
      },
      {
        "input": "10 10\n\n2\n\n1 1 2 2\n\n3 3 4 4\n\n1\n\n1 1 3 3",
        "output": "2"
      }
    ]
  },
  {
    "id": 735,
    "name": "Циклическое k-расширение",
    "description": "Вася недавно узнал, что такое циклическое k-расширение строки S. Его можно получить следующим образом: склеить k экземпляров строки S, а потом взять первые k символов результата.\nOUTPUT.TXTYES2abcdbcabcYESYESNO[Лучшие попытки]\nУзнав это, Вася обрадовался, взял некоторую строку, и начал к ней применять описанную операцию, не запоминая, какое он каждый раз брал k.\n3abcabcabcANO\nВам дана часть строки, получившейся у Васи. Ваша задача определить, не ошибся ли Вася в своих сложных преобразованиях, т. е., мог ли у него из первоначальной строки получиться ответ, содержащий данную строку в качестве подстроки.\nВходные данные\nВ первой строке входного файла INPUT.TXT находится изначальная строка, которую Вася бережно записал перед тем, как приступить к своим действиям. Во второй строке находится подстрока результата, полученного Васей. Обе строки не пусты и по длине не превышают 5 000 символов. Строки могут состоять из больших и маленьких английских букв (с учетом регистра), а также цифр.\nВыходные данные\nВ выходной файл OUTPUT.TXT выведите \"NO\", если можно точно сказать, что Вася ошибся, и \"YES\", если мог и не ошибиться.",
    "complexity": 53,
    "memory": 16000,
    "time": 1000,
    "examples": [
      {
        "input": "abc\nabc",
        "output": "YES"
      },
      {
        "input": "abcd\nbcabc",
        "output": "YES"
      },
      {
        "input": "abcabc\nabcA",
        "output": "NO"
      }
    ]
  },
  {
    "id": 739,
    "name": "Дана строка",
    "description": "Васе уже надоели задачи на строки! А Вам? А что делать? Что ж, приступим. Дана строка из маленьких букв английского алфавита. Разрешается любой ее символ сдвинуть не более, чем на K позиций в любую сторону так, чтобы в конечном счете они все встали на разные позиции (кроме случая, когда K=0). Например, если строка - aababac, а K = 2, то таким образом можно получить строки abaaabc или aaaabbc, но нельзя - aaacbab или aaaacbb.\nOUTPUT.TXTaaaabbc[Лучшие попытки]\nВася хочет сделать так, чтобы получившаяся с помощью такой операции строка была минимально возможной лексикографически (т.е. расположена раньше всех по правилам упорядочивания слов в словаре). Как же ему быть?\nВходные данные\nВ первой строке входного файла INPUT.TXT задано число K (K ≥ 0). Во второй строке задана сама исходная непустая строка, длиной не более 100 000 маленьких английских букв. Гарантируется, что K не превосходит длины строки.\nВыходные данные\nВ выходной файл OUTPUT.TXT выведите лексикографически минимальный из возможных результатов.",
    "complexity": 47,
    "memory": 16000,
    "time": 1000,
    "examples": [
      {
        "input": "2\naababac",
        "output": "aaaabbc"
      }
    ]
  },
  {
    "id": 920,
    "name": "Игуана",
    "description": "В  парке флоры и фауны затеяли масштабное переустройство. Организаторы  запланировали  расширение площади парка, увеличение количества экзотических животных и строительство новых вольеров. После утверждения плана строители и зоологи принялись за работу. \nijOUTPUT.TXT521011[Лучшие попытки]\nЗоологи со своей задачей справились: привезли новых жирафов,  долгожданных слонов, игуан c карибских островов и многих других животных и птиц. А вот строители не успели достроить новые вольеры, поэтому привезенных животных было решено временно разместить в клетках.\nОднако и эта задача оказалось непростой, так как клеток может не хватить для привезенных животных. А в одну клетку можно поместить только совместимых животных. Зоологи составили таблицу совместимости животных, представив ее в виде матрицы  A={aij} размером N×N. Если животные с номерами i и j совместимы, то aij=0, а если - нет, то aij=1. Необходимо определить минимальное количество клеток для безопасного размещения животных, когда во всех клетках находятся только совместимые между собой животные. При этом в клетке может находиться одно, два и более животных.\nВходные данные\nПервая строка входного файла INPUT.TXT содержит число N - количество животных (1 ≤ N ≤ 18).  Далее идет N строк по N чисел в каждой – матрица совместимости животных.\nВыходные данные\nВ выходной файл OUTPUT.TXT выведите одно целое число – минимальное количество клеток, необходимое для безопасного размещения животных.",
    "complexity": 62,
    "memory": 16000,
    "time": 1000,
    "examples": [
      {
        "input": "5\n\n0 1 1 1 1\n\n1 0 1 1 1\n\n1 1 0 1 1\n\n1 1 1 0 1\n\n1 1 1 1 0",
        "output": "5"
      },
      {
        "input": "1\n0",
        "output": "1"
      }
    ]
  },
  {
    "id": 919,
    "name": "Отель",
    "description": "wOUTPUT.TXTYES22 3 8 6YESYESYESNO[Лучшие попытки]\nПосле строительства пятизвездочного отеля было принято решение о реставрации главной площади. Площадь имеет прямоугольную форму, поэтому для реставрации была закуплена прямоугольная плитка. Однако, через некоторое время стало понятно, что в суматохе не подумали о том,  можно ли плиткой заданного размера полностью замостить площадь без пробелов. Дело в том, что плитка произведена из очень хрупкого камня, поэтому обрезать плитку нельзя. Помогите строителям понять, можно ли замостить площадь прямоугольной плиткой заданного размера.\nh32 3 6 8YES\nНапример, на рисунке показано, как площадь размером 9х6, может быть замощена плиткой 2х3.\n942 3 5 7NO\nВходные данныеw\nВходной файл INPUT.TXT содержит четыре числа tw, th, w, h (1 ≤ tw, th, w, h ≤ 109). Где tw, th – длина и ширина плитки, а w, h – длина и ширина площади.\nh\nВыходные данные\nВ выходной файл OUTPUT.TXT выведите «YES», если можно замостить площадь плиткой и «NO» в противном случае.",
    "complexity": 65,
    "memory": 16000,
    "time": 1000,
    "examples": [
      {
        "input": "2 3 9 6",
        "output": "YES"
      },
      {
        "input": "2 3 8 6",
        "output": "YES"
      },
      {
        "input": "2 3 6 8",
        "output": "YES"
      },
      {
        "input": "2 3 5 7",
        "output": "NO"
      }
    ]
  },
  {
    "id": 921,
    "name": "Турнир - 2",
    "description": "Word-ландия – новая страна, образованная объединением двух древних государств под воздействием внешних угроз. Эти государства теперь являются провинциями Word-ландии, но референдумы по их наименованию ещё не прошли, поэтому они называются Старшая и Младшая Byte-ландии.\n32OUTPUT.TXT124 0 0 10033[Лучшие попытки]\nДля сплочения населения было решено провести чемпионат между провинциями. В Старшей Byte-ландии национальной игрой являются шахматы, а в Младшей – волейбол. Поэтому чемпионат решили провести по шахболу. Чтобы не затягивать чемпионат, объединённое правительство решило провести ровно К матчей. Каждый матч – это либо партия в шахматы, либо волейбольный матч. Победитель в матче получает одно очко в зачёт чемпионата, в случае ничьей в шахматной партии обе провинции получают по 0.5 очка.\ni3\nПравительство заинтересовано в том, чтобы в чемпионате «победила дружба», то есть провинции набрали одинаковое количество очков. Поэтому высокие чины обратились к вам с просьбой определения минимального количества шахматных партий в чемпионате, чтобы разность математических ожиданий набранных провинциями очков была минимальна.\ni1\nЗа долгую историю Мировых чемпионатов известно, что Старшая Byte-ландия выигрывает в шахматы у Младшей с вероятностью p1 и проигрывает в волейбол с вероятностью p2. Ничья в шахматах достигалась с вероятностью p3.\nПримечание: Математическое ожидание - среднее значение случайной величины в теории вероятностей.  Для дискретной случайной величины Х с законом распределения P(X = xi) = pi математическим ожиданием называется сумма парных произведений всех возможных значений случайной величины на соответствующие им вероятности, т.е.\n2\n3\nВходные данные\nВходной файл INPUT.TXT содержит четыре целых числа: К (1 \u003c K ≤ 1016), p1, p2, p3 (0 ≤ p1, p2, p3 ≤ 100) – количества матчей и вероятностей в процентах.\nВыходные данные\nВ выходной файл OUTPUT.TXT выведите одно натуральное число – минимальное количество шахматных партий (учтите, что чемпионат не должен превратиться в шахматный турнир).",
    "complexity": 60,
    "memory": 16000,
    "time": 1000,
    "examples": [
      {
        "input": "3 50 50 50",
        "output": "1"
      },
      {
        "input": "4 0 0 100",
        "output": "3"
      }
    ]
  },
  {
    "id": 946,
    "name": "Полка",
    "description": "У Андрея есть младший брат Ванечка, который очень любит смотреть мультики. Ванечка вечно разбрасывал по дому и терял свои DVD с мультиками. Поэтому на день рождения Андрей подарил брату длинную полку для того, чтобы Ванечка ставил на нее свои диски. Чтобы на полке был порядок, Андрей просил Ванечку соблюдать простой порядок: \nзабирает диски он так же, то есть снимает только с правого или левого края.OUTPUT.TXT3 2221 1311[Лучшие попытки]\nесли на полке нет ни одного диска, то Ванечка просто ставит его;\nесли диск есть, то Ванечка ставит диск либо справа, либо слева от уже расставленных;\nзабирает диски он так же, то есть снимает только с правого или левого края.\nИ теперь Андрей хочет узнать, выполнил Ванечка его инструкции или нет.\nВходные данные\nВ первой строке входного файла INPUT.TXT указано целое число N (1 ≤ N ≤ 10000) - количество операций, которые выполнил Ванечка. Далее в N строках находится информация об операциях. Каждая операция постановки диска на полку описывается парой чисел. Первое из них (1 или 2) показывает, что диск ставится с левого края или с правого края соответственно. Второе целое число (от 0 до 10000) обозначает номер диска. Операции снятия диска с полки описывается одним числом 3 или 4, обозначающим с левого и правого края полки соответственно снимается диск.\nВ начальный момент полка пуста. Гарантируется, что последовательность операций корректна, нет команд снятия диска с пустой полки.\nВыходные данные\nВ выходной файл OUTPUT.TXT для каждой операции снятия диска с полки выведите его номер.",
    "complexity": 31,
    "memory": 16000,
    "time": 1000,
    "examples": [
      {
        "input": "5\n1 1\n2 2\n1 3\n3\n4",
        "output": "3 2"
      },
      {
        "input": "2\n1 1\n3",
        "output": "1"
      }
    ]
  },
  {
    "id": 892,
    "name": "Время года",
    "description": "По заданному номеру месяца в году требуется определить время года.\nOUTPUT.TXTSpring215ErrorError[Лучшие попытки]\nВходные данные\nВходной файл INPUT.TXT содержит натуральное число N (N≤100) – номер месяца.\nВыходные данные\nВ выходной файл OUTPUT.TXT выведите для летних месяцев значение «Summer», для зимних – «Winter», для весенних – «Spring», для осенних – «Autumn». Если число не соответствует возможному значению месяца, то в этом случае следует вывести «Error».",
    "complexity": 10,
    "memory": 16000,
    "time": 1000,
    "examples": [
      {
        "input": "3",
        "output": "Spring"
      },
      {
        "input": "15",
        "output": "Error"
      }
    ]
  },
  {
    "id": 922,
    "name": "Незнайка",
    "description": "Выходные данные\nВ выходной файл OUTPUT.TXT выведите время в часах (с точностью до двух знаков после запятой), за которое звездолет долетит до планеты. Если добраться до планеты не получится, то следует вывести «NO».",
    "complexity": 27,
    "memory": 16000,
    "time": 1000,
    "examples": [
      {
        "input": "5 3 5 3 4",
        "output": "4.00"
      },
      {
        "input": "5 3 5 3 6",
        "output": "12.00"
      },
      {
        "input": "5 1 3 3 6",
        "output": "NO"
      },
      {
        "input": "10 1 100 20 500",
        "output": "65.00"
      }
    ]
  },
  {
    "id": 947,
    "name": "Карточки - 3",
    "description": "Студент-первокурсник Антон никак не может понять странную формулу \nOUTPUT.TXT3 card(s)23.7161 card(s)61 card(s)1 card(s)273 card(s)[Лучшие попытки]\n1/2 + 1/3 + 1/4 + ... + 1/n + ... → бесконечность \n30.041 card(s)\nХорошо, что у Антона есть друг Васька, который отлично знает математику. Вот и придумал Васька, как Антошке объяснить эту самую бесконечность. Взял колоду карт и стал раскладывать карты на столе. Если есть одна карта, она нависает над столом на 1/2 длины карты. Если есть две карты, то верхняя нависает над нижней на 1/2 длины карты, а нижняя - нависает над столом на 1/3 длины. В итоге получается нависание 1/2+1/3=5/6. А если у нас есть N карт, то длина нависающей части уже 1/2+1/3+1/4+...+1/(N+1). \n45.19273 card(s)\nИ стал Васька с Антоном в такую игру играть: Антон называет какое-нибудь число, а Вася называет минимальное количество карт, которое нужно положить, чтобы длина нависающей части была бы не меньше этого числа.\nНапишите программу, которая помогает Васе каждый раз давать правильный ответ.\nВходные данные\nВходной файл INPUT.TXT содержит единственное положительное число X - длина нависающей части. Число X задано с двумя знаками после запятой и 0.01 ≤ x \u003c 10.00.\nВыходные данные\nВ выходной файл OUTPUT.TXT выведите ответ на задачу по формату, приведенному в примерах.",
    "complexity": 22,
    "memory": 16000,
    "time": 1000,
    "examples": [
      {
        "input": "1.00",
        "output": "3 card(s)"
      },
      {
        "input": "3.71",
        "output": "61 card(s)"
      },
      {
        "input": "0.04",
        "output": "1 card(s)"
      },
      {
        "input": "5.19",
        "output": "273 card(s)"
      }
    ]
  },
  {
    "id": 948,
    "name": "Строки в книге",
    "description": "В книге на одной странице помещается K строк. Таким образом, на 1-й странице печатаются строки с 1-й по K-ю, на второй — с (K+1)-й по (2∙K)-ю и т.д. Напишите программу, которая по номеру строки в тексте определяет номер страницы, на которой будет напечатана эта строка, и порядковый номер этой строки на странице.\nOUTPUT.TXT1 1220 252 52 53 13[Лучшие попытки]\nВходные данные315 433 13\nПервая строка входного файла INPUT.TXT содержит два числа через пробел: K – количество строк, которое печатается на странице, и число N – номер строки (1 ≤ K ≤ 200, 1 ≤ N ≤ 20000).\nВыходные данные\nВ выходной файл OUTPUT.TXT выведите два числа – номер страницы, на которой будет напечатана эта строка и номер строки на странице.",
    "complexity": 13,
    "memory": 16000,
    "time": 1000,
    "examples": [
      {
        "input": "50 1",
        "output": "1 1"
      },
      {
        "input": "20 25",
        "output": "2 5"
      },
      {
        "input": "15 43",
        "output": "3 13"
      }
    ]
  },
  {
    "id": 893,
    "name": "Хоккей",
    "description": "В соревнованиях по хоккею участвует N команд. Сколько существует вариантов распределения комплектов золотых, серебряных и бронзовых медалей, если одно призовое место может занять только одна команда?\nOUTPUT.TXT622068406840[Лучшие попытки]\nВходные данные\nВходной файл INPUT.TXT содержит целое число N (1 ≤ N ≤ 104) – количество команд.\nВыходные данные\nВ выходной файл OUTPUT.TXT выведите единственное число – искомое количество способов награждения участников.",
    "complexity": 21,
    "memory": 16000,
    "time": 1000,
    "examples": [
      {
        "input": "3",
        "output": "6"
      },
      {
        "input": "20",
        "output": "6840"
      }
    ]
  },
  {
    "id": 894,
    "name": "Кольцо",
    "description": "OUTPUT.TXT3.000[Лучшие попытки]\nЗаданы площадь кольца и радиус внешней окружности. Требуется определить радиус внутренней окружности.\nВходные данные\nВходной файл INPUT.TXT содержит два положительных вещественных числа: S и R1 – площадь кольца и радиус внешней окружности соответственно. Радиус внешней окружности не превышает 100.\nВыходные данные\nВ выходной файл OUTPUT.TXT выведите радиус внутренней окружности R2 с точностью не худшей, чем 10-3.",
    "complexity": 16,
    "memory": 16000,
    "time": 1000,
    "examples": [
      {
        "input": "50.265482 5.0",
        "output": "3.000"
      }
    ]
  },
  {
    "id": 949,
    "name": "Фибоначчиева последовательность",
    "description": "Выходные данные\nВ выходной файл OUTPUT.TXT выведите два числа — значения первого и второго членов этой последовательности.",
    "complexity": 17,
    "memory": 16000,
    "time": 1000,
    "examples": [
      {
        "input": "4 3 5",
        "output": "1 1"
      }
    ]
  },
  {
    "id": 803,
    "name": "Цифры после запятой",
    "description": "По заданным натуральным числам A и B найти K-ю цифру после запятой в дроби A/B в десятичной системе счисления.\nOUTPUT.TXT521 6 1366[Лучшие попытки]\nВходные данные[Решение]\nВ единственной строке входного файла INPUT.TXT записано три натуральных числа A, B и K через пробел. А и B – цифры (числа от 1 до 9), число K не превышает 106.\nВыходные данные\nВ выходной файл OUTPUT.TXT нужно вывести ответ на задачу.",
    "complexity": 26,
    "memory": 16000,
    "time": 1000,
    "examples": [
      {
        "input": "7 4 2",
        "output": "5"
      },
      {
        "input": "1 6 13",
        "output": "6"
      }
    ]
  },
  {
    "id": 896,
    "name": "Торт - 2",
    "description": "Никифор на день рождения собирается угостить друзей тортом. Известно, что на дне рождения может быть либо M, либо N человек, включая самого именинника. На какое минимальное количество частей ему нужно разрезать торт (не обязательно всех равных), чтобы при любом из указанных количеств собравшихся, все съели торт поровну?\nOUTPUT.TXT4[Лучшие попытки]\nВходные данные\nВходной файл INPUT.TXT содержит два натуральных числа M и N через пробел (1 ≤ M, N ≤ 30000).\nВыходные данные\nВ выходной файл OUTPUT.TXT выведите единственное число – искомое минимальное количество кусочков торта.",
    "complexity": 32,
    "memory": 16000,
    "time": 1000,
    "examples": [
      {
        "input": "2 3",
        "output": "4"
      }
    ]
  },
  {
    "id": 895,
    "name": "Крестики-нолики",
    "description": "OUTPUT.TXTWin2OXO\n.OX\nOXXLoseLoseDraw[Лучшие попытки]\nКрестики-нолики – логическая игра между двумя противниками на квадратном поле 3 на 3 клетки. Один из игроков играет «крестиками» (тот, кто ходит первым), другой – «ноликами». Игроки по очереди ставят на свободные клетки поля знаки (один всегда «крестики», другой всегда «нолики»). Первый, выстроивший в ряд три своих фигуры по вертикали, горизонтали или диагонали, выигрывает и на этом игра заканчивается. В том случае, когда все клетки заполнены и победитель не определен, игра завершается ничьей.\n3XOX\nXOX\nOXODraw\nПо состоянию игрового поля в конце игры требуется определить результат игры для первого игрока: выиграл, проиграл или сыграл вничью.\nВходные данные\nВходной файл INPUT.TXT содержит информацию об игровом поле – три строки по три символа в каждой. Символ «X» (ASCII 88) означает «крестик», символ «O» (ASCII 79) - «нолик», а символ «.» (ASCII 46) - пустую клетку.\nВыходные данные\nВ выходной файл OUTPUT.TXT выведите в случае победы первого игрока «Win», в случае его проигрыша – «Lose» и «Draw» в случае ничьей.",
    "complexity": 19,
    "memory": 16000,
    "time": 1000,
    "examples": [
      {
        "input": ".OX\n\n.XO\n\nXXO",
        "output": "Win"
      },
      {
        "input": "OXO\n\n.OX\n\nOXX",
        "output": "Lose"
      },
      {
        "input": "XOX\n\nXOX\n\nOXO",
        "output": "Draw"
      }
    ]
  },
  {
    "id": 801,
    "name": "Дом у дороги",
    "description": "Министерство дорожного транспорта решило построить себе новый офис. Поскольку министр регулярно выезжает с инспекцией наиболее важных трасс, было решено, что офис министерства не должен располагаться слишком далеко от них. \n2OUTPUT.TXT0.5 0.5[Лучшие попытки]\nНаиболее важные трассы представляют собой прямые на плоскости. Министерство хочет выбрать такое расположение для своего офиса, чтобы максимум из расстояний от офиса до трасс был как можно меньше.\n2\nТребуется написать программу, которая по заданному расположению наиболее важных трасс определяет оптимальное расположение дома для офиса министерства дорожного  транспорта.\n1\nВходные данные1\nПервая строка входного файла INPUT.TXT содержит одно целое число n – количество наиболее важных трасс (1 ≤ n ≤ 104).\n2\nПоследующие n строк описывают трассы. Каждая трасса описывается четырьмя целыми числами x1, y1, x2 и y2 и представляет собой прямую, проходящую через точки (x1, y1) и (x2, y2). Координаты заданных точек не превышают по модулю 104. Точки (x1, y1) и (x2, y2) ни для какой прямой не совпадают.\n2\n4Выходные данные\n1\nВыходной файл OUTPUT.TXT должен содержать два разделенных пробелом вещественных числа: координаты точки, в которой следует построить офис министерства дорожного транспорта. Координаты по модулю не должны превышать 109, гарантируется, что хотя бы один такой ответ существует. Если оптимальных ответов несколько, необходимо вывести любой из них.\n1\nОтвет должен иметь абсолютную или относительную погрешность не более 10-6, что означает следующее. Пусть максимальное расстояние от выведенной точки до некоторой трассы равно x, а в правильном ответе оно равно y. Ответ будет засчитан, если значение выражения |x – y| / max{1, |y| } не превышает 10-6.\n2Примеры\n2\n№INPUT.TXTOUTPUT.TXT\n14\n0 0 0 1\n0 0 1 0\n1 1 2 1\n1 1 1 20.5 0.5\nДля отправки решения задачи необходимо зарегистрироваться и авторизоваться!\n[Обсуждение]\n\n  [Все попытки]\n\n  [Лучшие попытки]\nwindow.yaContextCb.push(()=\u003e{\n  Ya.Context.AdvManager.render({\n    renderTo: 'yandex_rtb_R-A-122393-3',\n    blockId: 'R-A-122393-3'\n  })\n})",
    "complexity": 78,
    "memory": 16000,
    "time": 1000,
    "examples": [
      {
        "input": "4\n\n0 0 0 1\n\n0 0 1 0\n\n1 1 2 1\n\n1 1 1 2",
        "output": "0.5 0.5"
      }
    ]
  },
  {
    "id": 837,
    "name": "Точки и линии",
    "description": "Вася и Петя играют в следующую игру. Вася рисует в трехмерном пространстве N точек и говорит число M. Петя должен ответить, можно ли соединить эти N точек с помощью M непересекающихся линий, так, чтобы выполнялись следующие условия:\nДля любой пары точек существует не более одной соединяющей их линии.OUTPUT.TXTYesNo[Лучшие попытки]\nКаждая линия соединяет ровно две точки.\nНикакая линия не соединяет точку саму с собой.\nДля любой пары точек существует не более одной соединяющей их линии.\nСуществуют такие две точки A и B, что из A нельзя добраться вдоль нарисованных линий до B (по каждой линии можно идти в любую сторону).\nСуществуют такие две точки A и B, что из A нельзя добраться вдоль нарисованных линий до B (по каждой линии можно идти в любую сторону).[Решение]\nЕсли Петя отвечает правильно, то он выигрывает, иначе выигрывает Вася.\nВаша задача — написать программу, которая поможет Пете всегда выигрывать.\nВходные данные\nВ первой строке входного файла INPUT.TXT записано число  K – количество тестов во входном файле (1 ≤ K ≤ 1000). В следующих K строках записаны числа N (1 ≤ N ≤ 109) и M (0 ≤ M ≤ 109).\nВыходные данные\nДля каждого из K тестов в отдельной строке запишите правильный ответ на вопрос Васи, строку «Yes» (если ответ положительный) или «No» (если ответ отрицательный).",
    "complexity": 33,
    "memory": 16000,
    "time": 1000,
    "examples": [
      {
        "input": "2\n\n2 0\n2 2",
        "output": "Yes\nNo"
      }
    ]
  },
  {
    "id": 804,
    "name": "Лабиринт с тигром",
    "description": "В средние века в замках Европы был популярен следующий вид казни: в лабиринт, в котором находился тигр, заводили раба. Рабу была известна карта лабиринта и его первоначальное расположение. Тигр обладал очень тонким обонянием, то есть он знал, где находится раб в любой момент времени и мог в кратчайшее время настигнуть раба и съесть, если мог. \nOUTPUT.TXT12No2\n8 10\n##########\n#.#...##.#\n#.#..###.#\n#.#.##...#\n#.......##\n#..####..#\n#....T#..#\n##########12Yes12Yes[Лучшие попытки]\nДана схема лабиринта в виде таблицы N×M. Вход в лабиринт находится в левой верхней клетке.  В этом же месте находится раб в начальный момент времени. Выход из лабиринта находится в правой нижней клетке. Гарантируется, что от входа до выхода существует путь и что тигр находится в свободной клетке лабиринта. Также известно, что лабиринт ограничен сплошной стеной по периметру.\nНеобходимо определить длину кратчайшего пути раба до выхода, и сможет ли раб гарантированно выбраться из лабиринта живым, если за единицу времени как раб, так и тигр, могут переместиться в соседнюю по стороне клетку в произвольном свободном направлении (то есть туда, где нет стены).\nВходные данные\nПервая строка входного файла INPUT.TXT содержит два числа: N и M – длина и ширина лабиринта (4 ≤ N, M ≤ 1000). Далее следует  N строк по M символов – описание лабиринта. Символ «#» означает стену, а символ «.» - свободное пространство, «T» - положение тигра в начальный момент времени.\nВыходные данные\nВ первой строке выходного файла OUTPUT.TXT выведите целое число – длину кратчайшего пути раба, во второй строке выведите «Yes», если раб гарантированно сможет добраться до выхода, и «No» в противном случае.",
    "complexity": 48,
    "memory": 32000,
    "time": 1000,
    "examples": [
      {
        "input": "8 10\n\n##########\n\n#.#...##.#\n\n#.#..###.#\n\n#.#.##...#\n\n#.......##\n\n#...###..#\n\n#....T#..#\n\n##########",
        "output": "12\nNo"
      },
      {
        "input": "8 10\n\n##########\n\n#.#...##.#\n\n#.#..###.#\n\n#.#.##...#\n\n#.......##\n\n#..####..#\n\n#....T#..#\n\n##########",
        "output": "12\nYes"
      }
    ]
  },
  {
    "id": 802,
    "name": "Магический квадрат",
    "description": "4\n9\n2\n\n\n3\n5\n7\n\n\n8\n1\n6\n\n27\n8\n1\n6\n62OUTPUT.TXT122ImpossibleImpossible4 9 23 5 78 1 6[Лучшие попытки]\nМагический квадрат - это квадратная таблица N x N, заполненная N2 числами от 1 до N2 таким образом, что сумма чисел в каждой строке, каждом столбце и на обеих диагоналях одинакова. При этом числа в таблице не должны повторяться и каждое из чисел от 1 до N2 должно в ней присутствовать.\n2334 9 23 5 78 1 6\nТребуется написать программу, которая по заданному N строит магический квадрат.\nВходные данные\nВо входном файле INPUT.TXT задано единственное натуральное число N - размерность магического квадрата (N ≤ 1000).\nВыходные данные\nВ выходной файл OUTPUT.TXT необходимо вывести магический квадрат - матрицу, состоящую из N строк по N элементов в каждой. Если вариантов решения несколько, то можно вывести любой. В том случае, когда решение не существует, следует вывести \"Impossible\".",
    "complexity": 70,
    "memory": 16000,
    "time": 1000,
    "examples": [
      {
        "input": "1",
        "output": "1"
      },
      {
        "input": "2",
        "output": "Impossible"
      },
      {
        "input": "3",
        "output": "4 9 2\n3 5 7\n8 1 6"
      }
    ]
  },
  {
    "id": 818,
    "name": "Кипячение чая",
    "description": "В эту субботу у Васи день рождения, и через 15 минут к нему придут гости. Ему срочно надо вскипятить чай, для того чтобы напоить им гостей. У Васи дома есть много литровых чайников (можно считать, что их бесконечное количество), а розетка всего одна. Т.к. вода кипятится очень долго, за 15 минут она успеет вскипятиться максимум один раз. Но Вася – мальчик не промах, он достал из кладовки N тройников, в i-том тройнике ai разъемов. Теперь Вася ломает голову: как ему соединить тройники и воткнуть эту систему в розетку, чтобы максимизировать количество чайников, которые он сможет поставить кипятить.\niOUTPUT.TXT1232 5 499[Лучшие попытки]\nВаша задача заключается в написании программы, которая определит максимальное число чайников, которые возможно использовать для кипячения чая, используя данные тройники.\n[Решение]\nВходные данные\nВ первой строке входного файла INPUT.TXT содержится число N (1 ≤ N ≤ 105) – количество тройников. Во второй строке через пробел перечислены числа ai (1 ≤ ai ≤ 1000, 1 ≤ i ≤ N) – информация о тройниках.\nВыходные данные\nВ выходной файл OUTPUT.TXT выведите ответ на задачу.",
    "complexity": 14,
    "memory": 16000,
    "time": 1000,
    "examples": [
      {
        "input": "1\n1",
        "output": "1"
      },
      {
        "input": "3\n2 5 4",
        "output": "9"
      }
    ]
  },
  {
    "id": 817,
    "name": "Манхэттенские улицы",
    "description": "Система улиц Нью-Йоркского района Манхеттен весьма интересна. В Манхеттене есть n улиц, идущие с запада на восток (авеню), и m\t улиц, идущие с севера на юг (просто улицы). Ширина каждого авеню и каждой улицы равна d метров, а длина – k метров. При этом каждая улица пересекает каждый авеню и не имеет общих точек с другими улицами, а каждый авеню пересекает каждую улицу и не имеет общих точек с другими авеню.\nOUTPUT.TXT752100 10 23 45601100780011007800[Лучшие попытки]\nРазумеется, все авеню и улицы имеют асфальтовое покрытие. Дорожно-ремонтные службы интересуются: сколько квадратных метров асфальта уложено на все авеню и улицы. На перекрестках, без сомнения, асфальт уложен в один слой.\n[Решение]\nНапишите программу, вычисляющую ответ на их вопрос.\nВходные данные\nВходной файл INPUT.TXT содержит четыре натуральных числа n, m, d, k (1 ≤ n, m, d, k ≤ 109, k \u003e m∙d, k \u003e n∙d).\nВыходные данные\nВ выходной файл OUTPUT.TXT выведите ответ на задачу.",
    "complexity": 17,
    "memory": 16000,
    "time": 1000,
    "examples": [
      {
        "input": "1 1 5 10",
        "output": "75"
      },
      {
        "input": "100 10 23 4560",
        "output": "11007800"
      }
    ]
  },
  {
    "id": 822,
    "name": "Площадь треугольника",
    "description": "",
    "complexity": 15,
    "memory": 16000,
    "time": 1000,
    "examples": [
      {
        "input": "2 1 2 4 6 1",
        "output": "6"
      },
      {
        "input": "0 0 0 3 3 0",
        "output": "4.5"
      }
    ]
  },
  {
    "id": 821,
    "name": "Пятнашки",
    "description": "OUTPUT.TXT8 1 3\n0 2 5\n4 7 622URLERROR 2ERROR 2[Лучшие попытки]\nПятнашки – популярная головоломка, представляющая собой набор одинаковых квадратных костяшек с нанесёнными числами, заключённых в квадратную коробку, имеющей размер 4х4. Цель игры — перемещая костяшки по коробке добиться упорядочивания их по номерам (как показано на рисунке), желательно сделав как можно меньше перемещений. Известно, что не любое размещение костяшек на доске позволяет получить решаемую задачу.\n[Решение]\nРассмотрим более общую игру для доски N x N, где будет использоваться N2-1 костяшек с числами. Самый надежный способ получить решаемую головоломку – это провести последовательность произвольных ходов из конечного решенного состояния. Такой набор действий удобно представить в виде последовательности символов, обозначающих направления движения пустого места на доске. Пусть «U», «D», «L» и «R» – возможные направления движения, обозначающие «вверх», «вниз», «влево» и «вправо» соответственно. Игровую коробку удобно представить матрицей, а костяшки – числами. Пустое место будем обозначать цифрой «0».\nНапример, для N=3 первоначально мы будем иметь следующую доску:\n1 2 3\n 4 5 6\n 7 8 0\nПосле команды «ULD» мы получим следующее состояние:\n1 2 3\n 4 8 5\n 7 0 6\nЗаметим, что команда «URLD» невыполнима в связи с невозможностью на втором ходе передвинуть пустое поле вправо.\nПо заданному размеру поля и последовательности команд требуется определить конечное состояние игрового поля.\nВходные данные\nПервая строка входного файла INPUT.TXT содержит натуральное число N – размерность игрового поля (N ≤ 20). Во второй строке располагается последовательность команд (не более 104 действий), содержащая только символы «U», «D», «L» и «R», записанные слитно.\nВыходные данные\nВ выходной файл OUTPUT.TXT выведите таблицу конечного состояния игрового поля. В том случае, когда команда не выполнима, в выходной файл следует вывести только текст «ERROR K», где K – номер хода, на котором произошла ошибка. При выводе допускается использование избыточных пробелов и переносов строк.",
    "complexity": 35,
    "memory": 16000,
    "time": 1000,
    "examples": [
      {
        "input": "3\nULDLURULD",
        "output": "8 1 3\n\n0 2 5\n\n4 7 6"
      },
      {
        "input": "2\nURL",
        "output": "ERROR 2"
      }
    ]
  },
  {
    "id": 819,
    "name": "Прямоугольный параллелепипед",
    "description": "",
    "complexity": 10,
    "memory": 16000,
    "time": 1000,
    "examples": [
      {
        "input": "1 1 1",
        "output": "6 1"
      },
      {
        "input": "2 3 4",
        "output": "52 24"
      }
    ]
  },
  {
    "id": 820,
    "name": "Игра «Flip-Flop»",
    "description": "OUTPUT.TXT22\nbwbw\nwwww\nbbwb\nbwwb\nImpossibleImpossible[Лучшие попытки]\nВ игре «Flip-Flop» используется прямоугольное поле 4×4 с двухсторонними фишками, расположенными на каждом из 16 квадратов.  Одна сторона каждой фишки имеет черный цвет, а другая – белый. При каждом ходе происходит выбор клетки, рядом с которой (слева, справа, сверху, снизу и в центре)  происходит инверсия от 3х до 5ти фишек таким образом, что они меняют свой цвет на противоположный.\nРассмотрим в качестве примера следующую позицию:\nbwbw\n   wwww\n   bbwb\n   bwwb\nЗдесь «b» обозначает черный цвет лицевой стороны фишки, а «w» - белый. Если мы в качестве хода выбираем поле, расположенное в 3й строке и 1м столбце, то результат будет следующим:\nbwbw\n   bwww\n   wwwb\n   wwwb\nЦель игры заключается в том, чтобы все фишки стали одного и того же цвета. Вы должны написать программу, которая будет искать минимальное количество ходов, необходимых для достижения этой цели.\nВходные данные\nВходной файл INPUT.TXT содержит 4 строки по 4 символа «w» или «b» в каждой, описывающие цвета фишек.\nВыходные данные\nВ выходной файл OUTPUT.TXT выведите одно целое число – минимальное количество ходов, необходимых для достижения цели. Если исходная доска уже имеет набор фишек одинакового цвета, то следует вывести 0. Если решения не существует, то следует вывести слово «Impossible».",
    "complexity": 54,
    "memory": 16000,
    "time": 1000,
    "examples": [
      {
        "input": "wbww\n\nbbww\n\nwwbb\n\nwwbw",
        "output": "2"
      },
      {
        "input": "bwbw\n\nwwww\n\nbbwb\n\nbwwb",
        "output": "Impossible"
      }
    ]
  },
  {
    "id": 823,
    "name": "Мусорщик",
    "description": "iOUTPUT.TXT18[Лучшие попытки]\nВсем известно, что работа уборщицы становится все менее престижной, чем работа программиста. Поэтому, все больше становится программистов и все меньше уборщиц. И скоро, возможно, совсем некому будет делать уборку помещений, а чистота – она всегда актуальна и важна для работы, например, для тех же программистов.\ni[Решение]\nСотрудники одной из фирм разработали специальную машину «Мусорщик-001», которая предназначена для уборки прямоугольных пустых помещений. Машина не совершенна и может пока двигаться на 1 метр только влево, вправо и вперед (вдоль оси OY). Каждое помещение можно разбить на квадратные сектора со стороной в 1 метр и обозначить те, которые загрязнены. Для уборки помещения достаточно, чтобы машина-уборщик побывала в каждом из загрязненных секторов. Известно, что перед уборкой машина всегда находится в клетке (1,1) .\nОдна из компаний, где в штате нет уборщицы, но имеется полный штат программистов,  приобрела «Мусорщик-001». Пока программистам никак не удается написать программу, определяющую по заданному плану загрязнения помещения минимально возможную длину маршрута машины-уборщика, необходимого для уборки данной территории. Возможно, Вам удастся им помочь!\nВходные данные\nПервая строка входного файла INPUT.TXT содержит натуральное число n (n ≤ 1000). Следующие n строк содержат по два натуральных числа: xi и yi – координаты загрязненных секторов в заданном помещении (xi, yi ≤ 50).\nВыходные данные\nВ выходной файл OUTPUT.TXT выведите целое число, соответствующее минимальной длине маршрута в метрах, необходимого для уборки.",
    "complexity": 45,
    "memory": 16000,
    "time": 1000,
    "examples": [
      {
        "input": "7\n2 1\n3 2\n5 2\n5 4\n1 4\n3 6\n6 6",
        "output": "18"
      }
    ]
  },
  {
    "id": 807,
    "name": "Игра с графом",
    "description": "Петя и Вася играют в очередную интересную игру. У них есть лист бумаги, на котором изображены n кружочков, помеченных числами от 1 до n. Участники по очереди рисуют стрелочки, соединяющие кружочки. При этом стрелочку из кружочка a в кружочек b разрешено проводить, если выполнены два условия:\nOUTPUT.TXT25[Лучшие попытки]\nеще нет стрелочки из a в b;\nнельзя дойти по стрелочкам из b в a.\nНапример, в позиции на рис. 1 можно поставить одну из трех стрелочек (рис. 2).\nПроигрывает тот, кто не может сделать ход. Петя решил написать программу, играющую в эту игру. Для этого он хочет сначала посчитать, сколько различных позиций может получиться на доске.\nВходные данные\nВходной файл INPUT.TXT содержит одно число n (1 ≤ n ≤ 100).\nВыходные данные\nВ выходной файл OUTPUT.TXT выведите число возможных позиций без ведущих нулей.",
    "complexity": 83,
    "memory": 16000,
    "time": 1000,
    "examples": [
      {
        "input": "3",
        "output": "25"
      }
    ]
  },
  {
    "id": 808,
    "name": "Про любовь ...",
    "description": "2OUTPUT.TXT1.620 0 -1 3\n4 4 7 7\n1 0\n0 -3-1-1[Лучшие попытки]\nПаук и паучиха плывут по озеру на двух веточках. Плавать они не умеют, поэтому смогут встретиться только тогда, когда веточки соприкоснутся.\n2\nСчитая, что веточки имеют форму отрезков, и что они плывут с постоянными скоростями, определите, сколько осталось ждать встречи несчастным членистоногим.\n3\nВходные данные3\nВходной файл INPUT.TXT содержит 12 чисел: x1, y1, x2, y2, x3, y3, x4, y4, v1x, v1y, v2x, v2y. Координаты вершин первого отрезка: (x1, y1) и (x2, y2), координаты вершин второго отрезка: (x3, y3) и (x4, y4), скорость первого отрезка (v1x, v1y), скорость второго отрезка (v2x, v2y). Все числа целые и не превосходят по модулю 104. В начальный момент времени веточки не соприкасаются. Гарантируется, что веточки имеют ненулевую длину.\n4\n4Выходные данные\n1x\nВыведите в выходной файл OUTPUT.TXT время до ближайшего момента, когда веточки соприкоснутся, с ошибкой не более 10−4. Если веточки не соприкоснутся никогда, выведите число −1.\n1yПримеры\n2x\n№INPUT.TXTOUTPUT.TXT\n10 0 -1 3\n4 4 7 7\n3 0\n0 -11.6\n20 0 -1 3\n4 4 7 7\n1 0\n0 -3-1\n2y\n1Для отправки решения задачи необходимо зарегистрироваться и авторизоваться!\n1\n\n  [Обсуждение]\n\n  [Все попытки]\n\n  [Лучшие попытки]\n2\n2\n\n\n\nwindow.yaContextCb.push(()=\u003e{\n  Ya.Context.AdvManager.render({\n    renderTo: 'yandex_rtb_R-A-122393-3',\n    blockId: 'R-A-122393-3'\n  })\n})\n3\n3\n4\n4\n1x\n1y\n2x\n2y\n4",
    "complexity": 70,
    "memory": 16000,
    "time": 1000,
    "examples": [
      {
        "input": "0 0 -1 3\n\n4 4 7 7\n\n3 0\n\n0 -1",
        "output": "1.6"
      },
      {
        "input": "0 0 -1 3\n\n4 4 7 7\n\n1 0\n\n0 -3",
        "output": "-1"
      }
    ]
  },
  {
    "id": 806,
    "name": "Белоснежка и n гномов",
    "description": "Ну не гномы, а наказание какое-то! Подумала Белоснежка, в очередной раз пытаясь уложить гномов спать. Одного уложишь,  другой уже проснулся! И так всю ночь. У Белоснежки n гномов, и все они очень разные. Она знает, что для того, чтобы уложить спать i-го гнома нужно ai минут, и после этого он будет спать ровно bi минут. Помогите Белоснежке узнать, может ли она получить хотя бы минутку отдыха, когда все гномы будут спать, и если да, то в каком порядке для этого нужно укладывать гномов спать.\n22OUTPUT.TXT2 122\n10 10\n10 10-1-1[Лучшие попытки]\nНапример, пусть есть всего два гнома, a1=1, b1=10, a2=10, b2=20. Если Белоснежка сначала начнет укладывать первого гнома, то потом ей потребуется целых 10 минут, чтобы уложить второго, а за это время проснется первый. Если же она начнет со второго гнома, то затем она успеет уложить первого и получит целых 10 минут отдыха.\n2n\nВходные данные1\nПервая строка входного файла INPUT.TXT содержит число n (1 ≤ n ≤ 105), вторая строка содержит числа a1, a2, . . . an, третья - числа b1, b2, . . . bn (1 ≤ ai, bi ≤ 109).\n2\nnВыходные данные\ni\nВ выходной файл OUTPUT.TXT выведите n чисел – порядок, в котором нужно укладывать гномов спать. Если Белоснежке отдохнуть не удастся, выведите число −1.\niПримеры\n9\n№INPUT.TXTOUTPUT.TXT\n12\n1 10\n10 202 1\n22\n10 10\n10 10-1\nДля отправки решения задачи необходимо зарегистрироваться и авторизоваться!\n[Обсуждение]\n\n  [Все попытки]\n\n  [Лучшие попытки]\nwindow.yaContextCb.push(()=\u003e{\n  Ya.Context.AdvManager.render({\n    renderTo: 'yandex_rtb_R-A-122393-3',\n    blockId: 'R-A-122393-3'\n  })\n})",
    "complexity": 46,
    "memory": 64000,
    "time": 1000,
    "examples": [
      {
        "input": "2\n\n1 10\n\n10 20",
        "output": "2 1"
      },
      {
        "input": "2\n\n10 10\n\n10 10",
        "output": "-1"
      }
    ]
  },
  {
    "id": 805,
    "name": "Атака инопланетян",
    "description": "iOUTPUT.TXT4.500[Лучшие попытки]\nНа город Энск нападает флот инопланетян. Флот состоит из n космических кораблей, каждый из которых имеет форму равнобедренного прямоугольного треугольника. Носом инопланетного корабля считается вершина, угол при которой прямой, а осью корабля называется высота, опущенная на гипотенузу.\ni[Решение]\nФлот инопланетян прилетел с северо-востока, и застыл в таком положении, что все оси кораблей направлены строго на юго-запад.\t\ni\nЕдинственный способ нанести урон инопланетной армии  это пустить из некоторой точки поверхности Земли лазерный луч вертикально вверх. Пущенный так луч прожигает насквозь все вражеские корабли, через которые он проходит (даже те, которые он задевает по границе). Но этот выстрел повредит инопланетянам только в случае, если все n кораблей будут при этом поражены.\ni\nВоенные власти города Энска решили нанести удар по вражеским войскам. Для этого решено поставить лазер в одну из точек, над которыми находятся все n вражеских кораблей. Помогите военным определить площадь территории, на которой можно поставить лазер.\n5\nВходные данные\nВ первой строке входного файла INPUT.TXT содержится целое число n  количество инопланетных кораблей (1 ≤ n ≤ 100). В каждой из следующих n строк описывается положение очередного корабля. Описание состоит из трех целых чисел xi, yi и si, где xi и yi координаты носа, а si размер корабля. Поскольку корабль имеет форму равнобедренного прямоугольного треугольника, размером корабля военные решили называть длину катета. Размеры кораблей  положительные числа, не превышающие 1 000. Координаты носов кораблей не превышают по абсолютной величине 105.\nВыходные данные\nВ выходной файл OUTPUT.TXT выведите площадь территории, над которой находятся все инопланетные корабли. Выведите ответ с точностью до трех знаков после десятичной точки.",
    "complexity": 36,
    "memory": 16000,
    "time": 1000,
    "examples": [
      {
        "input": "3\n\n2 4 6\n\n4 2 7\n\n3 3 5",
        "output": "4.500"
      }
    ]
  },
  {
    "id": 825,
    "name": "Китайская игра «Цзяньшидзы»",
    "description": "В древнем Китае было придумано множество интересных игр. Все знают очень известную игру «Majong». В данной задаче мы рассмотрим другую интересную китайскую игру «Цзяньшидзы». Кратко сформулируем правила игры:\ni29OUTPUT.TXT0 01 23 5\n[Лучшие попытки]\nИз двух куч каменей, двое играющих поочередно могут брать:\ni2\nПроизвольное ненулевое число камней из одной кучи.\nОдновременно по одинаковому произвольному ненулевому числу камней из обеих куч.\n1\nВыигрывает тот, кто возьмет своим ходом последний камень.\n2\nНе сложно определить в каких случаях выигрывает первый, а в каких случаях выигрывает второй игрок. Задача сводится к нахождению так называемых проигрышных пар (ai, bi), означающих, что при кучах камней содержащих ai и bi камней проигрывает тот, кто в данный момент совершает свой ход. Вам предстоит решить эту задачу, но немного в другом виде.\n1\nОбозначим проигрышную, для ходящего позицию, когда в кучках a и b камней  (a, b). Так как порядок куч не играет роли, то всегда будем считать, что a ≤ b.  Упорядочим все проигрышные позиции в лексикографическом порядке, иначе говоря: \n2\n(a1, b1) \u003c (a2, b2), если (a1\u003c a2) или ((a1= a2) и (b1\u003c b2)).\n1\n2\nЗанумеруем проигрышные пары, начиная с 0. Ваша задача: найти k-ю пару проигрышных куч.\nВходные данные\nВ первой строке входного файла INTPUT.TXT находится число N, (1 ≤ N ≤ 1000) - количество тестов в файле. В следующих N строках содержатся числа ki, (0 ≤ ki ≤ 109) порядковый номер пары проигрышных куч, которую требуется найти.\nВыходные данные\nВ выходной файл OUTPUT.TXT выведите N пар чисел (aki, bki) по одной в каждой строке.",
    "complexity": 69,
    "memory": 16000,
    "time": 1000,
    "examples": [
      {
        "input": "3\n0\n1\n2",
        "output": "0 0\n1 2\n3 5"
      }
    ]
  },
  {
    "id": 826,
    "name": "Жизнь цвета индиго",
    "description": "Мальчику Севе очень нравится цвет индиго (это такой темно-синий цвет). Сева всячески старается окружить себя вещами этого цвета.\niOUTPUT.TXT2[Лучшие попытки]\nСкоро Новый год, и Сева решил изготовить гирлянду с лампочками, чтобы украсить ей свою комнату. Он купил n патронов для лампочек и соединил (n−1)-им проводом так, что в гирлянде не образовалось ни одного замкнутого контура. Его гирлянда, таким образом, с точки зрения математики, представляет собой дерево. Для того чтобы гирлянда была готова, осталось совсем немного  надо только добавить провод для подключения гирлянды в электрическую сеть и вкрутить разноцветные лампочки в патроны.\ni\nУ Севы есть лампочки трех разных цветов: синего, фиолетового и индиго. При этом, в некоторые патроны из соображений красоты нельзя устанавливать лампочки определенных цветов. Также, из соображений красоты, в гирлянде не должно быть двух лампочек одного цвета, напрямую соединенных проводом. Разумеется, Сева хочет, чтобы в гирлянде было как можно больше лампочек его любимого цвета.\nПомогите Севе. Напишите программу, которая найдет максимальное количество лампочек цвета индиго, которые можно установить в собранную Севой гирлянду.\nВходные данные\nПервая строка входного файла INPUT.TXT содержит целое число n  количество патронов для лампочек в Севиной гирлянде (1 ≤ n ≤ 50000). Последующие (n−1) строка содержат каждая по два числа: ui и vi (1 ≤ ui, vi ≤ n) – номера патронов, соединенных соответствующим проводом.\nДалее следуют n строк с описанием патронов. Каждая из них не пуста и состоит  не более, чем из трех различных символов «I», «B» или «V». i-ая из этих строк описывает i-ый патрон, а именно: если она содержит символ «I», то в i-ый патрон можно устанавливать лампочку цвета индиго, «B» - можно устанавливать лампочку синего цвета, «V» -  можно устанавливать лампочку фиолетового цвета.\nВыходные данные\nВ выходной файл OUTPUT.TXT выведите единственное число: ответ на задачу. Если же при наложенных ограничениях Севе вообще не удастся собрать гирлянду, выведите число −1.",
    "complexity": 53,
    "memory": 128000,
    "time": 1000,
    "examples": [
      {
        "input": "3\n1 2\n2 3\nIB\nIV\nIB",
        "output": "2"
      }
    ]
  },
  {
    "id": 824,
    "name": "Транспортная компания",
    "description": "Транспортная компания «Crash \u0026 Co» занимается перевозкой запчастей для машин. Недавно в России открылось N отделений этой компании. Руководство компании приняло решение купить часть дорог между своими отделениями, чтобы обезопасить свои фуры от аварий. При этом купленных дорог должно быть по возможности минимальное количество, но они должны давать возможность добраться из любого отделения в любое другое. Вам, как программисту отдела покупок, было поручено в кратчайшие сроки определить количество различных вариантов покупки требуемого набора дорог.\niOUTPUT.TXT424 31 22 33 411[Лучшие попытки]\nВходные данныеi\nВ первой строке входного файла INPUT.TXT записано количество отделений компании N (1 ≤ N ≤ 20), и число различных дорог, соединяющих отделения M (1 ≤ M ≤ 5000). В следующих M строках записаны пары различных номеров отделений ai, bi (1 ≤ ai, bi ≤ N),  соединенных дорогой.\nВыходные данные\nВ выходной файл OUTPUT.TXT выведите требуемое количество способов.",
    "complexity": 84,
    "memory": 16000,
    "time": 1000,
    "examples": [
      {
        "input": "4 4\n1 2\n2 3\n3 4\n4 1",
        "output": "4"
      },
      {
        "input": "4 3\n1 2\n2 3\n3 4",
        "output": "1"
      }
    ]
  },
  {
    "id": 827,
    "name": "Фруктовый сок",
    "description": "Женя недавно купил себе новую соковыжималку. Теперь по утрам он и его братья и сестры пьют свежевыжатый фруктовый сок. А это, между прочим, очень полезно! Недавно они поняли, что можно пить сок, выжатый не только из одного вида фруктов, как, например, апельсиновый, но и различные смеси, например, виноградно-яблочный.\n1OUTPUT.TXT223\n1 Apple\n1 Orange\n1 Mango33[Лучшие попытки]\nВ Жениной семье все очень любят сок, поэтому могут утром выпить не один стакан, причем разных видов сока. Например, его сестра Катя очень любит грейпфрутовый и апельсиновый соки. Женя, как наиболее технически грамотный человек, каждое утро занимается приготовлением соков.\nm\nОпишем подробнее, как работает соковыжималка. В нее загружаются фрукты, они проходят отжим в центрифуге, обезвоженная мякоть сбрасывается в отдельный резервуар, а сок попадает в специальную емкость.\nОсновная проблема состоит в том, что эту емкость иногда приходится мыть. Например, если после приготовления апельсинового сока, необходимо приготовить яблочный, то емкость надо мыть, иначе получится апельсиново-яблочный сок. Более формально, пусть сок A состоит из компонентов a1, ... , an, а сок B - из компонентов b1, ... , bm. Сок B можно готовить после сока A, если любой из компонентов сока A является компонентом сока B. В противном случае емкость для сока надо помыть.\nЖеня не очень любит мыть посуду, поэтому хочет мыть емкость как можно меньшее число раз. Помогите ему.\nВходные данные\nПервая строка входного файла INPUT.TXT содержит натуральное число N – количество различных соков, которые требуется приготовить (N ≤ 300). Каждая из последующих N строк описывает один из соков. Описание сока состоит из числа k его компонентов (1 ≤ k ≤ 300) и списка этих компонентов. Каждый из компонентов сока описывается словом длиной до 30 символов из строчных и прописных букв английского алфавита. Прописные и строчные буквы различаются. Различные компоненты имеют различные названия.\nВыходные данные\nВ выходной файл OUTPUT.TXT выведите минимальное количество раз, которое Жене придется помыть емкость для сока. Учитывайте при этом, что емкость для сока надо помыть и после приготовления последней порции сока.",
    "complexity": 66,
    "memory": 32000,
    "time": 1000,
    "examples": [
      {
        "input": "4\n\n1 Apple\n\n2 Apple Orange\n\n1 Orange\n\n2 Orange Pineapple",
        "output": "2"
      },
      {
        "input": "3\n\n1 Apple\n\n1 Orange\n\n1 Mango",
        "output": "3"
      }
    ]
  },
  {
    "id": 830,
    "name": "Странная таблица",
    "description": "Вася нарисовал таблицу из N+1 строки и M+1 столбца и заполнил ее по строкам целыми неотрицательными числами по следующему правилу:\nOUTPUT.TXT221 277[Лучшие попытки]\nИными словами, Ai,j – минимальное целое неотрицательное число, которое не встречалось или выше или левее в таблице.\nНапример, при N=1 и M=2 получается следующая таблица:\nТеперь ему интересно посчитать сумму\nто есть сумму элементов таблицы. Ваша задача  проверить его вычисления и написать программу, вычисляющую эту сумму.\nВходные данные\nВходной файл INPUT.TXT содержит числа N и M (1 ≤ N, M ≤ 109).\nВыходные данные\nВ выходной файл OUTPUT.TXT выведите искомую сумму.",
    "complexity": 81,
    "memory": 16000,
    "time": 1000,
    "examples": [
      {
        "input": "1 1",
        "output": "2"
      },
      {
        "input": "1 2",
        "output": "7"
      }
    ]
  },
  {
    "id": 828,
    "name": "Красивые последовательности",
    "description": "Математики – люди, весьма ценящие красоту. Они умеют находить ее даже в объектах, к которым, по мнению большинства, это понятие даже не может быть применимо. Например, недавно один математик, занимавшийся изучением последовательностей натуральных чисел, заметил, что некоторые из последовательностей отличаются необычайной красотой. Особенно красивыми он посчитал последовательности a1, ... , an длины n из чисел от 1 до k, обладающие следующими свойствами:\nOUTPUT.TXT527 6876876[Лучшие попытки]\na1=1;\nесли ai=M , i \u003e 1, то найдется j \u003c i : aj=M-1, либо M=1.\nПримером такой последовательности для n = 5, k = 3 является «1, 1, 2, 3, 1», а последовательность «1, 3, 1, 4» не является особенно красивой ни для каких n и k.\nВаша задача состоит в нахождении числа особенно красивых последовательностей для заданных n и k.\nВходные данные\nВходной файл INPUT.TXT содержит два целых числа: n и k (1 ≤ n, k ≤ 500).\nВыходные данные\nВ выходной файл OUTPUT.TXT выведите ответ на задачу.",
    "complexity": 56,
    "memory": 64000,
    "time": 1000,
    "examples": [
      {
        "input": "3 3",
        "output": "5"
      },
      {
        "input": "7 6",
        "output": "876"
      }
    ]
  },
  {
    "id": 829,
    "name": "Строки - 3",
    "description": "",
    "complexity": 60,
    "memory": 128000,
    "time": 1000,
    "examples": [
      {
        "input": "abcabc\nabc",
        "output": "4"
      },
      {
        "input": "abcabc\nacb",
        "output": "0"
      },
      {
        "input": "aaaaaaa\naa",
        "output": "6"
      },
      {
        "input": "aAaa8aaAa\naAa",
        "output": "4"
      }
    ]
  },
  {
    "id": 832,
    "name": "Игра в фишки",
    "description": "Вот уже 10 лет дядя Семен работает сторожем на складе, где хранятся старые процессоры. Его работа чрезвычайно скучна, поэтому все рабочее время он играет в увлекательную игру.\nOUTPUT.TXTYesNo[Лучшие попытки]\nСемен берет A фишек красного цвета, B фишек синего цвета и C зеленого цвета. За один ход он может заменить две фишки разных цветов на одну фишку третьего цвета. Считается, что Семен «сыграл» игру, если после некоторого количества ходов осталась одна фишка.\n[Решение]\nЗа 10 лет Семен так научился играть в эту игру, что для произвольных неотрицательных A, B, C он сразу может сказать: можно ли «сыграть» игру или нет.\nВаша задача – научиться это делать за более короткий срок.\nВходные данные\nВ первой строке входного файла  INPUT.TXT записано натуральное число N – число тестов (1 ≤ N ≤ 1000). В каждой из последующих N строк содержится тест: три целых числа: A, B и C (0 ≤ A, B, C ≤ 263 − 1).\nВыходные данные\nВ выходной файл OUTPUT.TXT для каждого теста выведите «Yes», если «сыграть» игру можно, иначе выведите «No». Ответ для каждого теста должен располагаться в отдельной строке.",
    "complexity": 48,
    "memory": 16000,
    "time": 1000,
    "examples": [
      {
        "input": "2\n1 0 0\n1 1 1",
        "output": "Yes\nNo"
      }
    ]
  },
  {
    "id": 831,
    "name": "Снова про простые числа",
    "description": "Найдите простое число из отрезка [a, b] с максимальной суммой цифр. Если таких чисел несколько, выберите из них максимальное.\nOUTPUT.TXT72900 1000997997-1[Лучшие попытки]\nНапомним, что простым называется натуральное число, большее единицы и делящееся только на единицу и на само себя.\n38 10-1[Решение]\nВходные данные\nВходной файл INPUT.TXT содержит два целых числа: a и b (1 ≤ a ≤ b ≤ 108, b−a ≤ 1000).\nВыходные данные\nВ выходной файл OUTPUT.TXT выведите ответ на задачу. Если указанный отрезок не содержит простых чисел, выведите в выходной файл -1.",
    "complexity": 27,
    "memory": 16000,
    "time": 1000,
    "examples": [
      {
        "input": "1 13",
        "output": "7"
      },
      {
        "input": "900 1000",
        "output": "997"
      },
      {
        "input": "8 10",
        "output": "-1"
      }
    ]
  },
  {
    "id": 834,
    "name": "Поместье",
    "description": "И молвил тогда Король: «Ты храбро сражался, Рыцарь, и твой подвиг не будет забыт в веках. За доблесть твою я дарую тебе сей замок и земли вокруг него. Однако нарушен был тобой строжайший из запретов – все воины видели, как ты сражался без Шляпы на голове подобно дикарям, и их злые духи могли вселиться в тебя. Ты знаешь, что закон предков велит отправлять на небеса души подобных тебе, пока зло, которое могло укорениться в них, не вырвалось наружу. Но в моей воле пощадить тебя, ибо я вижу, что ты достаточно силен, чтобы не позволить этому злу проникнуть в мысли и душу твои. Ты должен дать обет три месяца и три дня не покидать своей земли и каждый день три часа после захода солнца молить добрых духов о защите. Дела торопят меня, и не могу я препроводить тебя до замка. Поэтому я дарую тебе и дорогу от этого места до замка. А сейчас иди, и возвращайся по истечении срока.» - так записано в Зеленой Книге Лет.\ncOUTPUT.TXT5.69646[Лучшие попытки]\nПомимо этого из Зеленой Книги Лет известно, что земли, вместе с которыми был дарован замок, имели форму круга. Король был очень мудр и, во избежание лишних разбирательств относительно права на землю всегда даровал только области земли, на карте имеющие выпуклую форму. Недавно в распоряжении историков оказалась информация о том, где располагался замок и где происходил этот исторический разговор. Их интересует: участок земли какой площади получил Рыцарь в предположении, что дорога до замка была идеально прямой.\nc[Решение]\nВходные данныеc\nПервая строка входного файла INPUT.TXT содержит два вещественных числа xk и yk – координаты места, в котором происходил диалог. Во второй строке записаны три вещественных числа xc, yc и rc – координаты замка и радиус окружности, ограничивающей дарованную вместе с ним землю. Все числа во входном файле по модулю не превосходят 104.\n4\nВыходные данные\nВ выходной файл OUTPUT.TXT выведите одно вещественное число – площадь земельного участка, полученного Рыцарем, с точностью не менее трех знаков после десятичной точки.",
    "complexity": 25,
    "memory": 16000,
    "time": 1000,
    "examples": [
      {
        "input": "2 5\n2 1 1",
        "output": "5.69646"
      }
    ]
  },
  {
    "id": 833,
    "name": "Преобразование ДНК",
    "description": "",
    "complexity": 36,
    "memory": 16000,
    "time": 1000,
    "examples": [
      {
        "input": "AGCT\nGCAT",
        "output": "2\n1 2\n\n2 3"
      },
      {
        "input": "AGCTA\nATCGA",
        "output": "1\n1 5"
      }
    ]
  },
  {
    "id": 975,
    "name": "Числа - 4",
    "description": "Среди натуральных чисел от 1 до N требуется найти минимальное в лексикографическом порядке число, которое делится на K.\nOUTPUT.TXT1003\n100\n1012[Лучшие попытки]\nВходные данные\nВходной файл INPUT.TXT содержит несколько тестовых примеров (не более 2000). Каждый тестовый пример расположен на одной строке и состоит из двух целых чисел N и K (1 ≤ N ≤ 1018, 1 ≤ K ≤ N). Последняя строка содержит два нуля, их обрабатывать не требуется.\nВыходные данные\nВ выходной файл OUTPUT.TXT для каждого тестового примера выведите одно целое число – наименьшее в лексикографическом порядке число, не превышающее N, которое делится на K.",
    "complexity": 71,
    "memory": 16000,
    "time": 1000,
    "examples": [
      {
        "input": "2000 17\n\n2000 20\n\n2000 22\n\n0 0",
        "output": "1003\n\n100\n\n1012"
      }
    ]
  },
  {
    "id": 835,
    "name": "Задача о рюкзаке",
    "description": "Одной из классических NP-полных задач является так называемая «Задача о рюкзаке». Формулируется она следующим образом. Дано n предметов, каждый из которых характеризуется весом wi и полезностью pi. Необходимо выбрать некоторый набор этих предметов так, чтобы суммарный вес этого набора не превышал W, а суммарная полезность была максимальна.\niOUTPUT.TXT1 100125 100\n80 1000\n50 550\n50 550\n50 550\n50 5502 11002 32 11002 31 11006[Лучшие попытки]\nВаша задача состоит в том, чтобы написать программу, решающую задачу о рюкзаке.\ni3\n6 100\n80 1000\n50 550\n50 550\n50 550\n50 550\n100 11001 11006\nВходные данныеi\nПервая строка входного файла INPUT.TXT содержит натуральные числа n (1 ≤ n ≤ 20) и W (1 ≤ W ≤ 109). Каждая из последующих n строк содержит описание одного предмета. Каждое описание состоит из двух чисел: wi – веса предмета и pi – его полезности (1 ≤ wi, pi ≤ 109).\n9\nВыходные данные\nВ первой строке выходного файла OUTPUT.TXT выведите количество выбранных предметов и их суммарную полезность. Во второй строке выведите через пробел их номера в возрастающем порядке (предметы нумеруются с единицы в порядке, в котором они перечислены во входном файле).\nЕсли искомых наборов несколько, выберите тот, в котором наименьшее число предметов. Если же после этого ответ по-прежнему неоднозначен, выберите тот набор, в котором первый предмет имеет наименьший возможный номер, из всех таких выберите тот, в котором второй предмет имеет наименьший возможный номер, и т.д.",
    "complexity": 51,
    "memory": 16000,
    "time": 1000,
    "examples": [
      {
        "input": "2 10\n\n10 100\n\n9 80",
        "output": "1 100\n1"
      },
      {
        "input": "5 100\n\n80 1000\n\n50 550\n\n50 550\n\n50 550\n\n50 550",
        "output": "2 1100\n2 3"
      },
      {
        "input": "6 100\n\n80 1000\n\n50 550\n\n50 550\n\n50 550\n\n50 550\n\n100 1100",
        "output": "1 1100\n6"
      }
    ]
  },
  {
    "id": 951,
    "name": "Вирусы",
    "description": "Для моделирования различных объектов часто применяются так называемые клеточные поля. В простейшем случае – это прямоугольные таблицы, характеризующие некоторую область, а в каждой ячейке таблицы записывается какая-либо информация об исследуемом объекте. В биологии для моделирования распространения вирусов на плоской области в каждой ячейке помечается наличие вируса, а его распространение осуществляется в соседние ячейки по вертикали и горизонтали за одну единицу времени. В начальный момент времени в исследуемую область проникли несколько вирусов. Напишите программу, которая найдёт время заражения всей исследуемой прямоугольной области.\niOUTPUT.TXT4[Лучшие попытки]\nВходные данныеi\nПервая строка входного файла INPUT.TXT содержит два натуральных числа n и m - размеры таблицы (количество строк и столбцов соответственно). Известно, что 1 ≤ n, m ≤ 3000. Во второй строке вначале записано одно число k – количество проникших вирусов, а далее записаны 2k чисел – номера строк и столбцов первых заражённых ячеек yi, xi (1 ≤ k ≤ 10, 1 ≤ yi ≤ n, 1 ≤ xi ≤ m).\nВыходные данные\nВ выходной файл OUTPUT.TXT выведите одно число – время заражения всей области.",
    "complexity": 30,
    "memory": 16000,
    "time": 1000,
    "examples": [
      {
        "input": "4 5\n2 2 1 4 5",
        "output": "4"
      }
    ]
  },
  {
    "id": 836,
    "name": "Четно-нечетная задача",
    "description": "Задано n чисел a1, a2, ... , an. Выберите из них четные числа, у которых третья справа цифра в их представлении в восьмеричной системе счисления нечетна.\nn2OUTPUT.TXT364 64 10023128 129 13000[Лучшие попытки]\nВыбранные числа отсортируйте по неубыванию и выведите в выходной файл.\nn[Решение]\nВходные данныеi\nПервая строка входного файла INPUT.TXT содержит целое число n (1 ≤ n ≤ 105). Вторая строка входного файла содержит n целых чисел: a1, a2, ... , an. Они отделены друг от друга пробелами и заданы в десятичной системе счисления. Для всех i (1 ≤ i ≤ n ) верно неравенство 64 ≤ ai ≤ 109.\n9\nВыходные данные\nВ первой строке выходного файла OUTPUT.TXT выведите количество k искомых чисел. Во второй строке выведите эти числа в указанном порядке в десятичной системе счисления.",
    "complexity": 26,
    "memory": 32000,
    "time": 1000,
    "examples": [
      {
        "input": "4\n100 64 64 130",
        "output": "3\n64 64 100"
      },
      {
        "input": "3\n128 129 130",
        "output": "0"
      }
    ]
  },
  {
    "id": 952,
    "name": "В автобусе",
    "description": "Цена проезда в автобусах нашего города — один рубль. Однако, не все так просто — каждый взрослый пассажир имеет право провезти бесплатно не более одного ребенка. Это значит, что взрослый пассажир, который провозит с собой k (k \u003e 0) детей, платит всего k рублей: за один билет для себя и за (k - 1) билетов для своих детей. Также взрослый может ехать без детей, в этом случае он платит всего один рубль. Известно, что дети не могут проезжать в автобусе без сопровождения взрослых.\nOUTPUT.TXT2 220 5ImpossibleImpossible2 3[Лучшие попытки]\nПомогите посчитать минимальную и максимальную стоимость проезда в рублях, которую могли заплатить пассажиры автобуса.\n32 22 3\nВходные данные\nВходной файл INPUT.TXT содержит два целых числа n и m (0 ≤ n, m ≤ 105) — количество взрослых и количество детей в автобусе, соответственно.\nВыходные данные\nВ выходной файл OUTPUT.TXT выведите через пробел два числа — минимальную и максимальную возможную стоимость проезда, если поездка возможна, в противном случае следует вывести «Impossible» (без кавычек).",
    "complexity": 18,
    "memory": 16000,
    "time": 1000,
    "examples": [
      {
        "input": "1 2",
        "output": "2 2"
      },
      {
        "input": "0 5",
        "output": "Impossible"
      },
      {
        "input": "2 2",
        "output": "2 3"
      }
    ]
  },
  {
    "id": 954,
    "name": "Стаканы",
    "description": "OUTPUT.TXT22226612[Лучшие попытки]\nКак известно, стакан – предмет весьма функциональный. Самый банальный способ применения – ёмкость для жидкости, самый оригинальный ещё не изобретён. А мальчик Слава строит из стаканов башни, пользуясь удивительным свойством стаканов ставиться друг на друга или вставляться друг в друга.\n33212\nСлава строит башни из стаканов высотой 10 сантиметров, которых у него имеется бесконечное количество. Стакан можно поставить на уже имеющуюся конструкцию либо дном вниз, либо дном вверх. Если предыдущий стакан установлен аналогично новому, то конструкция вырастет на 1 сантиметр, так как стаканы надеваются друг на друга. В противном случае башня вырастет на 10 сантиметров.\nОднажды Слава заметил, что ни в коем случае нельзя вставлять друг в друга более трёх стаканов, иначе один из стаканов обязательно разобьётся.\nНа рисунке показан пример башни высотой 32 сантиметра из 5 стаканов.\nСлава умудрился построить красивую башню высотой k сантиметров. Но когда он пошёл за фотоаппаратом, чтобы запечатлеть это достижение, случайно задел конструкцию, и башня упала. Пытаясь восстановить своё творение, Слава понял, что есть несколько способов построить башню аналогичной высоты. Помогите Славе вычислить точное количество способов.\nВходные данные\nВходной файл INPUT.TXT содержит натуральное число k (k ≤ 105).\nВыходные данные\nВ выходной файл OUTPUT.TXT выведите количество способов построить башню заданной высоты, взятое по модулю 106.",
    "complexity": 40,
    "memory": 16000,
    "time": 1000,
    "examples": [
      {
        "input": "11",
        "output": "2"
      },
      {
        "input": "22",
        "output": "6"
      },
      {
        "input": "32",
        "output": "12"
      }
    ]
  },
  {
    "id": 956,
    "name": "Юный гитарист",
    "description": "Ваня решил заняться музыкой. Но какой музыкальный инструмент выбрать для изучения, он пока еще не решил. Его друг Женя, будучи немного постарше и опытнее, уже хорошо освоил гитару. Он хочет продемонстрировать Ване возможности игры на гитаре.\nOUTPUT.TXT420A C E A C EAm11[Лучшие попытки]\nНа гитаре шесть струн, каждая из них может быть зажата пальцем на определенном ладу или оставлена открытой (не прижатой ни на каком ладу), от этого изменяется нота, которая звучит, когда струна колеблется.\nЧтобы продемонстрировать возможности инструмента, Женя ведет с Ваней такую беседу. Ваня называет некоторый аккорд, а Женя говорит ему, сколькими способами можно этот аккорд взять на гитаре, то есть выбрать на каждой струне лад и зажать его (или оставить ее открытой), чтобы этот аккорд зазвучал. Женя любит громкий звук, поэтому звучать должны все струны.\nНот в музыке, конечно, семь, но помимо них существуют еще полутона. Поэтому для удобства мы будем считать, что нот всего 12. Их обозначения такие: A, Bb, B, C, C#, D, D#, E, F, F#, G, G#.\nКроме этого, C# может быть обозначен как Db, Bb как A#, D# как Eb, F# как Gb, а G# как Ab. Обозначения нот приведены в порядке их следования, то есть за A идет Bb, за Bb идет B, . . . , за G# идет снова A. Расстояние между любыми двумя соседними нотами равно одному полутону.\nСтрун у гитары шесть, они занумерованы с 1 по 6. Каждая струна издает определенную ноту, когда звучит и не прижата ни на каком ладу. Совокупность нот, соответствующих открытым струнам, называется строем гитары. Если открытую струну, издающую ноту номер i, зажать на j-том ладу (лады нумеруются с единицы), то этой струной будет издаваться нота i + j, то есть, от ноты i надо сместиться на j нот по циклу. Например, если открытая струна издает ноту D, то зажав ее на третьем ладу, мы получим ноту F, а на восьмом – ноту Bb.\nНа гитаре Вани N ладов, поэтому 1 ≤ j ≤ N. Аккордов существует большое множество, но строятся они по общей схеме. Вначале выбирается так называемая тоника аккорда – нота, от которой он будет строиться. Затем остальные ноты аккорда выписываются уже относительно нее.\nЗапись аккорда состоит из двух частей. Первая часть – это всегда обозначение тоники аккорда. Вторая часть описывает само звучание аккорда. Мы ограничимся несколькими частными случаями.\nМажорный аккорд\nК тонике добавляются ноты, отстоящие на 4 и 7 полутонов. Вторая часть записи этого аккорда пуста.\nПример: Eb, состоит из нот Eb, G, Bb.\nМинорный аккорд\nК тонике добавляются ноты, отстоящие на 3 и 7 полутонов.\nВторая часть записи этого аккорда состоит из маленькой английской буквы m.\nПример: Am, состоит из нот A, C, E.\nМажорный септаккорд\nОбразуется из мажорного аккорда путем добавления ноты, отстоящей от тоники на 10 полутонов.\nВторая часть состоит из цифры 7.\nПример: E7, состоит из нот E, B, G#, D.\nМинорный септаккорд\nОбразуется из минорного аккорда путем добавления ноты, отстоящей от тоники на 10 полутонов.\nВторая часть состоит из буквы m и цифры 7.\nПример: Gm7, состоит из нот G, D, Bb, F.\nНапишите программу, помогающую Жене отвечать на вопросы Вани. Учтите, что аккорд считается взятым на гитаре, если ни одна нота аккорда не пропущена и не взята ни одна нота, не принадлежащая аккорду. В отличие от реальной игры на гитаре, расстояние между ладами, на которых зажата хотя бы одна струна, может быть любым.\nВходные данные\nВ первой строке входного файла INPUT.TXT содержится N – число ладов гитары (0 ≤ N ≤ 9). Во второй строке записан строй гитары – шесть нот, соответствующие шести струнам гитары. Ноты обозначены, как в тексте задачи, и отделены друг от друга пробелами. Регистр букв важен. В третьей строке записан аккорд, который надо взять на гитаре.\nВыходные данные\nВ выходной файл OUTPUT.TXT выведите количество способов взять данный аккорд на данной гитаре.",
    "complexity": 57,
    "memory": 16000,
    "time": 1000,
    "examples": [
      {
        "input": "3\nE B G D A E\nC",
        "output": "4"
      },
      {
        "input": "0\nA C E A C E\nAm",
        "output": "1"
      }
    ]
  },
  {
    "id": 953,
    "name": "Дроби",
    "description": "В то время, пока другие дети бегали по улицам или гоняли мяч, мальчик Слава сидел дома и решал сложную математическую проблему. Вкратце, проблема выглядела так.\nOUTPUT.TXT2 3[Лучшие попытки]\nКаждое натуральное число, начиная с трёх, можно представить в виде суммы различных натуральных чисел, например, 5=3+2=4+1. А возможно ли представить правильную дробь m/n в виде суммы различных членов гармонического ряда 1/2, 1/3, 1/4, …, то есть m/n=1/x+1/y+1/z+…? При этом должно выполняться условие x \u003c y \u003c z \u003c … Если существует несколько решений, то надо найти то из них, у которого значение x минимально. Если неоднозначность не снимается, то надо найти решение с минимальным y, и так далее.\nВходные данные\nВходной файл INPUT.TXT содержит два натуральных числа m и n (1 ≤ m \u003c n ≤ 32).\nВыходные данные\nВ выходной файл OUTPUT.TXT выведите найденные числа x, y, z, … через пробел.",
    "complexity": 46,
    "memory": 16000,
    "time": 1000,
    "examples": [
      {
        "input": "5 6",
        "output": "2 3"
      }
    ]
  },
  {
    "id": 955,
    "name": "Вирусы - 2",
    "description": "Для моделирования различных объектов часто применяются так называемые клеточные поля. В простейшем случае – это прямоугольные таблицы, характеризующие некоторую область, а в каждой ячейке таблицы записывается какая-либо информация об исследуемом объекте. В биологии для моделирования распространения вирусов на плоской области в каждой ячейке помечается наличие вируса, а его распространение осуществляется в соседние ячейки по вертикали и горизонтали за одну единицу времени. Некоторые клетки обладают иммунитетом, заразить их невозможно и через них не распространяются вирусы. Напишите программу, которая найдёт минимально возможное число вирусов, с помощью которых можно заразить всю исследуемую прямоугольную область (за исключением защищённых клеток).\niOUTPUT.TXT2[Лучшие попытки]\nВходные данныеi\nВ первой строке входного файла INPUT.TXT содержится два натуральных числа n и m - размеры таблицы (количество строк и столбцов соответственно). Известно, что 1 ≤ n, m ≤ 100. Во второй строке вначале записано одно число k – количество защищённых клеток, а далее записаны 2k чисел – координаты этих клеток yi, xi (0 ≤ k ≤ n×m, 1 ≤ yi ≤ n, 1 ≤ xi ≤ m).\nВыходные данные\nВ выходной файл OUTPUT.TXT выведите одно число – минимально возможное число вирусов.",
    "complexity": 40,
    "memory": 16000,
    "time": 1000,
    "examples": [
      {
        "input": "4 5\n3 1 3 2 1 2 2",
        "output": "2"
      }
    ]
  },
  {
    "id": 350,
    "name": "Перестановки",
    "description": "Дана строка, состоящая из N попарно различных символов. Требуется вывести все перестановки символов данной строки.\nOUTPUT.TXTABBA2IOXXOI\nOIX\nIXO\nXIO\nOXI\nIOXXOI\nOIX\nIXO\nXIO\nOXI\nIOX[Лучшие попытки]\nВходные данные\nВходной файл INPUT.TXT содержит строку, состоящую из N символов (1 ≤ N ≤ 8), символы - буквы английского алфавита и цифры.\nВыходные данные\nВ выходной файл OUTPUT.TXT выведите в каждой строке по одной перестановке. Перестановки можно выводить в любом порядке. Повторений и строк, не являющихся перестановками исходной, быть не должно.",
    "complexity": 44,
    "memory": 16000,
    "time": 1000,
    "examples": [
      {
        "input": "AB",
        "output": "AB\nBA"
      },
      {
        "input": "IOX",
        "output": "XOI\n\nOIX\n\nIXO\n\nXIO\n\nOXI\n\nIOX"
      }
    ]
  },
  {
    "id": 900,
    "name": "Три грибника",
    "description": "Три грибника Петя, Вася и Коля, возвращаясь из лесу домой, решили устроить привал, а заодно и перекусить. Как это у нас принято, через некоторое время каждый начал хвастаться своими сегодняшними успехами, а потом делиться найденными грибами со своими товарищами. Изначально у каждого из них было некоторое целое количество грибов. Сначала Петя дал Васе и Коле по столько грибов, сколько у них уже было. Коля быстро понял, что так будет не по-братски, и дал Васе и Пете по столько грибов, сколько у них стало. Вася не мог отстать от сотоварищей и тоже дал каждому из друзей по столько грибов, сколько у них к этому моменту имелось. И тут друзья с удивлением обнаружили, что у всех стало грибов поровну. \nOUTPUT.TXT65 20 35[Лучшие попытки]\nИзвестно, что все вместе они собрали N грибов. Сколько грибов было у каждого из них перед привалом?\nВходные данные\nВходной файл INPUT.TXT содержит натуральное число N (N ≤ 30000).\nВыходные данные\nВ выходной файл OUTPUT.TXT выведите три числа через пробел - первоначальное количество грибов у Пети, Васи и Коли соответственно. Предполагается, что ответ для данного N существует.",
    "complexity": 23,
    "memory": 16000,
    "time": 1000,
    "examples": [
      {
        "input": "120",
        "output": "65 20 35"
      }
    ]
  },
  {
    "id": 899,
    "name": "Баланс скобок",
    "description": "Дана последовательность, состоящая из открывающихся и закрывающихся круглых, квадратных и фигурных скобок.\nOUTPUT.TXT01[Лучшие попытки]\nТребуется написать программу, которая определит возможность добавления в эту последовательность цифр и знаков арифметических действий таким образом, чтобы получилось правильное скобочное выражение.\nВходные данные\nВходной файл INPUT.TXT содержит не менее 1 и не более 10 строк. В каждой строке записана одна последовательность скобок. Длина последовательности от 1 до 255 символов.\nВыходные данные\nВ выходной файл OUTPUT.TXT выведите слитно символы 0 или 1. Их общее количество равно количеству введенных строк. Для каждой строки выводится 0, если из нее может получиться правильное скобочное выражение, и 1 иначе.",
    "complexity": 42,
    "memory": 16000,
    "time": 1000,
    "examples": [
      {
        "input": "([{}])\n([{",
        "output": "01"
      }
    ]
  },
  {
    "id": 908,
    "name": "Число - 3",
    "description": "Дано натуральное число N. Над ним можно произвести следующий набор операций:\nделить на два, если число четное.OUTPUT.TXT321003[Лучшие попытки]\nвычитать  единицу;\nделить  на три, если число кратно трем;\nделить на два, если число четное.\n\n3103\nПосле выполнения одной из операций к полученному результату также можно применить указанные операции, и делается это до тех пор, пока результат не окажется равным 1.\nВходные данные\nВходной файл INPUT.TXT содержит  натуральное число N (N ≤ 106).\nВыходные данные\nВ выходной файл OUTPUT.TXT выведите наименьшее количество операций, в результате выполнения которых будет получена единица.",
    "complexity": 35,
    "memory": 64000,
    "time": 1000,
    "examples": [
      {
        "input": "5",
        "output": "3"
      },
      {
        "input": "1",
        "output": "0"
      },
      {
        "input": "10",
        "output": "3"
      }
    ]
  },
  {
    "id": 902,
    "name": "Ленточка - 2",
    "description": "Расположенную вертикально прямоугольную бумажную ленточку с закрепленным нижним концом стали складывать следующим образом:\nOUTPUT.TXTPZ22OOONONO[Лучшие попытки]\n- на первом шаге ее согнули пополам так, что верхняя половина легла на нижнюю либо спереди (P - сгибание) либо сзади (Z - сгибание),\n- на последующих n-1 шагах выполнили аналогичное действие с получающейся на предыдущем шаге согнутой ленточкой, как с единым целым.\nЗатем ленточку развернули, приведя ее в исходное состояние. На ней остались сгибы - ребра от перегибов, причем некоторые из ребер оказались направленными выпуклостью к нам (K - ребра), а некоторые - от нас (O - ребра). Ребра пронумеровали сверху вниз числами от 1 до 2n-1.\nТребуется написать программу, которая по заданной строке символов из прописных букв \"O\" и \"K\", где нахождение на i-ом месте символа \"O\" или \"K\" определяет тип ребра на расправленной полоске, находит строку из прописных \"P\" и \"Z\", определяющих последовательность типов сгибаний, посредством которых получена ленточка с этой последовательностью ребер.\nВходные данные\nВ первой строке входного файла INPUT.TXT записано число n – количество сгибаний (n не более 20), во второй строке - строка из 2n-1 символов \"O\" или \"K\", определяющих типы ребер на расправленной ленточке.\nВыходные данные\nВ выходной файл OUTPUT.TXT выведите строку из n символов \"P\" и \"Z\", задающую последовательность сгибаний. Если такой последовательности сгибаний не существует, то вывести в файл \"NO\".",
    "complexity": 65,
    "memory": 16000,
    "time": 1000,
    "examples": [
      {
        "input": "2\nOOK",
        "output": "PZ"
      },
      {
        "input": "2\nOOO",
        "output": "NO"
      }
    ]
  },
  {
    "id": 898,
    "name": "Ленточка",
    "description": "Расположенную вертикально прямоугольную бумажную ленточку с закрепленным нижним концом стали складывать следующим образом:\nOUTPUT.TXTK22ZZ2 1 2OKOK[Лучшие попытки]\n- на первом шаге ее согнули пополам так, что верхняя половина легла на нижнюю либо спереди (P - сгибание) либо сзади (Z - сгибание),\n- на последующих n-1 шагах выполнили аналогичное действие с получающейся на предыдущем шаге согнутой ленточкой, как с единым целым.\nЗатем ленточку развернули, приведя ее в исходное состояние. На ней остались сгибы - ребра от перегибов, причем некоторые из ребер оказались направленными выпуклостью к нам (K - ребра), а некоторые - от нас (O - ребра). Ребра пронумеровали сверху вниз числами от 1 до 2n-1.\nТребуется написать программу, которая по заданной строке символов из прописных букв «P» и «Z», определяющей последовательность типов сгибаний, и номерам ребер сообщает тип этих ребер, получившийся после данной последовательности преобразований.\nВходные данные\nВ первой строке входного файла INPUT.TXT содержится натуральное число n – количество сгибаний ленточки (n ≤ 60), во второй строке – набор n символов из прописных английских букв «P» и «Z». Третья строка содержит в начале число k – количество рассматриваемых рёбер (k ≤ 10), а далее их номера (числа от 1 до 2n-1).\nВыходные данные\nВ выходной файл OUTPUT.TXT выведите k символов (прописные английские буквы «K» или «O») – типы рассматриваемых ребер.",
    "complexity": 60,
    "memory": 16000,
    "time": 1000,
    "examples": [
      {
        "input": "2\nPP\n1 1",
        "output": "K"
      },
      {
        "input": "2\nZZ\n2 1 2",
        "output": "OK"
      }
    ]
  },
  {
    "id": 957,
    "name": "Доказательство в HOL",
    "description": "Студент Дима учится на втором курсе университета. На втором курсе в его университете читается курс математической логики. В этом курсе особое внимание акцентируется на автоматических доказателях – программах, позволяющих с их помощью доказывать различные сложные теоремы.\nNOUTPUT.TXT0 11 122 2 22 2 3 3\n2 0 1 3\n4 1 1 5\n4 4 5 52 2 3 3\n2 0 1 3\n4 1 1 5\n4 4 5 5[Лучшие попытки]\nКурсовая работа по математической логике у Димы такая: необходимо доказать с помощью автоматического доказателя HOL, что шахматную доску размером 2N x 2N, из которой вырезана одна клетка, можно покрыть в один слой уголками из трех клеток.\nДима не верит в то, что это правда, и пытается составить контрпример. Ваша задача  доказать Диме, что он неправ, и решить задачу для Диминых входных данных.\nВходные данные\nВходной файл INPUT.TXT содержит три натуральных числа N, X, Y (N ≤ 6;  X,Y ≤ 2N). Этими числами задана доска 2N x 2N, из которой вырезана клетка с координатами (X, Y). X – координата по горизонтали, Y – по вертикали, (1, 1) –  верхний левый угол доски.\nВыходные данные\nВ выходной файл OUTPUT.TXT выведите 2N строк по 2N чисел – номера уголков, покрывающих соответствующие клетки. Каждый уголок характеризуется своим уникальным номером. Уголки пронумерованы начиная с единицы, без пропусков. Вырезанную клетку следует обозначить нулем.",
    "complexity": 51,
    "memory": 16000,
    "time": 1000,
    "examples": [
      {
        "input": "1 1 1",
        "output": "0 1\n1 1"
      },
      {
        "input": "2 2 2",
        "output": "2 2 3 3\n\n2 0 1 3\n\n4 1 1 5\n\n4 4 5 5"
      }
    ]
  },
  {
    "id": 901,
    "name": "Бессмыслица",
    "description": "Никифор утверждал, что бессмыслица, повторенная много раз, становится истиной. Для доказательства этого он применил следующую процедуру: переставил на клавиатуре своего компьютера клавиши в произвольном порядке и набрал некоторый текст. Получилась, естественно, бессмыслица. Он и эту бессмыслицу набрал на том же компьютере с той же подправленной клавиатурой. Новую бессмыслицу Никифор набрал еще раз и так далее – времени-то у него много.\nOUTPUT.TXT42566[Лучшие попытки]\nТребуется написать программу, которая найдет максимальное количество шагов его процедуры, чтобы получился исходный текст.\nВходные данные\nВходной файл INPUT.TXT содержит одно целое число N (1 \u003c N \u003c 60) – количество клавиш на клавиатуре компьютера Никифора.\nВыходные данные\nВ выходной файл OUTPUT.TXT выведите одно целое число – максимальное количество шагов проделанной Никифором процедуры.",
    "complexity": 67,
    "memory": 16000,
    "time": 1000,
    "examples": [
      {
        "input": "4",
        "output": "4"
      },
      {
        "input": "5",
        "output": "6"
      }
    ]
  },
  {
    "id": 958,
    "name": "Осмотр королевства",
    "description": "Давным давно в одном королевстве правил мудрый король. В том королевстве было n городов, любые два из которых были соединены дорогой. С целью безопасности дорожного движения, по каждой дороге разрешалось перемещаться только в одну сторону.\nOUTPUT.TXT1 3 2 4 5 6 7[Лучшие попытки]\nКороль любил свое королевство. Каждый год он k раз осуществлял осмотр королевства. Каждый осмотр начинался в столице, затем король, перемещаясь по дорогам, посещал некоторые города, и, наконец, прибывал в курортный город на берегу моря, где он отдыхал после нелегкой работы. Таким образом король посещал каждый город в королевстве ровно один раз в течении года (за исключением столицы, где каждый осмотр начинался, и морского курорта, где каждый осмотр заканчивался).\nНо годы уходили, и король становится стар. И ему было все сложнее делать эти k осмотров. Так что однажды он позвал своего министра транспорта и приказал ему сделать новую программу для осмотра королевства. Осмотр должен начинаться в столице и заканчиваться на морском курорте. Однако теперь весь этот путь должен посещать все города, которые ранее посещались в процессе k осмотров. И более того, если ранее некоторые города A и B посещались в процессе одного осмотра и причем A посещался до B, то новый осмотр также должен посещать A до B.\nПомогите королю сделать осмотр королевства менее утомительным, разработайте новый маршрут для осмотра.\nВходные данные\nПервая строка входного файла INPUT.TXT содержит два целых числа: n и k (3 ≤ n ≤ 400, 1 ≤ k ≤ 100). Следующие n строк описывают дороги. Каждая строка содержит n символов, i-й символ i-й из этих строк равен '.'. Для всех j≠i j-й символ i-й строки равен '+', если дорога идет из j-го города в i-й, либо '-', если дорога идет из i-го города в j-й. Столица имеет номер 1, морской курорт имеет номер n.\nСледующие k строк содержат описание маршрутов, по которым король традиционно осуществлял осмотр. Каждый маршрут описывается на одной строке. Описание содержит номера городов в том порядке, в котором король посещал города в процессе соответствующего осмотра. Гарантируется, что каждый осмотр начинается в столице, заканчивается в морском курорте, и следует по всем дорогам в корректном направлении. Каждый город, за исключением столицы и морского курорта, посещается ровно в одном маршруте. Ни один маршрут не идет непосредственно из столицы в морской курорт. Ни один маршрут не посещает в качестве промежуточного города столицу или морской курорт.\nВыходные данные\nВ выходной файл OUTPUT.TXT выведите n чисел – порядок, в котором следует посещать города. Если выполнить требования короля невозможно, выведите −1.",
    "complexity": 62,
    "memory": 16000,
    "time": 1000,
    "examples": [
      {
        "input": "7 2\n\n.------\n\n+.+----\n\n+-.-+++\n\n+++.---\n\n++-+.--\n\n++-++.-\n\n++-+++.\n\n1 3 4 7\n\n1 2 5 6 7",
        "output": "1 3 2 4 5 6 7"
      }
    ]
  },
  {
    "id": 903,
    "name": "Бисер",
    "description": "В шкатулке хранится разноцветный бисер (или бусины). Все бусины имеют одинаковую форму, размер и вес. Бусины могут быть одного из N различных цветов. В шкатулке много бусин каждого цвета.\nOUTPUT.TXT4[Лучшие попытки]\nТребуется определить минимальное число бусин, которые можно не глядя вытащить из шкатулки так, чтобы среди них гарантированно были две бусины одного цвета.\nВходные данные\nВходной файл INPUT.TXT содержит одно натуральное число N - количество цветов бусин (1 ≤ N ≤ 109).\nВыходные данные\nВ выходной файл OUTPUT.TXT выведите ответ на поставленную задачу.",
    "complexity": 2,
    "memory": 16000,
    "time": 1000,
    "examples": [
      {
        "input": "3",
        "output": "4"
      }
    ]
  },
  {
    "id": 959,
    "name": "Защита деревьев",
    "description": "Андрюша получил на день рождения подарок от родителей – маленького щенка. Он назвал его Весельчак. Весельчак еще очень маленький, но у него уже есть зубы. Они очень острые, и должно быть еще растут, потому что Весельчак очень любит погрызть все, что попадает в его поле зрения.\nOUTPUT.TXT3[Лучшие попытки]\nЛетом Андрюша с родителями приехал на дачу и Весельчака поселили во дворе. Папа у Андрюши – садовод любитель, и он выращивает во дворе n плодово-ягодных деревьев. Теперь он опасается, что Весельчак может погрызть его любимые деревья, поэтому он решил их защитить.\nОн нашел в сарае три длинные доски и теперь собирается соорудить из них забор. Забор будет треугольным, причем никакая часть доски не должна выступать за границу забора, поскольку в этом случае кто-нибудь может запнуться об нее и упасть. Распиливать доски нельзя  они могут в дальнейшем пригодиться в хозяйстве.\nОднако может получиться так, что нельзя огородить треугольным забором все деревья. В этом случае папа Андрюши хочет огородить как можно больше деревьев. Помогите ему определить, сколько деревьев он может защитить.\nВходные данные\nПервая строка входного файла INPUT.TXT содержит n –  количество деревьев во дворе (1 ≤ n ≤ 70). Вторая строка содержит три целых числа a, b и c – длины досок, которые будут использованы для забора (1 ≤ a, b, c ≤ 104, существует невырожденный треугольник со сторонами a, b и c). Следующие n строк содержат по два целых числа – координаты деревьев. Координаты не превышают 104 по абсолютной величине. Вы можете пренебречь толщиной деревьев. Никакие два дерева не совпадают.\nВыходные данные\nВ выходной файл OUTPUT.TXT выведите одно целое число – количество деревьев, которое можно защитить.",
    "complexity": 70,
    "memory": 16000,
    "time": 1000,
    "examples": [
      {
        "input": "5\n\n3 4 6\n\n6 0\n\n0 0\n\n1 2\n\n2 3\n\n6 1",
        "output": "3"
      }
    ]
  },
  {
    "id": 904,
    "name": "Crimsonland",
    "description": "Гриша третий день играет в Crimsonland, он «застрял» на самом сложном уровне: Panic Rush, так как ему постоянно не хватает боеприпасов. \n0OUTPUT.TXT2[Лучшие попытки]\nНа уровне Panic Rush есть несколько особенностей. Персонаж Гриши вооружён плазменным дробовиком с углом атаки α и неограниченной дальностью. Все монстры, попадающие в угол атаки, при выстреле тут же погибают. Дробовик достаточно тяжёлый, переносить его нельзя, но можно быстро поворачивать вокруг своей оси на любой угол. Монстры появляются все одновременно в произвольных точках карты, при этом их местоположение не совпадает с местоположением персонажа.\ni\nГриша нашел в интернете чит-код, и теперь он знает, где появятся монстры и какой будет угол атаки дробовика. Помогите Грише подсчитать минимальное количество выстрелов, необходимых для отражения атаки.\ni\nВходные данные4\nПервая строка входного файла INPUT.TXT содержит два целых числа N и α, где N (1 ≤ N ≤ 104) — количество монстров, а α (1 ≤ α ≤ 180) — угол атаки дробовика в градусах. В следующей строке указано местоположение персонажа X0 и Y0, затем в N строках описаны координаты появления монстров Xi и Yi (все координаты — целые числа, не превосходящие по модулю 104).\nВыходные данные\nВ выходной файл OUTPUT.TXT выведите наименьшее количество выстрелов, необходимых для отражения атаки.",
    "complexity": 56,
    "memory": 16000,
    "time": 1000,
    "examples": [
      {
        "input": "4 90\n\n1 1\n\n2 2\n\n0 2\n\n0 0\n\n2 0",
        "output": "2"
      }
    ]
  },
  {
    "id": 906,
    "name": "Функция - 2",
    "description": "Описана рекурсивная функция с тремя параметрами F(a, b, c):\nесли a \u003c b и b \u003c c, то F(a, b, c) = F(a, b, c-1) + F(a, b-1, c-1) - F(a, b-1, c)OUTPUT.TXT222 2 2445231048576[Лучшие попытки]\nесли a ≤ 0 или b ≤ 0 или c ≤ 0, то F(a, b, c) = 1\nесли a \u003e 20 или b \u003e 20 или c \u003e 20, то F(a, b, c) = F(20, 20, 20)\nесли a \u003c b и b \u003c c, то F(a, b, c) = F(a, b, c-1) + F(a, b-1, c-1) - F(a, b-1, c)\nиначе F(a, b, c) = F(a-1, b, c) + F(a-1, b-1, c) + F(a-1, b, c-1) - F(a-1, b-1, c-1)\n\nиначе F(a, b, c) = F(a-1, b, c) + F(a-1, b-1, c) + F(a-1, b, c-1) - F(a-1, b-1, c-1)310 4 6523\nОднако, если указанную функцию реализовать напрямую, то даже для небольших значений a, b и c (например, a = 15, b = 15, c = 15), программа будет работать несколько часов!\nНеобходимо реализовать эффективный алгоритм вычисления функции F, который успеет найти любое  ее значение менее чем за одну секунду!\n450 50 501048576\nВходные данные\nВходной файл INPUT.TXT содержит три целых числа a, b, c - параметры функции F (-104 ≤ a,b,c ≤ 104).\nВыходные данные\nВ выходной файл OUTPUT.TXT выведите значение функции F(a, b, c).",
    "complexity": 38,
    "memory": 16000,
    "time": 1000,
    "examples": [
      {
        "input": "1 1 1",
        "output": "2"
      },
      {
        "input": "2 2 2",
        "output": "4"
      },
      {
        "input": "10 4 6",
        "output": "523"
      },
      {
        "input": "50 50 50",
        "output": "1048576"
      }
    ]
  },
  {
    "id": 905,
    "name": "Криптограмма",
    "description": "На одной из лекций по информатике студент Петя узнал про новый шифр - простой замены. Он и на самом деле прост: в тексте каждая буква алфавита заменяется некоторой другой буквой того же алфавита  (может быть, той же самой).\nOUTPUT.TXT\nnow is the time for all good men to come to the aid of the party\nthe quick brown fox jumps over the lazy dog\nprogramming contests are fun arent they\n2\n3\nvtz ud xnm xugm itr pyy jttk gmv xt otgm xt xnm puk ti xnm fprxq\nxnm fffff lrtzv iia wwwfd tsmr xnm ypwq ktj\nfrtjrpgguvj otvxmdxd prm iev prmvx xnmq\n\nNo solution\n\nNo solution\n[Лучшие попытки]\nПетя написал письмо своему другу Васе. Письмо - это текст из нескольких строк, написанный на английском языке, с использованием только строчных английских букв и пробелов. В произвольное место, отдельной строкой Петя вставил ключевую фразу: \"the quick brown fox jumps over the lazy dog\", о которой они с Васей договорились заранее. После чего зашифровал письмо. Известно, что пробелы в письме не шифруются. Получив такое письмо, Вася сумеет его расшифровать и прочесть. Иногда Петя ошибается, и забывает вставить ключевую фразу. Увы, в этом случае прочесть письмо невозможно.\nТак как процесс расшифровки трудоемок, Вася просит написать программу, с помощью которой он сможет быстро расшифровывать письмо от Пети.\nВходные данные\nПервая строка входного файла INPUT.TXT содержит целое число N – количество строк в письме (1 ≤ N ≤ 200). Далее идет N строк письма (пустые строки отсутствуют, в каждой строке  не более 80 символов).\nВыходные данные\nВ выходной файл OUTPUT.TXT  в случае присутствия в тексте ключевой фразы выведите N строк расшифрованного сообщения. Если ключевой фразы нет, следует вывести «No solution» (без кавычек). Гарантируется, что есть не более одного способа расшифровки текста из входных данных.",
    "complexity": 31,
    "memory": 16000,
    "time": 1000,
    "examples": [
      {
        "input": "3\n\nvtz ud xnm xugm itr pyy jttk gmv xt otgm xt xnm puk ti xnm fprxq\n\nxnm ceuob lrtzv ita hegfd tsmr xnm ypwq ktj\n\nfrtjrpgguvj otvxmdxd prm iev prmvx xnmq",
        "output": "now is the time for all good men to come to the aid of the party\n\nthe quick brown fox jumps over the lazy dog\n\nprogramming contests are fun arent they"
      },
      {
        "input": "3\n\nvtz ud xnm xugm itr pyy jttk gmv xt otgm xt xnm puk ti xnm fprxq\n\nxnm fffff lrtzv iia wwwfd tsmr xnm ypwq ktj\n\nfrtjrpgguvj otvxmdxd prm iev prmvx xnmq",
        "output": "No solution"
      }
    ]
  },
  {
    "id": 960,
    "name": "Три буквы",
    "description": "",
    "complexity": 44,
    "memory": 16000,
    "time": 1000,
    "examples": [
      {
        "input": "abc",
        "output": "1"
      },
      {
        "input": "ab",
        "output": "0"
      }
    ]
  },
  {
    "id": 924,
    "name": "Симпатичный узор",
    "description": "На днях Иван у себя в прихожей выложил кафель, состоящий из квадратных черных и белых плиток. Прихожая Ивана имеет квадратную форму 4х4, вмещающую 16 плиток. Теперь Иван переживает, что узор из плиток, который у него получился, может быть не симпатичным. С точки зрения дизайна симпатичным узором считается тот, который не содержит в себе квадрата 2х2, состоящего из плиток одного цвета.\nOUTPUT.TXTYes2BBWB\nBBWB\nWWBW\nBBWBNoNo[Лучшие попытки]\nПримеры возможных узоров:\nПо заданному расположению плиток в прихожей Ивана требуется определить: является ли выполненный узор симпатичным.\nВходные данные\nВходной файл INPUT.TXT содержит 4 строки по 4 символа «W» или «B» в каждой, описывающие узор из плиток. Символ «W» обозначает плитку белого цвета, а «B» - черного.\nВыходные данные\nВ выходной файл OUTPUT.TXT выведите «Yes», если узор является симпатичным и «No» в противном случае.",
    "complexity": 20,
    "memory": 16000,
    "time": 1000,
    "examples": [
      {
        "input": "BWBW\n\nBBWB\n\nWWBB\n\nBWWW",
        "output": "Yes"
      },
      {
        "input": "BBWB\n\nBBWB\n\nWWBW\n\nBBWB",
        "output": "No"
      }
    ]
  },
  {
    "id": 907,
    "name": "Мышка",
    "description": "Однажды компьютерная мышка подумала, что стоит взять про запас  еще один  коврик. Чтобы никто не заметил запасного коврика, мышка решила его спрятать под свой прямоугольный коврик. Пробравшись ночью на склад, мышка обнаружила там только круглые коврики. Удастся ли мышке спрятать круглый коврик под прямоугольным ковриком?\nOUTPUT.TXTYES24 7 3NONO[Лучшие попытки]\nВходные данные\nПервая строка входного файла INPUT.TXT содержит три натуральных числа через пробел: W, H и R, где W и H -  ширина и высота прямоугольного коврика, а R – радиус запасного коврика. Все числа не превосходят значения 109.\nВыходные данные\nВ выходной файл OUTPUT.TXT выведите «YES», если новый коврик можно спрятать под старым, и слово «NO», если этого сделать нельзя.",
    "complexity": 9,
    "memory": 16000,
    "time": 1000,
    "examples": [
      {
        "input": "4 7 2",
        "output": "YES"
      },
      {
        "input": "4 7 3",
        "output": "NO"
      }
    ]
  },
  {
    "id": 934,
    "name": "Балда",
    "description": "А вы играли в «балду»? Это такая игра, когда из букв одного слова нужно составить как можно больше других слов. И чем длиннее такие слова, тем больше очков игрок заработает. Отсюда понятно, что самые выгодные слова – это те, которые получены перестановкой букв исходного слова.\nOUTPUT.TXTGroup of size 5: caret carte cater crate trace .\nGroup of size 4: abet bate beat beta .\nGroup of size 4: ate eat eta tea .\nGroup of size 1: displayed .\nGroup of size 1: singleton .\n28\nabc\nc++\ncba\nabc\npascal\njava\nscalpa\nbasicGroup of size 3: abc cba .\nGroup of size 2: pascal scalpa .\nGroup of size 1: basic .\nGroup of size 1: c++ .\nGroup of size 1: java .Group of size 3: abc cba .\nGroup of size 2: pascal scalpa .\nGroup of size 1: basic .\nGroup of size 1: c++ .\nGroup of size 1: java .[Лучшие попытки]\nХитрый Дима решил написать программу, которая распечатает ему заготовки для игры в \"балду\". Дима их выучит, и будет побеждать всех своих друзей. Дима решил распечатать группы слов, которые получаются перестановкой букв.\nТаких групп может оказаться слишком много, поэтому Дима решил распечатать первые пять с самым большим количеством слов. Ну, а если в словаре окажется менее пяти групп, Дима распечатает их все.\nА, может быть, и Вы себе такую программу создадите? Глядишь, и пригодится!\nВходные данные\nВходной файл INPUT.TXT содержит число N – количество слов в словаре (2 ≤ N ≤ 25000). Далее идет N слов, по одному в строке. Каждое слово содержит не более 40 символов. Коды ASCII символов в словах превышают 32.\nВыходные данные\nВ выходной файл OUTPUT.TXT выведите первые пять групп, отсортированных по количеству слов. Если групп меньше пяти, выведите все группы. Для каждой группы отсортируйте все слова в лексикографическом порядке. Повторяющиеся слова следует выводить однократно. Если есть несколько групп одного размера, отсортируйте их в лексикографическом порядке первого слова в группе (первое слово в группе – в лексикографическом порядке, а не в порядке добавления). Выводить группы слов следует согласно формату, описанному в примерах.",
    "complexity": 57,
    "memory": 16000,
    "time": 1000,
    "examples": [
      {
        "input": "16\n\nundisplayed\n\ntrace\n\ntea\n\nsingleton\n\neta\n\neat\n\ndisplayed\n\ncrate\n\ncater\n\ncarte\n\ncaret\n\nbeta\n\nbeat\n\nbate\n\nate\n\nabet",
        "output": "Group of size 5: caret carte cater crate trace .\n\nGroup of size 4: abet bate beat beta .\n\nGroup of size 4: ate eat eta tea .\n\nGroup of size 1: displayed .\n\nGroup of size 1: singleton ."
      },
      {
        "input": "8\n\nabc\n\nc++\n\ncba\n\nabc\n\npascal\n\njava\n\nscalpa\n\nbasic",
        "output": "Group of size 3: abc cba .\n\nGroup of size 2: pascal scalpa .\n\nGroup of size 1: basic .\n\nGroup of size 1: c++ .\n\nGroup of size 1: java ."
      }
    ]
  },
  {
    "id": 925,
    "name": "Кастинг",
    "description": "В театре работает n актеров. Известно, что среди них a – высоких, b – голубоглазых и с – блондинов. Для главной роли в новом спектакле режиссеру требуется только один высокий голубоглазый блондин. Чтобы спланировать свое время для беседы с каждым таким артистом из труппы театра, режиссеру необходимо узнать, какое максимальное или какое минимальное количество артистов из работающих  в театре подходит для этой роли.\nOUTPUT.TXT3215 3 4 522[Лучшие попытки]\nТребуется написать программу, которая по заданным числам n, a, b и с определяет минимальное или максимальное количество актеров, с которыми режиссер должен переговорить.\nВходные данные\nПервая строка входного файла INPUT.TXT содержит одно число, которое задает: минимальное или максимальное количество актеров необходимо найти. Это число может принимать следующие значения:\n1, если в данном тесте требуется определить минимальное количество актеров;\n2, если в данном тесте требуется определить максимальное количество актеров.\nВторая строка входного файла содержит разделенные пробелами четыре целых числа: n, a, b, с (1 ≤ n ≤ 10 000, 0 ≤ a ≤ n, 0 ≤ b ≤ n, 0 ≤ c ≤ n).\nВыходные данные\nВ выходной файл OUTPUT.TXT выведите одно число – минимальное или максимальное (в зависимости от входных данных) количество актеров, которые могут претендовать на главную роль в новом спектакле.",
    "complexity": 24,
    "memory": 16000,
    "time": 1000,
    "examples": [
      {
        "input": "2\n5 3 4 5",
        "output": "3"
      },
      {
        "input": "1\n5 3 4 5",
        "output": "2"
      }
    ]
  },
  {
    "id": 926,
    "name": "Города - 2",
    "description": "Юный программист решил придумать собственную игру. Игра происходит на поле размером N × N клеток, в некоторых клетках которого расположены города (каждый город занимает одну клетку; в каждой клетке может располагаться не более одного города). Всего должно быть чётное количество городов. \nOUTPUT.TXT222\n212\n21125\nDDDDD\nCDCDC\nDCCDC\nDDDDD\nDDDDD11111\n12221\n12221\n11111\n1111111111\n12221\n12221\n11111\n11111[Лучшие попытки]\nИзначально про каждую клетку игрового поля известно, расположен ли в ней город или нет. Чтобы начать игру, необходимо разделить игровое поле на два государства так, чтобы в каждом государстве было поровну клеток-городов.\nГраница между государствами должна проходить по границам клеток таким образом, чтобы из любой клетки каждого государства существовал путь по клеткам этого же государства в любую другую его клетку (из клетки можно перейти в соседнюю, если они имеют общую сторону). Каждая клетка игрового поля должна принадлежать только одному из двух государств, при этом государства не обязаны состоять из одинакового количества клеток.\nТребуется написать программу, которая с учетом сказанного разделит клетки заданного игрового поля между двумя государствами.\nВходные данные\nПервая строка входного файла INPUT.TXT содержит одно натуральное число N, задающее размер игрового поля (N ≤ 50).\nПоследующие N строк содержат по N заглавных английских букв (без пробелов), кодирующих соответствующие клетки игрового поля: 'C' обозначает клетку, занятую городом, 'D' – пустую клетку. Гарантируется, что на поле есть хотя бы два города и всего их четное число.\nВыходные данные\nВыходной файл OUTPUT.TXT должен содержать N строк по N цифр (без пробелов) в каждой, кодирующих соответствующие клетки. Цифра 1 обозначает, что данная клетка принадлежит первому государству, цифра 2 – данная клетка принадлежит второму государству. Если решений несколько, необходимо вывести любое из них.",
    "complexity": 23,
    "memory": 16000,
    "time": 1000,
    "examples": [
      {
        "input": "3\n\nDDD\n\nDDC\n\nDDC",
        "output": "222\n\n212\n\n211"
      },
      {
        "input": "5\n\nDDDDD\n\nCDCDC\n\nDCCDC\n\nDDDDD\n\nDDDDD",
        "output": "11111\n\n12221\n\n12221\n\n11111\n\n11111"
      }
    ]
  },
  {
    "id": 378,
    "name": "Суммы",
    "description": "",
    "complexity": 47,
    "memory": 16000,
    "time": 1000,
    "examples": [
      {
        "input": "3\n1 1 2",
        "output": "5"
      },
      {
        "input": "3\n1 3 2",
        "output": "7"
      },
      {
        "input": "5\n49 100 98 49 0",
        "output": "10"
      }
    ]
  },
  {
    "id": 840,
    "name": "Шары",
    "description": "В пространстве расположен шар, заданный координатами своего центра X,Y,Z и радиусом R. К нему добавляется не более N новых шаров, которые также описываются координатами центров Xi, Yi, Zi и радиусами Ri (1 ≤ i ≤ N). \niВложение одного шара в другой является пересечением.iOUTPUT.TXT2[Лучшие попытки]\ni\nШары добавляются до тех пор, пока есть хоть один шар, не пересекающийся с другими шарами. Требуется определить номер шара, после которого процесс добавления шаров можно прекратить.\n\ni[Решение]\nПримечание:\ni\nВзаимное пересечение абсолютно всех шаров не требуется, т.е. решением является и наличие непересекающихся групп пересекающихся шаров;\nКасание шаров не является пересечением.\nВложение одного шара в другой является пересечением.\n\ni\nВходные данныеi\nВходной файл INPUT.TXT содержит четыре вещественных числа разделенных пробелами X, Y, Z, R - параметры исходного шара (|X, Y, Z| ≤ 30000; 0 \u003c R ≤ 30000). Вторая строка содержит целое число N - количество шаров, которые предполагается добавить (1 ≤ N ≤ 5000). Следующие N строк содержат по четыре вещественных числа Xi, Yi, Zi, Ri - параметры i-го шара (1 ≤ i ≤ N; |Xi, Yi, Zi| ≤ 30000; 0 \u003c Ri ≤ 30000).\ni\nВыходные данные\nВ выходной файл OUTPUT.TXT выведите номер шара, после которого процесс добавления шаров можно остановить, или 0 - если даже после добавления всех имеющихся шаров остается хотя бы один шар, не пересекающийся с другими.",
    "complexity": 37,
    "memory": 16000,
    "time": 1000,
    "examples": [
      {
        "input": "2 2 1 1\n\n3\n\n5 2 2 1\n\n3 3 3 1.5\n\n8 8 8 1",
        "output": "2"
      }
    ]
  },
  {
    "id": 847,
    "name": "Анаграмма-2",
    "description": "Катя и Таня играли в слова. Одна из девочек называла слово на английском языке, вторая должна найти анаграмму. Анаграмма – это слово, полученное из другого слова путем перестановки всех без исключения букв первого слова.\nOUTPUT.TXTYES2post potsNONONO[Лучшие попытки]\nНаписать программу, которая проверит, правильно ли девочки создают анаграммы.\n3aabb aabbNO[Решение]\nВходные данные\nВходной файл INPUT.TXT содержит два слова на английском языке в нижнем регистре, разделенные пробелом. Каждое слово содержит от 1 до 20 символов.\nВыходные данные\nВ выходной файл OUTPUT.TXT выведите «YES», если анаграмма подобрана правильно, иначе выведите «NO».",
    "complexity": 28,
    "memory": 16000,
    "time": 1000,
    "examples": [
      {
        "input": "post stop",
        "output": "YES"
      },
      {
        "input": "post pots",
        "output": "NO"
      },
      {
        "input": "aabb aabb",
        "output": "NO"
      }
    ]
  },
  {
    "id": 838,
    "name": "Шаблон программы",
    "description": "Многие команды, участвующие в командных соревнованиях по программированию, используют так называемый «шаблон программы». Он набирается в самом начале соревнования и содержит общее для всех решений  - например, открытие и закрытие входных и выходных файлов.\nOUTPUT.TXT1272program solution;\nuses\n  sysutils, math;\nbegin\n  assign(input, '.in');\n  assign(output, '.out');\nend.489489[Лучшие попытки]\nТрехкратный чемпион мира по версии AMC команда Dream Team – не исключение. Во многом их успехи связаны с тем, что они очень тщательно готовятся к соревнованиям, продумывая даже очень мелкие детали. Например, перед последним финалом они во время пробного тура рассчитали, сколько джоулей энергии потратится на набор шаблона.\n[Решение]\nОрганизаторы финала использовали весьма странные клавиатуры — жесткость различных клавиш была различной. Таким образом, на нажатие разных клавиш требовалось различное количество энергии.\nЭксперименты, проведенные командой Dream Team во время пробного тура, показали следующее. На набор строчной буквы английского алфавита требуется количество энергии, равное сумме цифр ее порядкового номера в алфавите (буквы нумеруются с единицы). На нажатие клавиши «Shift» требуется 10 джоулей энергии (таким образом набор заглавной буквы английского алфавита требует на 10 джоулей больше, чем набор соответствующей ей строчной буквы), нажатие клавиши «Пробел» требует 4 джоуля энергии. Набор цифры x требует (13 – x) джоулей энергии, набор точки – 5 джоулей, точки с запятой – 7 джоулей, запятой – 2 джоуля. Знак равенства, плюс, минус, одинарная и двойная кавычка требуют по 3 джоуля энергии. Закрывающая и открывающая круглые скобки требуют по 1 джоулю, а фигурные, квадратные и угловые (т.е. символы \u003c и \u003e) – по 8. При этом для всех упомянутых знаков препинания на клавиатуре, используемой на финале, существуют отдельные клавиши, и другой возможности набрать соответствующий символ нет. Нажатие клавиши «Enter» (перевод строки) оказалось настолько легким, что энергозатраты на него можно считать нулевыми.\nВаша задача – написать программу, которая по тексту шаблона вычислит энергозатраты на его набор.\nВходные данные\nВходной файл INPUT.TXT содержит шаблон программы, энергетические затраты на набор которого необходимо вычислить. Он содержит только цифры, пробелы, строчные и заглавные буквы английского алфавита, точки, запятые, знаки равенства, плюсы, точки с запятыми, двойные кавычки (\"), одинарные кавычки ('), закрывающие и открывающие круглые, фигурные и квадратные скобки. Его размер не превышает 20000 байт.\nВыходные данные\nВ выходной файл OUTPUT.TXT выведите ответ на задачу.",
    "complexity": 30,
    "memory": 16000,
    "time": 1000,
    "examples": [
      {
        "input": "abCD \u0026#39;+=1;2,3.\u0026#34;()[]{}",
        "output": "127"
      },
      {
        "input": "program solution;\nuses\n  sysutils, math;\nbegin\n  assign(input, \u0026#39;.in\u0026#39;);\n  assign(output, \u0026#39;.out\u0026#39;);\nend.",
        "output": "489"
      }
    ]
  },
  {
    "id": 839,
    "name": "Всем известно",
    "description": "Всем известно, что многие олимпиадные задачи начинаются со слов «Всем известно». Но мало кто знает, что начинающему программисту Паше такие задачи меньше всего нравятся. Потому что обычно после слов «всем известно» описывается такой факт, о котором он даже не догадывался. После очередной подобной задачи Паша решил проверить, а действительно ли всем известно, что сумма первых N нечетных чисел равняется N2:\nOUTPUT.TXTNO211YESYES[Лучшие попытки]\n[Решение]\nДля этого Паша провел опрос всех людей, попавшихся ему под руку в известной социальной сети. Результаты опроса он записал в текстовый файл. Он ставил цифру один, если человеку был действительно известен данный факт, в противном случае в файл записывался нуль. Все было хорошо, пока Паша не открыл файл и не ужаснулся, увидев длинную последовательность из единичек. Как же он теперь будет искать среди них нули?\nУже всем известно, что Паша – начинающий программист, поэтому для обработки результатов исследования он обратился к вам за помощью.\nВходные данные\nВходной файл INPUT.TXT содержит непустую последовательность из нулей и единиц. Длина последовательности не превышает 104.\nВыходные данные\nВ выходной файл OUTPUT.TXT выведите слово «YES», если факт был известен всем опрошенным людям, и слово \"NO\" в противном случае.",
    "complexity": 14,
    "memory": 16000,
    "time": 1000,
    "examples": [
      {
        "input": "11111101010011",
        "output": "NO"
      },
      {
        "input": "11",
        "output": "YES"
      }
    ]
  },
  {
    "id": 844,
    "name": "Поля",
    "description": "Геннадий учится в сельской школе и мечтает стать агрономом. На уроке геометрии Геннадий познакомился с новой фигурой – прямоугольником. Освоив вычисление площади прямоугольника, Гена подумал о том, что квадратные поля гораздо удобнее, нежели прямоугольные. Поразмыслив еще немного, Гена столкнулся с интересной задачей: существует ли такое квадратное поле, у которого площадь в точности равна площади заданного поля прямоугольной формы, чтобы при этом длины сторон обоих полей были бы целыми числами?\nOUTPUT.TXT222 8440[Лучшие попытки]\nВходные данные315 420[Решение]\nВходной файл INPUT.TXT содержит целые числа a и b – длины сторон прямоугольника (1 \u003c = a*b ≤ 1014).\nВыходные данные\nВ выходной файл OUTPUT.TXT выведите либо одно целое число c – длину стороны квадрата, либо 0, если квадрата с целочисленной длиной стороны не существует.",
    "complexity": 16,
    "memory": 16000,
    "time": 1000,
    "examples": [
      {
        "input": "1 4",
        "output": "2"
      },
      {
        "input": "2 8",
        "output": "4"
      },
      {
        "input": "15 42",
        "output": "0"
      }
    ]
  },
  {
    "id": 841,
    "name": "Окружности",
    "description": "На какое максимальное число областей можно разбить плоскость при помощи N окружностей одинакового радиуса?\nOUTPUT.TXT12388[Лучшие попытки]\n[Решение]\nВходные данные\nВходной файл INPUT.TXT содержит целое число N – количество окружностей, 0 ≤ N ≤ 33333.\nВыходные данные\nВ выходной файл OUTPUT.TXT выведите одно число –  максимальное количество областей, на которое можно разбить плоскость при помощи N окружностей одинакового радиуса.",
    "complexity": 25,
    "memory": 16000,
    "time": 1000,
    "examples": [
      {
        "input": "0",
        "output": "1"
      },
      {
        "input": "3",
        "output": "8"
      }
    ]
  },
  {
    "id": 842,
    "name": "Деление-2",
    "description": "Рассмотрим дробь 1/N. Чтобы преобразовать эту обыкновенную дробь в дробь десятичную, следует разделить числитель на знаменатель. Результат может иметь конечное число знаков, но может быть и бесконечной периодической дробью.\nOUTPUT.TXTNO23YESYES[Лучшие попытки]\nПримеры:\n[Решение]\nN = 2: 1/2 = 0,5 – конечное число знаков.\nN = 7: 1/7 = 0,(142857) – бесконечная периодическая дробь.\nN = 28: 1/28=0,03(571428) – бесконечная периодическая дробь с предпериодом (предпериод - минимальная по длине часть после запятой, которая не входит ни в один период).\nЕсли десятичная дробь имеет конечное число знаков, то будем говорить, что она не имеет периода.\nВаша задача – написать программу, которая по заданному N определит, есть ли у дроби 1/N в десятичной записи период, или нет.\nВходные данные\nВходной файл INPUT.TXT содержит натуральное число N, не превосходящее 1018.\nВыходные данные\nВ выходной файл OUTPUT.TXT выведите «YES» – если у дроби 1/N есть период, иначе выведите «NO».",
    "complexity": 30,
    "memory": 16000,
    "time": 1000,
    "examples": [
      {
        "input": "2",
        "output": "NO"
      },
      {
        "input": "3",
        "output": "YES"
      }
    ]
  },
  {
    "id": 843,
    "name": "Экзамены",
    "description": "В этом году при поступлении в университет абитуриентам требовалось успешно сдать экзамены по математике и физике. К сожалению, с этим испытанием справились не все. Известно, что на экзамены пришло N абитуриентов, из них M – сдали математику, F – сдали физику, а L – не сдали ни одного предмета. Найдите, сколько абитуриентов сдали оба предмета и стали студентами, а также определите, сколько абитуриентов сдали один экзамен: только по математике или только по физике.\nOUTPUT.TXT1 1 0210 5 5 55 0 05 0 00 5 5[Лучшие попытки]\nВходные данные310 5 5 00 5 5[Решение]\nВходной файл INPUT.TXT содержит четыре целых числа, разделенных пробелами: N (0 \u003c N ≤ 2×109), M, F, L (0 ≤ M, F, L ≤ 2×109).\nВыходные данные\nВ выходной файл OUTPUT.TXT выведите три числа через пробел:\na) количество абитуриентов, сдавших оба экзамена;\nb) количество абитуриентов, сдавших только математику;\nс) количество абитуриентов, сдавших только физику.",
    "complexity": 20,
    "memory": 16000,
    "time": 1000,
    "examples": [
      {
        "input": "2 2 1 0",
        "output": "1 1 0"
      },
      {
        "input": "10 5 5 5",
        "output": "5 0 0"
      },
      {
        "input": "10 5 5 0",
        "output": "0 5 5"
      }
    ]
  },
  {
    "id": 845,
    "name": "Гиганты",
    "description": "Астроному Василию по роду службы часто приходится иметь дело с невероятно большими числами. Очень часто такие числа приходится возводить в не менее огромные степени. К счастью, для предварительных расчетов Василию не понадобится весь результат расчетов – вполне хватит последней цифры.\nOUTPUT.TXT322 522[Лучшие попытки]\nВходные данные[Решение]\nВходной файл INPUT.TXT содержит два натуральных числа X и Y, не превосходящих 1040.\nВыходные данные\nВ выходной файл OUTPUT.TXT выведите последнюю цифру числа XY.",
    "complexity": 35,
    "memory": 16000,
    "time": 1000,
    "examples": [
      {
        "input": "7 3",
        "output": "3"
      },
      {
        "input": "2 5",
        "output": "2"
      }
    ]
  },
  {
    "id": 977,
    "name": "Поезда",
    "description": "Во Флатландии расположено N городов. Недавно король Флатландии побывал в Японии и был поражен скоростными поездами Shinkansen, сеть которых связывает всю страну. Теперь он решил построить сеть высокоскоростных поездов во Флатландии.\nOUTPUT.TXT41[Лучшие попытки]\nКаждый маршрут скоростного поезда будет соединять ровно два города во Флатландии. Хотя реальной необходимости в скоростных поездах во Флатландии нет, король повелел, чтобы хотя бы одна линия скоростного поезда была в каждом городе.\nМинистр транспорта Флатландии сказал королю, что существует несколько сетей маршрутов поездов, удовлетворяющих данному свойству. Король был поражен этим фактом и попросил министра подсчитать количество возможных сетей. Помогите ему!\nВходные данные\nВходной файл INPUT.TXT содержит целое число N (2 ≤ N ≤ 100).\nВыходные данные\nВ выходной файл OUTPUT.TXT выведите количество сетей скоростных поездов, которые удовлетворяют требованиям короля.",
    "complexity": 70,
    "memory": 16000,
    "time": 1000,
    "examples": [
      {
        "input": "4",
        "output": "41"
      }
    ]
  },
  {
    "id": 987,
    "name": "Обмен пакетами",
    "description": "Вася получает доступ в Интернет с помощью мобильного телефона. Однако такая связь очень нестабильна, поэтому каждый раз после подключения ему приходиться проверять подключение. Для этого он просто в командной строке набирает примерно следующую фразу: «ping name», где name – это имя удаленного сервера, который точно находится в сети. Затем идет обмен пакетами с сервером и выдается статистика. Однако у Васи недавно сломался модуль, отвечающий за подсчет и вывод статистики. Вам надо будет помочь Васе – написать аналогичный модуль.\nOUTPUT.TXTPing statistics for 209.85.135.147:\nPackets: Sent = 4 Received = 3 Lost = 1 (25% loss)\nApproximate round trip times:\nMinimum = 100 Maximum = 300 Average = 200[Лучшие попытки]\nПосле вызова команды «ping» на удаленный сервер по очереди посылаются 4 пакета по 32 байта. Как только удаленный сервер получил пакет, он отвечает на него. Если пакет не уложился в определенное время (он должен дойти до удаленного сервера и вернуться обратно) в силу тех или иных причин (низкая скорость, отсутствие подключения и т.д.), он считается утерянным.\nДана информация обо всех 4 пакетах. Требуется определить количество потерянных пакетов, максимальное, минимальное и среднее время обмена одного пакета.\nВходные данные\nВходной файл INPUT.TXT содержит ровно 5 строк. В первой строке находится фраза «ping\tname», где name – это имя сервера. Имя сервера представляет собой IP адрес. IP-адрес – это 4 однобайтных числа (т.е. числа от 0 до 255), отделенные друг от друга точкой. В каждой из следующих 4 строк содержится либо фраза «Time out», если пакет считается утерянным, либо «Reply from name Time=number», где\tname –  это имя удаленного сервера, а number – время за которое вернулся пакет (number –  целое число, 0 ≤ number ≤ 104).\nВыходные данные\nВ выходной файл OUTPUT.TXT выведите статистику по обмену пакетами с удаленным сервером. Следуйте формату, приведенному в примере. Среднее время округлите до целого числа по математическим правилам. Если все 4 пакета утеряны, то выведите только первые две строки.",
    "complexity": 32,
    "memory": 16000,
    "time": 1000,
    "examples": [
      {
        "input": "«ping 209.85.135.147\n\nTime out\n\nReply from 209.85.135.147 Time=100\n\nReply from 209.85.135.147 Time=300\n\nReply from 209.85.135.147 Time=200»",
        "output": "«Ping statistics for 209.85.135.147:\n\nPackets: Sent = 4 Received = 3 Lost = 1 (25% loss)\n\nApproximate round trip times:\n\nMinimum = 100 Maximum = 300 Average = 200»"
      }
    ]
  },
  {
    "id": 846,
    "name": "Герои",
    "description": "Коварный кардинал Ришелье вновь организовал похищение подвесок королевы Анны; вновь спасать королеву приходится героическим мушкетерам. Атос, Портос, Арамис и д’Артаньян уже перехватили агентов кардинала и вернули украденное; осталось лишь передать подвески королеве Анне. Королева ждет мушкетеров в дворцовом саду. Дворцовый сад имеет форму прямоугольника и разбит на участки, представляющие собой небольшие садики, содержащие коллекции растений из разных климатических зон. К сожалению, на некоторых участках, в том числе на всех участках, расположенных на границах сада, уже притаились в засаде гвардейцы кардинала; на бой с ними времени у мушкетеров нет. Мушкетерам удалось добыть карту сада с отмеченными местами засад; теперь им предстоит выбрать наиболее оптимальные пути к королеве. Для надежности друзья разделили между собой спасенные подвески и проникли в сад поодиночке, поэтому начинают свой путь к королеве с разных участков сада. Двигаются герои по максимально короткой возможной траектории.\nxOUTPUT.TXT1025 5\n11111\n10001\n10111\n10101\n11111\n4 4 10\n2 2 1\n2 2 2\n2 2 3\n2 2 400[Лучшие попытки]\nМарлезонский балет вот-вот начнется; королева не в состоянии ждать героев больше L минут; ровно в начале L+1-ой минуты королева покинет парк, и те мушкетеры, что не успеют к этому времени до нее добраться, не смогут передать ей подвески. На преодоление одного участка у мушкетеров уйдет ровно по минуте. С каждого участка мушкетеры могут перейти на 4 соседние. Требуется выяснить, сколько подвесок будет красоваться на платье королевы, когда она придет на бал.\ny[Решение]\nВходные данныеx\nПервая строка входного файла INPUT.TXT содержит целые числа N и M (1 ≤ N,M ≤ 20) – размеры сада. Далее идут N строк по M символов в каждом; символы '0' соответствуют участкам, на которых нет засады, символы '1' – участкам, на которых разместились гвардейцы. В N+2-ой строке теста записано три целых числа: координаты участка, на котором королева будет ждать мушкетёров (Qx, Qy) (1 \u003c Qx \u003c N, 1 \u003c Qy \u003c M) и время в минутах до начала балета (1 ≤ L ≤ 1000). В N+3-ей строки записаны через пробел целые числа координаты участка, с которого стартует Атос (Ax,Ay) (1 \u003c Ax \u003c N, 1 \u003c Ay \u003c M) и количество подвесок, хранящихся у него (1 ≤ Pa ≤ 1000). В N+4, N+5 и N+6-ой строках аналогично записаны стартовые координаты и количество подвесок у Портоса, Арамиса и д’Артаньяна.\ny\nxВыходные данные\ny\nВ выходной файл OUTPUT.TXT выведите количество подвесок, которое королева успеет получить у мушкетеров до начала балета.\naПримеры\n№INPUT.TXTOUTPUT.TXT\n15 5\n11111\n10001\n10001\n10001\n11111\n4 4 10\n2 2 1\n2 3 2\n3 2 3\n3 3 410\n25 5\n11111\n10001\n10111\n10101\n11111\n4 4 10\n2 2 1\n2 2 2\n2 2 3\n2 2 40\nДля отправки решения задачи необходимо зарегистрироваться и авторизоваться!\n[Обсуждение]\n\n  [Все попытки]\n\n  [Лучшие попытки]\n\n  [Решение]\nwindow.yaContextCb.push(()=\u003e{\n  Ya.Context.AdvManager.render({\n    renderTo: 'yandex_rtb_R-A-122393-3',\n    blockId: 'R-A-122393-3'\n  })\n})",
    "complexity": 48,
    "memory": 16000,
    "time": 1000,
    "examples": [
      {
        "input": "5 5\n\n11111\n\n10001\n\n10001\n\n10001\n\n11111\n\n4 4 10\n\n2 2 1\n\n2 3 2\n\n3 2 3\n\n3 3 4",
        "output": "10"
      },
      {
        "input": "5 5\n\n11111\n\n10001\n\n10111\n\n10101\n\n11111\n\n4 4 10\n\n2 2 1\n\n2 2 2\n\n2 2 3\n\n2 2 4",
        "output": "0"
      }
    ]
  },
  {
    "id": 976,
    "name": "Сумма или произведение",
    "description": "Федя недавно начал учиться математике. Он научился складывать и умножать и был немедленно потрясен фактом, что 2 + 2 = 2 x 2. Теперь он хочет найти еще примеры таких соотношений.\nOUTPUT.TXT12533[Лучшие попытки]\nПетя называет набор чисел интересным, если произведение чисел из этого набора равно их сумме. Например, наборы {2, 2}, {5}, {1, 2, 3} – интересные, а набор {2, 3} – нет.\nПо заданному N, Федя хочет найти количество интересных наборов, содержащих N чисел. Помогите ему!\nВходные данные\nПервая строка входного файла INPUT.TXT содержит N (2 ≤ N ≤ 500).\nВыходные данные\nВ выходной файл OUTPUT.TXT выведите одно число – количество интересных наборов, содержащих N чисел.",
    "complexity": 74,
    "memory": 16000,
    "time": 1000,
    "examples": [
      {
        "input": "2",
        "output": "1"
      },
      {
        "input": "5",
        "output": "3"
      }
    ]
  },
  {
    "id": 978,
    "name": "Последовательность - 5",
    "description": "Выходные данные\nВ выходной файл OUTPUT.TXT выведите единственное число  an.",
    "complexity": 79,
    "memory": 16000,
    "time": 1000,
    "examples": [
      {
        "input": "12",
        "output": "5"
      },
      {
        "input": "45",
        "output": "10"
      }
    ]
  },
  {
    "id": 928,
    "name": "Березовая аллея",
    "description": "На краю деревни растет старая березовая аллея. Аллея имеет форму прямой полосы шириной W метров. Вдоль левой стороны аллеи растет N берез, а вдоль правой — M берез, при этом i-я береза с левой стороны аллеи находится на расстоянии ai метров от начала аллеи, а j-я береза с правой стороны — на расстоянии bj метров от начала аллеи.\nNMOUTPUT.TXT525 3\n1\n0\n1\n000[Лучшие попытки]\nii\nОтдыхая в деревне прошедшим летом, один юный информатик обнаружил, что кору берез стали грызть зайцы. Чтобы защитить деревья от зайцев, мальчик решил окружить березы красной лентой (зайцы не любят красный цвет и не станут заходить на огражденную лентой территорию). К сожалению, в его распоряжении оказалась только лента длиной L метров, которую, к тому же, нельзя было разрезать. Единственное, что можно было делать в этом случае — окружить этой лентой как можно больше берез. При этом, чтобы сохранить аллею, необходимо окружить на каждой стороне аллеи хотя бы одну березу.\n55\nТребуется написать программу, которая по заданной длине ленты, ширине аллеи и положению берез на ней определяет максимальное количество берез, которое можно окружить этой лентой. Считается, что березы представляются точками, толщиной берез и шириной ленты следует пренебречь.\nВходные данные\nПервая строка входного файла INPUT.TXT содержит два разделенных пробелом целых числа: длину ленты L и ширину аллеи W (1 ≤ L ≤ 2×105, 1 ≤ W ≤ 104).\nВторая и третья строки описывают березы вдоль левой стороны аллеи. Вторая строка содержит число N — количество берез (1 ≤ N ≤ 2000), а третья строка содержит N различных целых чисел a1, a2, …, aN, заданных по возрастанию (0 ≤ ai ≤ 105).\nЧетвертая и пятая строки описывают березы вдоль правой стороны аллеи. Четвертая строка содержит число M — количество берез (1 ≤ M ≤ 2000), а пятая строка содержит M различных целых чисел b1, b2, …, bM, заданных по возрастанию (0 ≤ bi ≤ 105).\nВыходные данные\nВыходной файл OUTPUT.TXT должен содержать одно целое число: максимальное количество берез, которое можно оградить заданной лентой. Гарантируется, что если максимальное число берез, которое можно оградить лентой длины L, равно X, то нет способа оградить (X + 1) березу лентой длины (L + 10-5).",
    "complexity": 70,
    "memory": 128000,
    "time": 1000,
    "examples": [
      {
        "input": "18 4\n\n3\n\n0 3 6\n\n4\n\n0 3 6 10",
        "output": "5"
      },
      {
        "input": "5 3\n\n1\n\n0\n\n1\n\n0",
        "output": "0"
      }
    ]
  },
  {
    "id": 927,
    "name": "A + B = C",
    "description": "Часто для пробного тура на различных олимпиадах по информатике предлагается задача «A + B», в которой по заданным целым числам A и B требуется найти их сумму.\nOUTPUT.TXT2220000016[Лучшие попытки]\nПри проведении городской олимпиады по информатике председатель жюри решил сам подготовить тесты для такой задачи. Для этого он использовал свою оригинальную методику, которая заключалась в следующем: сначала готовятся предполагаемые правильные ответы, а затем подбираются входные данные, соответствующие этим ответам. \n310000\nПусть председатель жюри выбрал число C, запись которого состоит из n десятичных цифр и не начинается с нуля. Теперь он хочет подобрать такие целые положительные числа A и B, чтобы их сумма была равна C, и запись каждого из них также состояла из n десятичных цифр и не начиналась с нуля. В дополнение к этому председатель жюри старается подобрать такие числа A и B, чтобы каждое из них было красивым. Красивым в его понимании является число, запись которого не содержит двух одинаковых подряд идущих цифр. Например, число 1272 считается красивым, а число 1227 — нет.\n423916\nТребуется написать программу, которая для заданного натурального числа C вычисляет количество пар красивых положительных чисел A и B, сумма которых равна C. Поскольку количество пар красивых чисел может быть большим, необходимо вывести остаток от деления этого количества на число 109+7.\nВходные данные\nВходной файл INPUT.TXT содержит одно целое положительное число C. Число C не начинается с нуля. Количество цифр в записи числа С не превышает 10 000.\nВыходные данные\nВ выходной файл OUTPUT.TXT должен содержать одно целое число — остаток от деления количества искомых пар красивых чисел A и B на число 109+7.",
    "complexity": 47,
    "memory": 16000,
    "time": 1000,
    "examples": [
      {
        "input": "22",
        "output": "2"
      },
      {
        "input": "200",
        "output": "0"
      },
      {
        "input": "1000",
        "output": "0"
      },
      {
        "input": "239",
        "output": "16"
      }
    ]
  },
  {
    "id": 979,
    "name": "Формула 001",
    "description": "Мальчик Миша собирается участвовать в школьных соревнованиях по гонкам с препятствиями по версии «Формула 001». Но к любым соревнованиям необходимо готовиться. Младший брат Миши, Ральф, не так силен в гонках с препятствиями, как его старший брат, но зато он обладает незаурядной фантазией. Он решил помочь брату и придумал игру, играя в которую, можно существенно увеличить свой опыт в вождении гоночного автомобиля.\niOUTPUT.TXT2\n1 2 3230 00 20 3-1-1[Лучшие попытки]\nИгра состоит в следующем. Пусть у нас есть бесконечное игровое поле, покрытое бесконечной квадратной сеткой. Некоторое множество узлов этой сетки отмечено. Назовем это множество S. В игре участвуют несколько игроков. У каждого игрока есть машина – фигура, которая может находиться только в узлах из множества S. В начале игры все машины находятся в различных начальных узлах. Ход каждого игрока состоит в перемещении машины в некоторый узел из множества S, возможно, тот же самый. Цель игры – добраться до определенного, финишного узла первым.\n9\nХод происходит по следующим правилам. Пусть на предыдущем шаге машина была перемещена на вектор (X, Y) (если это первый шаг, то X=0 и Y=0). Тогда за один текущий ход машину можно передвинуть на один из следующих векторов: (X−1, Y−1), (X−1, Y), (X−1, Y+1), (X, Y−1), (X, Y), (X, Y+1), (X+1, Y−1),  (X+1, Y) и  (X+1, Y+1).\nКонечно, на какой-либо из этих векторов машину переместить можно только при том условии, что после этого она попадет в узел из множества S. Если ход сделать нельзя, то игрок считается проигравшим и выбывает из игры.\nНекоторое время поиграв в эту игру, Миша и Ральф занялись ее анализом. В данный момент они хотят узнать, за какое наименьшее число ходов из стартового узла возможно попасть в финишный. Сами они эту задачу решить не смогли и обратились за помощью к Вам. Помогите им!\nВходные данные\nВ первой строке входного файла INPUT.TXT находится N – число элементов множества S. 2 ≤ N ≤ 1000. В последующих N строках находятся координаты узлов из этого множества – целые числа Xi, Yi (−109 ≤ Xi, Yi ≤ 109).\nНикакие два узла во входном файле не совпадают. Занумеруем эти узлы, начиная с 1, в порядке их описания во входном файле. Стартовым узлом будет являться узел с номером 1, финишным  узел с номером N .\nВыходные данные\nВ выходной файл OUTPUT.TXT выведите -1, если добраться до финишного узла невозможно. Иначе, в первой строке выведите минимальное требуемое число ходов K . Во второй выведите K+1 число – номера посещенных узлов в порядке посещения. Первым узлом должен быть узел с номером 1, последним – узел с номером N .",
    "complexity": 57,
    "memory": 32000,
    "time": 1000,
    "examples": [
      {
        "input": "3\n0 0\n0 1\n0 2",
        "output": "2\n\n1 2 3"
      },
      {
        "input": "3\n0 0\n0 2\n0 3",
        "output": "-1"
      }
    ]
  },
  {
    "id": 929,
    "name": "Игральные кубики",
    "description": "Юный математик Матвей интересуется теорией вероятностей, и по этой причине у него всегда есть с собой несколько стандартных шестигранных игральных кубиков. Стандартный шестигранный кубик имеет три противолежащих пары граней, которые размечены таким образом, что напротив грани с числом 1 находится грань с числом 6, напротив грани с числом 2 — грань с числом 5 и напротив грани с числом 3 — грань с числом 4.\nOUTPUT.TXT5 122366 2166 216[Лучшие попытки]\nАнализируя различные игры с шестигранными кубиками, Матвей придумал новую игру. В эту игру играют два игрока, и проходит она следующим образом: первый игрок бросает один или несколько стандартных кубиков (количество кубиков он определяет сам). После этого первому игроку начисляется количество очков, равное сумме чисел, оказавшихся на верхних гранях всех кубиков, а второму игроку — сумма чисел, оказавшихся на нижних гранях этих кубиков. Побеждает тот, кто набрал больше очков.\nНапример, если был брошен один кубик, и на верхней его грани выпало число два, то первый игрок получает два очка, а второй — пять. В свою очередь, если было брошено два кубика и на их верхних гранях выпало по единице, то первый игрок получает также два очка, а второй игрок – двенадцать очков, так как на нижних гранях этих кубиков оказались шестерки.\nМатвей рассказал об этой игре своему другу, юному информатику Фоме, и они начали играть в неё через Интернет. Поскольку Фома не видит результат броска и не знает, сколько кубиков бросает Матвей как первый игрок, то о набранных каждым игроком очках он узнает только от Матвея. Чтобы проверить достоверность этой информации, Фома решил узнать, какое минимальное и максимальное количество очков мог получить он, как второй игрок, если известно, сколько очков набрал Матвей.\nТребуется написать программу, которая по количеству очков, набранных первым игроком после броска, определяет наименьшее и наибольшее количество очков, которые может получить второй игрок за этот бросок.\nВходные данные\nВходной файл INPUT.TXT содержит одно натуральное число n — количество очков, которые получил первый игрок (n ≤ 1010).\nВыходные данные\nВ выходной файл OUTPUT.TXT выведите два разделенных пробелом целых числа: минимальное и максимальное количество очков соответственно, которые мог набрать второй игрок при таком броске кубиков.",
    "complexity": 15,
    "memory": 16000,
    "time": 1000,
    "examples": [
      {
        "input": "2",
        "output": "5 12"
      },
      {
        "input": "36",
        "output": "6 216"
      }
    ]
  },
  {
    "id": 982,
    "name": "Шашки - 3",
    "description": "Сема — любитель игр на шахматной доске. Больше всего он любит играть в шашки. Сема решил написать программу, которая будет играть в шашки. По его задумке, она будет показывать, какие шашки можно взять на данном ходу. Ваша задача — реализовать эту функцию.\nOUTPUT.TXTWhite: 0Black: 02.W.W.W.W\nW.W.W.W.\n.....W..\nW.W...W.\n.B.B....\nB...B.B.\n.B.B.B.B\nB.B...B.White: 3\n(5, 2), (5, 4), (7, 4)\nBlack: 1\n(4, 3)White: 3\n(5, 2), (5, 4), (7, 4)\nBlack: 1\n(4, 3)[Лучшие попытки]\nНапомним, что взять можно только по диагонали одним из четырех способов:\nПосле того, как белая шашка перемещается на пустое поле, черная шашка снимается с доски и считается взятой. При этом, если после перемещения белой шашки, у нее вновь появляется возможность взять, то она продолжает свой ход. Аналогичны правила и для черных шашек.\nОтметим, что в рассматриваемом варианте игры в шашки отсутствует понятие «дамка», то есть возможности шашки по взятию не зависят от того, доходила она до последней горизонтали или нет.\nВходные данные\nВ первых восьми строках входного файла INPUT.TXT записаны по восемь символов из множества {«.», «B», «W»}, которые обозначают пустое поле, черную шашку и белую шашку соответственно. Во входном файле не более 12\t шашек каждого цвета. Все шашки расположены либо на черных, либо на белых полях.\nВыходные данные\nВ выходной файл OUTPUT.TXT выдайте поля, на которых стоят шашки, которые можно взять, если ходят белые или черные. Используйте формат вывода аналогичный примерам.\nОтсортируйте поля сначала по первой координате (измеряется по вертикали), а при равенстве первых – по второй (измеряется по горизонтали). Учитывайте, что первый символ первой строки входного файла соответствует полю (1, 1), последний символ первой строки – полю (1, 8), первый символ последней строки – полю (8, 1), последний символ последней строки – (8, 8).",
    "complexity": 54,
    "memory": 16000,
    "time": 1000,
    "examples": [
      {
        "input": ".W.W.W.W\n\nW.W.W.W.\n\n.W.W.W.W\n\n........\n\n........\n\nB.B.B.B.\n\n.B.B.B.B\n\nB.B.B.B.",
        "output": "White: 0\nBlack: 0"
      },
      {
        "input": ".W.W.W.W\n\nW.W.W.W.\n\n.....W..\n\nW.W...W.\n\n.B.B....\n\nB...B.B.\n\n.B.B.B.B\n\nB.B...B.",
        "output": "White: 3\n\n(5, 2), (5, 4), (7, 4)\n\nBlack: 1\n\n(4, 3)"
      }
    ]
  },
  {
    "id": 983,
    "name": "Бег по эскалатору",
    "description": "Пусть N человек бегут вниз по эскалатору, причем i-ый пробегает одну ступеньку за ti секунд. По технике безопасности бега по эскалатору, на эскалаторе запрещены «обгоны», то есть если человек A в процессе бега догнал человека B, который бежит с более низкой скоростью, то далее, до конца эскалатора, человек\tA бежит со скоростью человека B. Однако ступени эскалатора таковы, что на них может помещаться несколько человек одновременно.\niOUTPUT.TXT203333[Лучшие попытки]\nВаша задача написать программу, которая поможет работникам станции рассчитать, когда закончит свой бег по эскалатору каждый бегущий человек.\ni\nВходные данныеi\nВ первой строке входного файла INPUT.TXT записано число N (1 ≤ N ≤ 105). В следующих N строках перечислены пары чисел ti, wi (1 ≤ ti, wi ≤ 106) – время пробега одной ступени и количество ступеней до конца эскалатора для i-го человека. Гарантируется, что изначально всем людям осталось бежать различное число ступеней.\n6\nВыходные данные\nВ i-ой строке выходного файла OUTPUT.TXT выведите время в секундах, через которое i-ый человек сойдет с эскалатора.",
    "complexity": 33,
    "memory": 16000,
    "time": 1000,
    "examples": [
      {
        "input": "3\n2 10\n3 11\n1 12",
        "output": "20\n33\n33"
      }
    ]
  },
  {
    "id": 930,
    "name": "Имена",
    "description": "На далекой планете Тау Кита есть непонятные нам обычаи. Например, таукитяне очень необычно для землян выбирают имена своим детям. Родители так выбирают имя ребенку, чтобы оно могло быть получено как удалением некоторого набора букв из имени отца, так и удалением некоторого набора букв из имени матери. Например, если отца зовут «abacaba», а мать — «bbccaa», то их ребенок может носить имена «a», «bba», «bcaa», но не может носить имена «aaa», «ab» или «bbc». Возможно, что имя ребенка совпадает с именем отца и/или матери, если оно может быть получено из имени другого родителя удалением нескольких (возможно, ни одной) букв.\nOUTPUT.TXTca2ccbaaccbbaaccbaccba[Лучшие попытки]\nПусть отец по имени X и мать по имени Y выбирают имя своему новорожденному ребенку. Так как в таукитянских школах учеников часто вызывают к доске в лексикографическом порядке имен учеников, то есть в порядке следования имен в словаре, то они хотят выбрать своему ребенку такое имя, чтобы оно лексикографически следовало как можно позже.\nФормально, строка S лексикографически больше строки T, если выполняется одно из двух условий:\n•\tстрока T получается из S удалением одной или более букв с конца строки S;\n•\tпервые (i - 1) символов строк T и S не различаются, а буква в i-й позиции строки T следует в алфавите раньше буквы в i-й позиции строки S.\nТребуется написать программу, которая по именам отца и матери находит лексикографически наибольшее имя для их ребенка.\nВходные данные\nПервая строка входного файла INPUT.TXT содержит имя отца X. Вторая строка входного файла содержит имя матери Y. Каждое имя состоит из строчных букв английского алфавита, включает хотя бы одну букву и имеет длину не более 105 букв.\nВыходные данные\nВ выходной файл OUTPUT.TXT выведите искомое лексикографически наибольшее из возможных имен ребенка. В случае, если подходящего имени для ребенка не существует, выходной файл должен быть пустым.",
    "complexity": 38,
    "memory": 16000,
    "time": 1000,
    "examples": [
      {
        "input": "abcabca\nabcda",
        "output": "ca"
      },
      {
        "input": "ccba\naccbbaa",
        "output": "ccba"
      }
    ]
  },
  {
    "id": 981,
    "name": "Медиана",
    "description": "",
    "complexity": 90,
    "memory": 16000,
    "time": 1000,
    "examples": [
      {
        "input": "x\u0026amp;y|y\u0026amp;z|x\u0026amp;z",
        "output": "\u0026lt;xyz\u0026gt;"
      },
      {
        "input": "x",
        "output": "x"
      },
      {
        "input": "((u|v|x|y)\u0026amp;z)|(u\u0026amp;v\u0026amp;x\u0026amp;y)",
        "output": "\u0026lt;uz\u0026lt;vz\u0026lt;xzy\u0026gt;\u0026gt;\u0026gt;"
      }
    ]
  },
  {
    "id": 980,
    "name": "Отрезание ушей",
    "description": "",
    "complexity": 80,
    "memory": 64000,
    "time": 1000,
    "examples": [
      {
        "input": "5 8\n\n1 2\n\n2 3\n\n3 5\n\n5 1\n\n2 4\n\n4 1\n\n3 4\n\n4 5",
        "output": "4\n\n1 1 4\n\n1 3 4\n\n2 2 4 5\n\n4 1 5 3 2 1"
      },
      {
        "input": "3 2\n1 2\n1 3",
        "output": "-1"
      }
    ]
  },
  {
    "id": 931,
    "name": "Две окружности - 2",
    "description": "Юный футболист Митя обнаружил на школьном футбольном поле две различные окружности, нарисованные едва заметной белой краской. Вспомнив истории о загадочных кругах на полях, он отметил эти окружности с помощью небольших камушков. Митя разложил на поле n камушков так, чтобы каждый из них находился на одной из окружностей или даже на их пересечении, если эти окружности пересекаются. Получилось так, что на каждой окружности размещался хотя бы один камушек. Обладая отличным глазомером, Митя расположил камушки на окружностях абсолютно точно, без какой-либо погрешности.\n6OUTPUT.TXT6 1 2 34 7 5 625\n-1000000 0\n0 1000000\n1000000 0\n0 -1000000\n0 01 2 3 41 51 2 3 41 5[Лучшие попытки]\nНа следующий день пошел дождь, краска стерлась, и нарисованные окружности исчезли, но все камушки остались на своих местах. Теперь Мите очень нужно найти доказательство необычного явления, свидетелем которого он был, то есть, восстановить окружности. \ni\nТребуется написать программу, которая по координатам камушков на поле находит вариант размещения их на двух несовпадающих окружностях.\ni\nВходные данные6\nПервая строка входного файла INPUT.TXT содержит целое число n — количество размещенных Митей камушков на поле (2 ≤ n ≤ 2000). Последующие n строк содержат целочисленные координаты камушков (xi, yi) — в каждой строке по одной паре координат, разделенных пробелом (−106 ≤ xi, yi ≤ 106).\nНикакие два камушка не размещаются в одной точке. Гарантируется, что ответ для заданного набора камушков существует.\nВыходные данные\nВыходной файл OUTPUT.TXT должен содержать две строки. Первая строка должна содержать последовательность номеров всех камушков, которые принадлежат первой окружности, вторая строка — последовательность номеров всех камушков, которые принадлежат второй окружности. Считается, что камушки пронумерованы от 1 до n в порядке их следования во входных данных.\nКаждый камушек должен встречаться хотя бы в одной из двух последовательностей. Если камушек встречается в обеих последовательностях, то это обозначает, что он находится на пересечении окружностей.\nНумерация окружностей не имеет значения, то есть выводить две последовательности можно в любом порядке. Числа в последовательностях можно также выводить в произвольном порядке. Каждая из последовательностей должна содержать не менее одного числа. Все числа в строках должны быть разделены пробелами.\nЕсли вариантов расположения окружностей несколько, можно выбрать любой из них.",
    "complexity": 72,
    "memory": 16000,
    "time": 1000,
    "examples": [
      {
        "input": "7\n\n1 -1\n\n0 0\n\n1 1\n\n3 1\n\n3 -1\n\n2 0\n4 0",
        "output": "6 1 2 3\n4 7 5 6"
      },
      {
        "input": "5\n\n-1000000 0\n\n0 1000000\n\n1000000 0\n\n0 -1000000\n\n0 0",
        "output": "1 2 3 4\n1 5"
      }
    ]
  },
  {
    "id": 932,
    "name": "Столицы",
    "description": "В стране Триландии близятся выборы новых столиц. Столицы в Триландии необычные, поскольку ими являются одновременно сразу три различных города. Такая идея размещения столиц основана на исследованиях эффективности управления страной, выполненных ведущими экономистами Триландии.\niOUTPUT.TXT127 2\n1 2\n1 3\n1 4\n5 1\n5 6\n5 755[Лучшие попытки]\nВсего в Триландии n городов, из которых некоторые пары городов соединены дорогами и по каждой из них можно проехать в обе стороны. Время проезда по каждой дороге в одну сторону равно одному часу. При этом все города соединены дорогами таким образом, что из каждого города можно добраться в любой другой, причем это можно сделать единственным способом, если по каждой дороге проезжать не более одного раза и только в одну сторону.\ni\nКак показали результаты проведенных триландскими экономистами исследований, управление страной будет наиболее эффективным, если три столицы будут выбраны так, что время проезда по кратчайшему пути между каждой парой столиц составит ровно d часов. Перед проведением выборов необходимо знать, сколько существует различных троек городов, удовлетворяющих описанным выше свойствам. Две тройки городов считаются различными, если в первой тройке есть хотя бы один город, которого нет во второй тройке, и наоборот.\ni\nТребуется написать программу, которая по количеству городов в Триландии и описанию дорог находит количество троек городов, которые могут быть столицами.\ni\nВходные данныеi\nПервая строка входного файла INPUT.TXT содержит два разделенных пробелом целых числа: количество городов в Триландии n и требуемое время в пути между столицами d (3 ≤ n ≤ 105, 1 ≤ d \u003c n). Каждая из последующих (n – 1) строк содержит описание одной дороги: пару разделенных пробелом различных целых чисел ai и bi — номера городов, которые соединены двусторонней дорогой (1 ≤ ai ≤ n, 1 ≤ bi ≤ n, ai ≠ bi). Каждая пара городов соединена не более чем одной дорогой.\nВыходные данные\nВыходной файл OUTPUT.TXT должен содержать одно целое число — количество подходящих троек городов, которые могут быть выбраны столицами. В случае, если подходящих троек городов не окажется, выходной файл должен содержать ноль.",
    "complexity": 92,
    "memory": 256000,
    "time": 1000,
    "examples": [
      {
        "input": "4 2\n\n1 2\n\n1 3\n\n1 4",
        "output": "1"
      },
      {
        "input": "7 2\n\n1 2\n\n1 3\n\n1 4\n\n5 1\n\n5 6\n\n5 7",
        "output": "5"
      }
    ]
  },
  {
    "id": 968,
    "name": "Строки - 4",
    "description": "Определим расстояние между равными по длине строками SA и SB (обозначим d(SA, SB)) как сумму для всех 1 ≤ i ≤ |SA| кратчайших расстояний между буквами SA(i)\tи SB(i) в циклически замкнутом английском алфавите (т.е. после буквы «a» идет буква «b», ..., после буквы «z» идет «a»). Например d(aba, aca) = 1, а d(aba, zbz) = 2.\nAk+3AOUTPUT.TXT12abac88[Лучшие попытки]\nB\nНапомним, что циклическим сдвигом строки S\tназывается строка (обозначим, как S→k) Sk+1Sk+2Sk+3 ... S|S|S1S2 ... Sk для некоторого k, где |S| – длина строки S.\n|S|B\nA1\nСтепенью циклического расстояния между строками SA и SB (|SA| = |SB|) называется сумма:\nA2\nBk\nТребуется посчитать степень циклического расстояния заданных строк SA и SB.\nВходные данные\nВходной файл INPUT.TXT содержит две строки равной длины, не превышающей 105 символов. Строки состоят только из маленьких букв английского алфавита.\nВыходные данные\nВ выходной файл OUTPUT.TXT выведите ответ на задачу.",
    "complexity": 48,
    "memory": 16000,
    "time": 1000,
    "examples": [
      {
        "input": "a\nb",
        "output": "1"
      },
      {
        "input": "ab\nac",
        "output": "8"
      }
    ]
  },
  {
    "id": 933,
    "name": "Телефон",
    "description": "Услуги телефонной сети оплачиваются по следующему правилу: за разговоры до А минут в месяц – В рублей за минуту, а разговоры сверх установленной нормы оплачиваются из расчета С рублей за минуту. Требуется написать программу, вычисляющую плату за пользование телефоном для разговоров продолжительностью Т минут в месяц.\nOUTPUT.TXT60220 1 3 305050[Лучшие попытки]\nВходные данные\nПервая строка входного файла INPUT.TXT содержит натуральные числа через пробел A, B, C и T, не превышающие 1000.\nВыходные данные\nВ выходной файл OUTPUT.TXT выведите единственное целое число – месячную плату за пользование телефоном.",
    "complexity": 12,
    "memory": 16000,
    "time": 1000,
    "examples": [
      {
        "input": "30 2 3 30",
        "output": "60"
      },
      {
        "input": "20 1 3 30",
        "output": "50"
      }
    ]
  },
  {
    "id": 985,
    "name": "Объявление массивов",
    "description": "В языке Java для удобства работы любой объявленный массив является объектом, который содержит некоторую вспомогательную информацию и собственно сам массив.\nkOUTPUT.TXT25\n184\n42424\n1440[Лучшие попытки]\nРассмотрим внутреннюю структуру такого объекта. В нем содержится 16 байт вспомогательной информации, 4 байта уходит на хранение длины массива, а затем сам массив, который занимает length*size памяти, где length – это его длина, а size –  размер объектов хранящихся в массиве.\ni\nЕсли мы объявляем в программе двухмерный массив, то у нас создастся объект, который будет содержать в себе массив, каждый элемент которого будет являться одномерным массивом. Так же не следует забывать, что на каждый объект создается внешняя ссылка размером 4 байта.\nАналогично, при объявлении массивов размерности k будет создан массив, каждым элементом которого является массив размерности k−1.\nВаша задача – по данным о размерах примитивных типов, из которых состоят массивы, выяснить, сколько памяти занимает каждый из заданных массивов.\nВходные данные\nВ первой строке входного файла INPUT.TXT содержится количество различных примитивных типов N (1 ≤ N ≤ 100). В следующих N строках содержатся названия примитивных типов, состоящие из маленьких английских букв, длиной не более 30 символов, и через пробел размер типа в байтах. Размеры типов не превосходят 231−1 байт. Следующая строка содержит число объявленных массивов M (1 ≤ M ≤ 1000). В следующих M строках содержатся описания массивов в формате «type name[number1] ... [numberk];», где type – один из примитивных типов, описанных выше, name – имя массива, состоящее из маленьких английских букв, длиной не более 30 символов, 1 ≤ numberi ≤ 1000. Размерность массива не превышает 50.\nВыходные данные\nВ выходной файл OUTPUT.TXT выведите в M строках информацию об объеме памяти в байтах, занимаемым каждым из массивов, согласно последовательности, определенной во входных данных.",
    "complexity": 47,
    "memory": 16000,
    "time": 1000,
    "examples": [
      {
        "input": "4\n\nbyte 1\n\nshort 2\n\nint 4\n\nlong 8\n\n4\n\nbyte a[1];\n\nshort b[2][2][2];\n\nint c[100][100];\n\nlong a[177];",
        "output": "25\n\n184\n\n42424\n\n1440"
      }
    ]
  },
  {
    "id": 984,
    "name": "Финал ACM ICPC",
    "description": "Ежегодно в Санкт-Петербурге, Барнауле и некоторых городах ближнего зарубежья проходят соревнования по программированию. Эти соревнования проходят в рамках студенческого чемпионата мира по программированию, организованного одной из самых авторитетных ассоциаций ACM (Association for Computing Machinery). На этих соревнованиях проходит отбор команд с Северо-Восточного Европейского Региона NEERC (North-Eastern European Regional Contest).\nOUTPUT.TXTFantasy University #1\nCrazy University #1\nFantasy University #2\nVery Good U #2\nGood U #1[Лучшие попытки]\nЕжегодно перед организаторами соревнований встает проблема определения команд, которые будут приглашены к участию в финале чемпионата мира по программированию. По новым правилам в финал проходят не более N команд, представляющих NEERC. Кроме этого, от одного университета не могут проходить более K команд. При этом из всех таких множеств выбирается то, в котором сумма мест, занятых этими командами в полуфинальных соревнованиях минимально возможная.\nВаша задача по итоговому протоколу полуфинальных соревнований и числам N и K определить, какие команды будут приглашены к участию в финале чемпионата мира.\nВходные данные\nВ первой строке входного файла INPUT.TXT находится три натуральных числа: P – количество команд, принявших участие в полуфинале, N и K (N, K ≤ P ≤ 105).\nВ следующих P строках, по одному в строке перечислены названия университетов, команды которых заняли соответствующие места. Название университета содержит строчные и прописные английские буквы и пробелы. Длина названия университета не превышает 30 символов. В следующей строке перечислены номера команд соответствующих университетов. Таким образом, если название университета записано в i-ой строке (2 ≤ i ≤ P+1), то эта команда заняла i-1 место на полуфинале и имеет номер, записанный на i-1 месте в P+2 строке.\nВыходные данные\nВ выходной файл OUTPUT.TXT выведите названия команд, приглашенных к участию в финале чемпионата мира по программированию, упорядоченных по месту, занятому на полуфинале. В качестве названия команды выведите название университета и через пробел «#ID», где ID – номер команды.",
    "complexity": 36,
    "memory": 32000,
    "time": 1000,
    "examples": [
      {
        "input": "9 5 2\n\nFantasy University\n\nCrazy University\n\nFantasy University\n\nFantasy University\n\nVery Good U\n\nGood U\n\nVery Good U\n\nCrazy University\n\nGood U\n\n1 1 2 3 2 1 1 2 2",
        "output": "Fantasy University #1\n\nCrazy University #1\n\nFantasy University #2\n\nVery Good U #2\n\nGood U #1"
      }
    ]
  },
  {
    "id": 972,
    "name": "Задачка по геометрии",
    "description": "Петя учится в третьем классе. Его учитель геометрии часто задает ему сложные домашние задания. На последнем уроке Петя проходил окружности. Он научился рисовать окружность с помощью циркуля. Выполнив большую часть домашнего задания, Петя столкнулся со следующей проблемой: ему дано два отрезка. Требуется провести окружность, которая пересекла бы внутреннюю часть каждого отрезка ровно один раз. При этом окружность должна именно пересекать внутреннюю часть каждого отрезка, не разрешается, чтобы она касалась отрезка или проходила через его конец.\n12OUTPUT.TXT0.5 0 2[Лучшие попытки]\nПомогите Пете доделать его домашнее задание.\n12\nВходные данные21\nВходной файл INPUT.TXT содержит несколько тестовых наборов (не более 2000). Каждый тестовый набор записан на двух строках. Первая строка тестового набора содержит четыре целых числа x11, y11, x12, y12 – координаты концов первого отрезка. Вторая строка содержит четыре целых числа x21, y21, x22, y22 – координаты концов второго отрезка. Входной файл завершается парой строк, каждая из которых содержит по четыре нуля. Эти строки не следует обрабатывать. Координаты не превышают 100 по модулю.\n21\n22Выходные данные\n22\nВ выходной файл OUTPUT.TXT для каждого тестового набора выведите три вещественных числа – координаты центра и радиус окружности. Все числа в выходном файле не должны по модулю превышать 1010. Жюри выполняет все сравнения вещественных чисел с точностью 10−4.",
    "complexity": 66,
    "memory": 16000,
    "time": 1000,
    "examples": [
      {
        "input": "0 0 0 4\n\n1 0 1 4\n\n0 0 0 0\n\n0 0 0 0",
        "output": "0.5 0 2"
      }
    ]
  },
  {
    "id": 986,
    "name": "Прыгучее путешествие",
    "description": "",
    "complexity": 24,
    "memory": 16000,
    "time": 1000,
    "examples": [
      {
        "input": "3 0 0 1\n\n2 0\n\n1 1\n\n0 1",
        "output": "3"
      },
      {
        "input": "2 0 0 100\n\n1 1\n\n2 2",
        "output": "1"
      },
      {
        "input": "3 0 0 1\n\n1 1\n\n2 2\n\n3 3",
        "output": "Yes"
      }
    ]
  },
  {
    "id": 971,
    "name": "Треугольник - 4",
    "description": "",
    "complexity": 28,
    "memory": 16000,
    "time": 1000,
    "examples": [
      {
        "input": "9 4",
        "output": "YES\n3 9\n6 3\n18 0"
      }
    ]
  },
  {
    "id": 961,
    "name": "Все, что движется",
    "description": "Дано поле N×M и объекты на нем в моменты времени T и T+1. Каждый объект представлен одной английской буквой и в любой момент времени может занимать ровно одну клетку поля. \nOUTPUT.TXT1A23 3\nx.O\n.X.\n.o.\n\nx.O\n.X.\n.o.00[Лучшие попытки]\nОбъект движется, если в два последовательных момента времени его положения различаются.\nНайдите все, что движется.\nВходные данные\nВ первой строке входного файла INPUT.TXT записаны два целых числа N и M (1 ≤ N, M ≤ 100). В следующих N строках по M символов – поле в момент времени T. Каждый символ либо является точкой «.», и это означает, что в этом месте поля ничего нет, либо английская буква, обозначающая то, что в этом месте находится объект. Никакие два различных объекта не обозначены одним и тем же символом.\nДалее идет пустая строка.\nВ следующих N строках находится описание того же поля в момент времени T+1 в том же формате. Множество объектов, находящихся на поле в момент времени T, равно множеству объектов в момент времени T + 1.\nВыходные данные\nВ первой строке выходного файла OUTPUT.TXT выведите количество движущихся объектов. Во второй строке выведите символы, соответствующие движущимся объектам, в алфавитном порядке, причем сначала выведите все маленькие английские буквы, затем все большие. Пробелы между символами выводить не следует.",
    "complexity": 28,
    "memory": 16000,
    "time": 1000,
    "examples": [
      {
        "input": "2 2\n\n.A\n\n..\n\n\n\nA.\n\n..",
        "output": "1\nA"
      },
      {
        "input": "3 3\n\nx.O\n\n.X.\n\n.o.\n\n\n\nx.O\n\n.X.\n\n.o.",
        "output": "0"
      }
    ]
  },
  {
    "id": 974,
    "name": "Странный ним",
    "description": "Алиса и Боб играют в игру, которую они называют «странный ним». На столе расположены три кучки камней, содержащие a, b и c камней, соответственно. Алиса ходит первой.\nвзять 3 камня из второй кучки;OUTPUT.TXTAlice wins the game.Bob wins the game.[Лучшие попытки]\nТот игрок, который делает ход, выбирает одну из кучек и берет из нее несколько камней. При этом должно выполняться следующее условие: после хода каждого игрока на столе не должно быть двух кучек, содержащих равное количество камней. Забирать все камни из кучки разрешается. Тот, кто берет последний камень, выигрывает.\nвзять 1 камень из третьей кучки;\nПусть, например, кучки содержат 1, 3 и 5 камней, тогда разрешены следующие ходы:\nвзять 3 камня из третьей кучки;\nвзять 1 камень из первой кучки;\nвзять 1 камень из второй кучки;\nвзять 3 камня из второй кучки;\nвзять 1 камень из третьей кучки;\nвзять 3 камня из третьей кучки;\nвзять 5 камней из третьей кучки.\nвзять 5 камней из третьей кучки.\nПо заданным a, b и c, определите, кто выиграет, если оба игрока играют оптимально.\nВходные данные\nВходной файл INPUT.TXT содержит несколько тестовых примеров (не более 1000). Каждый тестовый пример состоит из трех целых чисел a, b и c, расположенных на одной строке (1 ≤ a, b, c ≤ 109, a ≠ b, a ≠ c, b ≠ c). Последняя строка входного файла содержит три нуля, ее обрабатывать не требуется.\nВыходные данные\nВ выходной файл OUTPUT.TXT для каждого тестового примера выведите, кто выиграет в игре, если оба игрока играют оптимально.",
    "complexity": 65,
    "memory": 16000,
    "time": 1000,
    "examples": [
      {
        "input": "1 2 3\n1 3 5\n0 0 0",
        "output": "Alice wins the game.\nBob wins the game."
      }
    ]
  },
  {
    "id": 810,
    "name": "Число - 2",
    "description": "По заданным числам a, b, c и d, найдите наименьшее натуральное число n, большее a∙c, которое нельзя представить в виде произведения двух натуральных чисел u и v, таких, что a ≤ u ≤ b и c ≤ v ≤ d.\nOUTPUT.TXT321 2 3 577[Лучшие попытки]\nВходные данные\nВходной файл INPUT.TXT содержит одну строку, состоящую из натуральных чисел a, b, c, d (1 ≤ a ≤ b ≤ 106, 1 ≤ c ≤ d ≤ 106).\nВыходные данные\nВ выходной файл OUTPUT.TXT выведите искомое число n.",
    "complexity": 58,
    "memory": 16000,
    "time": 1000,
    "examples": [
      {
        "input": "1 2 1 2",
        "output": "3"
      },
      {
        "input": "1 2 3 5",
        "output": "7"
      }
    ]
  },
  {
    "id": 973,
    "name": "Главные дороги",
    "description": "Город, в котором живет Гоша, имеет N перекрестков, некоторые из которых соединены дорогами. По каждой дороге разрешено движение в обоих направлениях. Каждый день Гоша ездит на машине из дома на работу и обратно. Но дороги в городе, где живет Гоша, не очень хорошие, они часто портятся, и приходится их ремонтировать. Гоша заметил, что когда некоторые дороги закрывают на ремонт, часто он все равно может доехать из дома до работы за то же время, что в случае, когда ни одна дорога на ремонт не закрыта. С другой стороны, встречаются дороги такие, что когда они закрываются на ремонт, то время, которое требуется Гоше, чтобы добраться от дома до работы, увеличивается. А иногда Гоша просто не может доехать от дома до работы на машине. Такие дороги Гоша называет главными.\nOUTPUT.TXT25 7[Лучшие попытки]\nПомогите Гоше найти все главные дороги в городе.\nВходные данные\nПервая строка входного файла INPUT.TXT содержит N и M – количество перекрестков и дорог в городе, соответственно (2 ≤ N ≤ 20 000, 1 ≤ M ≤ 100 000). Гоша живет около перекрестка 1, а работает у перекрестка N.\nСледующие M строк содержат информацию о дорогах. Каждая дорога описывается двумя перекрестками, которые она соединяет, и временем, которое необходимо Гоше, чтобы проехать по этой дороге от одного конца до другого. Время проезда по дороге – натуральное число, не превышающее 100 000. Между парой перекрестков может быть несколько дорог, но никакая дорога не соединяет перекресток с самим собой.\nГарантируется, что если все дороги доступны, Гоша может добраться от дома до работы.\nВыходные данные\nВ первой строке выходного файла OUTPUT.TXT выведите K – количество главных дорог. На второй строке выведите K чисел – номера главных дорог. Дороги пронумерованы от 1 до M в том порядке, в котором они заданы во входном файле.",
    "complexity": 82,
    "memory": 32000,
    "time": 1000,
    "examples": [
      {
        "input": "6 7\n\n1 2 1\n\n2 3 1\n\n2 5 3\n\n1 3 2\n\n3 5 1\n\n2 4 1\n\n5 6 2",
        "output": "2\n5 7"
      }
    ]
  },
  {
    "id": 809,
    "name": "Спички детям не игрушка!",
    "description": "Вася любит решать головоломки со спичками. Чаще всего они формулируется следующим образом: дано изображение A, составленное из спичек; переложите в нем минимальное количество спичек так, чтобы получилось изображение B. Например, из римского числа XIV можно получить ромб с диагональю, переложив всего три спички.\n2OUTPUT.TXT3[Лучшие попытки]\n2\nГоловоломки, которые решает Вася, всегда имеют решение. Это значит, что набор спичек, используемый в изображении A, совпадает с набором спичек, используемым в изображении B. Кроме того, в одном изображении никогда не встречаются две спички, у которых есть общий участок ненулевой длины (то есть спички могут пересекаться, но не могут накладываться друг на друга). Вася устал решать головоломки вручную, и теперь он просит вас написать программу, которая будет решать головоломки за него. Программа будет получать описания изображений A и B и должна найти минимальное количество спичек, которые надо переложить в изображении A, чтобы полученная картинка получалась из B параллельным переносом.\n4\nВходные данные\nВ первой строке входного файла INPUT.TXT содержится целое число n – количество спичек в каждом из изображений (1 ≤ n ≤ 1000). В следующих n строках записаны координаты концов спичек на изображении A. Спичка номер i описывается целыми числами x1i, y1i, x2i, y2i координатами ее концов. Следующие n строк содержат описание изображения B в таком же формате. Набор длин этих спичек совпадает с набором длин спичек с изображения A. Все координаты по абсолютной величине не превосходят 104. Все спички имеют ненулевую длину.\nВыходные данные\nВыведите в выходной файл OUTPUT.TXT минимальное количество спичек, которые следует переложить, чтобы изображение A совпало с изображением B, с точностью до параллельного переноса.",
    "complexity": 65,
    "memory": 32000,
    "time": 1000,
    "examples": [
      {
        "input": "5\n\n0 0 1 2\n\n1 0 0 2\n\n2 0 2 2\n\n4 0 3 2\n\n4 0 5 2\n\n9 -1 10 1\n\n10 1 9 3\n\n8 1 10 1\n\n8 1 9 -1\n\n8 1 9 3",
        "output": "3"
      }
    ]
  },
  {
    "id": 811,
    "name": "Шахматная мастерская",
    "description": "Хозяин мастерской по изготовлению шахматных досок гроссмейстер Хосе Раулевич Капабланка был очень зол. «Ну, кто так раскрашивает доски?! Ну скажи мне, Бобби, разве я тебя так учил раскрашивать доски?!» - спрашивал он у своего подмастерья.\nOUTPUT.TXT8\n1 1\n1 3\n2 2\n2 4\n3 1\n3 3\n4 2\n4 423 3\nWBW\nBWB\nWBW00[Лучшие попытки]\nА дело было вот в чем. Недавно его мастерская получила заказ на изготовление нестандартной шахматной доски размером N на M . Саму шахматную доску из дорогой породы дерева он изготовил, а раскрасить ее поля он поручил своему подмастерью и ученику Бобби. Бобби, однако, справился с этой задачей очень плохо. Он раскрасил доску так, что некоторые соседние поля оказались покрашенными в один цвет. А такого на шахматной доске никогда не было, и быть не может!\n[Решение]\nТеперь у Бобби есть всего одна ночь на исправление своей ошибки. Казалось бы, времени много. Но все усложняется тем, что перекрасить поле шахматной доски  достаточно сложная задача, ведь надо аккуратно снять старый слой краски. Поэтому Бобби хочет перекрасить наименьшее возможное число полей. Помогите ему  написать программу, которая найдет: какие поля доски ему надо перекрасить.\nЕдинственным требованием к шахматной доске, которая должна получиться в результате, является то, что любые два соседних поля покрашены в разные цвета. Ну, и, конечно, любое поле должно быть либо белым, либо черным.\nСоседними полями на шахматной доске Хосе Раулевич считает поля, имеющие общую сторону.\nВходные данные\nПервая строка входного файла INPUT.TXT содержит два целых числа: N и M (1 ≤ N, M ≤ 100). Далее идут N строк по M символов в каждой. j-ый символ i-ой из этих строк равен W, если Бобби покрасил соответствующее (т.е. находящееся на пересечении i-ой горизонтали и j-ой вертикали) поле в белый цвет, и B, если в черный.\nВыходные данные\nВ первой строке выходного файла OUTPUT.TXT выведите минимальное количество k полей, которые должен перекрасить Бобби.\nДалее выведите k строк, описывающих поля, которые он должен перекрасить. Описание каждого поля должно состоять из двух чисел: i и j (1 ≤ i ≤ N, 1 ≤ j ≤ M), задающих горизонталь и вертикаль, на пересечении которых находится данное поле.\nНи одно поле не должно быть указано в этом списке дважды. Может оказаться так, что k = 0, и Хосе Раулевич зря кричал на Бобби. Впрочем, это объясняется тем, что гроссмейстер уже весьма стар и его зрение далеко не идеально.",
    "complexity": 30,
    "memory": 16000,
    "time": 1000,
    "examples": [
      {
        "input": "4 4\n\nBBBB\n\nBBBB\n\nBBBB\n\nBBBB",
        "output": "8\n\n1 1\n\n1 3\n\n2 2\n\n2 4\n\n3 1\n\n3 3\n\n4 2\n\n4 4"
      },
      {
        "input": "3 3\n\nWBW\n\nBWB\n\nWBW",
        "output": "0"
      }
    ]
  },
  {
    "id": 988,
    "name": "Последовательность чисел",
    "description": "Рассмотрим рекуррентно заданную последовательность чисел Si:\ni−1iOUTPUT.TXT1No solution12[Лучшие попытки]\nS1 = 1\nSi = Si−1, i, Si−1 для i ≥ 2.\ni\nВаша задача написать программу, которая будет находить число, стоящее на k-ой позиции в последовательности Sp.\ni\nВходные данные63\nВ первой строке входного файла INPUT.TXT записано число тестов T, (1 ≤ T ≤ 103). В следующих T строках записаны пары чисел ki, pi, (1 ≤ ki, pi ≤ 263−1, 1 ≤ i ≤ T ).\nВыходные данные\nВ выходной файл OUTPUT.TXT выведите для каждого теста значение ki-го элемента последовательности Spi, если такого элемента нет, выведите «No solution» без кавычек.",
    "complexity": 42,
    "memory": 16000,
    "time": 1000,
    "examples": [
      {
        "input": "4\n1 1\n2 1\n1 2\n2 2",
        "output": "1\nNo solution\n1\n2"
      }
    ]
  },
  {
    "id": 990,
    "name": "Пирожные",
    "description": "Санта Клаус планирует принести подарки на новый год n ребятам. У него есть m пирожных, и он собирается подарить каждому ребенку несколько пирожных. Однако неожиданно возникла проблема. Детям не нравится, когда кому-то достается больше пирожных, чем ему.\ninOUTPUT.TXT22 9 924 92 1 5 872 1 3 372 1 3 3[Лучшие попытки]\nКаждый ребенок характеризуется своей жадностью, жадность i-го ребенка равна gi. Если ai ребят получат больше пирожных чем i-й, то его неудовлетворенность будет равна gi∙ai.\nii\nТеперь у Санты проблема:  надо поделить пирожные между ребятами так, чтобы суммарная неудовлетворенность была минимальна. Каждый ребенок должен получить хотя бы одно пирожное. Санта собирается раздать все m пирожных. Помогите ему распределить их между ребятами!\n7\nВходные данные\nПервая строка входного файла INPUT.TXT содержит числа n и m (1 ≤ n ≤ 30, n ≤ m ≤ 5000). Вторая строка содержит n целых чисел g1, g2, ..., gn (1 ≤ gi ≤ 107).\nВыходные данные\nНа первой строке выходного файла OUTPUT.TXT выведите минимально возможную суммарную неудовлетворенность. Вторая строка должна содержать n целых чисел:  сколько пирожных следует дать каждому ребенку. Если решений несколько, то выведите любое.",
    "complexity": 76,
    "memory": 16000,
    "time": 1000,
    "examples": [
      {
        "input": "3 20\n1 2 3",
        "output": "2\n2 9 9"
      },
      {
        "input": "4 9\n2 1 5 8",
        "output": "7\n2 1 3 3"
      }
    ]
  },
  {
    "id": 812,
    "name": "Сжатие последовательности",
    "description": "Семен изобрел новый способ сжатия данных. Правда, он пока умеет сжимать только последовательность из N единиц. Метод сжатия основывается на представлении последовательности из N единиц в виде последовательности из чисел от 1 до A, так, чтобы суммы членов обеих последовательностей совпадали (т.е. были равны N). Например, последовательность 1, 1, 1, 1, 1, при A = 3 может быть преобразована в последовательность 1, 2, 1, 1 или 2, 3 или другие последовательности.\nOUTPUT.TXT124 255[Лучшие попытки]\nВаша задача – посчитать количество способов сжать заданную последовательность.\nВходные данные\nВ единственной строке входного файла INPUT.TXT записано два числа N и A (1 ≤ A ≤ N ≤ 1000).\nВыходные данные\nВ выходной файл OUTPUT.TXT выведите одно целое число без лидирующих нулей - ответ на задачу.",
    "complexity": 69,
    "memory": 16000,
    "time": 1000,
    "examples": [
      {
        "input": "2 1",
        "output": "1"
      },
      {
        "input": "4 2",
        "output": "5"
      }
    ]
  },
  {
    "id": 993,
    "name": "Симпатичные последовательности",
    "description": "",
    "complexity": 61,
    "memory": 16000,
    "time": 1000,
    "examples": [
      {
        "input": "10 1\n0 1 1 0 2 2 1 2 2 3",
        "output": "8"
      },
      {
        "input": "2 0\n1 0",
        "output": "0"
      }
    ]
  },
  {
    "id": 970,
    "name": "От перестановки что-то меняется ...",
    "description": "",
    "complexity": 9,
    "memory": 16000,
    "time": 1000,
    "examples": [
      {
        "input": "3 5 2",
        "output": "YES"
      },
      {
        "input": "2 2 5",
        "output": "NO"
      },
      {
        "input": "2 2 4",
        "output": "YES"
      }
    ]
  },
  {
    "id": 989,
    "name": "Окопы",
    "description": "Однажды Андрей и Петя решили пострелять друг в друга из пистолетов. Нет, конечно, не из настоящих, а из игрушечных. Для того, чтобы игра стала еще более интересной, каждый из них вырыл себе окоп. Окоп представляет собой отрезок, соединяющий две точки. Известно, что окопы Андрея и Пети не пересекаются, более того, они вообще не имеют общих точек.\n2OUTPUT.TXT1 -1 01 1 0[Лучшие попытки]\nТеперь им предстоит выбрать «линию фронта», такую прямую, которую в процессе игры пересекать запрещается. Только вот проблема – окопы уже вырыты, а ребята не могут сообразить, как им провести линию, так чтобы окопы оказались по разные стороны от нее и не имели общих точек с ней. Так как рытье окопов дело трудоемкое, то они попросили помощи у Вас.\n2\nВходные данные4\nВходной файл INPUT.TXT содержит не более 1000 тестов. Каждый тест описывается двумя строками. Первая строка теста содержит 4 целых числа x1, y1, x2, y2 – координаты концов отрезка, задающего первый окоп. Вторая строка теста в аналогичном формате описывает второй окоп. Входной файл заканчивается двумя строчками, каждая из которых содержит 4 нуля. Тесты разделены пустой строкой. Все координаты не превышают 104 по абсолютной величине.\nВыходные данные\nВ выходной файл OUTPUT.TXT выведите числа a, b, c – коэффициенты уравнения прямой ax + by + c = 0, разделяющей окопы. Числа a, b, c должны быть целыми и не должны превышать 109 по абсолютной величине.",
    "complexity": 64,
    "memory": 16000,
    "time": 1000,
    "examples": [
      {
        "input": "0 1 1 2\n\n0 -1 1 0\n\n\n\n0 1 -1 2\n\n0 -1 -1 0\n\n\n\n0 0 0 0\n\n0 0 0 0",
        "output": "1 -1 0\n1 1 0"
      }
    ]
  },
  {
    "id": 969,
    "name": "Сверхстепень",
    "description": "Назовем значение выражения 22n n-ой сверхстепенью числа 2. Таким образом, например, третья сверхстепень числа 2 равна 223 = 28 = 256. \n8OUTPUT.TXT256210 1066[Лучшие попытки]\nВаша задача –  вычислить n-ую сверхстепень двойки по модулю m.\nВходные данные\nВходной файл INPUT.TXT содержит два целых числа: n (0 ≤ n ≤ 105) и m (2 ≤ m ≤ 104).\nВыходные данные\nВ выходной файл OUTPUT.TXT выведите ответ на задачу.",
    "complexity": 30,
    "memory": 16000,
    "time": 1000,
    "examples": [
      {
        "input": "3 1000",
        "output": "256"
      },
      {
        "input": "10 10",
        "output": "6"
      }
    ]
  },
  {
    "id": 848,
    "name": "Заклинание Ауэрса",
    "description": "Заклинание Ауэрса представляет собой набор звуков, записываемых малыми буквами английского алфавита без пробелов. Сам по себе этот набор не обладает ни секретностью, ни магической силой и приведен во всех учебниках по белой магии в соответствующем разделе. Там же указан способ его применения: \nOUTPUT.TXT4bao\nbab2aaaaa1aaaaa1aaaaa3rarabar[Лучшие попытки]\nа) разбить набор букв на палиндромы, то есть непустые слова, которые читаются одинаково как справа налево, так и слева направо; \n3rarabar3rarabar\nб) произносить их по порядку, после каждого, взмахивая умклайдетом (в крайнем случае, щелкая пальцами);\nв) магическая сила заклинания обратно пропорциональна числу палиндромов, на которые разбит набор букв.\nДаже домовые знают, что это заклинание можно разбить на отдельные буквы и очень забавно наблюдать, как они, щелкая пальцами и выкрикивая отдельные звуки заклинания, выводят клопов. Однако истинную мощь заклинание обретает только тогда, когда оно разбито на наименьшее возможное число палиндромов. Знание этого разбиения доступно только самым великим магам, например Кристобалю Хозевичу Хунте.\nЖелая поднять свою квалификацию мага, Александр Привалов решил использовать современные средства для нахождения кратчайшего разбиения заклинания Ауэрса на палиндромы. Уже неделю он бьется над составлением переборной программы для своего Алдана, но пока все без толку. У него уже начала расти шерсть на ушах, помогите ему.\nВходные данные\nВ единственной строке файла INPUT.TXT содержится непустой исходный набор, состоящий из маленьких букв английского алфавита без пробелов (количество символов в наборе не больше 70).\nВыходные данные\nВ первой строке выходного файла OUTPUT.TXT необходимо указать наименьшее число k палиндромов, на которые разбивается набор. Эти k палиндромов нужно привести в следующих k строках в том порядке, в котором они входят в исходный набор и должны произноситься при использовании заклинания. Если имеется несколько минимальных разбиений, достаточно вывести любое из них.",
    "complexity": 51,
    "memory": 16000,
    "time": 1000,
    "examples": [
      {
        "input": "baobab",
        "output": "4\nb\na\no\n\nbab"
      },
      {
        "input": "aaaaa",
        "output": "1\naaaaa"
      },
      {
        "input": "rarabar",
        "output": "3\nrar\naba\nr"
      }
    ]
  },
  {
    "id": 852,
    "name": "Поврежденный XML",
    "description": "Формат XML является распространенным способом обмена данными между различными программами. Недавно программист Иванов написал небольшую программу, которая сохраняет некоторую важную информацию в виде XML-строки.\nЕсли A — корректная XML-строка, то строка \u003cX\u003eA\u003c/X\u003e, получающаяся приписыванием в начало A открывающегося тега, а в конец — закрывающегося с таким же именем, также является корректной XML-строкой. Здесь X — любая непустая строка из строчных букв английского алфавита.OUTPUT.TXT\u003ca\u003e\u003c/a\u003e2\u003ca\u003e\u003caa\u003e\u003ca\u003e\u003c/a\u003e\u003ca\u003e\u003c/a\u003e\u003ca\u003e\u003c/a\u003e\u003ca\u003e\u003c/a\u003e[Лучшие попытки]\nXML-строка состоит из открывающих и закрывающих тегов. Открывающий тег начинается с открывающей угловой скобки (\u003c), за ней следует имя тега — непустая строка из строчных букв английского алфавита, а затем закрывающая угловая скобка (\u003e). Примеры открывающих тегов: \u003ca\u003e, \u003cdog\u003e.\n3\u003ca\u003e\u003c\u003ea\u003e\u003ca\u003e\u003c/a\u003e\nЗакрывающий тег начинается с открывающей угловой скобки, за ней следует прямой слеш (/), затем имя тега — непустая строка из строчных букв английского алфавита, а затем закрывающая угловая скобка. Примеры закрывающихся тегов: \u003c/a\u003e, \u003c/dog\u003e.\n4\u003ca/\u003c/a\u003e\u003ca\u003e\u003c/a\u003e\nXML-строка называется корректной, если она может быть получена по следующим правилам:\nПустая строка является корректной XML-строкой.\nЕсли A и B — корректные XML-строки, то строка AB, получающаяся приписыванием строки B в конец строки A, также является корректной XML-строкой.\nЕсли A — корректная XML-строка, то строка \u003cX\u003eA\u003c/X\u003e, получающаяся приписыванием в начало A открывающегося тега, а в конец — закрывающегося с таким же именем, также является корректной XML-строкой. Здесь X — любая непустая строка из строчных букв английского алфавита.\nНапример, представленные ниже строки:\n\u003ca\u003e\u003c/a\u003e\n\u003ca\u003e\u003cab\u003e\u003c/ab\u003e\u003cc\u003e\u003c/c\u003e\u003c/a\u003e\n\u003ca\u003e\u003c/a\u003e\u003ca\u003e\u003c/a\u003e\u003ca\u003e\u003c/a\u003e\nявляются корректными XML-строками, а такие строки как:\n\u003ca\u003e\u003c/b\u003e\n\u003ca\u003e\u003cb\u003e\n\u003ca\u003e\u003cb\u003e\u003c/a\u003e\u003c/b\u003e\nне являются корректными XML-строками.\nИванов отправил файл с сохраненной XML-строкой по электронной почте своему коллеге Петрову. Однако, к сожалению, файл повредился в процессе пересылки: ровно один символ в строке заменился на некоторый другой символ.\nТребуется написать программу, которая по строке, которую получил Петров, восстановит исходную XML-строку, которую отправлял Иванов.\nВходные данные\nВходной файл INPUT.TXT содержит одну строку, которая заменой ровно одного символа может быть превращена в корректную XML-строку. Длина строки лежит в пределах от 7 до 1000, включительно. Строка содержит только строчные буквы английского алфавита и символы «\u003c» (ASCII код 60), «\u003e»(ASCII код 62) и «/»(ASCII код 47). Строка во входном файле заканчивается переводом строки.\nВыходные данные\nВ выходной файл OUTPUT.TXT должен содержать корректную XML-строку, которая может быть получена из строки во входном файле заменой ровно одного символа на другой. Если вариантов ответа несколько, можно вывести любой.",
    "complexity": 54,
    "memory": 16000,
    "time": 1000,
    "examples": [
      {
        "input": "\u0026lt;a\u0026gt;\u0026lt;/b\u0026gt;",
        "output": "\u0026lt;a\u0026gt;\u0026lt;/a\u0026gt;"
      },
      {
        "input": "\u0026lt;a\u0026gt;\u0026lt;aa\u0026gt;",
        "output": "\u0026lt;a\u0026gt;\u0026lt;/a\u0026gt;"
      },
      {
        "input": "\u0026lt;a\u0026gt;\u0026lt;\u0026gt;a\u0026gt;",
        "output": "\u0026lt;a\u0026gt;\u0026lt;/a\u0026gt;"
      },
      {
        "input": "\u0026lt;a/\u0026lt;/a\u0026gt;",
        "output": "\u0026lt;a\u0026gt;\u0026lt;/a\u0026gt;"
      }
    ]
  },
  {
    "id": 991,
    "name": "ePig",
    "description": "Андрей и Аня разрабатывают новую P2P сеть для обмена файлами, они назвали свою сеть ePig. В этой задаче вам предлагается смоделировать работу сети при распространении одного большого файла.\nOUTPUT.TXT3 3[Лучшие попытки]\nПусть сетью пользуются\tn клиентов, пронумерованных от 1 до n. Исходно файл целиком доступен на клиенте номер 1. Остальные клиенты хотели бы получить этот файл. Для оптимизации процесса файл разбивается на k идентичных фрагментов, пронумерованных от 1 до k. Передача файла состоит из нескольких раундов. Каждый раунд занимает одну минуту, за время раунда каждый клиент может получить ровно один фрагмент и/или передать ровно один фрагмент. После того как клиент скачивает фрагмент файла, он может раздавать его другим клиентам.\nПеред каждым раундом каждый клиент решает, какой фрагмент он будет запрашивать. Клиент запрашивает фрагмент, который предоставляется наименьшим числом клиентов (разумеется, кроме тех фрагментов, которые у него уже есть). Если таких фрагментов несколько, он выбирает тот, у которого минимальный номер.\nПосле этого клиенты делают запросы на фрагменты. Каждый клиент выбирает другого клиента, у которого он запрашивает выбранный фрагмент. Если несколько клиентов предоставляют необходимый фрагмент, то выбирается клиент, у которого минимальное количество предоставляемых им фрагментов. Если и таких клиентов несколько, выбирается клиент с минимальным номером.\nКаждый клиент рассматривает все запросы, которые к нему поступили, и выбирает один их них. Клиент X удовлетворяет тот из запросов, который приходит от самого ценного клиента. Ценность клиента определяется количеством фрагментов, которые клиент X получал от него ранее. Если имеется несколько клиентов с одинаковой ценностью, то фрагмент отдается тому из клиентов, у которого перед раундом имеется минимальное количество фрагментов. Если и таких клиентов несколько, то фрагмент отдается клиенту с минимальным номером.\nПосле того, как выбрано, какие запросы будут удовлетворены, начинается раунд. Клиенты, запросы которых были отклонены, ничего не скачивают в этот раунд, а остальные клиенты скачивают запрошенные фрагменты. После этого начинается новый раунд, и т. д.\nПо заданным n и k для каждого клиента определите число раундов, которое потребуется, чтобы он получил файл целиком.\nВходные данные\nВходной файл INPUT.TXT содержит два целых числа: n и k (2 ≤ n ≤ 100, 1 ≤ k ≤ 200).\nВыходные данные\nВ выходной файл OUTPUT.TXT выведите для каждого клиента кроме первого одно число – количество раундов перед тем, как он скачает файл целиком.",
    "complexity": 50,
    "memory": 16000,
    "time": 1000,
    "examples": [
      {
        "input": "3 2",
        "output": "3 3"
      }
    ]
  },
  {
    "id": 853,
    "name": "Игра с числами",
    "description": "Сегодня на уроке математики Петя и Вася изучали понятие арифметической прогрессии. Арифметической прогрессией с разностью d называется последовательность чисел a1, a2, …, ak, в которой разность между любыми двумя последовательными числами равна d. Например, последовательность 2, 5, 8, 11 является арифметической прогрессией с разностью 3.\nknnnOUTPUT.TXT13222 400[Лучшие попытки]\nПосле урока Петя и Вася придумали новую игру с числами. Игра проходит следующим образом. \ni\nВ корзине находятся n фишек, на которых написаны различные целые числа \na1, a2, …, an. По ходу игры игроки выкладывают фишки из корзины на стол. Петя и Вася делают ходы по очереди, первым ходит Петя. Ход состоит в том, что игрок берет одну фишку из корзины и выкладывает ее на стол. Игрок может сам решить, какую фишку взять. После этого он должен назвать целое число d ≥ 2 такое, что все числа на выбранных к данному моменту фишках являются членами некоторой арифметической прогрессии с разностью d, не обязательно последовательными. Например, если на столе выложены фишки с числами 2, 8 и 11, то можно назвать число 3, поскольку эти числа являются членами приведенной в начале условия арифметической прогрессии с разностью 3.\n5\nИгрок проигрывает, если он не может сделать ход из-за отсутствия фишек в корзине или из-за того, что добавление любой фишки из корзины на стол приводит к тому, что он не сможет подобрать соответствующее число d.\nНапример, если в корзине имеются числа 2, 3, 5 и 7, то Петя может выиграть. Для этого ему необходимо первым ходом выложить на стол число 3. После первого хода у него много вариантов назвать число d, например он может назвать d = 3. Теперь у Васи два варианта хода.\nВася может вторым ходом выложить фишку с числом 5 и назвать d = 2. Тогда Петя выкладывает фишку с числом 7, называя d = 2. На столе оказываются фишки с числами 3, 5 и 7, а в корзине осталась только фишка с числом 2. Вася не может ее выложить, поскольку после этого он не сможет назвать корректное число d. В этом случае Вася проигрывает.\nВася может вторым ходом выложить фишку с числом 7 и также назвать, например, d = 2. Тогда Петя выкладывает фишку с числом 5, называя также \nd = 2. Вася снова попадает в ситуацию, когда на столе оказываются фишки с числами 3, 5 и 7, а в корзине осталась только фишка с числом 2, и он также проигрывает.\nЗаметим, что любой другой первый ход Пети приводит к его проигрышу. Если он выкладывает число 2, то Вася отвечает числом 7, и Петя не может выложить ни одной фишки. Если Петя выкладывает фишку с числом 5 или 7, то Вася выкладывает фишку с числом 2, и у Пети также нет допустимого хода.\nТребуется написать программу, которая по заданному количеству фишек n и числам на фишках a1, a2, …, an определяет, сможет ли Петя выиграть вне зависимости от действий Васи, и находит все возможные первые ходы Пети, ведущие к выигрышу.\nВходные данные\nПервая строка входного файла INPUT.TXT содержит  целое число (1 ≤ n ≤ 200). Вторая строка содержит n различных целых чисел a1, a2, …, an  (для всех i от 1 до n выполняется неравенство 1 ≤ ai ≤ 105). Соседние числа разделены ровно одним пробелом.\nВыходные данные\nПервая строка выходного файла OUTPUT.TXT должна содержать число k — количество различных первых ходов, которые может сделать Петя, чтобы выиграть. Если Вася может выиграть вне зависимости от действий Пети, строка должна содержать цифру 0.\nВо второй строке должно содержаться k различных целых чисел — все выигрышные числа. Будем называть число выигрышным, если, выложив в качестве первого хода фишку, содержащую это число, Петя может выиграть вне зависимости от действий Васи. Соседние числа в строке должны быть разделены ровно одним пробелом.",
    "complexity": 77,
    "memory": 16000,
    "time": 1000,
    "examples": [
      {
        "input": "4\n2 3 5 7",
        "output": "1\n3"
      },
      {
        "input": "2\n2 4",
        "output": "0"
      }
    ]
  },
  {
    "id": 992,
    "name": "Неприводимые диаграммы Юнга",
    "description": "Диаграммы Юнга используются для того, чтобы изобразить разбиение числа на слагаемые. Разбиение числа n на слагаемые представляет собой сумму вида\t n = m1+ m2+ . . . + mk, где m1≥ m2≥ . . . ≥ mk.\nk2OUTPUT.TXT11 12121010[Лучшие попытки]\n1\nДиаграмма состоит из n квадратиков, организованных в виде k рядов, где k –количество слагаемых в разбиении. Ряд, соответствующий числу mi, содержит mi квадратиков. Все ряды выровнены по левому краю и упорядочены от более длинного к более короткому.\nk\n2\nНапример, диаграмма Юнга, приведенная на рисунке, соответствует разбиению 9 = 5 + 2 + 2.\n1\nk2\nРассмотрим один метод преобразования диаграмм Юнга. Разрешается выбрать любые два соседних квадратика и удалить их. При этом накладывается следующее ограничение: после преобразования оставшийся набор квадратиков должен быть корректной диаграммой Юнга, верхний левый квадратик которой расположен в том же месте, что и у исходной диаграммы (либо должна остаться пустая диаграмма).\nk\nНапример, удалив последние квадратики второго и третьего ряда из приведенной выше диаграммы, мы получаем диаграмму для разбиения 7 = 5 + 1 + 1.\n8\nУдаляя два последних квадратика первого ряда из этой исходной диаграммы, мы получаем диаграмму для разбиения 7 = 3 + 2 + 2.\nИ еще один способ преобразовать эту диаграмму – удалить последний ряд целиком. Диаграмма, которую нельзя преобразовать указанным способом, называется неприводимой. В частности, пустая диаграмма Юнга является неприводимой.\nКаждую диаграмму можно преобразовывать до тех пор, пока она не станет неприводимой. Вообще говоря, может быть несколько способов преобразовать диаграмму к неприводимой. По заданной диаграмме Юнга найдите все неприводимые диаграммы, в которые ее можно преобразовать.\nВходные данные\nПервая строка входного файла INPUT.TXT содержит число\tk – количество рядов в диаграмме (1 ≤ k ≤ 105). Вторая строка содержит k целых чисел: m1, m2, ..., mk. Сумма n = m1+ m2+ . . . + mk не превышает 108.\nВыходные данные\nВ первой строке выходного файла OUTPUT.TXT выведите число p – количество неприводимых диаграмм Юнга, к которым можно преобразовать заданную. Следующие p строк должны описывать эти диаграммы. Каждая строка должна начинаться с числа t – количества рядов в соответствующей диаграмме.\nДалее должно следовать t чисел – количество квадратиков в соответствующих рядах.",
    "complexity": 52,
    "memory": 16000,
    "time": 1000,
    "examples": [
      {
        "input": "3\n5 2 2",
        "output": "1\n1 1"
      },
      {
        "input": "1\n2",
        "output": "1\n0"
      }
    ]
  },
  {
    "id": 855,
    "name": "Праздничный ужин",
    "description": "Рядом с офисом компании, в которой работает программист Джон, открылось новое кафе. Директор компании решил провести там новогодний ужин. \nk2mmkOUTPUT.TXT3 2 2[Лучшие попытки]\nМеню праздничного новогоднего ужина в кафе состоит из k типов блюд. Для каждого типа блюда есть несколько вариантов на выбор. Всего есть a1 вариантов для первого типа блюда, a2 вариантов для второго типа блюда, и так далее, ak вариантов для k-го типа блюда. Всего, таким образом, предлагается a1×a2×…×ak различных заказов праздничного ужина.\n1ki\n2\nВсего на ужине будут присутствовать m сотрудников компании. Каждый сотрудник должен заказать ровно один вариант блюда каждого типа на выбор. Таким образом, ужин каждого сотрудника будет состоять из k блюд. Для того чтобы ужин каждого сотрудника компании был уникален, администратор кафе придумал следующую схему. Сотрудники делают заказ ужина из меню один за другим. Каждый сотрудник выбирает k блюд, по одному варианту каждого типа. После выбора заказа из меню, сотрудник указывает один из типов блюд, и выбранный этим сотрудником вариант блюда этого типа больше не предлагается тем сотрудникам, которые делают заказ после него.\n29\nk\nКаждый сотрудник компании запомнил, сколько возможных заказов ужина ему было предложено. Выяснилось, что директору, который выбирал первым, было предложено на выбор n1 = a1×a2×…×ak заказов. Тому, кто выбирал вторым, досталось лишь n2 \u003c n1 заказов, поскольку один из вариантов одного из типов блюд уже не был доступен, и так далее. Джону, который выбирал последним, был предложен выбор лишь из nm заказов. Джон заинтересовался, а какое количество вариантов каждого типа блюд было на выбор у директора компании.\n1\nm\nТребуется написать программу, которая по заданным числам k, m и n1, n2, …, nm выяснит, какое количество вариантов каждого типа блюд изначально предлагалось на выбор.\nВходные данные\nВходной файл INPUT.TXT содержит два целых числа k и m, разделенных ровно одним пробелом (1 ≤ k ≤ 20, 2 ≤ m ≤ 100). Вторая строка содержит m чисел: n1, n2, …, nm (для всех i от 1 до m выполняется неравенство 1 ≤ ni ≤ 109).\nВыходные данные\nВыходной файл OUTPUT.TXT должен содержать k чисел: a1, a2, …, ak. Если возможных вариантов решения поставленной задачи несколько, требуется вывести любой. Соседние числа должны быть разделены ровно одним пробелом. Гарантируется, что хотя бы одно решение существует.",
    "complexity": 47,
    "memory": 16000,
    "time": 1000,
    "examples": [
      {
        "input": "3 3\n12 8 4",
        "output": "3 2 2"
      }
    ]
  },
  {
    "id": 849,
    "name": "Задача про ферзей",
    "description": "OUTPUT.TXT7 2\n2 6\n3 8\n1 3\n4 1\n6 7\n8 4\n5 522No solutionNo solution[Лучшие попытки]\nТребуется расставить N ферзей на клеточной шахматной доске размером N×N так, чтобы ни один из них не находился под боем другого.\nВходные данные\nВходной файл INPUT.TXT содержит натуральное число N ≤ 106.\nВыходные данные\nВ выходной файл OUTPUT.TXT выведите N пар целых чисел - координаты расстановки ферзей. Если для заданного N такой расстановки не существует, то следует вывести «No solution». Если существует несколько решений, то разрешается вывести любое из них.",
    "complexity": 54,
    "memory": 16000,
    "time": 1000,
    "examples": [
      {
        "input": "8",
        "output": "7 2\n\n2 6\n\n3 8\n\n1 3\n\n4 1\n\n6 7\n\n8 4\n\n5 5"
      },
      {
        "input": "2",
        "output": "No solution"
      }
    ]
  },
  {
    "id": 850,
    "name": "Цапли",
    "description": "Петя и Маша пришли в зоопарк. Больше всего Пете понравились цапли. Он был поражен их способностью спать на одной ноге. В вольере находятся несколько цапель. Некоторые из них стоят на двух ногах, некоторые — на одной. Когда цапля стоит на одной ноге, то другую ее ногу не видно. Петя пересчитал видимые ноги всех цапель, и у него получилось число a. Через несколько минут к вольеру подошла Маша. За это время некоторые цапли могли поменять позу, поэтому Петя предложил ей заново пересчитать видимые ноги цапель. Когда Маша это сделала, у нее получилось число b. Выйдя из зоопарка, Петя с Машей заинтересовались, сколько же всего цапель было в вольере. Вскоре ребята поняли, что однозначно определить это число можно не всегда. Теперь они хотят понять, какое минимальное и какое максимальное количество цапель могло быть в вольере.\nOUTPUT.TXT2 3[Лучшие попытки]\nТребуется написать программу, которая по заданным числам a и b выведет минимальное и максимальное количество цапель, которое могло быть в вольере.\nВходные данные\nВходной файл INPUT.TXT содержит два целых числа a и b, разделенных ровно одним пробелом (1 ≤ a ≤ 109, 1 ≤ b ≤ 109).\nВыходные данные\nВ выходной файл OUTPUT.TXT выведите два целых числа, разделенных пробелом — минимальное и максимальное число цапель, которое могло быть в вольере. Гарантируется, что хотя бы одно количество цапель соответствует условию задачи.",
    "complexity": 15,
    "memory": 16000,
    "time": 1000,
    "examples": [
      {
        "input": "3 4",
        "output": "2 3"
      }
    ]
  },
  {
    "id": 856,
    "name": "Космический кегельбан",
    "description": "xxxcOUTPUT.TXT7[Лучшие попытки]\nНа планете Плюк открылся новый космический кегельбан. Поле для кегельбана представляет собой бесконечную плоскость, на которой расставлены кегли. \nyyy6\nКаждая кегля представляет собой высокий цилиндр с основанием в виде круга радиусом r метров. Все кегли одинаковые. Кегли расставлены по следующим правилам. Кегли образуют n рядов, в первом ряду стоит одна кегля, во втором — две, и так далее. В последнем n-м ряду стоит n кеглей. Введем на плоскости систему координат таким образом, чтобы единица измерения была равна одному километру. Центр единственной кегли в первом ряду находится в точке (0, 0). Центры кеглей во втором ряду находятся в точках (–1, 1) и (1, 1). Таким образом, центры кеглей в i-м ряду находятся в точках с координатами (–(i –1), i – 1), (–(i – 3), i – 1), …, (i – 1, i – 1). \nxc\nИгра происходит следующим образом. Используется шар с радиусом q метров. Игрок выбирает начальное положение центра шара (xc, yc) и вектор направления движения шара (vx, vy). После этого шар помещается в начальную точку и двигается, не останавливаясь, в направлении вектора (vx, vy). Считается, что шар сбил кеглю, если в процессе движения шара имеет место ситуация, когда у шара и кегли есть общая точка. Сбитые кегли не меняют направления движения шара и не сбивают соседние кегли при падении.\ny6\nНа рисунке приведен пример расположения кеглей для r = 500, n = 4 и шара для q = 1000, xc = –2, yc = –2, vx = 1, vy = 1.\n6\nТребуется написать программу, которая по заданным радиусу кегли r, количеству рядов кеглей n, радиусу шара q, его начальному положению (xc, yc) и вектору направления движения (vx, vy) определяет количество кеглей, сбитых шаром.\nc\nВходные данныеc\nПервая строка входного файла INPUT.TXT содержит два целых числа: r и n, разделенных ровно одним пробелом (1 ≤ r ≤ 700, 1 ≤ n ≤ 200 000). Вторая строка входного файла содержит целое число q (1 ≤ q ≤ 109). Третья строка входного файла содержит два целых числа xc и yc, разделенных ровно одним пробелом (–106≤ xc ≤ 106, –106≤ yc, 1000×yc \u003c –(r + q) ). Четвертая строка входного файла содержит два целых числа vx и vy, разделенных ровно одним пробелом (–106≤ vx ≤ 106, 0 \u003c vy ≤ 106).\nx\nyВыходные данные\n6\nВ выходной файл OUTPUT.TXT выведите одно целое число — количество сбитых кеглей.\nxПример\n6\n№INPUT.TXTOUTPUT.TXT\n1500 4\n1000\n-2 -2\n1 17\ny\n6Для отправки решения задачи необходимо зарегистрироваться и авторизоваться!\n[Обсуждение]\n\n  [Все попытки]\n\n  [Лучшие попытки]\nwindow.yaContextCb.push(()=\u003e{\n  Ya.Context.AdvManager.render({\n    renderTo: 'yandex_rtb_R-A-122393-3',\n    blockId: 'R-A-122393-3'\n  })\n})",
    "complexity": 53,
    "memory": 16000,
    "time": 1000,
    "examples": [
      {
        "input": "500 4\n\n1000\n\n-2 -2\n\n1 1",
        "output": "7"
      }
    ]
  },
  {
    "id": 935,
    "name": "Шахматное поле",
    "description": "На стандартной шахматной доске 8х8 заданы координаты двух клеток. Требуется определить: имеют ли данные клетки одинаковый цвет?\n2OUTPUT.TXTYES21 2 7 5NONO[Лучшие попытки]\nВходные данные2\nВходной файл INPUT.TXT содержит целые числа x1, y1, x2, y2, описывающие координаты двух клеток (x1,y1) и (x2,y2). Ограничения: 1 ≤ x1,y1,x2,y2 ≤ 8.\n1\n1Выходные данные\n2\nВ выходной файл OUTPUT.TXT выведите YES, если поля одного цвета, или слово NO в противном случае.\n2Примеры\n1\n№INPUT.TXTOUTPUT.TXT\n11 1 4 4YES\n21 2 7 5NO\n1\n2Для отправки решения задачи необходимо зарегистрироваться и авторизоваться!\n2\n\n  [Обсуждение]\n\n  [Все попытки]\n\n  [Лучшие попытки]\nwindow.yaContextCb.push(()=\u003e{\n  Ya.Context.AdvManager.render({\n    renderTo: 'yandex_rtb_R-A-122393-3',\n    blockId: 'R-A-122393-3'\n  })\n})",
    "complexity": 16,
    "memory": 16000,
    "time": 1000,
    "examples": [
      {
        "input": "1 1 4 4",
        "output": "YES"
      },
      {
        "input": "1 2 7 5",
        "output": "NO"
      }
    ]
  },
  {
    "id": 854,
    "name": "Кондиционер",
    "description": "В офисе, где работает программист Петр, установили кондиционер нового типа. Этот кондиционер отличается особой простотой в управлении. У кондиционера есть всего лишь два управляемых параметра: желаемая температура и режим работы.\n«auto» — автоматический режим. В этом режиме кондиционер может как увеличивать, так и уменьшать температуру в комнате до желаемой.roomOUTPUT.TXT20210 20freeze1010[Лучшие попытки]\nКондиционер может работать в следующих четырех режимах:\n«fan» — вентиляция. В этом режиме кондиционер осуществляет только вентиляцию воздуха и не изменяет температуру в комнате.cond\n«freeze» — охлаждение. В этом режиме кондиционер может только уменьшать температуру. Если температура в комнате и так не больше желаемой, то он выключается.\n«heat» — нагрев. В этом режиме кондиционер может только увеличивать температуру. Если температура в комнате и так не меньше желаемой, то он выключается.\n«auto» — автоматический режим. В этом режиме кондиционер может как увеличивать, так и уменьшать температуру в комнате до желаемой.\n«fan» — вентиляция. В этом режиме кондиционер осуществляет только вентиляцию воздуха и не изменяет температуру в комнате.\nКондиционер достаточно мощный, поэтому при настройке на правильный режим работы он за час доводит температуру в комнате до желаемой.\nТребуется написать программу, которая по заданной температуре в комнате troom, установленным на кондиционере желаемой температуре tcond и режиму работы определяет температуру, которая установится в комнате через час.\nВходные данные\nПервая строка входного файла INPUT.TXT содержит два целых числа troom и tcond, разделенных ровно одним пробелом (–50 ≤ troom ≤ 50, –50 ≤ tcond ≤ 50).\nВторая строка содержит одно слово, записанное строчными буквами английского алфавита — режим работы кондиционера, как указано выше.\nВыходные данные\nВыходной файл OUTPUT.TXT должен содержать одно целое число — температуру, которая установится в комнате через час.",
    "complexity": 12,
    "memory": 16000,
    "time": 1000,
    "examples": [
      {
        "input": "10 20\nheat",
        "output": "20"
      },
      {
        "input": "10 20\nfreeze",
        "output": "10"
      }
    ]
  },
  {
    "id": 851,
    "name": "Круглый стол",
    "description": "Возрождая древние традиции английских рыцарей, в одном городе члены школьного клуба любителей информатики каждую неделю собираются за круглым столом и обсуждают результаты последних соревнований.\nOUTPUT.TXTBGG22 2BGBGBGBG[Лучшие попытки]\nРуководитель клуба Иван Петрович недавно заметил, что не все ребята активно участвуют в обсуждении. Понаблюдав за несколькими заседаниями клуба, он заметил, что активность члена клуба зависит от того, кто с кем сидит рядом.\nВ клуб приходят на занятия m мальчиков и n девочек. Иван Петрович заметил, что мальчик активно участвует в обсуждении только тогда, когда непосредственно рядом с ним с обеих сторон от него сидят девочки, а девочка активно участвует в обсуждении только тогда, когда непосредственно рядом с ней с одной стороны от нее сидит мальчик, а с другой — девочка.\nЖелая сделать заседание клуба как можно более интересным, Иван Петрович решил разместить участников за круглым столом таким образом, чтобы как можно больше членов клуба приняло активное участие в обсуждении.\nТребуется написать программу, которая по заданным числам m и n выведет такой способ размещения m мальчиков и n девочек за круглым столом, при котором максимальное количество членов клуба будет активно участвовать в обсуждении.\nВходные данные\nВходной файл INPUT.TXT содержит два целых числа m и n, разделенных ровно одним пробелом (0 ≤ m ≤ 1000, 0 ≤ n ≤ 1000, m + n ≥ 3).\nВыходные данные\nВ выходной файл OUTPUT.TXT выведите строку с расположенными в некотором порядке m символами «B» (заглавная английская буква) и n символами «G» (заглавная английская буква). Символ «B» означает мальчика, а символ «G» — девочку.\nСимволы следует расположить в том порядке, в котором нужно разместить членов клуба вокруг стола. Соседние символы соответствуют членам клуба, которые сидят рядом. Рядом сидят также члены клуба, соответствующие первому и последнему символу выведенной строки.",
    "complexity": 29,
    "memory": 16000,
    "time": 1000,
    "examples": [
      {
        "input": "1 2",
        "output": "BGG"
      },
      {
        "input": "2 2",
        "output": "BGBG"
      }
    ]
  },
  {
    "id": 940,
    "name": "Орфография",
    "description": "У студента-филолога Васи есть замечательный друг Петя. И Петя никак не может выучить английский язык. Английский текст Петя еще кое-как читает, но пишет с ужасными ошибками, причем чаще всего он вставляет в слова лишние буквы. \nOUTPUT.TXTMISSPELL22       ABCACAC[Лучшие попытки]\nВася решил помочь Пете. Теперь каждый день Вася диктует Пете слова, а Петя их записывает. После семестра занятий Петя стал писать много лучше и теперь делает в словах только по одной ошибке. Чтобы автоматизировать процесс исправления ошибок, Вася просит Вас написать программу, которая удаляет из слова одну лишнюю букву и показывает Пете правильное слово.\nВходные данные\nВходной файл INPUT.TXT содержит целое число K - номер лишней буквы, а затем через один или несколько пробелов записано слово S, состоящее из английских букв верхнего регистра. Гарантируется, что номер буквы от единицы до длины слова включительно. Длина слова не более 80 символов.\nВыходные данные\nВ выходной файл OUTPUT.TXT выведите исправленное слово.",
    "complexity": 13,
    "memory": 16000,
    "time": 1000,
    "examples": [
      {
        "input": "4 MISTSPELL",
        "output": "MISSPELL"
      },
      {
        "input": "2       ABC",
        "output": "AC"
      }
    ]
  },
  {
    "id": 936,
    "name": "Алтайский технический университет",
    "description": "Как известно, в Барнауле на протяжении многих лет проводятся олимпиады по программированию. Там бывали многие студенты и школьники из нашего города. Наверняка, все запомнили здание Алтайского технического университета и памятник Ползунову на площади перед ним.\nOUTPUT.TXT32350 200 2\n5\n350 202\n350 199\n350 198\n348 200\n352 20044[Лучшие попытки]\nПлощадь перед университетом имеет форму круга с памятником Ползунову в центре. По ночам памятнику скучно, и он наблюдает окружающий мир, поворачиваясь вокруг своей оси, но, не сходя со своего пьедестала. К сожалению, растущие вокруг деревья затрудняют памятнику обзор, поэтому он видит хорошо на расстоянии, не превышающем радиус площади - R. А поскольку глаз на затылке у памятника нет, он может наблюдать только за теми событиями, которые расположены в полукруге радиуса R. Точки на границе полукруга памятник видит тоже хорошо.\nПонятно, что памятник хочет наблюдать как можно больше людей на площади. Ваша задача – написать программу, определяющую максимальное количество людей, которые может наблюдать памятник.\nВходные данные\nПервая строка входного файла INPUT.TXT содержит три числа: X,Y – целые координаты памятника и R – вещественный радиус площади (R\u003e0). Во второй строке указано целое число N – количество людей на площади (1 ≤ N ≤ 150). Далее в N строках перечислены координаты точек (xi,yi), в которых находятся люди. Все координаты являются целыми числами, не превышающими по модулю 1000.\nВыходные данные\nВ выходной файл OUTPUT.TXT выведите одно целое число – максимальное количество людей, которые может наблюдать памятник.",
    "complexity": 41,
    "memory": 16000,
    "time": 1000,
    "examples": [
      {
        "input": "25 25 3.5\n\n7\n\n25 28\n\n23 27\n\n27 27\n\n24 23\n\n26 23\n\n24 29\n\n26 29",
        "output": "3"
      },
      {
        "input": "350 200 2\n\n5\n\n350 202\n\n350 199\n\n350 198\n\n348 200\n\n352 200",
        "output": "4"
      }
    ]
  },
  {
    "id": 813,
    "name": "Игра в 24",
    "description": "«Игра в 24» - это математическая игра, в которой используются специальные карточки. На каждой карточке записаны четыре числа. Задача игроков состоит в том, чтобы получить число 24, используя эти числа и арифметические операции (сложение, вычитание, умножение и деление, скобки при этом можно расставить произвольным образом). «Игра в 24» используется в некоторых школах при изучении математики в начальных классах.\nOUTPUT.TXTYES21 1 1 1NONO[Лучшие попытки]\nВ этой задаче рассматривается упрощенный вариант этой игры, в котором в число разрешенных операций входят только сложение, вычитание и умножение.\nНазовем карточку для упрощенной «Игры в 24» правильной, если из указанных на ней чисел с помощью сложения, вычитания, умножения и расстановки скобок произвольным образом можно получить число 24.\nФирма American Card Manufacturer (ACM) занимается выпуском наборов карточек для этой игры. Однако, выпуск таких карточек сопряжен с некоторыми трудностями. Одна из них состоит в том, что не любой набор из четырех чисел задает «правильную» карточку.\nПо этой причине задача проверки «правильности» данной карточки является весьма актуальной. Ваша задача состоит в написании программы, которая будет осуществлять указанную проверку.\nВходные данные\nВходной файл INPUT.TXT содержит четыре натуральных числа, не превосходящих 30, которые написаны на исследуемой карточке.\nВыходные данные\nВ выходной файл OUTPUT.TXT выведите слово YES, если карточка является правильной, и слово NO в противном случае.",
    "complexity": 62,
    "memory": 16000,
    "time": 1000,
    "examples": [
      {
        "input": "1 2 3 4",
        "output": "YES"
      },
      {
        "input": "1 1 1 1",
        "output": "NO"
      }
    ]
  },
  {
    "id": 814,
    "name": "Гипотеза Гольдбаха - 2",
    "description": "Гипотеза Гольдбаха гласит, что любое четное число большее двух представимо в виде суммы двух простых чисел. Она является одной из самых старых нерешенных задач математики. На март 2004 года, гипотеза Гольдбаха проверена для всех четных чисел, больших 2 и не превышающих 1017.\nOUTPUT.TXT1210210=3+7=5+520[Лучшие попытки]\nВаша задача будет несколько более общей. Задано число x. Необходимо найти число способов представить его в виде суммы ровно двух простых чисел (представления, отличающиеся порядком слагаемых, следует считать одинаковыми).\nПояснение4=2+210=3+7=5+5311011 непредставимо11 непредставимо[Решение]\nНапомним, что простым называется натуральное число, большее единицы и делящееся только на единицу и на само себя.\nВходные данные\nВходной файл INPUT.TXT содержит натуральное число x (x ≤ 10000).\nВыходные данные\nВ выходной файл OUTPUT.TXT выведите ответ на задачу.",
    "complexity": 32,
    "memory": 16000,
    "time": 1000,
    "examples": [
      {
        "input": "4",
        "output": "1"
      },
      {
        "input": "10",
        "output": "2"
      },
      {
        "input": "11",
        "output": "0"
      }
    ]
  },
  {
    "id": 965,
    "name": "Мафия в городе",
    "description": "Об этом еще никто не знает, но многие догадываются – мафия уже в городе. Поговаривают, что в планах главы мафиозного клана захват контроля над всем городом, однако поначалу он решил ограничиться захватом основных линий связи города.\nOUTPUT.TXT2 31 225 4\n1 2\n1 3\n1 4\n1 51 111 11[Лучшие попытки]\nВ городе находятся n базовых телефонных станций, некоторые пары которых соединены двусторонними каналами связи. Для удобства, занумеруем базовые станции целыми числами от 1 до n, канал связи в этом случае задается парой чисел (u, v) –  номерами станций, которые он соединяет.\nБудем говорить, что канал связи (u, v) – контролируется мафией, если захвачена, либо станция u, либо станция v (либо обе).\nГлава мафиозного клана хочет контролировать все каналы связи, захватив при этом как можно меньше базовых станций. Ваша задача  помочь службе безопасности телефонной компании, составив возможный план захвата и определив количество таких планов.\nВходные данные\nПервая строка входного файла  INPUT.TXT содержит два целых числа: n и m \n(2 ≤ n ≤ 18, 0 ≤ m). Каждая из последующих m строк описывает один канал связи и содержит по два целых числа: u и v (1 ≤ u, v ≤ n, u ≠ v) – номера базовых станций, соединенных этим каналом связи. Любая пара станций соединена не более, чем одним каналом.\nВыходные данные\nВ первой строке выходного файла OUTPUT.TXT выведите два числа: k и c – соответственно, минимальное количество базовых станций, которые необходимо захватить для того, чтобы контролировать все каналы связи, и число способов захватить такое количество станций так, чтобы контролировать все каналы связи.\nВо второй строке выведите k чисел – номера базовых станций, соответствующих одному из способов захвата.",
    "complexity": 47,
    "memory": 16000,
    "time": 1000,
    "examples": [
      {
        "input": "3 3\n\n1 2\n\n2 3\n\n3 1",
        "output": "2 3\n1 2"
      },
      {
        "input": "5 4\n\n1 2\n\n1 3\n\n1 4\n\n1 5",
        "output": "1 1\n1"
      }
    ]
  },
  {
    "id": 966,
    "name": "Трубы",
    "description": "Для поддержания температуры и чистоты воды в бассейн постоянно наливают новую воду и выливают старую. Иногда это происходит одновременно. Сотрудники бассейна составили план налива/слива воды. В плане перечислены напор слива/налива воды и интервал времени, в которое он будет происходить. Вода может выливаться (а также наливаться) одновременно из нескольких труб. Необходимо узнать объем воды в бассейне через заданное время T . Стоит заметить, что вода не может выливаться из пустого бассейна.\niOUTPUT.TXT1023\n0 10 1\n5 10 1\n10 15 -11015155[Лучшие попытки]\nВходные данныеi33\n0 10 -10\n5 10 1\n10 15 1155\nВ первой строке входного файла INPUT.TXT записано целое число N – количество записей в плане (1 ≤ N\t≤ 1000). Далее следует N строк, содержащих по три целых числа li, ri и vi – начало работы трубы, конец работы трубы и напор, с которой вода поступает в бассейн (объем воды, поступающий в бассейн за единицу времени). Если напор отрицателен, то вода вытекает из бассейна (0 ≤ li, ri, |vi| ≤ 1000, li ≤ ri). В последней строке записано целое число T – время, через которое необходимо определить объем воды в бассейне (0 ≤ T ≤ 10000).\ni\niВыходные данные\ni\nВ выходной файл OUTPUT.TXT выведите ответ на задачу – объем воды в бассейне через время T, если изначально бассейн пуст.\niПримеры\n№INPUT.TXTOUTPUT.TXT\n13\n0 10 1\n5 10 1\n10 15 -110010\n23\n0 10 1\n5 10 1\n10 15 -11015\n33\n0 10 -10\n5 10 1\n10 15 1155\nДля отправки решения задачи необходимо зарегистрироваться и авторизоваться!\n[Обсуждение]\n\n  [Все попытки]\n\n  [Лучшие попытки]\nwindow.yaContextCb.push(()=\u003e{\n  Ya.Context.AdvManager.render({\n    renderTo: 'yandex_rtb_R-A-122393-3',\n    blockId: 'R-A-122393-3'\n  })\n})",
    "complexity": 29,
    "memory": 16000,
    "time": 1000,
    "examples": [
      {
        "input": "3\n\n0 10 1\n\n5 10 1\n\n10 15 -1\n100",
        "output": "10"
      },
      {
        "input": "3\n\n0 10 1\n\n5 10 1\n\n10 15 -1\n10",
        "output": "15"
      },
      {
        "input": "3\n\n0 10 -10\n\n5 10 1\n\n10 15 1\n15",
        "output": "5"
      }
    ]
  },
  {
    "id": 815,
    "name": "Обходчик лабиринтов",
    "description": "В скором времени на телеэкраны одной страны выйдет новое шоу «Двое в лабиринте». Его сюжет будет состоять в том, что два участника будут помещены в лабиринт. Их целью является поиск выхода из данного лабиринта. Первый, кто найдет выход, получит крупный денежный приз.\nOUTPUT.TXTOK\n2\n3 424 6 2\n1 2 1\n1 2 2\n1 3 1\n1 3 2\n3 4 1\n3 3 1\n2\n1 2\n1HangsHangs[Лучшие попытки]\nОднако, прежде чем шоу выйдет на экраны, лабиринты должны быть сертифицированы Государственным Бюро по Сертификации Лабиринтов. В своей работе бюро использует специальные машины, называемые обходчиками лабиринтов.\nПоскольку в силу специфики работы этих машин для каждого лабиринта приходится строить нового обходчика, Вам поручено провести компьютерное моделирование обхода лабиринта обходчиком.\nЛабиринт состоит из n комнат, соединенных m коридорами. На концах коридора имеются две двери, одна из которых открывается только из коридора, в вторая  только из комнаты, из которой коридор выходит,  таким образом, движение по коридору разрешено только в одну сторону. Кроме этого, каждый из коридоров покрашен в один из k цветов (это сделано для того, чтобы немного облегчить участникам нахождение выхода из лабиринта). Цвет коридора указан на соответствующей ему двери в комнате, из которой он выходит. При этом из комнаты могут выходить несколько коридоров одного цвета.\nОбходчик лабиринтов работает по программе, которая состоит из L инструкций. Каждая инструкция – это номер цвета (число от 1 до k). Обход лабиринта начинается в комнате номер s и совершается следующим образом: обходчик поочередно считывает инструкции и на каждом шаге выбирает один из коридоров, покрашенных в цвет, указанный в этой инструкции. Если такого коридора не находится, то обходчик «зависает».\nТак как на каждом шаге у обходчика может быть не один вариант выбора коридора, то комната, в которой он окажется после выполнения программы может определяться неоднозначно.\nВаша задача состоит в том, чтобы по описанию лабиринта и программе для обходчика определить, в каких комнатах обходчик может оказаться после выполнения соответствующей программы.\nВходные данные\nПервая\tстрока входного\tфайла INPUT.TXT содержит три целых числа: n, m, k (1 ≤ n, k ≤ 1000, 0 ≤ m ≤ 10000). Далее идут m строк, описывающих коридоры. Описание каждого коридора состоит из трех целых чисел: u, v, c (1 ≤ u, v ≤ n, 1 ≤ c ≤ k). Их значения таковы: u - номер комнаты, из которой выходит коридор, v - номер комнаты, в которую ведет коридор, c  цвет этого коридора. Коридор может вести из комнаты в саму себя, между двумя комнатами может существовать несколько коридоров (более того, несколько коридоров одного цвета).\n(m+2)-ая строка входного файла содержит целое число L (1 ≤ L ≤ 1000). (m+3)-ая строка содержит L целых чисел от 1 до k – программы для обходчика лабиринта.\nПоследняя строка входного файла содержит целое число s (1 ≤ s ≤ n).\nВыходные данные\nВ выходной файл OUTPUT.TXT  следует вывести слово Hangs в случае, если обходчик «зависает» независимо от того, какие коридоры он выбирает при существовании нескольких коридоров одного цвета.\nИначе, выведите на первой строке выходного файла слово OK, во второй – количество r комнат, в которых обходчик может оказаться после выполнения программы. В третьей строке выходного файла в этом случае выведите номера этих комнат в возрастающем порядке.",
    "complexity": 65,
    "memory": 16000,
    "time": 1000,
    "examples": [
      {
        "input": "4 6 2\n\n1 2 1\n\n1 2 2\n\n1 3 1\n\n1 3 2\n\n3 4 2\n\n3 3 2\n\n2\n\n1 2\n\n1",
        "output": "OK\n\n2\n\n3 4"
      },
      {
        "input": "4 6 2\n\n1 2 1\n\n1 2 2\n\n1 3 1\n\n1 3 2\n\n3 4 1\n\n3 3 1\n\n2\n\n1 2\n\n1",
        "output": "Hangs"
      }
    ]
  },
  {
    "id": 938,
    "name": "Простые числа - 2",
    "description": "Знаете ли вы, что такое простое число? Простое число – это натуральное число, имеющее ровно два различных натуральных делителя: единицу и самого себя. Все остальные числа, кроме единицы, называются составными. Например, числа 2, 3, 5, 7, 11 являются простыми. А числа 4, 6, 10 – составными.\nOUTPUT.TXT15211\n2 4 6 8 10 13 39 105 200 201 143105105[Лучшие попытки]\nТребуется из заданного набора чисел выбрать одно, имеющее максимальное количество простых делителей. Например, 30 имеет три простых делителя (2, 3 и 5), а 40 – только два (2 и 5).\nВходные данные\nПервая строка входного файла INPUT.TXT содержит число N – количество чисел в наборе. Во второй строке теста содержится N чисел, разделенных пробелом. Все числа во входных данных целые, принимающие значения от 2 до 1024.\nВыходные данные\nВ выходной файл OUTPUT.TXT выведите число с максимальным количеством простых делителей. Если таких чисел несколько, выведите наименьшее из них.",
    "complexity": 28,
    "memory": 16000,
    "time": 1000,
    "examples": [
      {
        "input": "10\n\n3 5 7 9 11 13 15 17 19 21",
        "output": "15"
      },
      {
        "input": "11\n\n2 4 6 8 10 13 39 105 200 201 143",
        "output": "105"
      }
    ]
  },
  {
    "id": 939,
    "name": "Золотоискатели",
    "description": "Артель золотоискателей, состоящая из трех человек, добыла  N  самородков. Один из золотоискателей решил уехать, не ожидая конца вахты, так как у него  на Большой  земле  родился сын.\nnOUTPUT.TXT31 3 4231 3 600[Лучшие попытки]\nАртельщики  решили  выдать отъезжающему ровно третью часть добытого золота.  Выбрать  такой  набор камней  оказалось  непростой задачей. Вам надо написать программу,  которая находит  набор самородков,  вес которого составляет третью часть от веса добытого золота, либо определить, что это невозможно сделать.\ni\nВходные данные\nПервая строка входного файла INPUT.TXT содержит целое число N - количество добытых самородков (1 ≤ N ≤ 100). Во второй строке записано N целых чисел  m1, m2, …, mn (1 ≤ mi ≤ 100),  разделенные пробелами - веса добытых самородков.\nВыходные данные\nВ первую строку выходного файла OUTPUT.TXT следует вывести число K - количество самородков в наборе, а в следующей строке - K чисел, задающих номера самородков. В случае неоднозначного ответа выведите любой. В случае, если выделить ровно третью часть невозможно, выведите один ноль",
    "complexity": 59,
    "memory": 16000,
    "time": 1000,
    "examples": [
      {
        "input": "8\n1 3 4 1 2 5 1 1",
        "output": "3\n1 3 4"
      },
      {
        "input": "3\n1 3 6",
        "output": "0"
      }
    ]
  },
  {
    "id": 963,
    "name": "Морфизм",
    "description": "Рассмотрим слова, состоящие из первых n букв английского алфавита. Морфизм –  это функция f, которая по букве возвращает слово. Рассмотрим пример морфизма: f(A) = ABC, f(B) = A, f(C) = BC.\nlk−1OUTPUT.TXTB23 1 7\nABC\nABC\nA\nBC--[Лучшие попытки]\nЕсли мы рассмотрим слово w = c1c2...cl и применим к нему морфизм f, мы получим слово f(w) = f(c1)f(c2)...f(cl). Например, для морфизма из предыдущего параграфа f(ABC) = ABCABC.\n1\n2\nМы можем применять морфизм к слову несколько раз. Положим f0(w) = w, и для k \u003e 0 положим fk(w) = f(fk−1(w)).\nl\nПо заданному морфизму f, слову w, числу k и числу p, найдите p-й символ слова fk(w).\nВходные данные\nПервая строка входного файла INPUT.TXT содержит числа n, k и p (1 ≤ n ≤ 10, 0 ≤ k ≤ 109,1 ≤ p ≤ 20). Вторая строка входного файла содержит слово w. Его длина не превышает 50. Следующие n строк содержат f(A), f(B), и т.д. Каждое значение – это строка, содержащая от 1 до 50 символов.\nВыходные данные\nВ выходной файл OUTPUT.TXT выведите p-й символ fk(w), или «-» (минус) - если такой символ отсутствует.",
    "complexity": 63,
    "memory": 16000,
    "time": 1000,
    "examples": [
      {
        "input": "3 1 5\n\nABC\n\nABC\n\nA\n\nBC",
        "output": "B"
      },
      {
        "input": "3 1 7\n\nABC\n\nABC\n\nA\n\nBC",
        "output": "-"
      }
    ]
  },
  {
    "id": 964,
    "name": "Ничего не потерялось",
    "description": "Разработка новой поисковой системы, которая ведется группой компаний Giggle, проходит под лозунгом «Ничего и не терялось». Вы работаете в отделе передовых разработок, и на сегодняшний день вашей задачей является разработка тестовой версии поискового «движка».\nOUTPUT.TXTOK\n=====\nOK\n=====\nResults: 1 site(s) found\n1) neerc.ifmo.ru/school/io\n=====\nResults: 1 site(s) found\n1) neerc.ifmo.ru\n=====\nOK\n=====\nResults: 2 site(s) found\n1) neerc.ifmo.ru\n2) neerc.ifmo.ru/school/io\n=====\nAlready exists\n=====\nOK\n=====\nResults: 1 site(s) found\n1) neerc.ifmo.ru\n=====\nNot found\n=====\nOK\n=====\nResults: 0 site(s) found212\nAdd keyword \"keyword\" to site01\nAdd keyword \"keyword\" to site02\nAdd keyword \"keyword\" to site03\nAdd keyword \"keyword\" to site04\nAdd keyword \"keyword\" to site05\nAdd keyword \"keyword\" to site06\nAdd keyword \"keyword\" to site07\nAdd keyword \"keyword\" to site08\nAdd keyword \"keyword\" to site09\nAdd keyword \"keyword\" to site10\nAdd keyword \"keyword\" to site11\nSearch \"keyword\"OK\n=====\nOK\n=====\nOK\n=====\nOK\n=====\nOK\n=====\nOK\n=====\nOK\n=====\nOK\n=====\nOK\n=====\nOK\n=====\nOK\n=====\nResults: 11 site(s) found\n1) site01\n2) site02\n3) site03\n4) site04\n5) site05\n6) site06\n7) site07\n8) site08\n9) site09\n10) site10OK\n=====\nOK\n=====\nOK\n=====\nOK\n=====\nOK\n=====\nOK\n=====\nOK\n=====\nOK\n=====\nOK\n=====\nOK\n=====\nOK\n=====\nResults: 11 site(s) found\n1) site01\n2) site02\n3) site03\n4) site04\n5) site05\n6) site06\n7) site07\n8) site08\n9) site09\n10) site10[Лучшие попытки]\nТестовая версия реализует лишь часть функциональности полной версии. В частности, отсутствуют такие функции, как использование логических выражений в запросах, перевод найденных страниц с одного языка на другой и т.д.\nВозможности тестовой версии поисковой системы ограничиваются обработкой трех видов запросов: запросов на добавление, на удаление и на поиск. Система работает следующим образом. В любой момент времени существует множество известных системе сайтов, причем для каждого сайта известно множество ключевых слов, встречающихся на нем.\nЗапрос на добавление содержит ключевое слово и название сайта. При его выполнении ключевое слово добавляется в множество ключевых слов, присутствующих на данном сайте. Если этого слова в соответствующем множестве еще нет, то результатом запроса является «OK», в противном случае – «Already exists».\nЗапрос на удаление содержит ключевое слово и название сайта. При его выполнении ключевое слово исключается из множества ключевых слов, присутствующих на данном сайте. Если этого слова в соответствующем множестве нет, то результатом запроса является «Not found», в противном случае – «OK».\nЗапрос на поиск содержит только ключевое слово. Результатом запроса является лексикографически отсортированный список сайтов, содержащих данное ключевое слово. При этом в результат выводятся только первые 10 сайтов из этого списка.\nЗадан список запросов. Необходимо вывести результат их последовательного выполнения.\nВходные данные\nПервая строка входного файла INPUT.TXT содержит целое число n –  количество запросов, которые необходимо обработать (0 ≤ n ≤ 2500). Каждая из последующих n строк содержит запрос. Запрос на добавление имеет следующий формат:\nAdd keyword \u003c keyword \u003e to \u003c site \u003e, где \u003c keyword \u003e – ключевое слово,  – название сайта, на который добавляется это ключевое слово.\nЗапрос на удаление имеет следующий формат:\nRemove keyword \u003c keyword \u003e from \u003c site \u003e, где \u003c keyword \u003e – ключевое слово, \u003c site \u003e – название сайта, на котором удаляется это ключевое слово.\nЗапрос на поиск имеет следующий формат:\nSearch \u003c keyword \u003e, где \u003c keyword \u003e  – ключевое слово.\nВсе ключевые слова (\u003c keyword \u003e) состоят из строчных букв английского алфавита. Длины ключевых слов не превосходят 30 символов.\nВсе названия сайтов (\u003c site \u003e) состоят из строчных букв английского алфавита, символов «косая черта» («/») и точек («.»). Длины названий сайтов не превосходят 100 символов.\nВыходные данные\nВ выходной файл OUTPUT.TXT выведите результат для каждого запроса. При этом придерживайтесь формата, приведенного в примерах. Не забудьте обратить внимание на второй пример. Результаты запросов разделяйте строкой из пяти символов «равно» («=»).",
    "complexity": 51,
    "memory": 16000,
    "time": 1000,
    "examples": [
      {
        "input": "12\n\nAdd keyword \u0026#34;olympiads\u0026#34; to neerc.ifmo.ru/school/io\n\nAdd keyword \u0026#34;neerc\u0026#34; to neerc.ifmo.ru\n\nSearch \u0026#34;olympiads\u0026#34;\n\nSearch \u0026#34;neerc\u0026#34;\n\nAdd keyword \u0026#34;olympiads\u0026#34; to neerc.ifmo.ru\n\nSearch \u0026#34;olympiads\u0026#34;\n\nAdd keyword \u0026#34;olympiads\u0026#34; to neerc.ifmo.ru/school/io\n\nRemove keyword \u0026#34;olympiads\u0026#34; from neerc.ifmo.ru/school/io\n\nSearch \u0026#34;olympiads\u0026#34;\n\nRemove keyword \u0026#34;olymp\u0026#34; from neerc.ifmo.ru\n\nRemove keyword \u0026#34;olympiads\u0026#34; from neerc.ifmo.ru\n\nSearch \u0026#34;olympiads\u0026#34;",
        "output": "OK\n\n=====\n\nOK\n\n=====\n\nResults: 1 site(s) found\n\n1) neerc.ifmo.ru/school/io\n\n=====\n\nResults: 1 site(s) found\n\n1) neerc.ifmo.ru\n\n=====\n\nOK\n\n=====\n\nResults: 2 site(s) found\n\n1) neerc.ifmo.ru\n\n2) neerc.ifmo.ru/school/io\n\n=====\n\nAlready exists\n\n=====\n\nOK\n\n=====\n\nResults: 1 site(s) found\n\n1) neerc.ifmo.ru\n\n=====\n\nNot found\n\n=====\n\nOK\n\n=====\n\nResults: 0 site(s) found"
      },
      {
        "input": "12\n\nAdd keyword \u0026#34;keyword\u0026#34; to site01\n\nAdd keyword \u0026#34;keyword\u0026#34; to site02\n\nAdd keyword \u0026#34;keyword\u0026#34; to site03\n\nAdd keyword \u0026#34;keyword\u0026#34; to site04\n\nAdd keyword \u0026#34;keyword\u0026#34; to site05\n\nAdd keyword \u0026#34;keyword\u0026#34; to site06\n\nAdd keyword \u0026#34;keyword\u0026#34; to site07\n\nAdd keyword \u0026#34;keyword\u0026#34; to site08\n\nAdd keyword \u0026#34;keyword\u0026#34; to site09\n\nAdd keyword \u0026#34;keyword\u0026#34; to site10\n\nAdd keyword \u0026#34;keyword\u0026#34; to site11\n\nSearch \u0026#34;keyword\u0026#34;",
        "output": "OK\n\n=====\n\nOK\n\n=====\n\nOK\n\n=====\n\nOK\n\n=====\n\nOK\n\n=====\n\nOK\n\n=====\n\nOK\n\n=====\n\nOK\n\n=====\n\nOK\n\n=====\n\nOK\n\n=====\n\nOK\n\n=====\n\nResults: 11 site(s) found\n\n1) site01\n\n2) site02\n\n3) site03\n\n4) site04\n\n5) site05\n\n6) site06\n\n7) site07\n\n8) site08\n\n9) site09\n\n10) site10"
      }
    ]
  },
  {
    "id": 996,
    "name": "Забавная последовательность",
    "description": "Выходные данные\nВ выходной файл OUTPUT.TXT выведите an.",
    "complexity": 26,
    "memory": 16000,
    "time": 1000,
    "examples": [
      {
        "input": "1",
        "output": "1"
      },
      {
        "input": "8",
        "output": "18"
      }
    ]
  },
  {
    "id": 994,
    "name": "Длиннейшая общая подпара",
    "description": "Выходные данные\nВ выходной файл OUTPUT.TXT выведите α на первой строке выходного файла и β на второй строке. Если существует несколько решений, выведите любое из них.",
    "complexity": 48,
    "memory": 64000,
    "time": 1000,
    "examples": [
      {
        "input": "abacabadabacaba\n\nacabacadacabaca",
        "output": "acaba\nabaca"
      },
      {
        "input": "ab\nbc",
        "output": "b"
      }
    ]
  },
  {
    "id": 998,
    "name": "Велосипедные дорожки",
    "description": "Андрюша живет в пригороде. Неподалеку от Андрюшиного дома проложены две велосипедные дорожки, каждая из которых имеет вид круга с радиусом r. У дорожек нет общих точек. Андрюшин дом расположен около одной из дорожек, а его школа расположена около другой дорожки. Каждый день Андрюша ездит в школу и обратно на велосипеде. Он заметил, что когда он едет по дорожке, его скорость составляет u, а когда едет просто по полю, то v, причем u \u003e v. Теперь Андрюша хочет узнать, за какое минимальное время он сможет добраться из школы домой. \n22OUTPUT.TXT16.5757337181220 5-5 0 5 202 117.204051724917.2040517249[Лучшие попытки]\nВведем систему координат таким образом, что центр дорожки, расположенной около Андрюшиного дома, находится в точке (0, 0), а центр дорожки, где расположена его школа, находится в точке (0, d). Радиус каждой дорожки равен r. Андрюшин дом расположен в точке (x1, y1), а его школа в точке (x2, y2). Скорость Андрюши по дороге равна u, а по полю – v.\n22\nВходные данные1\nВходной файл INPUT.TXT содержит 8 вещественных чисел: d, r, x1, y1, x2, y2, u и v (1≤ r ≤ 100, 2r \u003c d ≤ 100, 1 ≤ v \u003c u ≤ 10, x12+ y12 = r2, x22 + (y2− d)2 = r2). Все неравенства выполнены с точностью до 10−9.\n2\n1Выходные данные\n2\nВ выходной файл OUTPUT.TXT выведите одно вещественное число – минимальное время, которое Андрюше требуется, чтобы добраться из дома до школы. Ответ следует вывести с точностью не меньше, чем 10−6.\n2Примеры\n2\n№INPUT.TXTOUTPUT.TXT\n120 55 0 5 202 116.5757337181\n220 5-5 0 5 202 117.2040517249\n2Пояснение к примерам\n2\n2\n2Для отправки решения задачи необходимо зарегистрироваться и авторизоваться!\n−9\n\n  [Обсуждение]\n\n  [Все попытки]\n\n  [Лучшие попытки]\nwindow.yaContextCb.push(()=\u003e{\n  Ya.Context.AdvManager.render({\n    renderTo: 'yandex_rtb_R-A-122393-3',\n    blockId: 'R-A-122393-3'\n  })\n})",
    "complexity": 72,
    "memory": 16000,
    "time": 1000,
    "examples": [
      {
        "input": "20 5\n5 0 5 20\n2 1",
        "output": "16.5757337181"
      },
      {
        "input": "20 5\n-5 0 5 20\n2 1",
        "output": "17.2040517249"
      }
    ]
  },
  {
    "id": 937,
    "name": "Макрос",
    "description": "Однажды Бараш решил поучаствовать в литературном конкурсе программистов. Стихотворения принимались на четырех языках: Assembly, Foxy, Lispy, Prology. Как старый поэт-программист, Бараш признавал только Assembly. Поэтому писать пришлось на нем. Он запустил свой верный edit.com под Dos 6.22 и приступил к делу. Учитывая то, что Бараш был ленивым программистом, он вовсю использовал макросы. Это чрезвычайно ускоряло процесс стихосложения, так как у Бараша было множество заготовок, как и у любого старого поэта-программиста.\nЦиклические макроопределения:\n#rep_n_{}\nn – целое число повторов текста  (0 ≤ n ≤ 100).OUTPUT.TXT\na\n\na_b_b\na\n24\n#a_{#b_{#c_{a}##c_}##b_}##a_\n#e_{#b_{#c_{b}##c_}##b_}##e_\n#f_{#b_{#c_{c}##c_}##b_}##f_\n##a_##e_##f_##b_##c_a\nb\nc\nabca\nb\nc\nabc[Лучшие попытки]\nСтих получился шикарным, но, посовещавшись со своей подругой Нюшей, Бараш понял, что стих недоступен для понимания подавляющего большинства ценителей искусства. Поэтому Бараш решил пожертвовать формой произведения, дабы донести его высший смысл. Для этого он решил отказаться от использования макроопределений в своем произведении, выполнив макроподстановку.\n (0 ≤ n ≤ 100).\nПроблема в том, что одно стихотворное макроопределение могло содержать другие макроопределения. Также Бараш был большим любителем циклической макрогенерации, что не могло не отразиться в его произведениях. Ему не хватило душевных сил корежить произведение собственными руками, поэтому он попросил о помощи вас. Помогите Барашу!\nБараш использовал следующий формат макроопределений (вместо каждого символа ‘_’ во входном и выходном файлах будет стоять точно один пробел):\nМакроопределения:\n#identificator_{}\nИдентификатор (имя макроопределения) состоит не более, чем из 10 строчных английских букв. Не встречается макроопределений с именем “rep”.\nМакровызовы:\n##identificator_\nЦиклические макроопределения:\n#rep_n_{}\nn – целое число повторов текста  (0 ≤ n ≤ 100).\nНазовем блоком текст , заключенный между фигурными скобками. Bсе стихотворение также называется блоком.\nВ любом блоке могут встречаться другие макроопределения и макровызовы.\nМакроопределение считается действующим для всего последующего текста текущего блока и всех последующих вложенных блоков, если только во вложенном блоке не переобъявлено макроопределение с таким же именем. Если во вложенных блоках встретились макроопределения с таким же именем, как и во внешнем блоке, тогда действующим считается макроопределение внутреннего блока. В блоке не может встретиться двух одноименных макроопределений.\nРекурсивные вызовы отсутствуют. Вызовы несуществующих макроопределений игнорируются.  Все макровызовы, которые в тексте стихотворения стоят ранее макроопределения, считаются несуществующими и, следовательно,  игнорируются.\nВходные данные\nВходной файл INPUT.TXT содержит число N - количество строк в стихотворении. Далее идет N строк стихотворения. Общий объем входных данных не превышает 1024 байт.\nВыходные данные\nВ выходной файл OUTPUT.TXT выведите исправленный текст стихотворения.",
    "complexity": 72,
    "memory": 16000,
    "time": 1000,
    "examples": [
      {
        "input": "5\n\n##a_\n\n#a_{a}##a_\n\n#b_{##a__#a_{b}##a_#c_{##a_}_##c_}\n\n##b_##c_\n\n##a_",
        "output": "a\n\n\n\na_b_b\n\na"
      },
      {
        "input": "4\n\n#a_{#b_{#c_{a}##c_}##b_}##a_\n\n#e_{#b_{#c_{b}##c_}##b_}##e_\n\n#f_{#b_{#c_{c}##c_}##b_}##f_\n\n##a_##e_##f_##b_##c_",
        "output": "a\n\nb\n\nc\n\nabc"
      }
    ]
  },
  {
    "id": 942,
    "name": "Олимпиада",
    "description": "Трое студентов, пятикурсник, третьекурсник и первокурсник, живут в одной комнате общежития и любят участвовать в соревнованиях по программированию по правилам ACM. У каждого из них свой подход к решению задач. Пятикурсник решает все задачи строго по порядку - сначала первую, затем вторую, и так до последней. Третьекурсник решает задачи строго в обратном порядке – сначала последнюю, затем предпоследнюю, и так до первой. А первокурсник сначала решает самую простую задачу, затем – самую простую из оставшихся задач, и так до самой сложной. Сложность задачи определяется временем, необходимым для её решения. Для решения одной и той же задачи наши студенты тратят одинаковое количество времени.\nOUTPUT.TXT12410 20 30 4011[Лучшие попытки]\nВаша задача – по описанию соревнований по программированию определить, кто из студентов победит. Напомним, что по правилам ACM побеждает участник, за 300 минут решивший больше всего задач, а при равенстве количества задач – набравший меньше штрафного времени.\nНаши студенты – очень сильные программисты, и при решении задач они не делают неправильных попыток. Поэтому за задачу начисляется штраф в размере количества минут от начала соревнования до её посылки на проверку. Если же и количество штрафного времени совпадает – то студент со старшего курса уступает победу студенту с младшего курса.\nВходные данные\nПервая строка входного файла INPUT.TXT содержит натуральное число N (N ≤ 10) – количество задач. Во второй строке записаны через пробел N натуральных чисел – количество минут, необходимое для решения каждой задачи. Время решения задачи не превосходит 300 минут.\nВыходные данные\nВ выходной файл OUTPUT.TXT выведите номер курса студента, одержавшего победу в олимпиаде.",
    "complexity": 2,
    "memory": 16000,
    "time": 1000,
    "examples": [
      {
        "input": "3\n40 30 60",
        "output": "1"
      },
      {
        "input": "4\n10 20 30 40",
        "output": "1"
      }
    ]
  },
  {
    "id": 997,
    "name": "Проверка орфографии - 2",
    "description": "Время от времени каждому школьнику, изучающему английский язык, приходится сдавать учителю сочинение на английском языке. Учителя английского языка бывают разные. Когда школьник использует в сочинении слова, которые на уроках еще не проходили, одни восхищаются юным талантом, другие багровеют от злости и ставят двойку непослушному ученику, осмелившемуся кичиться своими знаниями.\nOUTPUT.TXTEverything is going to be OK.22 2\nseven\nday\nOn the\nseventh daySome words from the text are unknown.Some words from the text are unknown.The usage of the vocabulary is not perfect.[Лучшие попытки]\nК сожалению, Ваша учительница  из других. Она не потерпит ни малейшего отступления от использования словарного запаса. В этот раз еще одна беда обрушилась на Вашу голову. Сочинение, заданное на завтра  контрольное сочинение по выученным словам. А это значит, что все слова, которые Вы выучили на уроках, должны присутствовать в сочинении хотя бы по одному разу.\n34 1\nvocabulary\nwide\ntoo\nmuch\nToo wide vocabulary.The usage of the vocabulary is not perfect.\nТаким образом, перед сдачей сочинения Вам необходимо проверить, что каждое слово в тексте сочинения встречается в словаре, и каждое слово из словаря встречается в тексте.\nВходные данные\nВ первой строке входного файла INPUT.TXT находится два числа N и M (1 ≤ N ≤ 103, 1 ≤ M ≤ 105). В следующих N строках находится по одному слову из словаря. Все слова состоят из строчных английских букв. Длина каждого слова не превышает 20. Каждое слово состоит хотя бы из одного символа. Лишних пробелов перед словом и после него нет.\nВ следующих M строках находится текст сочинения. Текст состоит из заглавных и строчных английских букв, пробелов и знаков препинания: точек (.), запятых (,), двоеточий (:), точек с запятыми (;), тире (-), апострофов ('), кавычек (\"), восклицательных (!) и вопросительных (?) знаков.\nОбщая длина текста не превосходит 104 символов. В данной задаче большие и маленькие буквы в словах не различаются.\nВыходные данные\nВ выходной файл OUTPUT.TXT выведите «Everything is going to be OK.», если с сочинением все в порядке. Если не все слова из текста встречаются в словаре, выведите «Some words from the text are unknown.». Если же предыдущее неверно, но некоторые слова из словаря не встречаются в тексте, выведите «The usage of the vocabulary is not perfect.».",
    "complexity": 39,
    "memory": 16000,
    "time": 1000,
    "examples": [
      {
        "input": "3 1\n\nam\n\nbill\n\ni\n\nI am Bill, am I?",
        "output": "Everything is going to be OK."
      },
      {
        "input": "2 2\n\nseven\n\nday\n\nOn the\n\nseventh day",
        "output": "Some words from the text are unknown."
      },
      {
        "input": "4 1\n\nvocabulary\n\nwide\n\ntoo\n\nmuch\n\nToo wide vocabulary.",
        "output": "The usage of the vocabulary is not perfect."
      }
    ]
  },
  {
    "id": 941,
    "name": "Unix",
    "description": "Наш любимый сисадмин Алексей установил новую ОС семейства Unix. Основные её особенности - это стабильность, надежность, гибкость и масштабируемость и огромное количество идущего в стандартной поставке программного обеспечения. Одна из таких встроенных программ предназначена для сложения чисел, представленных в троичной системе счисления. Вы понимаете то, что Костя - известный тестер, и делом чести для него является найти ошибку в реализации столь сложной задачи. Помогите ему - напишите свою, абсолютно безошибочную версию «троичного калькулятора».\nOUTPUT.TXT2220 1021717[Лучшие попытки]\nВходные данные\nВходной файл INPUT.TXT содержит два, разделенных пробелом, числа N и M (0 ≤ N, M ≤ 231-1) в троичной системе счисления.\nВыходные данные\nВ выходной файл OUTPUT.TXT выведите ответ – сумму N и M в десятичной системе счисления.",
    "complexity": 29,
    "memory": 16000,
    "time": 1000,
    "examples": [
      {
        "input": "1 1",
        "output": "2"
      },
      {
        "input": "20 102",
        "output": "17"
      }
    ]
  },
  {
    "id": 943,
    "name": "Змейка - 3",
    "description": "Напишите программу, которая выводит элемент из строки Y и столбца X матрицы размера N×M, которая заполнена следующим образом:\n2589101110OUTPUT.TXT525 2 3 1449[Лучшие попытки]\n0123\n7654\n891011\n341133 4 3 29\nВходные данные\nВходной файл INPUT.TXT содержит натуральные числа N, M, Y, X (Y ≤ N ≤ 50; X ≤ M ≤ 50). N - количество строк матрицы, M - количество столбцов матрицы, Y и X - номера строки и столбца искомого элемента.\nВыходные данные\nВ выходной файл OUTPUT.TXT выведите искомый элемент.",
    "complexity": 16,
    "memory": 16000,
    "time": 1000,
    "examples": [
      {
        "input": "3 4 2 3",
        "output": "5"
      },
      {
        "input": "5 2 3 1",
        "output": "4"
      },
      {
        "input": "3 4 3 2",
        "output": "9"
      }
    ]
  },
  {
    "id": 913,
    "name": "Автобус",
    "description": "Василий работает водителем автобуса, и у него есть по-настоящему тяжелая работа: он перевозит пассажиров из пункта A в пункт B. При этом он должен выполнять свою работу безопасно и как можно быстрее. Кроме того, каждый водитель должен повиноваться дорожным правилам и нормам, иначе, он будет оштрафован местной полицией.\nOUTPUT.TXT100[Лучшие попытки]\nМаршрут Василия состоит из N отрезков, которые он проезжает последовательно, начиная от 1-го и завершая N-м отрезком. У каждого отрезка задана длина в километрах Di.\nКонечно, на маршруте Василия есть ограничения скорости. У каждого отрезка есть свое собственное ограничение скорости Li км/ч. В случае превышения скорости на i-м отрезке, водитель автобуса будет немедленно остановлен полицейским, который потратит Hi часов на заполнение соответствующих бумаг. Водитель не может быть остановлен более одного раза на каждом отрезке.\nАвтобус едет вдоль маршрута с постоянной скоростью S, которую Василий выбирает в начале маршрута (в пункте A). Автобус не может превышать максимальную конструктивную скорость, которая определена значением M км/ч.\nПожалуйста, помогите Василию выбирать правильную скорость, чтобы достигнуть конечного пункта B как можно быстрее.\nВходные данные\nПервая строка входного файла INPUT.TXT содержит  два числа, разделенные пробелом:  количество отрезков N (N ≤ 1000) в маршруте Василия и максимально возможную конструктивную скорость автобуса M (M ≤ 105). Далее идут N строк, в каждой из которых определены разделенные пробелом значения Di, Li и Hi,  описывающие i-й отрезок пути (Di, Hi ≤ 1000, Li ≤ 105). Все числа, определенные во входных данных натуральные.\nВыходные данные\nВ выходной файл OUTPUT.TXT выведите оптимальную скорость автобуса. В случае неоднозначного ответа следует выбрать наибольшее значение.",
    "complexity": 39,
    "memory": 16000,
    "time": 1000,
    "examples": [
      {
        "input": "1 100\n1000 100 10",
        "output": "100"
      }
    ]
  },
  {
    "id": 995,
    "name": "Голова на плечах",
    "description": "Изготовитель всемирно известного шампуня, компания «Голова на плечах» всерьез заботится о качестве своей продукции. В частности, она постоянно улучшает различные показатели своего шампуня, с целью чего постоянно проводит исследования. Но, согласно законодательству, на человеке проводить исследования нельзя, а проводить исследования на животных компания считает ниже своего достоинства. Поэтому ученые, работающие в компании, разработали математическую модель человека и проводят исследования на ней.\nhOUTPUT.TXT121 10\n3\n-1 0 -1 -10\n0 -1 0 -10\n1 0 1 -1000[Лучшие попытки]\nЧеловек, согласно этой модели, состоит из головы и плеч. Голова представляет собой окружность с центром в точке (0,0) и радиусом R, а плечи  бесконечную прямую y = −K, где R \u003c K. \nh\nОбъектом изучения исследователей являются волосы. Каждый волос в данной модели представлен отрезком, начинающимся на голове (строго на окружности) и заканчивающимся на плечах (строго на прямой). При этом ни один волос не имеет с окружностью головы более одной общей точки. В данный момент ученые озабочены проблемой секущихся волос. Пара волос называется секущейся, если соответствующие этим волосам отрезки имеют общую точку.\ns\nДана математическая модель человека. Найдите количество секущихся пар волос.\ns\nВходные данные\nВ первой строке входного файла заданы два целых числа R, K (1 ≤ R \u003c K ≤ 103). Во второй строке записано целое число N (0 ≤ N ≤ 105)  количество волос в модели человека. В следующих N строках находится по 4 вещественных числа Xh, Yh, Xs, Ys – координаты начала и конца очередного волоса. Первая пара чисел соответствует концу, лежащему на окружности головы, вторая пара соответствует концу, лежащему на плечах.\nГарантируется, что никакой волос не имеет с окружностью головы более одной общей точки. Также гарантируется, что среди начальных и конечных точек нет одинаковых.\nВыходные данные\nВ выходной файл OUTPUT.TXT выведите число секущихся пар волос.",
    "complexity": 59,
    "memory": 16000,
    "time": 1000,
    "examples": [
      {
        "input": "1 2\n\n3\n\n0 -1 -2 -2\n\n1 0 2 -2\n\n-1 0 -1 -2",
        "output": "1"
      },
      {
        "input": "1 10\n\n3\n\n-1 0 -1 -10\n\n0 -1 0 -10\n\n1 0 1 -10",
        "output": "0"
      }
    ]
  },
  {
    "id": 912,
    "name": "Одежда",
    "description": "Несмотря на небольшую площадь, территорию Волшебной страны населяет множество народов, различных по культуре и внешнему облику, но говорящих на одном языке. Каждый народ предпочитает носить одежду определённого цвета, который отличается от цвета одежды других народов. Народы имеют разные традиции, порой традиции одних народов противоречат традициям других народов. Поэтому жители каждого города следуют традициям того народа, представителей которого проживает в этом городе больше всего. Если оказывается, что таких народов несколько, все жители города следуют традициям самого миролюбивого народа с белым цветом одежды (белый цвет обозначается нулём).\niOUTPUT.TXT2245 5 4 400[Лучшие попытки]\nПутешественник стоит на высоком холме недалеко от входа в город. С этого холма он видит цвет одежды каждого жителя города. Путешественник торопится войти в город, ему важно быстро определить, традициям какого народа следовать в этом городе.\nВходные данные\nПервая строка входного файла INPUT.TXT содержит число N - количество жителей города, которых видит путешественник (1 ≤ N ≤ 104). Вторая строка теста содержит N натуральных чисел, разделенных пробелами.  Каждое число сi – это цвет одежды i-го жителя  (1 ≤ ci ≤ 100).\nВыходные данные\nВ выходной файл OUTPUT.TXT выведите единственное целое число – цвет одежды народа, традициям которого следуют жители города.",
    "complexity": 24,
    "memory": 16000,
    "time": 1000,
    "examples": [
      {
        "input": "6\n1 2 5 2 1 2",
        "output": "2"
      },
      {
        "input": "4\n5 5 4 4",
        "output": "0"
      }
    ]
  },
  {
    "id": 910,
    "name": "Последовательность - 4",
    "description": "Бесконечная числовая последовательность задана с помощью формулы ее k-го члена:\nOUTPUT.TXT2210000 200909349562[Лучшие попытки]\nAk = k!*2k, где k = 1, 2, 3,...\n3100 1000000000909349562\nНайти сумму N первых членов этой последовательности. Так как найденная сумма может быть очень большой, выведите ее по модулю M.\nВходные данные\nВходной файл INPUT.TXT содержит два целых числа N - количество членов последовательности (1 ≤ N ≤ 104) и M - модуль (2 ≤ M ≤ 109).\nВыходные данные\nВ выходной файл OUTPUT.TXT выведите сумму N первых членов последовательности по модулю M.",
    "complexity": 28,
    "memory": 16000,
    "time": 1000,
    "examples": [
      {
        "input": "5 10",
        "output": "2"
      },
      {
        "input": "10000 2",
        "output": "0"
      },
      {
        "input": "100 1000000000",
        "output": "909349562"
      }
    ]
  },
  {
    "id": 944,
    "name": "Размен",
    "description": "У вас имеется неограниченное количество монеток N разных достоинств. Определить, можно ли с их помощью разменять заданные К сумм денег.\nOUTPUT.TXT1 1 0 1 121101300[Лучшие попытки]\nВходные данные\nВ первой строке входного файла INPUT.TXT задано число N, далее во второй строке записаны N чисел, задающих достоинства монеток. В третьей строке задано число К – количество сумм. В четвертой строке располагаются К чисел, определяющих размеры сумм. Все числа во входном файле натуральны и не превосходят 1000.\nВыходные данные\nВ выходной файл OUTPUT.TXT выведите К чисел через пробел: для каждой суммы следует вывести 0, если ее разменять нельзя, и 1, если можно.",
    "complexity": 41,
    "memory": 16000,
    "time": 1000,
    "examples": [
      {
        "input": "2\n3 5\n5\n3 6 7 11 12",
        "output": "1 1 0 1 1"
      },
      {
        "input": "1\n10\n1\n3",
        "output": "0"
      }
    ]
  },
  {
    "id": 911,
    "name": "Взвешивания",
    "description": "OUTPUT.TXTL:1 3R:92R 3L:3R:L:3R:[Лучшие попытки]\nЗнаменитый химик Д. И. Менделеев, будучи директором Главной палаты мер и весов, интересовался задачей составления набора гирь,  чтобы с их помощью можно было взвесить любой груз. Выяснилось, что если при взвешивании груза класть гири и на левую и на правую чашки весов, то самым удобным является набор гирь в троичной системе.\nДля взвешиваний используют чашечные весы и большой набор гирь 1, 3, 9, 27, 81 грамм и т.д. (для любого k ≥ 0 есть только одна гиря весом 3k грамм).\nНа одну из чашек весов положили груз весом N грамм. Какие гири нужно положить на левую и правую чашки, чтобы их уравновесить?\nВходные данные\nВходной файл INPUT.TXT содержит символ C и число N, разделенные пробелом. C  - символ «L» или «R», обозначающий соответственно левую или правую чашку весов, на которой лежит груз. N – масса груза в граммах (1 ≤ N ≤ 109).\nВыходные данные\nВ выходной файл OUTPUT.TXT выведите две строки: первая строка должна начинаться с \"L:\", вторая – с \"R:\", после чего через пробел должны идти в порядке возрастания массы веса гирь, которые нужно положить на левую и правую чашу весов, соответственно.",
    "complexity": 40,
    "memory": 16000,
    "time": 1000,
    "examples": [
      {
        "input": "L 5",
        "output": "L:1 3\nR:9"
      },
      {
        "input": "R 3",
        "output": "L:3\nR:"
      }
    ]
  },
  {
    "id": 909,
    "name": "Морской бой - 3",
    "description": "Всем известна  увлекательная игра «Морской бой». Сейчас играть в морской бой можно не только с соседом по парте, но и с компьютером. Игра c компьютером ведется на прямоугольном поле произвольных размеров N×M, где N - количество строк, M - количество столбцов. Приближается чемпионат Мира по морскому бою. Планируется вести его трансляцию  в режиме реального времени: демонстрировать карту с кораблями и выводить статистику: количество целых, подбитых и уничтоженных кораблей, находящихся  на поле. Требуется написать программу для подсчета статистики.\nколичество уничтоженных кораблейOUTPUT.TXT2 1 1[Лучшие попытки]\nКорабль на поле — это связанная фигура, стоящая из одной или нескольких рядом лежащих клеток, имеющих общую сторону.  Корабли могут быть абсолютно любых форм и размеров!\nВходные данные\nПервая строка входного файла INPUT.TXT содержит два целых числа N и M (1≤ N,M ≤ 103), разделённых пробелами - размеры игрового поля. Далее идут N строк по M символов - описание игрового поля.\nАнглийская буква 'X' обозначает подбитую клетку корабля, 'S' - не подбитую клетку корабля, '-' – свободное водное пространство.\nВыходные данные\nВ выходной файл OUTPUT.TXT выведите через пробел три числа:\nколичество целых кораблей\nколичество подбитых кораблей\nколичество уничтоженных кораблей",
    "complexity": 50,
    "memory": 32000,
    "time": 1000,
    "examples": [
      {
        "input": "3 8\n\n---SSS--\n\nXX--S-X-\n\nX-S---S-",
        "output": "2 1 1"
      }
    ]
  },
  {
    "id": 916,
    "name": "Экономия",
    "description": "Представь, что ты - капитан команды, которая только что выиграла мировой финал ACM ICPC, и теперь тебе предстоит отпраздновать свою победу со своими друзьями, которых у тебя ровно K-1. Для этого необходимо закупить N бутылок любимого напитка (остается только догадываться какого) в ближайшем магазине. Стоимость i-й бутылки составляет Ci рублей. К сожалению, продавец не любит, когда его клиенты покупают слишком много бутылок, поэтому он продаёт только по одной бутылке за раз, а также изменяет цену бутылки для клиента, который ранее у него уже делал покупки. Точнее, если клиент уже купил X бутылок, то он должен заплатить (X+1)*Ci рублей, чтобы купить бутылку номер i.\nNOUTPUT.TXT13[Лучшие попытки]\nНеобходимо определить минимально возможную стоимость приобретения N бутылок с учетом того, что в процессе покупки могут участвовать не более K человек (только ты и твои друзья).\ni\nВходные данные6\nПервая строка входного файла INPUT.TXT содержит два числа N и K (N, K ≤ 100), соответственно во второй строке определены значения C1, C2, ..., CN ( Ci ≤ 106). Все числа во входных данных натуральные.\nВыходные данные\nВ выходной файл OUTPUT.TXT выведите оптимальную стоимость покупки.",
    "complexity": 28,
    "memory": 16000,
    "time": 1000,
    "examples": [
      {
        "input": "3 3\n2 5 6",
        "output": "13"
      }
    ]
  },
  {
    "id": 914,
    "name": "Пересечение",
    "description": "В трехмерном пространстве заданы два прямоугольных параллелепипеда. Необходимо определить: пересекаются ли они?\n3OUTPUT.TXTYES[Лучшие попытки]\nВходные данные4\nВходной файл INPUT.TXT содержит два блока по четыре строки, содержащие описание первого и второго параллелепипеда. В первой строке блока находятся координаты одной из вершин параллелепипеда x, y и z, разделенные пробелом. В остальных трех строках находится описание трех векторов (ребер) v1, v2, v3 параллелепипеда прилегающих к указанной вершине. Все координаты – целые числа, не превышающие 104 по абсолютной величине.\nВыходные данные\nВ выходной файл OUTPUT.TXT выведите «YES», если параллелепипеды пересекаются и «NO» в противном случае.",
    "complexity": 79,
    "memory": 16000,
    "time": 1000,
    "examples": [
      {
        "input": "30 50 0\n\n50 50 0\n\n-30 30 0\n\n0 0 100\n\n0 40 70\n\n0 20 20\n\n0 20 -20\n\n1 0 0",
        "output": "YES"
      }
    ]
  },
  {
    "id": 999,
    "name": "Диверсия",
    "description": "В королевстве Далеком n городов, соединенных m двусторонними дорогами. Некоторые дороги вымощены камнем, а другие представляют собой лишь обычные проселочные дороги. Столица королевства расположена в городе номер 1. Дороги устроены таким образом, что можно из любого города добраться до любого другого, перемещаясь исключительно по вымощенным камнем дорогам, причем количество каменных дорог  минимальное возможное. Проселочные же дороги были построены таким образом, что если каменная дорога заблокирована или уничтожена, то все равно можно добраться из любого города до любого другого по дорогам.\nOUTPUT.TXT4[Лучшие попытки]\nОбозначим количество каменных дорог, по которым требуется проехать, чтобы попасть из города u в город v как s(u, v). Дороги подчиняются следующему правилу: если два города u и v соединены дорогой (неважно, каменной или проселочной), то либо s(1, u) + s(u, v) =\ts(1, v), либо s(1, v) + s(v, u) = s(1, u).\nКороль соседнего королевства планирует напасть на Далекое. В качестве начала операции предполагается уничтожить некоторые дороги. Расчеты показали, что финансирования, выделенного министерству атаки, достаточно, чтобы уничтожить ровно одну каменную и одну проселочную дорогу. Король хотел бы уничтожить такую пару дорог, чтобы после этого хотя бы для каких-нибудь двух городов стало невозможно добраться из одного города в другой.\nТеперь он просит министра атаки посчитать количество возможных диверсионных планов. Однако министр атаки обучен только атаковать, считать для него слишком сложно. Помогите ему!\nВходные данные\nПервая строка входного файла INPUT.TXT содержит n и m – количество городов и дорог, соответственно (3 ≤ n ≤ 20 000, m ≤ 100 000). Следующие m строк описывают дороги, каждая строка содержит три целых числа – номера городов, соединенных соответствующей дорогой, и 1, если соответствующая дорога вымощена камнем, или 0, если соответствующая дорога – проселочная. Никакие два города не соединены более чем одной дорогой, никакая дорога не соединяет город сам с собой.\nВыходные данные\nВ выходной файл OUTPUT.TXT выведите одно целое число – количество способов организовать диверсию.",
    "complexity": 70,
    "memory": 16000,
    "time": 1000,
    "examples": [
      {
        "input": "6 7\n\n1 2 1\n\n2 3 1\n\n1 4 0\n\n3 4 1\n\n4 5 1\n\n3 6 0\n\n5 6 1",
        "output": "4"
      }
    ]
  },
  {
    "id": 967,
    "name": "Несложная сортировка",
    "description": "",
    "complexity": 25,
    "memory": 16000,
    "time": 1000,
    "examples": [
      {
        "input": "9 10 10\n\n1 2 3 4 5 6 7 9 8",
        "output": "1 4 9 16 25 36 49 64 81"
      },
      {
        "input": "10 2 2\n\n1 2 4 8 16 32 64 128 256 512",
        "output": "1 1 1 1 1 1 1 1 1 1"
      }
    ]
  },
  {
    "id": 915,
    "name": "Кубик - 2",
    "description": "За каждый ход игрок получает K*A очков, где A - число, записанное в текущей клетке поля, K - цифра на той грани кубика, которой он стоит на игровом поле. OUTPUT.TXT78[Лучшие попытки]\nВ последнее время настольные игры стали очень популярны. В нашу жизнь возвращаются как некогда забытые, так и новые увлекательные игры. К вам попала совершенно новая, уникальная настольная игра. Для игры нужен игральный кубик (его развертка приведена на рисунке) и прямоугольное игровое поле, разбитое на клетки. В каждой клетке поля написано целое число.\nИгрок ходит, пока не окажется в нижней правой клетке поля. Тогда очки за все его ходы суммируются.\nИграть могут несколько человек по следующим правилам:\nКогда один игрок закончил ходить, начинает ходить второй игрок и т.д.\nПервым ходом игрок ставит кубик в левую верхнюю клетку поля на любую грань.\nКаждым следующим ходом игрок переходит на соседнюю справа или снизу клетку, перекатывая кубик на любую из 4 соседних граней.\nЗа каждый ход игрок получает K*A очков, где A - число, записанное в текущей клетке поля, K - цифра на той грани кубика, которой он стоит на игровом поле. \nИгрок ходит, пока не окажется в нижней правой клетке поля. Тогда очки за все его ходы суммируются. \nКогда один игрок закончил ходить, начинает ходить второй игрок и т.д.\nПобедитель - игрок, набравший больше всех очков.\nПобедитель - игрок, набравший больше всех очков.\nПо заданному игровому полю определите максимальную сумму очков, которую можно получить, играя по указанным правилам.\nВходные данные\nПервая строка входного файла INPUT.TXT содержит разделенные пробелом числа N и M - размеры игрового поля (1 ≤ N×M ≤ 105). Далее идет N строк по M чисел, разделенных пробелами - числа, записанные в клетках игрового поля. Все числа по модулю не превышают 103.\nВыходные данные\nВ выходной файл OUTPUT.TXT выведите целое число – наибольшее количество очков, которые можно получить при оптимальной игре.",
    "complexity": 54,
    "memory": 16000,
    "time": 1000,
    "examples": [
      {
        "input": "3 3\n\n1 -2 3\n\n-4 5 -6\n\n7 -8 9",
        "output": "78"
      }
    ]
  },
  {
    "id": 945,
    "name": "Баллы",
    "description": "Мир наш развивается, строятся города, люди улетают в космос, изменяется система аттестации студентов в СФУ. Но вот проблема - систему аттестации студентов изменили, а программное обеспечение, которое поставлено в деканатах для контроля успеваемости, оставили прежним. Поэтому Вам срочно требуется внедрить во всех деканатах новую программу поиска студентов с заданным баллом!\niOUTPUT.TXTNO YES NO YES22 21 21 3YES NOYES NO[Лучшие попытки]\nВходные данныеi\nВ первой строке входного файла INPUT.TXT содержатся натуральные числа N и K (N, K ≤ 200 000) – соответственно количество студентов, подлежащих аттестации, и число запросов декана об успеваемости студентов. Во второй строке находятся N целых чисел ai, упорядоченных по возрастанию. Эти числа - аттестационные баллы студентов. В третьей строке располагаются K целых чисел bi, определяющие искомый балл. (0 ≤ ai, bi ≤ 232)\n32\nВыходные данные\nВ выходной файл OUTPUT.TXT выведите для каждого из K запросов через пробел слово «YES», если студент с таким баллом есть, и «NO» в противном случае.",
    "complexity": 45,
    "memory": 64000,
    "time": 1000,
    "examples": [
      {
        "input": "3 4\n1 6 9\n7 9 10 1",
        "output": "NO YES NO YES"
      },
      {
        "input": "2 2\n1 2\n1 3",
        "output": "YES NO"
      }
    ]
  },
  {
    "id": 461,
    "name": "Выборы",
    "description": "В одном из государств все решения традиционно принимались простым большинством голосов на общем собрании граждан, которых, к счастью, было не очень много. Одна из местных партий, стремясь прийти к власти как можно более законным путем, смогла добиться некоторой реформы избирательной системы. Главным аргументом было то, что население острова в последнее время значительно возросло, и проведение общих собраний перестало быть легкой задачей.\nOUTPUT.TXT625\n4 2 1 3 7\n55[Лучшие попытки]\nСуть реформы состояла в следующем: с момента введения ее в действие все избиратели острова делились на K групп (необязательно равных по численности). Голосование по любому вопросу теперь следовало проводить отдельно в каждой группе, причем считалось, что группа высказывается \"за\", если \"за\" голосует более половины людей в этой группе, а в противном случае считалось, что группа высказывается \"против\". После проведения голосования в группах подсчитывалось количество групп, высказавшихся \"за\" и \"против\", и вопрос решался положительно в том и только том случае, когда групп, высказавшихся \"за\", оказывалось более половины общего количества групп.\nЭта система вначале была с радостью принята жителями острова. Когда первые восторги рассеялись, очевидны стали, однако, некоторые недостатки новой системы. Оказалось, что сторонники партии, предложившей систему, смогли оказать некоторое влияние на формирование групп избирателей. Благодаря этому, они получили возможность проводить некоторые решения, не обладая при этом реальным большинством голосов.\nПусть, например, на острове были сформированы три группы избирателей, численностью в 5, 5 и 7 человек соответственно. Тогда партии достаточно иметь по три сторонника в каждой из первых двух групп, и она сможет провести решение всего 6-ю голосами \"за\", вместо 9-и, необходимых при общем голосовании.\nТребуется написать программу, которая по заданному разбиению избирателей на группы определит минимальное количество сторонников партии, достаточное для принятия любого решения.\nВходные данные\nВходной файл INPUT.TXT состоит из двух строк. В первой строке записано натуральное число K \u003c 1001 - количество групп избирателей. Во второй строке через пробел записаны K натуральных чисел, которые задают количество избирателей в группах. Население острова не превосходит 30000 человек.\nВыходные данные\nВ выходной файл OUTPUT.TXT выведите ответ на задачу.",
    "complexity": 26,
    "memory": 16000,
    "time": 1000,
    "examples": [
      {
        "input": "3\n\n5 5 7",
        "output": "6"
      },
      {
        "input": "5\n\n4 2 1 3 7",
        "output": "5"
      }
    ]
  },
  {
    "id": 917,
    "name": "Забор - 3",
    "description": "Однажды было принято решение о строительстве очередного небоскреба.  Для ограждения территории  были привезены прямоугольные бетонные блоки. Все блоки имеют одинаковую  ширину, но могут быть различными по длине. Начальник стройки решил, во что бы то ни стало отгородить участок как можно большей площади, используя все имеющиеся в наличии блоки. Блоки должны соприкасаться друг с другом углами.\nOUTPUT.TXT6.00[Лучшие попытки]\nВходные данные\nПервая строка входного файла INPUT.TXT содержит целое число N (3 ≤ N ≤ 100) – количество блоков. Во второй строке определены N целых чисел Li –   длины блоков (1 ≤ Li ≤ 100). Гарантируется, что с использованием данных блоков возможно огородить ненулевую площадь.\nВыходные данные\nВ выходной файл OUTPUT.TXT выведите с точностью, не худшей чем 10-2, максимально возможную площадь территории, которую можно отгородить при помощи данного набора блоков. Шириной блоков можно пренебречь.",
    "complexity": 72,
    "memory": 16000,
    "time": 1000,
    "examples": [
      {
        "input": "3\n3 4 5",
        "output": "6.00"
      }
    ]
  },
  {
    "id": 962,
    "name": "Развлечение с квадратиками",
    "description": "У Димы есть N квадратиков, стороны которых параллельны осям координат. Для двух квадратов A и B обозначим фигуру, которая состоит из точек A, не принадлежащих B, как A-B.\n9OUTPUT.TXT624\n0 0 3\n1 1 3\n2 2 3\n4 4 300[Лучшие попытки]\nТеперь Дима хочет найти количество наборов из четырех различных квадратиков A, B , C и D, таких что A-B и C-D равны с точностью до параллельного переноса (повороты не разрешаются).\nВходные данные\nПервая строка входного файла INPUT.TXT содержит N – количество квадратиков (4 ≤ N ≤ 400). Следующие N строк описывают квадратики. Каждый квадратик описывается тремя целыми числами: X, Y\tи L – координатами левого нижнего угла и длиной стороны (−109 ≤ X, Y ≤ 109,1 ≤ L ≤ 109).\nВыходные данные\nВ выходной файл OUTPUT.TXT выведите количество наборов из четырех различных квадратиков A, B, C и D, таких что A-B и C-D равны с точностью до параллельного переноса. Наборы, содержащие одно и то же множество квадратиков, но в разном порядке, считаются различными.",
    "complexity": 75,
    "memory": 64000,
    "time": 1000,
    "examples": [
      {
        "input": "4\n\n0 0 3\n\n1 1 1\n\n2 2 1\n\n1 1 3",
        "output": "6"
      },
      {
        "input": "4\n\n0 0 3\n\n1 1 3\n\n2 2 3\n\n4 4 3",
        "output": "0"
      }
    ]
  },
  {
    "id": 897,
    "name": "Степенные числа",
    "description": "Число n называется степенным, если его можно получить из некоторого числа умножением на себя хотя бы один раз. Например, 4 степенное число, так как 4=2•2, 27 тоже степенное число, так как 27=3•3•3, а 28 не является степенным числом. Определить являются ли заданные числа степенными.\nOUTPUT.TXTYESNO[Лучшие попытки]\nВходные данные\nПервая строка входного файла INPUT.TXT содержит натуральное число n - количество исследуемых чисел (1 ≤ n ≤ 10). Во второй строке через пробел записаны n чисел - исследуемые числа. Каждое из них больше 1 и меньше 109.\nВыходные данные\nВ выходной файл OUTPUT.TXT выведите n строк. В i-й строке должно быть записано «YES», если i-е число является степенным и «NO» в противном случае.",
    "complexity": 31,
    "memory": 16000,
    "time": 1000,
    "examples": [
      {
        "input": "2\n27 28",
        "output": "YES\nNO"
      }
    ]
  },
  {
    "id": 950,
    "name": "Сжатие бинарных последовательностей",
    "description": "Последовательность из символов «0» и «1» называется бинарной. Они широко применяются в информатике и других науках. Одно из неудобств бинарных последовательностей – их трудно запоминать. Для решения этой проблемы были предложены разные способы их сжатия. Программист Слава использует следующий способ: просматривая последовательность слева направо, он заменяет «1» на «a», «01» на «b», «001» на «c», …, «00000000000000000000000001» на «z». Напишите программу, которая поможет Славе автоматизировать этот способ сжатия.\nOUTPUT.TXTab2101001abcabcy[Лучшие попытки]\nВходные данные30000000000000000000000001y\nВходной файл INPUT.TXT содержит бинарную последовательность – строку из символов «0» и «1» длиной от 1 до 255 символов. Гарантируется, что к ней применим указанный способ сжатия.\nВыходные данные\nВ выходной файл OUTPUT.TXT выведите одну строку из английских строчных букв от «a» до «z» – сжатие заданной бинарной последовательности.",
    "complexity": 19,
    "memory": 16000,
    "time": 1000,
    "examples": [
      {
        "input": "101",
        "output": "ab"
      },
      {
        "input": "101001",
        "output": "abc"
      },
      {
        "input": "0000000000000000000000001",
        "output": "y"
      }
    ]
  },
  {
    "id": 918,
    "name": "График",
    "description": "Антон работает курьером. У него много заказов. На выполнение одного заказа у Антона уходит ровно один день. Для каждого заказа определена  стоимость и срок его выполнения (количество дней, оставшихся до запланированного дня выполнения заказа). Однажды проснувшись, Антон изучил свой график и понял, что возможно он не сможет выполнить все заказы, и его могут уволить. Поэтому он решил выполнить лишь некоторые из них так, чтобы при этом получить максимальный доход.\n5OUTPUT.TXT22231 101 203 244444[Лучшие попытки]\nВходные данныеi\nПервая строка входного файла INPUT.TXT содержит целое число N (1 ≤ N ≤ 1000) – количество заказов. Затем в N строках описаны данные каждого заказа Ti и Ci (натуральные числа, не превосходящие 105). Где Ti – последний день, в который еще можно выполнить заказ, Ci – вознаграждение за выполнение заказа.\ni\nВыходные данные\nВ выходной файл OUTPUT.TXT выведите максимальное вознаграждение, которое можно получить, выполняя заказы.",
    "complexity": 58,
    "memory": 16000,
    "time": 1000,
    "examples": [
      {
        "input": "2\n1 10\n2 12",
        "output": "22"
      },
      {
        "input": "3\n1 10\n1 20\n3 24",
        "output": "44"
      }
    ]
  },
  {
    "id": 857,
    "name": "Abracadabra",
    "description": "Выходные данные\nВ выходной файл OUTPUT.TXT выведите m чисел, по одному на строке. Для каждой строки-образца в порядке, в котором они заданы во входном файле, следует вывести количество слов словаря, для которых она является супрефиксом.",
    "complexity": 59,
    "memory": 64000,
    "time": 1000,
    "examples": [
      {
        "input": "4\n\nabacaba\n\nabracadabra\n\naa\n\nabra\n\n3\n\na\n\nabra\n\nabac",
        "output": "4\n\n2\n\n0"
      }
    ]
  },
  {
    "id": 496,
    "name": "Сбор черники",
    "description": "В фермерском хозяйстве в Карелии выращивают чернику. Она растет на круглой грядке, причем кусты высажены только по окружности. Таким образом, у каждого куста есть ровно два соседних. Всего на грядке растет N кустов.\nNOUTPUT.TXT9231 2 366[Лучшие попытки]\nЭти кусты обладают разной урожайностью, поэтому ко времени сбора на них выросло различное число ягод – на i-ом кусте выросло ai ягод.\ni[Решение]\nВ этом фермерском хозяйстве внедрена система автоматического сбора черники. Эта система состоит из управляющего модуля и нескольких собирающих модулей. Собирающий модуль за один заход, находясь непосредственно перед некоторым кустом, собирает ягоды с этого куста и с двух соседних с ним.\nНапишите программу для нахождения максимального числа ягод, которое может собрать за один заход собирающий модуль, находясь перед некоторым кустом заданной во входном файле грядки.\nВходные данные\nПервая строка входного файла INPUT.TXT содержит целое число N (3 ≤ N ≤ 1000) – количество кустов черники. Вторая строка содержит N целых положительных чисел a1, a2, ..., aN – число ягод черники, растущее на соответствующем кусте. Все ai не превосходят 1000.\nВыходные данные\nВ выходной файл OUTPUT.TXT выведите ответ на задачу.",
    "complexity": 17,
    "memory": 16000,
    "time": 1000,
    "examples": [
      {
        "input": "4\n1 2 3 4",
        "output": "9"
      },
      {
        "input": "3\n1 2 3",
        "output": "6"
      }
    ]
  },
  {
    "id": 775,
    "name": "Проблема Коллатца",
    "description": "Студент Василий начитался новостей о Григории Перельмане и решил, что тоже хочет миллион долларов. Получить его он собирается, исследовав проблему Коллатца. Эта проблема предполагает следующую последовательность преобразований: некоторое натуральное число N делится на 2, если оно четное, в противном случае умножается на три и увеличивается на единицу. Получившееся число N1 (равное либо N/2, либо 3N+1) подвергается той же процедуре, и так далее. Существует гипотеза, что  любое  натуральное число N в результате вышеописанных преобразований превращается в единицу. Количество шагов, требующихся для получения единицы, зависит от исходного числа по весьма сложному принципу: так, 27 превращается в 1 за 111 шагов, а 3 – за 7.\nOUTPUT.TXT4[Лучшие попытки]\nВасилий предположил, что быстрее всего в единицу превращаются числа Мерсенна – числа вида 2n-1, где n – целое положительное. Теперь ему хочется проверить эту теорию. Помогите ему, напишите программу, которая по заданному числу Мерсенна N и размеру отрезка M будет выяснять, существует ли число K (N \u003c K ≤ N+M), которое будет превращаться в единицу за меньшее число шагов, нежели N.\nВходные данные\nВходной файл INPUT.TXT содержит целые числа N (3 ≤ N ≤ 10100) и M (0 ≤ M ≤ 10100), разделенные пробелом.\nВыходные данные\nВ выходной файл OUTPUT.TXT выведите число K, если его удалось найти (в том случае, когда таких чисел несколько следует выводить то из них, которое обращается в единицу быстрее, а если и таких несколько, то меньшее из них) и слово «NO» (кавычки не выводятся) в противном случае.",
    "complexity": 23,
    "memory": 16000,
    "time": 1000,
    "examples": [
      {
        "input": "3 5",
        "output": "4"
      }
    ]
  },
  {
    "id": 923,
    "name": "Легион",
    "description": "Легион – основная организационная единица в армии Древнего Рима. В разное время легионы имели разную численность и различное построение. Самым простым построением была шеренга. Чтобы из N солдат легиона, выстроенных в шеренгу, отобрать троих в разведку, выполнялись следующие операции: если солдат в шеренге больше трех, то шеренга разбивалась на две, одна из которых состоит из солдат, стоящих на четных позициях, а вторая – из стоящих на нечетных позициях. Для всех полученных шеренг эта процедура повторялась до тех пор, пока в каждой из них не останется не более трех солдат. Если солдат осталось трое, то данную группу можно послать в разведку.\nOUTPUT.TXT22400[Лучшие попытки]\nТребуется определить, сколько групп по три человека может быть сформировано из исходной шеренги.\nВходные данные\nВходной файл INPUT.TXT содержит единственное целое число N - количество солдат в шеренге (0 ≤ N ≤ 1018).\nВыходные данные\nВ выходной файл OUTPUT.TXT выведите одно целое число – количество групп по три человека, сформированных из исходной шеренги.",
    "complexity": 44,
    "memory": 16000,
    "time": 1000,
    "examples": [
      {
        "input": "10",
        "output": "2"
      },
      {
        "input": "4",
        "output": "0"
      }
    ]
  },
  {
    "id": 512,
    "name": "Выпускной",
    "description": "Вот и еще один учебный год подошел к концу, и старшеклассники спешно начали готовиться к экзаменам. Как всегда после всех экзаменов должен был состояться выпускной бал, и в школе уже всем ходом шла подготовка к нему. Одной, но очень обязательной частью этого мероприятия должен был стать вальс, кружиться в котором должно по задумке ровно K пар. Ответственным за танец был назначен школьный учитель трудов Александр Степанович. По его первому указанию по всей школе были развешаны объявления о наборе мальчиков и девочек, которые хотят принять участие в танце. По окончании набора всех желающих, в списке у «Степаныча» было записано N мальчиков и M девочек. Теперь нужно было сформировать из всего этого ровно K пар, но оказалось, что сделать это не так-то просто. Оказывается, что не каждый мальчик захочет танцевать с любой девочкой и не каждая девочка согласиться вальсировать с любым мальчиком. Перед нашим героем встала нелегкая задача и, немного поразмыслив, он решил думать масштабно – а конкретно, сколько же всего существует вариантов сформировать из N мальчиков и M девочек ровно K пар с учетом их предпочтений? Так как в рубанках и молотках «Степаныч» понимает больше чем в математике, с просьбой помочь ему он обратился к вам.\nOUTPUT.TXT2421 5 1\nYYNNY\n33[Лучшие попытки]\nВходные данные\nВ первой строке входного файла INPUT.TXT содержится 3 целых числа: N – количество мальчиков, M – количество девочек и K – количество пар (1 ≤  N, M, K ≤ 10). Далее идет описание пожеланий мальчиков и девочек – N строк длины M. Если символ, стоящий в i-ой строке на j-ом месте равен «Y» – это значит что i-й мальчик и j-я девочка могут стоять в паре и «N» если не могут.\nВыходные данные\nВ выходной файл OUTPUT.TXT выведите целое число - количество различных способов формирования из N мальчиков и M девочек ровно K пар с учетом их пожеланий.",
    "complexity": 75,
    "memory": 16000,
    "time": 1000,
    "examples": [
      {
        "input": "3 4 3\n\nYYYY\n\nYYYY\n\nYYYY",
        "output": "24"
      },
      {
        "input": "1 5 1\n\nYYNNY",
        "output": "3"
      }
    ]
  },
  {
    "id": 403,
    "name": "Обмен валюты",
    "description": "Петя работает в обменном пункте во Флатландии. Недавно Петя получил от начальства набор цифр для отображения обменного курса. К сожалению, набор содержит всего по две копии каждой цифры. Теперь Петя хочет узнать, сколько различных обменных курсов он сможет отобразить.\nOUTPUT.TXT99021 100100100[Лучшие попытки]\nПетя обменивает флатландские доллары на крайландские тугрики. Петя уверен, что курс обмена будет целым числом, которое находится в диапазоне от L до R, включительно.\nВходные данные\nВходной файл INPUT.TXT содержит два целых числа L и R (1 ≤ L ≤ R ≤ 1018).\nВыходные данные\nВ выходной файл OUTPUT.TXT выведите одно целое число - количество обменных курсов, которые Петя может отобразить с использованием полученного набора.",
    "complexity": 70,
    "memory": 16000,
    "time": 1000,
    "examples": [
      {
        "input": "1 1000",
        "output": "990"
      },
      {
        "input": "1 100",
        "output": "100"
      }
    ]
  }
]
